{
  "numpy.polynomial": {
    "description": "A sub-package for efficiently dealing with polynomials.\n\nWithin the documentation for this sub-package, a \"finite power series,\"\ni.e., a polynomial (also referred to simply as a \"series\") is represented\nby a 1-D numpy array of the polynomial's coefficients, ordered from lowest\norder term to highest.  For example, array([1,2,3]) represents\n``P_0 + 2*P_1 + 3*P_2``, where P_n is the n-th order basis polynomial\napplicable to the specific module in question, e.g., `polynomial` (which\n\"wraps\" the \"standard\" basis) or `chebyshev`.  For optimal performance,\nall operations on polynomials, including evaluation at an argument, are\nimplemented as operations on the coefficients.  Additional (module-specific)\ninformation can be found in the docstring for the module of interest.\n\nThis package provides *convenience classes* for each of six different kinds\nof polynomials:\n\n         ========================    ================\n         **Name**                    **Provides**\n         ========================    ================\n         `~polynomial.Polynomial`    Power series\n         `~chebyshev.Chebyshev`      Chebyshev series\n         `~legendre.Legendre`        Legendre series\n         `~laguerre.Laguerre`        Laguerre series\n         `~hermite.Hermite`          Hermite series\n         `~hermite_e.HermiteE`       HermiteE series\n         ========================    ================\n\nThese *convenience classes* provide a consistent interface for creating,\nmanipulating, and fitting data with polynomials of different bases.\nThe convenience classes are the preferred interface for the `~numpy.polynomial`\npackage, and are available from the ``numpy.polynomial`` namespace.\nThis eliminates the need to navigate to the corresponding submodules, e.g.\n``np.polynomial.Polynomial`` or ``np.polynomial.Chebyshev`` instead of\n``np.polynomial.polynomial.Polynomial`` or\n``np.polynomial.chebyshev.Chebyshev``, respectively.\nThe classes provide a more consistent and concise interface than the\ntype-specific functions defined in the submodules for each type of polynomial.\nFor example, to fit a Chebyshev polynomial with degree ``1`` to data given\nby arrays ``xdata`` and ``ydata``, the\n`~chebyshev.Chebyshev.fit` class method::\n\n    >>> from numpy.polynomial import Chebyshev\n    >>> c = Chebyshev.fit(xdata, ydata, deg=1)\n\nis preferred over the `chebyshev.chebfit` function from the\n``np.polynomial.chebyshev`` module::\n\n    >>> from numpy.polynomial.chebyshev import chebfit\n    >>> c = chebfit(xdata, ydata, deg=1)\n\nSee :doc:`routines.polynomials.classes` for more details.\n\nConvenience Classes\n===================\n\nThe following lists the various constants and methods common to all of\nthe classes representing the various kinds of polynomials. In the following,\nthe term ``Poly`` represents any one of the convenience classes (e.g.\n`~polynomial.Polynomial`, `~chebyshev.Chebyshev`, `~hermite.Hermite`, etc.)\nwhile the lowercase ``p`` represents an **instance** of a polynomial class.\n\nConstants\n---------\n\n- ``Poly.domain``     -- Default domain\n- ``Poly.window``     -- Default window\n- ``Poly.basis_name`` -- String used to represent the basis\n- ``Poly.maxpower``   -- Maximum value ``n`` such that ``p**n`` is allowed\n- ``Poly.nickname``   -- String used in printing\n\nCreation\n--------\n\nMethods for creating polynomial instances.\n\n- ``Poly.basis(degree)``    -- Basis polynomial of given degree\n- ``Poly.identity()``       -- ``p`` where ``p(x) = x`` for all ``x``\n- ``Poly.fit(x, y, deg)``   -- ``p`` of degree ``deg`` with coefficients\n  determined by the least-squares fit to the data ``x``, ``y``\n- ``Poly.fromroots(roots)`` -- ``p`` with specified roots\n- ``p.copy()``              -- Create a copy of ``p``\n\nConversion\n----------\n\nMethods for converting a polynomial instance of one kind to another.\n\n- ``p.cast(Poly)``    -- Convert ``p`` to instance of kind ``Poly``\n- ``p.convert(Poly)`` -- Convert ``p`` to instance of kind ``Poly`` or map\n  between ``domain`` and ``window``\n\nCalculus\n--------\n- ``p.deriv()`` -- Take the derivative of ``p``\n- ``p.integ()`` -- Integrate ``p``\n\nValidation\n----------\n- ``Poly.has_samecoef(p1, p2)``   -- Check if coefficients match\n- ``Poly.has_samedomain(p1, p2)`` -- Check if domains match\n- ``Poly.has_sametype(p1, p2)``   -- Check if types match\n- ``Poly.has_samewindow(p1, p2)`` -- Check if windows match\n\nMisc\n----\n- ``p.linspace()`` -- Return ``x, p(x)`` at equally-spaced points in ``domain``\n- ``p.mapparms()`` -- Return the parameters for the linear mapping between\n  ``domain`` and ``window``.\n- ``p.roots()``    -- Return the roots of `p`.\n- ``p.trim()``     -- Remove trailing coefficients.\n- ``p.cutdeg(degree)`` -- Truncate p to given degree\n- ``p.truncate(size)`` -- Truncate p to given size",
    "functions": [
      "Chebyshev",
      "Hermite",
      "HermiteE",
      "Laguerre",
      "Legendre",
      "Polynomial",
      "set_default_printstyle",
      "test"
    ],
    "classes": [
      "Chebyshev",
      "Hermite",
      "HermiteE",
      "Laguerre",
      "Legendre",
      "Polynomial"
    ]
  },
  "numpy.testing": {
    "description": "Common test support for all numpy test scripts.\n\nThis single module should provide all the common functionality for numpy tests\nin a single location, so that test scripts can just import it and work right\naway.",
    "functions": [
      "IgnoreException",
      "KnownFailureException",
      "SkipTest",
      "TestCase",
      "assert_",
      "assert_allclose",
      "assert_almost_equal",
      "assert_approx_equal",
      "assert_array_almost_equal",
      "assert_array_almost_equal_nulp",
      "assert_array_compare",
      "assert_array_equal",
      "assert_array_less",
      "assert_array_max_ulp",
      "assert_equal",
      "assert_no_gc_cycles",
      "assert_no_warnings",
      "assert_raises",
      "assert_raises_regex",
      "assert_string_equal",
      "assert_warns",
      "break_cycles",
      "build_err_msg",
      "clear_and_catch_warnings",
      "decorate_methods",
      "jiffies",
      "measure",
      "memusage",
      "print_assert_equal",
      "rundocs",
      "runstring",
      "suppress_warnings",
      "tempdir",
      "temppath",
      "test"
    ],
    "classes": [
      "IgnoreException",
      "KnownFailureException",
      "SkipTest",
      "TestCase",
      "clear_and_catch_warnings",
      "suppress_warnings"
    ]
  },
  "numpy.version": {
    "description": "No description available",
    "functions": [],
    "classes": []
  },
  "numpy.rec": {
    "description": "No module named 'numpy.rec'",
    "functions": []
  },
  "numpy.exceptions": {
    "description": "Exceptions and Warnings (:mod:`numpy.exceptions`)\n=================================================\n\nGeneral exceptions used by NumPy.  Note that some exceptions may be module\nspecific, such as linear algebra errors.\n\n.. versionadded:: NumPy 1.25\n\n    The exceptions module is new in NumPy 1.25.  Older exceptions remain\n    available through the main NumPy namespace for compatibility.\n\n.. currentmodule:: numpy.exceptions\n\nWarnings\n--------\n.. autosummary::\n   :toctree: generated/\n\n   ComplexWarning             Given when converting complex to real.\n   VisibleDeprecationWarning  Same as a DeprecationWarning, but more visible.\n\nExceptions\n----------\n.. autosummary::\n   :toctree: generated/\n\n    AxisError          Given when an axis was invalid.\n    DTypePromotionError   Given when no common dtype could be found.\n    TooHardError       Error specific to `numpy.shares_memory`.",
    "functions": [
      "AxisError",
      "ComplexWarning",
      "DTypePromotionError",
      "ModuleDeprecationWarning",
      "TooHardError",
      "VisibleDeprecationWarning"
    ],
    "classes": [
      "AxisError",
      "ComplexWarning",
      "DTypePromotionError",
      "ModuleDeprecationWarning",
      "TooHardError",
      "VisibleDeprecationWarning"
    ]
  },
  "numpy.ma": {
    "description": "=============\nMasked Arrays\n=============\n\nArrays sometimes contain invalid or missing data.  When doing operations\non such arrays, we wish to suppress invalid values, which is the purpose masked\narrays fulfill (an example of typical use is given below).\n\nFor example, examine the following array:\n\n>>> x = np.array([2, 1, 3, np.nan, 5, 2, 3, np.nan])\n\nWhen we try to calculate the mean of the data, the result is undetermined:\n\n>>> np.mean(x)\nnan\n\nThe mean is calculated using roughly ``np.sum(x)/len(x)``, but since\nany number added to ``NaN`` [1]_ produces ``NaN``, this doesn't work.  Enter\nmasked arrays:\n\n>>> m = np.ma.masked_array(x, np.isnan(x))\n>>> m\nmasked_array(data = [2.0 1.0 3.0 -- 5.0 2.0 3.0 --],\n      mask = [False False False  True False False False  True],\n      fill_value=1e+20)\n\nHere, we construct a masked array that suppress all ``NaN`` values.  We\nmay now proceed to calculate the mean of the other values:\n\n>>> np.mean(m)\n2.6666666666666665\n\n.. [1] Not-a-Number, a floating point value that is the result of an\n       invalid operation.\n\n.. moduleauthor:: Pierre Gerard-Marchant\n.. moduleauthor:: Jarrod Millman",
    "functions": [
      "MAError",
      "MaskError",
      "MaskType",
      "MaskedArray",
      "abs",
      "absolute",
      "add",
      "all",
      "allclose",
      "allequal",
      "alltrue",
      "amax",
      "amin",
      "angle",
      "anom",
      "anomalies",
      "any",
      "append",
      "apply_along_axis",
      "apply_over_axes",
      "arange",
      "arccos",
      "arccosh",
      "arcsin",
      "arcsinh",
      "arctan",
      "arctan2",
      "arctanh",
      "argmax",
      "argmin",
      "argsort",
      "around",
      "array",
      "asanyarray",
      "asarray",
      "atleast_1d",
      "atleast_2d",
      "atleast_3d",
      "average",
      "bitwise_and",
      "bitwise_or",
      "bitwise_xor",
      "bool_",
      "ceil",
      "choose",
      "clip",
      "clump_masked",
      "clump_unmasked",
      "column_stack",
      "common_fill_value",
      "compress",
      "compress_cols",
      "compress_nd",
      "compress_rowcols",
      "compress_rows",
      "compressed",
      "concatenate",
      "conjugate",
      "convolve",
      "copy",
      "corrcoef",
      "correlate",
      "cos",
      "cosh",
      "count",
      "count_masked",
      "cov",
      "cumprod",
      "cumsum",
      "default_fill_value",
      "diag",
      "diagflat",
      "diagonal",
      "diff",
      "divide",
      "dot",
      "dstack",
      "ediff1d",
      "empty",
      "empty_like",
      "equal",
      "exp",
      "expand_dims",
      "fabs",
      "filled",
      "fix_invalid",
      "flatnotmasked_contiguous",
      "flatnotmasked_edges",
      "flatten_mask",
      "flatten_structured_array",
      "floor",
      "floor_divide",
      "fmod",
      "frombuffer",
      "fromflex",
      "fromfunction",
      "getdata",
      "getmask",
      "getmaskarray",
      "greater",
      "greater_equal",
      "harden_mask",
      "hsplit",
      "hstack",
      "hypot",
      "identity",
      "ids",
      "in1d",
      "indices",
      "inner",
      "innerproduct",
      "intersect1d",
      "isMA",
      "isMaskedArray",
      "is_mask",
      "is_masked",
      "isarray",
      "isin",
      "left_shift",
      "less",
      "less_equal",
      "log",
      "log10",
      "log2",
      "logical_and",
      "logical_not",
      "logical_or",
      "logical_xor",
      "make_mask",
      "make_mask_descr",
      "make_mask_none",
      "mask_cols",
      "mask_or",
      "mask_rowcols",
      "mask_rows",
      "masked_all",
      "masked_all_like",
      "masked_array",
      "masked_equal",
      "masked_greater",
      "masked_greater_equal",
      "masked_inside",
      "masked_invalid",
      "masked_less",
      "masked_less_equal",
      "masked_not_equal",
      "masked_object",
      "masked_outside",
      "masked_values",
      "masked_where",
      "max",
      "maximum",
      "maximum_fill_value",
      "mean",
      "median",
      "min",
      "minimum",
      "minimum_fill_value",
      "mod",
      "multiply",
      "mvoid",
      "ndenumerate",
      "ndim",
      "negative",
      "nonzero",
      "not_equal",
      "notmasked_contiguous",
      "notmasked_edges",
      "ones",
      "ones_like",
      "outer",
      "outerproduct",
      "polyfit",
      "power",
      "prod",
      "product",
      "ptp",
      "put",
      "putmask",
      "ravel",
      "remainder",
      "repeat",
      "reshape",
      "resize",
      "right_shift",
      "round",
      "round_",
      "row_stack",
      "set_fill_value",
      "setdiff1d",
      "setxor1d",
      "shape",
      "sin",
      "sinh",
      "size",
      "soften_mask",
      "sometrue",
      "sort",
      "sqrt",
      "squeeze",
      "stack",
      "std",
      "subtract",
      "sum",
      "swapaxes",
      "take",
      "tan",
      "tanh",
      "test",
      "trace",
      "transpose",
      "true_divide",
      "union1d",
      "unique",
      "vander",
      "var",
      "vstack",
      "where",
      "zeros",
      "zeros_like"
    ],
    "classes": [
      "MAError",
      "MaskError",
      "MaskType",
      "MaskedArray",
      "bool_",
      "masked_array",
      "mvoid"
    ]
  },
  "numpy.fft": {
    "description": "Discrete Fourier Transform (:mod:`numpy.fft`)\n=============================================\n\n.. currentmodule:: numpy.fft\n\nThe SciPy module `scipy.fft` is a more comprehensive superset\nof ``numpy.fft``, which includes only a basic set of routines.\n\nStandard FFTs\n-------------\n\n.. autosummary::\n   :toctree: generated/\n\n   fft       Discrete Fourier transform.\n   ifft      Inverse discrete Fourier transform.\n   fft2      Discrete Fourier transform in two dimensions.\n   ifft2     Inverse discrete Fourier transform in two dimensions.\n   fftn      Discrete Fourier transform in N-dimensions.\n   ifftn     Inverse discrete Fourier transform in N dimensions.\n\nReal FFTs\n---------\n\n.. autosummary::\n   :toctree: generated/\n\n   rfft      Real discrete Fourier transform.\n   irfft     Inverse real discrete Fourier transform.\n   rfft2     Real discrete Fourier transform in two dimensions.\n   irfft2    Inverse real discrete Fourier transform in two dimensions.\n   rfftn     Real discrete Fourier transform in N dimensions.\n   irfftn    Inverse real discrete Fourier transform in N dimensions.\n\nHermitian FFTs\n--------------\n\n.. autosummary::\n   :toctree: generated/\n\n   hfft      Hermitian discrete Fourier transform.\n   ihfft     Inverse Hermitian discrete Fourier transform.\n\nHelper routines\n---------------\n\n.. autosummary::\n   :toctree: generated/\n\n   fftfreq   Discrete Fourier Transform sample frequencies.\n   rfftfreq  DFT sample frequencies (for usage with rfft, irfft).\n   fftshift  Shift zero-frequency component to center of spectrum.\n   ifftshift Inverse of fftshift.\n\n\nBackground information\n----------------------\n\nFourier analysis is fundamentally a method for expressing a function as a\nsum of periodic components, and for recovering the function from those\ncomponents.  When both the function and its Fourier transform are\nreplaced with discretized counterparts, it is called the discrete Fourier\ntransform (DFT).  The DFT has become a mainstay of numerical computing in\npart because of a very fast algorithm for computing it, called the Fast\nFourier Transform (FFT), which was known to Gauss (1805) and was brought\nto light in its current form by Cooley and Tukey [CT]_.  Press et al. [NR]_\nprovide an accessible introduction to Fourier analysis and its\napplications.\n\nBecause the discrete Fourier transform separates its input into\ncomponents that contribute at discrete frequencies, it has a great number\nof applications in digital signal processing, e.g., for filtering, and in\nthis context the discretized input to the transform is customarily\nreferred to as a *signal*, which exists in the *time domain*.  The output\nis called a *spectrum* or *transform* and exists in the *frequency\ndomain*.\n\nImplementation details\n----------------------\n\nThere are many ways to define the DFT, varying in the sign of the\nexponent, normalization, etc.  In this implementation, the DFT is defined\nas\n\n.. math::\n   A_k =  \\sum_{m=0}^{n-1} a_m \\exp\\left\\{-2\\pi i{mk \\over n}\\right\\}\n   \\qquad k = 0,\\ldots,n-1.\n\nThe DFT is in general defined for complex inputs and outputs, and a\nsingle-frequency component at linear frequency :math:`f` is\nrepresented by a complex exponential\n:math:`a_m = \\exp\\{2\\pi i\\,f m\\Delta t\\}`, where :math:`\\Delta t`\nis the sampling interval.\n\nThe values in the result follow so-called \"standard\" order: If ``A =\nfft(a, n)``, then ``A[0]`` contains the zero-frequency term (the sum of\nthe signal), which is always purely real for real inputs. Then ``A[1:n/2]``\ncontains the positive-frequency terms, and ``A[n/2+1:]`` contains the\nnegative-frequency terms, in order of decreasingly negative frequency.\nFor an even number of input points, ``A[n/2]`` represents both positive and\nnegative Nyquist frequency, and is also purely real for real input.  For\nan odd number of input points, ``A[(n-1)/2]`` contains the largest positive\nfrequency, while ``A[(n+1)/2]`` contains the largest negative frequency.\nThe routine ``np.fft.fftfreq(n)`` returns an array giving the frequencies\nof corresponding elements in the output.  The routine\n``np.fft.fftshift(A)`` shifts transforms and their frequencies to put the\nzero-frequency components in the middle, and ``np.fft.ifftshift(A)`` undoes\nthat shift.\n\nWhen the input `a` is a time-domain signal and ``A = fft(a)``, ``np.abs(A)``\nis its amplitude spectrum and ``np.abs(A)**2`` is its power spectrum.\nThe phase spectrum is obtained by ``np.angle(A)``.\n\nThe inverse DFT is defined as\n\n.. math::\n   a_m = \\frac{1}{n}\\sum_{k=0}^{n-1}A_k\\exp\\left\\{2\\pi i{mk\\over n}\\right\\}\n   \\qquad m = 0,\\ldots,n-1.\n\nIt differs from the forward transform by the sign of the exponential\nargument and the default normalization by :math:`1/n`.\n\nType Promotion\n--------------\n\n`numpy.fft` promotes ``float32`` and ``complex64`` arrays to ``float64`` and\n``complex128`` arrays respectively. For an FFT implementation that does not\npromote input arrays, see `scipy.fftpack`.\n\nNormalization\n-------------\n\nThe argument ``norm`` indicates which direction of the pair of direct/inverse\ntransforms is scaled and with what normalization factor.\nThe default normalization (``\"backward\"``) has the direct (forward) transforms\nunscaled and the inverse (backward) transforms scaled by :math:`1/n`. It is\npossible to obtain unitary transforms by setting the keyword argument ``norm``\nto ``\"ortho\"`` so that both direct and inverse transforms are scaled by\n:math:`1/\\sqrt{n}`. Finally, setting the keyword argument ``norm`` to\n``\"forward\"`` has the direct transforms scaled by :math:`1/n` and the inverse\ntransforms unscaled (i.e. exactly opposite to the default ``\"backward\"``).\n`None` is an alias of the default option ``\"backward\"`` for backward\ncompatibility.\n\nReal and Hermitian transforms\n-----------------------------\n\nWhen the input is purely real, its transform is Hermitian, i.e., the\ncomponent at frequency :math:`f_k` is the complex conjugate of the\ncomponent at frequency :math:`-f_k`, which means that for real\ninputs there is no information in the negative frequency components that\nis not already available from the positive frequency components.\nThe family of `rfft` functions is\ndesigned to operate on real inputs, and exploits this symmetry by\ncomputing only the positive frequency components, up to and including the\nNyquist frequency.  Thus, ``n`` input points produce ``n/2+1`` complex\noutput points.  The inverses of this family assumes the same symmetry of\nits input, and for an output of ``n`` points uses ``n/2+1`` input points.\n\nCorrespondingly, when the spectrum is purely real, the signal is\nHermitian.  The `hfft` family of functions exploits this symmetry by\nusing ``n/2+1`` complex points in the input (time) domain for ``n`` real\npoints in the frequency domain.\n\nIn higher dimensions, FFTs are used, e.g., for image analysis and\nfiltering.  The computational efficiency of the FFT means that it can\nalso be a faster way to compute large convolutions, using the property\nthat a convolution in the time domain is equivalent to a point-by-point\nmultiplication in the frequency domain.\n\nHigher dimensions\n-----------------\n\nIn two dimensions, the DFT is defined as\n\n.. math::\n   A_{kl} =  \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1}\n   a_{mn}\\exp\\left\\{-2\\pi i \\left({mk\\over M}+{nl\\over N}\\right)\\right\\}\n   \\qquad k = 0, \\ldots, M-1;\\quad l = 0, \\ldots, N-1,\n\nwhich extends in the obvious way to higher dimensions, and the inverses\nin higher dimensions also extend in the same way.\n\nReferences\n----------\n\n.. [CT] Cooley, James W., and John W. Tukey, 1965, \"An algorithm for the\n        machine calculation of complex Fourier series,\" *Math. Comput.*\n        19: 297-301.\n\n.. [NR] Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P.,\n        2007, *Numerical Recipes: The Art of Scientific Computing*, ch.\n        12-13.  Cambridge Univ. Press, Cambridge, UK.\n\nExamples\n--------\n\nFor examples, see the various functions.",
    "functions": [
      "fft",
      "fft2",
      "fftfreq",
      "fftn",
      "fftshift",
      "hfft",
      "ifft",
      "ifft2",
      "ifftn",
      "ifftshift",
      "ihfft",
      "irfft",
      "irfft2",
      "irfftn",
      "rfft",
      "rfft2",
      "rfftfreq",
      "rfftn",
      "test"
    ],
    "classes": []
  },
  "numpy.char": {
    "description": "No module named 'numpy.char'",
    "functions": []
  },
  "numpy.typing": {
    "description": "============================\nTyping (:mod:`numpy.typing`)\n============================\n\n.. versionadded:: 1.20\n\nLarge parts of the NumPy API have :pep:`484`-style type annotations. In\naddition a number of type aliases are available to users, most prominently\nthe two below:\n\n- `ArrayLike`: objects that can be converted to arrays\n- `DTypeLike`: objects that can be converted to dtypes\n\n.. _typing-extensions: https://pypi.org/project/typing-extensions/\n\nMypy plugin\n-----------\n\n.. versionadded:: 1.21\n\n.. automodule:: numpy.typing.mypy_plugin\n\n.. currentmodule:: numpy.typing\n\nDifferences from the runtime NumPy API\n--------------------------------------\n\nNumPy is very flexible. Trying to describe the full range of\npossibilities statically would result in types that are not very\nhelpful. For that reason, the typed NumPy API is often stricter than\nthe runtime NumPy API. This section describes some notable\ndifferences.\n\nArrayLike\n~~~~~~~~~\n\nThe `ArrayLike` type tries to avoid creating object arrays. For\nexample,\n\n.. code-block:: python\n\n    >>> np.array(x**2 for x in range(10))\n    array(<generator object <genexpr> at ...>, dtype=object)\n\nis valid NumPy code which will create a 0-dimensional object\narray. Type checkers will complain about the above example when using\nthe NumPy types however. If you really intended to do the above, then\nyou can either use a ``# type: ignore`` comment:\n\n.. code-block:: python\n\n    >>> np.array(x**2 for x in range(10))  # type: ignore\n\nor explicitly type the array like object as `~typing.Any`:\n\n.. code-block:: python\n\n    >>> from typing import Any\n    >>> array_like: Any = (x**2 for x in range(10))\n    >>> np.array(array_like)\n    array(<generator object <genexpr> at ...>, dtype=object)\n\nndarray\n~~~~~~~\n\nIt's possible to mutate the dtype of an array at runtime. For example,\nthe following code is valid:\n\n.. code-block:: python\n\n    >>> x = np.array([1, 2])\n    >>> x.dtype = np.bool_\n\nThis sort of mutation is not allowed by the types. Users who want to\nwrite statically typed code should instead use the `numpy.ndarray.view`\nmethod to create a view of the array with a different dtype.\n\nDTypeLike\n~~~~~~~~~\n\nThe `DTypeLike` type tries to avoid creation of dtype objects using\ndictionary of fields like below:\n\n.. code-block:: python\n\n    >>> x = np.dtype({\"field1\": (float, 1), \"field2\": (int, 3)})\n\nAlthough this is valid NumPy code, the type checker will complain about it,\nsince its usage is discouraged.\nPlease see : :ref:`Data type objects <arrays.dtypes>`\n\nNumber precision\n~~~~~~~~~~~~~~~~\n\nThe precision of `numpy.number` subclasses is treated as a covariant generic\nparameter (see :class:`~NBitBase`), simplifying the annotating of processes\ninvolving precision-based casting.\n\n.. code-block:: python\n\n    >>> from typing import TypeVar\n    >>> import numpy as np\n    >>> import numpy.typing as npt\n\n    >>> T = TypeVar(\"T\", bound=npt.NBitBase)\n    >>> def func(a: \"np.floating[T]\", b: \"np.floating[T]\") -> \"np.floating[T]\":\n    ...     ...\n\nConsequently, the likes of `~numpy.float16`, `~numpy.float32` and\n`~numpy.float64` are still sub-types of `~numpy.floating`, but, contrary to\nruntime, they're not necessarily considered as sub-classes.\n\nTimedelta64\n~~~~~~~~~~~\n\nThe `~numpy.timedelta64` class is not considered a subclass of\n`~numpy.signedinteger`, the former only inheriting from `~numpy.generic`\nwhile static type checking.\n\n0D arrays\n~~~~~~~~~\n\nDuring runtime numpy aggressively casts any passed 0D arrays into their\ncorresponding `~numpy.generic` instance. Until the introduction of shape\ntyping (see :pep:`646`) it is unfortunately not possible to make the\nnecessary distinction between 0D and >0D arrays. While thus not strictly\ncorrect, all operations are that can potentially perform a 0D-array -> scalar\ncast are currently annotated as exclusively returning an `ndarray`.\n\nIf it is known in advance that an operation _will_ perform a\n0D-array -> scalar cast, then one can consider manually remedying the\nsituation with either `typing.cast` or a ``# type: ignore`` comment.\n\nRecord array dtypes\n~~~~~~~~~~~~~~~~~~~\n\nThe dtype of `numpy.recarray`, and the `numpy.rec` functions in general,\ncan be specified in one of two ways:\n\n* Directly via the ``dtype`` argument.\n* With up to five helper arguments that operate via `numpy.format_parser`:\n  ``formats``, ``names``, ``titles``, ``aligned`` and ``byteorder``.\n\nThese two approaches are currently typed as being mutually exclusive,\n*i.e.* if ``dtype`` is specified than one may not specify ``formats``.\nWhile this mutual exclusivity is not (strictly) enforced during runtime,\ncombining both dtype specifiers can lead to unexpected or even downright\nbuggy behavior.\n\nAPI\n---\n\n.. data:: ArrayLike\n    :value: typing.Union[...]\n    \n    A `~typing.Union` representing objects that can be coerced\n    into an `~numpy.ndarray`.\n    \n    Among others this includes the likes of:\n    \n    * Scalars.\n    * (Nested) sequences.\n    * Objects implementing the `~class.__array__` protocol.\n    \n    .. versionadded:: 1.20\n    \n    .. admonition:: See Also\n\n        :term:`array_like`:\n            Any scalar or sequence that can be interpreted as an ndarray.\n        \n    .. rubric:: Examples\n\n    .. code-block:: python\n    \n        >>> import numpy as np\n        >>> import numpy.typing as npt\n    \n        >>> def as_array(a: npt.ArrayLike) -> np.ndarray:\n        ...     return np.array(a)\n    \n    \n.. data:: DTypeLike\n    :value: typing.Union[...]\n    \n    A `~typing.Union` representing objects that can be coerced\n    into a `~numpy.dtype`.\n    \n    Among others this includes the likes of:\n    \n    * :class:`type` objects.\n    * Character codes or the names of :class:`type` objects.\n    * Objects with the ``.dtype`` attribute.\n    \n    .. versionadded:: 1.20\n    \n    .. admonition:: See Also\n\n        :ref:`Specifying and constructing data types <arrays.dtypes.constructing>`\n            A comprehensive overview of all objects that can be coerced\n            into data types.\n        \n    .. rubric:: Examples\n\n    .. code-block:: python\n    \n        >>> import numpy as np\n        >>> import numpy.typing as npt\n    \n        >>> def as_dtype(d: npt.DTypeLike) -> np.dtype:\n        ...     return np.dtype(d)\n    \n    \n.. data:: NDArray\n    :value: numpy.ndarray[typing.Any, numpy.dtype[+_ScalarType_co]]\n    \n    A :term:`generic <generic type>` version of\n    `np.ndarray[Any, np.dtype[+ScalarType]] <numpy.ndarray>`.\n    \n    Can be used during runtime for typing arrays with a given dtype\n    and unspecified shape.\n    \n    .. versionadded:: 1.21\n    \n    .. rubric:: Examples\n\n    .. code-block:: python\n    \n        >>> import numpy as np\n        >>> import numpy.typing as npt\n    \n        >>> print(npt.NDArray)\n        numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]\n    \n        >>> print(npt.NDArray[np.float64])\n        numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]\n    \n        >>> NDArrayInt = npt.NDArray[np.int_]\n        >>> a: NDArrayInt = np.arange(10)\n    \n        >>> def func(a: npt.ArrayLike) -> npt.NDArray[Any]:\n        ...     return np.array(a)\n    \n    \n.. autoclass:: numpy.typing.NBitBase",
    "functions": [
      "ArrayLike",
      "DTypeLike",
      "NBitBase",
      "NDArray",
      "test"
    ],
    "classes": [
      "NBitBase"
    ]
  },
  "numpy": {
    "description": "NumPy\n=====\n\nProvides\n  1. An array object of arbitrary homogeneous items\n  2. Fast mathematical operations over arrays\n  3. Linear Algebra, Fourier Transforms, Random Number Generation\n\nHow to use the documentation\n----------------------------\nDocumentation is available in two forms: docstrings provided\nwith the code, and a loose standing reference guide, available from\n`the NumPy homepage <https://numpy.org>`_.\n\nWe recommend exploring the docstrings using\n`IPython <https://ipython.org>`_, an advanced Python shell with\nTAB-completion and introspection capabilities.  See below for further\ninstructions.\n\nThe docstring examples assume that `numpy` has been imported as ``np``::\n\n  >>> import numpy as np\n\nCode snippets are indicated by three greater-than signs::\n\n  >>> x = 42\n  >>> x = x + 1\n\nUse the built-in ``help`` function to view a function's docstring::\n\n  >>> help(np.sort)\n  ... # doctest: +SKIP\n\nFor some objects, ``np.info(obj)`` may provide additional help.  This is\nparticularly true if you see the line \"Help on ufunc object:\" at the top\nof the help() page.  Ufuncs are implemented in C, not Python, for speed.\nThe native Python help() does not know how to view their help, but our\nnp.info() function does.\n\nTo search for documents containing a keyword, do::\n\n  >>> np.lookfor('keyword')\n  ... # doctest: +SKIP\n\nGeneral-purpose documents like a glossary and help on the basic concepts\nof numpy are available under the ``doc`` sub-module::\n\n  >>> from numpy import doc\n  >>> help(doc)\n  ... # doctest: +SKIP\n\nAvailable subpackages\n---------------------\nlib\n    Basic functions used by several sub-packages.\nrandom\n    Core Random Tools\nlinalg\n    Core Linear Algebra Tools\nfft\n    Core FFT routines\npolynomial\n    Polynomial tools\ntesting\n    NumPy testing tools\ndistutils\n    Enhancements to distutils with support for\n    Fortran compilers support and more  (for Python <= 3.11).\n\nUtilities\n---------\ntest\n    Run numpy unittests\nshow_config\n    Show numpy build configuration\nmatlib\n    Make everything matrices.\n__version__\n    NumPy version string\n\nViewing documentation using IPython\n-----------------------------------\n\nStart IPython and import `numpy` usually under the alias ``np``: `import\nnumpy as np`.  Then, directly past or use the ``%cpaste`` magic to paste\nexamples into the shell.  To see which functions are available in `numpy`,\ntype ``np.<TAB>`` (where ``<TAB>`` refers to the TAB key), or use\n``np.*cos*?<ENTER>`` (where ``<ENTER>`` refers to the ENTER key) to narrow\ndown the list.  To view the docstring for a function, use\n``np.cos?<ENTER>`` (to view the docstring) and ``np.cos??<ENTER>`` (to view\nthe source code).\n\nCopies vs. in-place operation\n-----------------------------\nMost of the functions in `numpy` return a copy of the array argument\n(e.g., `np.sort`).  In-place versions of these functions are often\navailable as array methods, i.e. ``x = np.array([1,2,3]); x.sort()``.\nExceptions to this rule are documented.",
    "functions": [
      "DataSource",
      "RankWarning",
      "abs",
      "absolute",
      "add",
      "add_docstring",
      "add_newdoc",
      "add_newdoc_ufunc",
      "all",
      "allclose",
      "alltrue",
      "amax",
      "amin",
      "angle",
      "any",
      "append",
      "apply_along_axis",
      "apply_over_axes",
      "arange",
      "arccos",
      "arccosh",
      "arcsin",
      "arcsinh",
      "arctan",
      "arctan2",
      "arctanh",
      "argmax",
      "argmin",
      "argpartition",
      "argsort",
      "argwhere",
      "around",
      "array",
      "array2string",
      "array_equal",
      "array_equiv",
      "array_repr",
      "array_split",
      "array_str",
      "asanyarray",
      "asarray",
      "asarray_chkfinite",
      "ascontiguousarray",
      "asfarray",
      "asfortranarray",
      "asmatrix",
      "atleast_1d",
      "atleast_2d",
      "atleast_3d",
      "average",
      "bartlett",
      "base_repr",
      "binary_repr",
      "bincount",
      "bitwise_and",
      "bitwise_not",
      "bitwise_or",
      "bitwise_xor",
      "blackman",
      "block",
      "bmat",
      "bool_",
      "broadcast",
      "broadcast_arrays",
      "broadcast_shapes",
      "broadcast_to",
      "busday_count",
      "busday_offset",
      "busdaycalendar",
      "byte",
      "byte_bounds",
      "bytes_",
      "can_cast",
      "cbrt",
      "cdouble",
      "ceil",
      "cfloat",
      "character",
      "chararray",
      "choose",
      "clip",
      "clongdouble",
      "clongfloat",
      "column_stack",
      "common_type",
      "compare_chararrays",
      "complex128",
      "complex256",
      "complex64",
      "complex_",
      "complexfloating",
      "compress",
      "concatenate",
      "conj",
      "conjugate",
      "convolve",
      "copy",
      "copysign",
      "copyto",
      "corrcoef",
      "correlate",
      "cos",
      "cosh",
      "count_nonzero",
      "cov",
      "cross",
      "csingle",
      "cumprod",
      "cumproduct",
      "cumsum",
      "datetime64",
      "datetime_as_string",
      "datetime_data",
      "deg2rad",
      "degrees",
      "delete",
      "deprecate",
      "deprecate_with_doc",
      "diag",
      "diag_indices",
      "diag_indices_from",
      "diagflat",
      "diagonal",
      "diff",
      "digitize",
      "disp",
      "divide",
      "divmod",
      "dot",
      "double",
      "dsplit",
      "dstack",
      "dtype",
      "ediff1d",
      "einsum",
      "einsum_path",
      "empty",
      "empty_like",
      "equal",
      "errstate",
      "exp",
      "exp2",
      "expand_dims",
      "expm1",
      "extract",
      "eye",
      "fabs",
      "fastCopyAndTranspose",
      "fill_diagonal",
      "find_common_type",
      "finfo",
      "fix",
      "flatiter",
      "flatnonzero",
      "flexible",
      "flip",
      "fliplr",
      "flipud",
      "float128",
      "float16",
      "float32",
      "float64",
      "float_",
      "float_power",
      "floating",
      "floor",
      "floor_divide",
      "fmax",
      "fmin",
      "fmod",
      "format_float_positional",
      "format_float_scientific",
      "format_parser",
      "frexp",
      "from_dlpack",
      "frombuffer",
      "fromfile",
      "fromfunction",
      "fromiter",
      "frompyfunc",
      "fromregex",
      "fromstring",
      "full",
      "full_like",
      "gcd",
      "generic",
      "genfromtxt",
      "geomspace",
      "get_array_wrap",
      "get_include",
      "get_printoptions",
      "getbufsize",
      "geterr",
      "geterrcall",
      "geterrobj",
      "gradient",
      "greater",
      "greater_equal",
      "half",
      "hamming",
      "hanning",
      "heaviside",
      "histogram",
      "histogram2d",
      "histogram_bin_edges",
      "histogramdd",
      "hsplit",
      "hstack",
      "hypot",
      "i0",
      "identity",
      "iinfo",
      "imag",
      "in1d",
      "indices",
      "inexact",
      "info",
      "inner",
      "insert",
      "int16",
      "int32",
      "int64",
      "int8",
      "int_",
      "intc",
      "integer",
      "interp",
      "intersect1d",
      "intp",
      "invert",
      "is_busday",
      "isclose",
      "iscomplex",
      "iscomplexobj",
      "isfinite",
      "isfortran",
      "isin",
      "isinf",
      "isnan",
      "isnat",
      "isneginf",
      "isposinf",
      "isreal",
      "isrealobj",
      "isscalar",
      "issctype",
      "issubclass_",
      "issubdtype",
      "issubsctype",
      "iterable",
      "ix_",
      "kaiser",
      "kron",
      "lcm",
      "ldexp",
      "left_shift",
      "less",
      "less_equal",
      "lexsort",
      "linspace",
      "load",
      "loadtxt",
      "log",
      "log10",
      "log1p",
      "log2",
      "logaddexp",
      "logaddexp2",
      "logical_and",
      "logical_not",
      "logical_or",
      "logical_xor",
      "logspace",
      "longcomplex",
      "longdouble",
      "longfloat",
      "longlong",
      "lookfor",
      "mask_indices",
      "mat",
      "matmul",
      "matrix",
      "max",
      "maximum",
      "maximum_sctype",
      "may_share_memory",
      "mean",
      "median",
      "memmap",
      "meshgrid",
      "min",
      "min_scalar_type",
      "minimum",
      "mintypecode",
      "mod",
      "modf",
      "moveaxis",
      "msort",
      "multiply",
      "nan_to_num",
      "nanargmax",
      "nanargmin",
      "nancumprod",
      "nancumsum",
      "nanmax",
      "nanmean",
      "nanmedian",
      "nanmin",
      "nanpercentile",
      "nanprod",
      "nanquantile",
      "nanstd",
      "nansum",
      "nanvar",
      "ndarray",
      "ndenumerate",
      "ndim",
      "ndindex",
      "nditer",
      "negative",
      "nested_iters",
      "nextafter",
      "nonzero",
      "not_equal",
      "number",
      "obj2sctype",
      "object_",
      "ones",
      "ones_like",
      "outer",
      "packbits",
      "pad",
      "partition",
      "percentile",
      "piecewise",
      "place",
      "poly",
      "poly1d",
      "polyadd",
      "polyder",
      "polydiv",
      "polyfit",
      "polyint",
      "polymul",
      "polysub",
      "polyval",
      "positive",
      "power",
      "printoptions",
      "prod",
      "product",
      "promote_types",
      "ptp",
      "put",
      "put_along_axis",
      "putmask",
      "quantile",
      "rad2deg",
      "radians",
      "ravel",
      "ravel_multi_index",
      "real",
      "real_if_close",
      "recarray",
      "recfromcsv",
      "recfromtxt",
      "reciprocal",
      "record",
      "remainder",
      "repeat",
      "require",
      "reshape",
      "resize",
      "result_type",
      "right_shift",
      "rint",
      "roll",
      "rollaxis",
      "roots",
      "rot90",
      "round",
      "round_",
      "row_stack",
      "safe_eval",
      "save",
      "savetxt",
      "savez",
      "savez_compressed",
      "sctype2char",
      "searchsorted",
      "select",
      "set_numeric_ops",
      "set_printoptions",
      "set_string_function",
      "setbufsize",
      "setdiff1d",
      "seterr",
      "seterrcall",
      "seterrobj",
      "setxor1d",
      "shape",
      "shares_memory",
      "short",
      "show_config",
      "show_runtime",
      "sign",
      "signbit",
      "signedinteger",
      "sin",
      "sinc",
      "single",
      "singlecomplex",
      "sinh",
      "size",
      "sometrue",
      "sort",
      "sort_complex",
      "source",
      "spacing",
      "split",
      "sqrt",
      "square",
      "squeeze",
      "stack",
      "std",
      "str_",
      "string_",
      "subtract",
      "sum",
      "swapaxes",
      "take",
      "take_along_axis",
      "tan",
      "tanh",
      "tensordot",
      "test",
      "tile",
      "timedelta64",
      "trace",
      "transpose",
      "trapz",
      "tri",
      "tril",
      "tril_indices",
      "tril_indices_from",
      "trim_zeros",
      "triu",
      "triu_indices",
      "triu_indices_from",
      "true_divide",
      "trunc",
      "typename",
      "ubyte",
      "ufunc",
      "uint",
      "uint16",
      "uint32",
      "uint64",
      "uint8",
      "uintc",
      "uintp",
      "ulonglong",
      "unicode_",
      "union1d",
      "unique",
      "unpackbits",
      "unravel_index",
      "unsignedinteger",
      "unwrap",
      "ushort",
      "vander",
      "var",
      "vdot",
      "vectorize",
      "void",
      "vsplit",
      "vstack",
      "where",
      "who",
      "zeros",
      "zeros_like"
    ],
    "classes": [
      "DataSource",
      "RankWarning",
      "bool_",
      "broadcast",
      "busdaycalendar",
      "byte",
      "bytes_",
      "cdouble",
      "cfloat",
      "character",
      "chararray",
      "clongdouble",
      "clongfloat",
      "complex128",
      "complex256",
      "complex64",
      "complex_",
      "complexfloating",
      "csingle",
      "datetime64",
      "double",
      "dtype",
      "errstate",
      "finfo",
      "flatiter",
      "flexible",
      "float128",
      "float16",
      "float32",
      "float64",
      "float_",
      "floating",
      "format_parser",
      "generic",
      "half",
      "iinfo",
      "inexact",
      "int16",
      "int32",
      "int64",
      "int8",
      "int_",
      "intc",
      "integer",
      "intp",
      "longcomplex",
      "longdouble",
      "longfloat",
      "longlong",
      "matrix",
      "memmap",
      "ndarray",
      "ndenumerate",
      "ndindex",
      "nditer",
      "number",
      "object_",
      "poly1d",
      "recarray",
      "record",
      "short",
      "signedinteger",
      "single",
      "singlecomplex",
      "str_",
      "string_",
      "timedelta64",
      "ubyte",
      "ufunc",
      "uint",
      "uint16",
      "uint32",
      "uint64",
      "uint8",
      "uintc",
      "uintp",
      "ulonglong",
      "unicode_",
      "unsignedinteger",
      "ushort",
      "vectorize",
      "void"
    ]
  },
  "numpy.dtypes": {
    "description": "DType classes and utility (:mod:`numpy.dtypes`)\n===============================================\n\nThis module is home to specific dtypes related functionality and their classes.\nFor more general information about dtypes, also see `numpy.dtype` and\n:ref:`arrays.dtypes`.\n\nSimilar to the builtin ``types`` module, this submodule defines types (classes)\nthat are not widely used directly.\n\n.. versionadded:: NumPy 1.25\n\n    The dtypes module is new in NumPy 1.25.  Previously DType classes were\n    only accessible indirectly.\n\n\nDType classes\n-------------\n\nThe following are the classes of the corresponding NumPy dtype instances and\nNumPy scalar types.  The classes can be used in ``isinstance`` checks and can\nalso be instantiated or used directly.  Direct use of these classes is not\ntypical, since their scalar counterparts (e.g. ``np.float64``) or strings\nlike ``\"float64\"`` can be used.\n\n.. list-table::\n    :header-rows: 1\n\n    * - Group\n      - DType class\n\n    * - Boolean\n      - ``BoolDType``\n\n    * - Bit-sized integers\n      - ``Int8DType``, ``UInt8DType``, ``Int16DType``, ``UInt16DType``,\n        ``Int32DType``, ``UInt32DType``, ``Int64DType``, ``UInt64DType``\n\n    * - C-named integers (may be aliases)\n      - ``ByteDType``, ``UByteDType``, ``ShortDType``, ``UShortDType``,\n        ``IntDType``, ``UIntDType``, ``LongDType``, ``ULongDType``,\n        ``LongLongDType``, ``ULongLongDType``\n\n    * - Floating point\n      - ``Float16DType``, ``Float32DType``, ``Float64DType``,\n        ``LongDoubleDType``\n\n    * - Complex\n      - ``Complex64DType``, ``Complex128DType``, ``CLongDoubleDType``\n\n    * - Strings\n      - ``BytesDType``, ``BytesDType``\n\n    * - Times\n      - ``DateTime64DType``, ``TimeDelta64DType``\n\n    * - Others\n      - ``ObjectDType``, ``VoidDType``",
    "functions": [
      "BoolDType",
      "ByteDType",
      "BytesDType",
      "CLongDoubleDType",
      "Complex128DType",
      "Complex64DType",
      "DateTime64DType",
      "Float16DType",
      "Float32DType",
      "Float64DType",
      "Int16DType",
      "Int32DType",
      "Int64DType",
      "Int8DType",
      "IntDType",
      "LongDType",
      "LongDoubleDType",
      "LongLongDType",
      "ObjectDType",
      "ShortDType",
      "StrDType",
      "TimeDelta64DType",
      "UByteDType",
      "UInt16DType",
      "UInt32DType",
      "UInt64DType",
      "UInt8DType",
      "UIntDType",
      "ULongDType",
      "ULongLongDType",
      "UShortDType",
      "VoidDType"
    ],
    "classes": [
      "BoolDType",
      "ByteDType",
      "BytesDType",
      "CLongDoubleDType",
      "Complex128DType",
      "Complex64DType",
      "DateTime64DType",
      "Float16DType",
      "Float32DType",
      "Float64DType",
      "Int16DType",
      "Int32DType",
      "Int64DType",
      "Int8DType",
      "IntDType",
      "LongDType",
      "LongDoubleDType",
      "LongLongDType",
      "ObjectDType",
      "ShortDType",
      "StrDType",
      "TimeDelta64DType",
      "UByteDType",
      "UInt16DType",
      "UInt32DType",
      "UInt64DType",
      "UInt8DType",
      "UIntDType",
      "ULongDType",
      "ULongLongDType",
      "UShortDType",
      "VoidDType"
    ]
  },
  "numpy.random": {
    "description": "========================\nRandom Number Generation\n========================\n\nUse ``default_rng()`` to create a `Generator` and call its methods.\n\n=============== =========================================================\nGenerator\n--------------- ---------------------------------------------------------\nGenerator       Class implementing all of the random number distributions\ndefault_rng     Default constructor for ``Generator``\n=============== =========================================================\n\n============================================= ===\nBitGenerator Streams that work with Generator\n--------------------------------------------- ---\nMT19937\nPCG64\nPCG64DXSM\nPhilox\nSFC64\n============================================= ===\n\n============================================= ===\nGetting entropy to initialize a BitGenerator\n--------------------------------------------- ---\nSeedSequence\n============================================= ===\n\n\nLegacy\n------\n\nFor backwards compatibility with previous versions of numpy before 1.17, the\nvarious aliases to the global `RandomState` methods are left alone and do not\nuse the new `Generator` API.\n\n==================== =========================================================\nUtility functions\n-------------------- ---------------------------------------------------------\nrandom               Uniformly distributed floats over ``[0, 1)``\nbytes                Uniformly distributed random bytes.\npermutation          Randomly permute a sequence / generate a random sequence.\nshuffle              Randomly permute a sequence in place.\nchoice               Random sample from 1-D array.\n==================== =========================================================\n\n==================== =========================================================\nCompatibility\nfunctions - removed\nin the new API\n-------------------- ---------------------------------------------------------\nrand                 Uniformly distributed values.\nrandn                Normally distributed values.\nranf                 Uniformly distributed floating point numbers.\nrandom_integers      Uniformly distributed integers in a given range.\n                     (deprecated, use ``integers(..., closed=True)`` instead)\nrandom_sample        Alias for `random_sample`\nrandint              Uniformly distributed integers in a given range\nseed                 Seed the legacy random number generator.\n==================== =========================================================\n\n==================== =========================================================\nUnivariate\ndistributions\n-------------------- ---------------------------------------------------------\nbeta                 Beta distribution over ``[0, 1]``.\nbinomial             Binomial distribution.\nchisquare            :math:`\\chi^2` distribution.\nexponential          Exponential distribution.\nf                    F (Fisher-Snedecor) distribution.\ngamma                Gamma distribution.\ngeometric            Geometric distribution.\ngumbel               Gumbel distribution.\nhypergeometric       Hypergeometric distribution.\nlaplace              Laplace distribution.\nlogistic             Logistic distribution.\nlognormal            Log-normal distribution.\nlogseries            Logarithmic series distribution.\nnegative_binomial    Negative binomial distribution.\nnoncentral_chisquare Non-central chi-square distribution.\nnoncentral_f         Non-central F distribution.\nnormal               Normal / Gaussian distribution.\npareto               Pareto distribution.\npoisson              Poisson distribution.\npower                Power distribution.\nrayleigh             Rayleigh distribution.\ntriangular           Triangular distribution.\nuniform              Uniform distribution.\nvonmises             Von Mises circular distribution.\nwald                 Wald (inverse Gaussian) distribution.\nweibull              Weibull distribution.\nzipf                 Zipf's distribution over ranked data.\n==================== =========================================================\n\n==================== ==========================================================\nMultivariate\ndistributions\n-------------------- ----------------------------------------------------------\ndirichlet            Multivariate generalization of Beta distribution.\nmultinomial          Multivariate generalization of the binomial distribution.\nmultivariate_normal  Multivariate generalization of the normal distribution.\n==================== ==========================================================\n\n==================== =========================================================\nStandard\ndistributions\n-------------------- ---------------------------------------------------------\nstandard_cauchy      Standard Cauchy-Lorentz distribution.\nstandard_exponential Standard exponential distribution.\nstandard_gamma       Standard Gamma distribution.\nstandard_normal      Standard normal distribution.\nstandard_t           Standard Student's t-distribution.\n==================== =========================================================\n\n==================== =========================================================\nInternal functions\n-------------------- ---------------------------------------------------------\nget_state            Get tuple representing internal state of generator.\nset_state            Set state of generator.\n==================== =========================================================",
    "functions": [
      "BitGenerator",
      "Generator",
      "MT19937",
      "PCG64",
      "PCG64DXSM",
      "Philox",
      "RandomState",
      "SFC64",
      "SeedSequence",
      "beta",
      "binomial",
      "bytes",
      "chisquare",
      "choice",
      "default_rng",
      "dirichlet",
      "exponential",
      "f",
      "gamma",
      "geometric",
      "get_bit_generator",
      "get_state",
      "gumbel",
      "hypergeometric",
      "laplace",
      "logistic",
      "lognormal",
      "logseries",
      "multinomial",
      "multivariate_normal",
      "negative_binomial",
      "noncentral_chisquare",
      "noncentral_f",
      "normal",
      "pareto",
      "permutation",
      "poisson",
      "power",
      "rand",
      "randint",
      "randn",
      "random",
      "random_integers",
      "random_sample",
      "ranf",
      "rayleigh",
      "sample",
      "seed",
      "set_bit_generator",
      "set_state",
      "shuffle",
      "standard_cauchy",
      "standard_exponential",
      "standard_gamma",
      "standard_normal",
      "standard_t",
      "test",
      "triangular",
      "uniform",
      "vonmises",
      "wald",
      "weibull",
      "zipf"
    ],
    "classes": [
      "BitGenerator",
      "Generator",
      "MT19937",
      "PCG64",
      "PCG64DXSM",
      "Philox",
      "RandomState",
      "SFC64",
      "SeedSequence"
    ]
  },
  "numpy.emath": {
    "description": "No module named 'numpy.emath'",
    "functions": []
  },
  "numpy.lib": {
    "description": "**Note:** almost all functions in the ``numpy.lib`` namespace\nare also present in the main ``numpy`` namespace.  Please use the\nfunctions as ``np.<funcname>`` where possible.\n\n``numpy.lib`` is mostly a space for implementing functions that don't\nbelong in core or in another NumPy submodule with a clear purpose\n(e.g. ``random``, ``fft``, ``linalg``, ``ma``).\n\nMost contains basic functions that are used by several submodules and are\nuseful to have in the main name-space.",
    "functions": [
      "Arrayterator",
      "DataSource",
      "NumpyVersion",
      "RankWarning",
      "add_docstring",
      "add_newdoc",
      "add_newdoc_ufunc",
      "angle",
      "append",
      "apply_along_axis",
      "apply_over_axes",
      "array_split",
      "asarray_chkfinite",
      "asfarray",
      "average",
      "bartlett",
      "bincount",
      "blackman",
      "broadcast_arrays",
      "broadcast_shapes",
      "broadcast_to",
      "byte_bounds",
      "column_stack",
      "common_type",
      "copy",
      "corrcoef",
      "cov",
      "delete",
      "deprecate",
      "deprecate_with_doc",
      "diag",
      "diag_indices",
      "diag_indices_from",
      "diagflat",
      "diff",
      "digitize",
      "disp",
      "dsplit",
      "dstack",
      "ediff1d",
      "expand_dims",
      "extract",
      "eye",
      "fill_diagonal",
      "fix",
      "flip",
      "fliplr",
      "flipud",
      "fromregex",
      "genfromtxt",
      "get_array_wrap",
      "get_include",
      "gradient",
      "hamming",
      "hanning",
      "histogram",
      "histogram2d",
      "histogram_bin_edges",
      "histogramdd",
      "hsplit",
      "i0",
      "imag",
      "in1d",
      "info",
      "insert",
      "interp",
      "intersect1d",
      "iscomplex",
      "iscomplexobj",
      "isin",
      "isneginf",
      "isposinf",
      "isreal",
      "isrealobj",
      "issubclass_",
      "issubdtype",
      "issubsctype",
      "iterable",
      "ix_",
      "kaiser",
      "kron",
      "load",
      "loadtxt",
      "lookfor",
      "mask_indices",
      "median",
      "meshgrid",
      "mintypecode",
      "msort",
      "nan_to_num",
      "nanargmax",
      "nanargmin",
      "nancumprod",
      "nancumsum",
      "nanmax",
      "nanmean",
      "nanmedian",
      "nanmin",
      "nanpercentile",
      "nanprod",
      "nanquantile",
      "nanstd",
      "nansum",
      "nanvar",
      "ndenumerate",
      "ndindex",
      "packbits",
      "pad",
      "percentile",
      "piecewise",
      "place",
      "poly",
      "poly1d",
      "polyadd",
      "polyder",
      "polydiv",
      "polyfit",
      "polyint",
      "polymul",
      "polysub",
      "polyval",
      "put_along_axis",
      "quantile",
      "ravel_multi_index",
      "real",
      "real_if_close",
      "recfromcsv",
      "recfromtxt",
      "roots",
      "rot90",
      "row_stack",
      "safe_eval",
      "save",
      "savetxt",
      "savez",
      "savez_compressed",
      "select",
      "setdiff1d",
      "setxor1d",
      "show_runtime",
      "sinc",
      "sort_complex",
      "source",
      "split",
      "take_along_axis",
      "test",
      "tile",
      "trapz",
      "tri",
      "tril",
      "tril_indices",
      "tril_indices_from",
      "trim_zeros",
      "triu",
      "triu_indices",
      "triu_indices_from",
      "typename",
      "union1d",
      "unique",
      "unpackbits",
      "unravel_index",
      "unwrap",
      "vander",
      "vectorize",
      "vsplit",
      "who"
    ],
    "classes": [
      "Arrayterator",
      "DataSource",
      "NumpyVersion",
      "RankWarning",
      "ndenumerate",
      "ndindex",
      "poly1d",
      "vectorize"
    ]
  },
  "numpy.ctypeslib": {
    "description": "============================\n``ctypes`` Utility Functions\n============================\n\nSee Also\n--------\nload_library : Load a C library.\nndpointer : Array restype/argtype with verification.\nas_ctypes : Create a ctypes array from an ndarray.\nas_array : Create an ndarray from a ctypes array.\n\nReferences\n----------\n.. [1] \"SciPy Cookbook: ctypes\", https://scipy-cookbook.readthedocs.io/items/Ctypes.html\n\nExamples\n--------\nLoad the C library:\n\n>>> _lib = np.ctypeslib.load_library('libmystuff', '.')     #doctest: +SKIP\n\nOur result type, an ndarray that must be of type double, be 1-dimensional\nand is C-contiguous in memory:\n\n>>> array_1d_double = np.ctypeslib.ndpointer(\n...                          dtype=np.double,\n...                          ndim=1, flags='CONTIGUOUS')    #doctest: +SKIP\n\nOur C-function typically takes an array and updates its values\nin-place.  For example::\n\n    void foo_func(double* x, int length)\n    {\n        int i;\n        for (i = 0; i < length; i++) {\n            x[i] = i*i;\n        }\n    }\n\nWe wrap it using:\n\n>>> _lib.foo_func.restype = None                      #doctest: +SKIP\n>>> _lib.foo_func.argtypes = [array_1d_double, c_int] #doctest: +SKIP\n\nThen, we're ready to call ``foo_func``:\n\n>>> out = np.empty(15, dtype=np.double)\n>>> _lib.foo_func(out, len(out))                #doctest: +SKIP",
    "functions": [
      "as_array",
      "as_ctypes",
      "as_ctypes_type",
      "asarray",
      "c_intp",
      "flagsobj",
      "frombuffer",
      "integer",
      "load_library",
      "ndarray",
      "ndpointer"
    ],
    "classes": [
      "c_intp",
      "flagsobj",
      "integer",
      "ndarray"
    ]
  },
  "numpy.linalg": {
    "description": "``numpy.linalg``\n================\n\nThe NumPy linear algebra functions rely on BLAS and LAPACK to provide efficient\nlow level implementations of standard linear algebra algorithms. Those\nlibraries may be provided by NumPy itself using C versions of a subset of their\nreference implementations but, when possible, highly optimized libraries that\ntake advantage of specialized processor functionality are preferred. Examples\nof such libraries are OpenBLAS, MKL (TM), and ATLAS. Because those libraries\nare multithreaded and processor dependent, environmental variables and external\npackages such as threadpoolctl may be needed to control the number of threads\nor specify the processor architecture.\n\n- OpenBLAS: https://www.openblas.net/\n- threadpoolctl: https://github.com/joblib/threadpoolctl\n\nPlease note that the most-used linear algebra functions in NumPy are present in\nthe main ``numpy`` namespace rather than in ``numpy.linalg``.  There are:\n``dot``, ``vdot``, ``inner``, ``outer``, ``matmul``, ``tensordot``, ``einsum``,\n``einsum_path`` and ``kron``.\n\nFunctions present in numpy.linalg are listed below.\n\n\nMatrix and vector products\n--------------------------\n\n   multi_dot\n   matrix_power\n\nDecompositions\n--------------\n\n   cholesky\n   qr\n   svd\n\nMatrix eigenvalues\n------------------\n\n   eig\n   eigh\n   eigvals\n   eigvalsh\n\nNorms and other numbers\n-----------------------\n\n   norm\n   cond\n   det\n   matrix_rank\n   slogdet\n\nSolving equations and inverting matrices\n----------------------------------------\n\n   solve\n   tensorsolve\n   lstsq\n   inv\n   pinv\n   tensorinv\n\nExceptions\n----------\n\n   LinAlgError",
    "functions": [
      "LinAlgError",
      "cholesky",
      "cond",
      "det",
      "eig",
      "eigh",
      "eigvals",
      "eigvalsh",
      "inv",
      "lstsq",
      "matrix_power",
      "matrix_rank",
      "multi_dot",
      "norm",
      "pinv",
      "qr",
      "slogdet",
      "solve",
      "svd",
      "tensorinv",
      "tensorsolve",
      "test"
    ],
    "classes": [
      "LinAlgError"
    ]
  },
  "numpy.strings": {
    "description": "No module named 'numpy.strings'",
    "functions": []
  }
}
