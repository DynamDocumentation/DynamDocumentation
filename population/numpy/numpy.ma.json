{
  "description": "=============\nMasked Arrays\n=============\n\nArrays sometimes contain invalid or missing data.  When doing operations\non such arrays, we wish to suppress invalid values, which is the purpose masked\narrays fulfill (an example of typical use is given below).\n\nFor example, examine the following array:\n\n>>> x = np.array([2, 1, 3, np.nan, 5, 2, 3, np.nan])\n\nWhen we try to calculate the mean of the data, the result is undetermined:\n\n>>> np.mean(x)\nnan\n\nThe mean is calculated using roughly ``np.sum(x)/len(x)``, but since\nany number added to ``NaN`` [1]_ produces ``NaN``, this doesn't work.  Enter\nmasked arrays:\n\n>>> m = np.ma.masked_array(x, np.isnan(x))\n>>> m\nmasked_array(data = [2.0 1.0 3.0 -- 5.0 2.0 3.0 --],\n      mask = [False False False  True False False False  True],\n      fill_value=1e+20)\n\nHere, we construct a masked array that suppress all ``NaN`` values.  We\nmay now proceed to calculate the mean of the other values:\n\n>>> np.mean(m)\n2.6666666666666665\n\n.. [1] Not-a-Number, a floating point value that is the result of an\n       invalid operation.\n\n.. moduleauthor:: Pierre Gerard-Marchant\n.. moduleauthor:: Jarrod Millman",
  "functions": [
    {
      "name": "MAError",
      "signature": "MAError(...)",
      "docstring": {
        "description": "Class for masked array related errors.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "MaskError",
      "signature": "MaskError(...)",
      "docstring": {
        "description": "Class for mask related errors.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "MaskType",
      "signature": "bool_(...)",
      "docstring": {
        "description": "Boolean type (True or False), stored as a byte.\n\n.. warning::\n\n   The :class:`bool_` type is not a subclass of the :class:`int_` type\n   (the :class:`bool_` is not even a number type). This is different\n   than Python's default implementation of :class:`bool` as a\n   sub-class of :class:`int`.\n\n:Character code: ``'?'``",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "MaskedArray",
      "signature": "MaskedArray(data=None, mask=False, dtype=None, copy=False, subok=True, ndmin=0, fill_value=None, keep_mask=True, hard_mask=None, shrink=True, order=None)",
      "docstring": {
        "description": "An array class with possibly masked values.\n\nMasked values of True exclude the corresponding element from any\ncomputation.\n\nConstruction::\n\n  x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\n                  ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\n                  shrink=True, order=None)",
        "parameters": {
          "data": {
            "type": "array_like",
            "description": "Input data."
          },
          "mask": {
            "type": "sequence, optional",
            "description": "Mask. Must be convertible to an array of booleans with the same\n    shape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Data type of the output.\n    If `dtype` is None, the type of the data argument (``data.dtype``)\n    is used. If `dtype` is not None and different from ``data.dtype``,\n    a copy is performed."
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to copy the input data (True), or to use a reference instead.\n    Default is False."
          },
          "subok": {
            "type": "bool, optional",
            "description": "Whether to return a subclass of `MaskedArray` if possible (True) or a\n    plain `MaskedArray`. Default is True."
          },
          "ndmin": {
            "type": "int, optional",
            "description": "Minimum number of dimensions. Default is 0."
          },
          "fill_value": {
            "type": "scalar, optional",
            "description": "Value used to fill in the masked values when necessary.\n    If None, a default based on the data-type is used."
          },
          "keep_mask": {
            "type": "bool, optional",
            "description": "Whether to combine `mask` with the mask of the input data, if any\n    (True), or to use only `mask` for the output (False). Default is True."
          },
          "hard_mask": {
            "type": "bool, optional",
            "description": "Whether to use a hard mask or not. With a hard mask, masked values\n    cannot be unmasked. Default is False."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to force compression of an empty mask. Default is True."
          },
          "order": {
            "type": "{'C', 'F', 'A'}, optional",
            "description": "Specify the order of the array.  If order is 'C', then the array\n    will be in C-contiguous order (last-index varies the fastest).\n    If order is 'F', then the returned array will be in\n    Fortran-contiguous order (first-index varies the fastest).\n    If order is 'A' (default), then the returned array may be\n    in any order (either C-, Fortran-contiguous, or even discontiguous),\n    unless a copy is required, in which case it will be C-contiguous."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "The ``mask`` can be initialized with an array of boolean values\nwith the same shape as ``data``.\n\n>>> data = np.arange(6).reshape((2, 3))\n>>> np.ma.MaskedArray(data, mask=[[False, True, False],\n...                               [False, False, True]])\nmasked_array(\n  data=[[0, --, 2],\n        [3, 4, --]],\n  mask=[[False,  True, False],\n        [False, False,  True]],\n  fill_value=999999)\n\nAlternatively, the ``mask`` can be initialized to homogeneous boolean\narray with the same shape as ``data`` by passing in a scalar\nboolean value:\n\n>>> np.ma.MaskedArray(data, mask=False)\nmasked_array(\n  data=[[0, 1, 2],\n        [3, 4, 5]],\n  mask=[[False, False, False],\n        [False, False, False]],\n  fill_value=999999)\n\n>>> np.ma.MaskedArray(data, mask=True)\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=999999,\n  dtype=int64)\n\n.. note::\n    The recommended practice for initializing ``mask`` with a scalar\n    boolean value is to use ``True``/``False`` rather than\n    ``np.True_``/``np.False_``. The reason is :attr:`nomask`\n    is represented internally as ``np.False_``.\n\n    >>> np.False_ is np.ma.nomask\n    True"
      }
    },
    {
      "name": "abs",
      "signature": "absolute(a, *args, **kwargs)",
      "docstring": {
        "description": "absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate the absolute value element-wise.\n\n``np.abs`` is a shorthand for this function.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "absolute : ndarray\n    An ndarray containing the absolute value of\n    each element in `x`.  For complex input, ``a + ib``, the\n    absolute value is :math:`\\sqrt{ a^2 + b^2 }`.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = np.array([-1.2, 1.2])\n>>> np.absolute(x)\narray([ 1.2,  1.2])\n>>> np.absolute(1.2 + 1j)\n1.5620499351813308\n\nPlot the function over ``[-10, 10]``:\n\n>>> import matplotlib.pyplot as plt\n\n>>> x = np.linspace(start=-10, stop=10, num=101)\n>>> plt.plot(x, np.absolute(x))\n>>> plt.show()\n\nPlot the function over the complex plane:\n\n>>> xx = x + 1j * x[:, np.newaxis]\n>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')\n>>> plt.show()\n\nThe `abs` function can be used as a shorthand for ``np.absolute`` on\nndarrays.\n\n>>> x = np.array([-1.2, 1.2])\n>>> abs(x)\narray([1.2, 1.2])"
      }
    },
    {
      "name": "absolute",
      "signature": "absolute(a, *args, **kwargs)",
      "docstring": {
        "description": "absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate the absolute value element-wise.\n\n``np.abs`` is a shorthand for this function.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "absolute : ndarray\n    An ndarray containing the absolute value of\n    each element in `x`.  For complex input, ``a + ib``, the\n    absolute value is :math:`\\sqrt{ a^2 + b^2 }`.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = np.array([-1.2, 1.2])\n>>> np.absolute(x)\narray([ 1.2,  1.2])\n>>> np.absolute(1.2 + 1j)\n1.5620499351813308\n\nPlot the function over ``[-10, 10]``:\n\n>>> import matplotlib.pyplot as plt\n\n>>> x = np.linspace(start=-10, stop=10, num=101)\n>>> plt.plot(x, np.absolute(x))\n>>> plt.show()\n\nPlot the function over the complex plane:\n\n>>> xx = x + 1j * x[:, np.newaxis]\n>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')\n>>> plt.show()\n\nThe `abs` function can be used as a shorthand for ``np.absolute`` on\nndarrays.\n\n>>> x = np.array([-1.2, 1.2])\n>>> abs(x)\narray([1.2, 1.2])"
      }
    },
    {
      "name": "add",
      "signature": "add(a, b, *args, **kwargs)",
      "docstring": {
        "description": "add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nAdd arguments element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "add : ndarray or scalar\n    The sum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "",
        "notes": "Equivalent to `x1` + `x2` in terms of array broadcasting.",
        "examples": ">>> np.add(1.0, 4.0)\n5.0\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.add(x1, x2)\narray([[  0.,   2.,   4.],\n       [  3.,   5.,   7.],\n       [  6.,   8.,  10.]])\n\nThe ``+`` operator can be used as a shorthand for ``np.add`` on ndarrays.\n\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> x1 + x2\narray([[ 0.,  2.,  4.],\n       [ 3.,  5.,  7.],\n       [ 6.,  8., 10.]])"
      }
    },
    {
      "name": "all",
      "signature": "all(a, *args, **params)",
      "docstring": {
        "description": "all(self, axis=None, out=None, keepdims=<no value>)\n\nReturns True if all elements evaluate to True.\n\nThe output array is masked where all the values along the given axis\nare masked: if the output would have been a scalar and that all the\nvalues are masked, then the output is `masked`.\n\nRefer to `numpy.all` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.ndarray.all : corresponding function for ndarrays\nnumpy.all : equivalent function",
        "notes": "",
        "examples": ">>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue"
      }
    },
    {
      "name": "allclose",
      "signature": "allclose(a, b, masked_equal=True, rtol=1e-05, atol=1e-08)",
      "docstring": {
        "description": "Returns True if two arrays are element-wise equal within a tolerance.\n\nThis function is equivalent to `allclose` except that masked values\nare treated as equal (default) or unequal, depending on the `masked_equal`\nargument.",
        "parameters": {
          "masked_equal": {
            "type": "bool, optional",
            "description": "Whether masked values in `a` and `b` are considered equal (True) or not\n    (False). They are considered equal by default."
          },
          "rtol": {
            "type": "float, optional",
            "description": "Relative tolerance. The relative difference is equal to ``rtol * b``.\n    Default is 1e-5."
          },
          "atol": {
            "type": "float, optional",
            "description": "Absolute tolerance. The absolute difference is equal to `atol`.\n    Default is 1e-8."
          }
        },
        "returns": "y : bool\n    Returns True if the two arrays are equal within the given\n    tolerance, False otherwise. If either array contains NaN, then\n    False is returned.",
        "raises": "",
        "see_also": "all, any\nnumpy.allclose : the non-masked `allclose`.",
        "notes": "If the following equation is element-wise True, then `allclose` returns\nTrue::\n\n  absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\nReturn True if all elements of `a` and `b` are equal subject to\ngiven tolerances.",
        "examples": ">>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n>>> a\nmasked_array(data=[10000000000.0, 1e-07, --],\n             mask=[False, False,  True],\n       fill_value=1e+20)\n>>> b = np.ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])\n>>> np.ma.allclose(a, b)\nFalse\n\n>>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n>>> b = np.ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])\n>>> np.ma.allclose(a, b)\nTrue\n>>> np.ma.allclose(a, b, masked_equal=False)\nFalse\n\nMasked values are not compared directly.\n\n>>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n>>> b = np.ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])\n>>> np.ma.allclose(a, b)\nTrue\n>>> np.ma.allclose(a, b, masked_equal=False)\nFalse"
      }
    },
    {
      "name": "allequal",
      "signature": "allequal(a, b, fill_value=True)",
      "docstring": {
        "description": "Return True if all entries of a and b are equal, using\nfill_value as a truth value where either or both are masked.",
        "parameters": {
          "fill_value": {
            "type": "bool, optional",
            "description": "Whether masked values in a or b are considered equal (True) or not\n    (False)."
          }
        },
        "returns": "y : bool\n    Returns True if the two arrays are equal within the given\n    tolerance, False otherwise. If either array contains NaN,\n    then False is returned.",
        "raises": "",
        "see_also": "all, any\nnumpy.ma.allclose",
        "notes": "",
        "examples": ">>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n>>> a\nmasked_array(data=[10000000000.0, 1e-07, --],\n             mask=[False, False,  True],\n       fill_value=1e+20)\n\n>>> b = np.array([1e10, 1e-7, -42.0])\n>>> b\narray([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])\n>>> np.ma.allequal(a, b, fill_value=False)\nFalse\n>>> np.ma.allequal(a, b)\nTrue"
      }
    },
    {
      "name": "alltrue",
      "signature": "reduce(target, axis=0, dtype=None)",
      "docstring": {
        "description": "Reduce `target` along the given `axis`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "amax",
      "signature": "amax(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)",
      "docstring": {
        "description": "Return the maximum of an array or maximum along an axis.\n\n`amax` is an alias of `~numpy.max`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "max : alias of this function\nndarray.max : equivalent method",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "amin",
      "signature": "amin(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)",
      "docstring": {
        "description": "Return the minimum of an array or minimum along an axis.\n\n`amin` is an alias of `~numpy.min`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "min : alias of this function\nndarray.min : equivalent method",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "angle",
      "signature": "angle(a, *args, **kwargs)",
      "docstring": {
        "description": "Return the angle of the complex argument.",
        "parameters": {
          "z": {
            "type": "array_like",
            "description": "A complex number or sequence of complex numbers."
          },
          "deg": {
            "type": "bool, optional",
            "description": "Return angle in degrees if True, radians if False (default)."
          }
        },
        "returns": "angle : ndarray or scalar\n    The counterclockwise angle from the positive real axis on the complex\n    plane in the range ``(-pi, pi]``, with dtype as numpy.float64.\n\n    .. versionchanged:: 1.16.0\n        This function works on subclasses of ndarray like `ma.array`.",
        "raises": "",
        "see_also": "arctan2\nabsolute",
        "notes": "Although the angle of the complex number 0 is undefined, ``numpy.angle(0)``\nreturns the value 0.",
        "examples": ">>> np.angle([1.0, 1.0j, 1+1j])               # in radians\narray([ 0.        ,  1.57079633,  0.78539816]) # may vary\n>>> np.angle(1+1j, deg=True)                  # in degrees\n45.0"
      }
    },
    {
      "name": "anom",
      "signature": "anom(a, *args, **params)",
      "docstring": {
        "description": "anom(self, axis=None, dtype=None)\n\nCompute the anomalies (deviations from the arithmetic mean)\nalong the given axis.\n\nReturns an array of anomalies, with the same shape as the input and\nwhere the arithmetic mean is computed along the given axis.",
        "parameters": {
          "axis": {
            "type": "int, optional",
            "description": "Axis over which the anomalies are taken.\n    The default is to use the mean of the flattened array as reference."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Type to use in computing the variance. For arrays of integer type\n     the default is float32; for arrays of float types it is the same as\n     the array type."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "mean : Compute the mean of the array.",
        "notes": "",
        "examples": ">>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)"
      }
    },
    {
      "name": "anomalies",
      "signature": "anom(a, *args, **params)",
      "docstring": {
        "description": "anom(self, axis=None, dtype=None)\n\nCompute the anomalies (deviations from the arithmetic mean)\nalong the given axis.\n\nReturns an array of anomalies, with the same shape as the input and\nwhere the arithmetic mean is computed along the given axis.",
        "parameters": {
          "axis": {
            "type": "int, optional",
            "description": "Axis over which the anomalies are taken.\n    The default is to use the mean of the flattened array as reference."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Type to use in computing the variance. For arrays of integer type\n     the default is float32; for arrays of float types it is the same as\n     the array type."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "mean : Compute the mean of the array.",
        "notes": "",
        "examples": ">>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)"
      }
    },
    {
      "name": "any",
      "signature": "any(a, *args, **params)",
      "docstring": {
        "description": "any(self, axis=None, out=None, keepdims=<no value>)\n\nReturns True if any of the elements of `a` evaluate to True.\n\nMasked values are considered as False during computation.\n\nRefer to `numpy.any` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.ndarray.any : corresponding function for ndarrays\nnumpy.any : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "append",
      "signature": "append(a, b, axis=None)",
      "docstring": {
        "description": "Append values to the end of an array.\n\n.. versionadded:: 1.9.0",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Values are appended to a copy of this array."
          },
          "b": {
            "type": "array_like",
            "description": "These values are appended to a copy of `a`.  It must be of the\n    correct shape (the same shape as `a`, excluding `axis`).  If `axis`\n    is not specified, `b` can be any shape and will be flattened\n    before use."
          },
          "axis": {
            "type": "int, optional",
            "description": "The axis along which `v` are appended.  If `axis` is not given,\n    both `a` and `b` are flattened before use."
          }
        },
        "returns": "append : MaskedArray\n    A copy of `a` with `b` appended to `axis`.  Note that `append`\n    does not occur in-place: a new array is allocated and filled.  If\n    `axis` is None, the result is a flattened array.",
        "raises": "",
        "see_also": "numpy.append : Equivalent function in the top-level NumPy module.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = ma.masked_values([1, 2, 3], 2)\n>>> b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)\n>>> ma.append(a, b)\nmasked_array(data=[1, --, 3, 4, 5, 6, --, 8, 9],\n             mask=[False,  True, False, False, False, False,  True, False,\n                   False],\n       fill_value=999999)"
      }
    },
    {
      "name": "apply_along_axis",
      "signature": "apply_along_axis(func1d, axis, arr, *args, **kwargs)",
      "docstring": {
        "description": "Apply a function to 1-D slices along the given axis.\n\nExecute `func1d(a, *args, **kwargs)` where `func1d` operates on 1-D arrays\nand `a` is a 1-D slice of `arr` along `axis`.\n\nThis is equivalent to (but faster than) the following use of `ndindex` and\n`s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices::\n\n    Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n    for ii in ndindex(Ni):\n        for kk in ndindex(Nk):\n            f = func1d(arr[ii + s_[:,] + kk])\n            Nj = f.shape\n            for jj in ndindex(Nj):\n                out[ii + jj + kk] = f[jj]\n\nEquivalently, eliminating the inner loop, this can be expressed as::\n\n    Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n    for ii in ndindex(Ni):\n        for kk in ndindex(Nk):\n            out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])",
        "parameters": {
          "func1d": {
            "type": "function (M,) -> (Nj...)",
            "description": "This function should accept 1-D arrays. It is applied to 1-D\n    slices of `arr` along the specified axis."
          },
          "axis": {
            "type": "integer",
            "description": "Axis along which `arr` is sliced."
          },
          "arr": {
            "type": "ndarray (Ni..., M, Nk...)",
            "description": "Input array."
          },
          "args": {
            "type": "any",
            "description": "Additional arguments to `func1d`."
          },
          "kwargs": {
            "type": "any",
            "description": "Additional named arguments to `func1d`.\n\n    .. versionadded:: 1.9.0"
          }
        },
        "returns": "out : ndarray  (Ni..., Nj..., Nk...)\n    The output array. The shape of `out` is identical to the shape of\n    `arr`, except along the `axis` dimension. This axis is removed, and\n    replaced with new dimensions equal to the shape of the return value\n    of `func1d`. So if `func1d` returns a scalar `out` will have one\n    fewer dimensions than `arr`.",
        "raises": "",
        "see_also": "apply_over_axes : Apply a function repeatedly over multiple axes.",
        "notes": "",
        "examples": ">>> def my_func(a):\n...     \"\"\"Average first and last element of a 1-D array\"\"\"\n...     return (a[0] + a[-1]) * 0.5\n>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n>>> np.apply_along_axis(my_func, 0, b)\narray([4., 5., 6.])\n>>> np.apply_along_axis(my_func, 1, b)\narray([2.,  5.,  8.])\n\nFor a function that returns a 1D array, the number of dimensions in\n`outarr` is the same as `arr`.\n\n>>> b = np.array([[8,1,7], [4,3,9], [5,2,6]])\n>>> np.apply_along_axis(sorted, 1, b)\narray([[1, 7, 8],\n       [3, 4, 9],\n       [2, 5, 6]])\n\nFor a function that returns a higher dimensional array, those dimensions\nare inserted in place of the `axis` dimension.\n\n>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n>>> np.apply_along_axis(np.diag, -1, b)\narray([[[1, 0, 0],\n        [0, 2, 0],\n        [0, 0, 3]],\n       [[4, 0, 0],\n        [0, 5, 0],\n        [0, 0, 6]],\n       [[7, 0, 0],\n        [0, 8, 0],\n        [0, 0, 9]]])"
      }
    },
    {
      "name": "apply_over_axes",
      "signature": "apply_over_axes(func, a, axes)",
      "docstring": {
        "description": "Apply a function repeatedly over multiple axes.\n\n`func` is called as `res = func(a, axis)`, where `axis` is the first\nelement of `axes`.  The result `res` of the function call must have\neither the same dimensions as `a` or one less dimension.  If `res`\nhas one less dimension than `a`, a dimension is inserted before\n`axis`.  The call to `func` is then repeated for each axis in `axes`,\nwith `res` as the first argument.",
        "parameters": {
          "func": {
            "type": "function",
            "description": "This function must take two arguments, `func(a, axis)`."
          },
          "a": {
            "type": "array_like",
            "description": "Input array."
          },
          "axes": {
            "type": "array_like",
            "description": "Axes over which `func` is applied; the elements must be integers."
          }
        },
        "returns": "apply_over_axis : ndarray\n    The output array.  The number of dimensions is the same as `a`,\n    but the shape can be different.  This depends on whether `func`\n    changes the shape of its output with respect to its input.",
        "raises": "",
        "see_also": "apply_along_axis :\n    Apply a function to 1-D slices of an array along the given axis.",
        "notes": "",
        "examples": ">>> a = np.ma.arange(24).reshape(2,3,4)\n>>> a[:,0,1] = np.ma.masked\n>>> a[:,1,:] = np.ma.masked\n>>> a\nmasked_array(\n  data=[[[0, --, 2, 3],\n         [--, --, --, --],\n         [8, 9, 10, 11]],\n        [[12, --, 14, 15],\n         [--, --, --, --],\n         [20, 21, 22, 23]]],\n  mask=[[[False,  True, False, False],\n         [ True,  True,  True,  True],\n         [False, False, False, False]],\n        [[False,  True, False, False],\n         [ True,  True,  True,  True],\n         [False, False, False, False]]],\n  fill_value=999999)\n>>> np.ma.apply_over_axes(np.ma.sum, a, [0,2])\nmasked_array(\n  data=[[[46],\n         [--],\n         [124]]],\n  mask=[[[False],\n         [ True],\n         [False]]],\n  fill_value=999999)\n\nTuple axis arguments to ufuncs are equivalent:\n\n>>> np.ma.sum(a, axis=(0,2)).reshape((1,-1,1))\nmasked_array(\n  data=[[[46],\n         [--],\n         [124]]],\n  mask=[[[False],\n         [ True],\n         [False]]],\n  fill_value=999999)"
      }
    },
    {
      "name": "arange",
      "signature": "arange(...)",
      "docstring": {}
    },
    {
      "name": "arccos",
      "signature": "arccos(a, *args, **kwargs)",
      "docstring": {
        "description": "arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTrigonometric inverse cosine, element-wise.\n\nThe inverse of `cos` so that, if ``y = cos(x)``, then ``x = arccos(y)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "`x`-coordinate on the unit circle.\n    For real arguments, the domain is [-1, 1]."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "angle : ndarray\n    The angle of the ray intersecting the unit circle at the given\n    `x`-coordinate in radians [0, pi].\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "cos, arctan, arcsin, emath.arccos",
        "notes": "`arccos` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that ``cos(z) = x``. The convention is to return\nthe angle `z` whose real part lies in `[0, pi]`.\n\nFor real-valued input data types, `arccos` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arccos` is a complex analytic function that\nhas branch cuts ``[-inf, -1]`` and `[1, inf]` and is continuous from\nabove on the former and from below on the latter.\n\nThe inverse `cos` is also known as `acos` or cos^-1.\n\nReferences\n----------\nM. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n10th printing, 1964, pp. 79.\nhttps://personal.math.ubc.ca/~cbm/aands/page_79.htm",
        "examples": "We expect the arccos of 1 to be 0, and of -1 to be pi:\n\n>>> np.arccos([1, -1])\narray([ 0.        ,  3.14159265])\n\nPlot arccos:\n\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-1, 1, num=100)\n>>> plt.plot(x, np.arccos(x))\n>>> plt.axis('tight')\n>>> plt.show()"
      }
    },
    {
      "name": "arccosh",
      "signature": "arccosh(a, *args, **kwargs)",
      "docstring": {
        "description": "arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nInverse hyperbolic cosine, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "arccosh : ndarray\n    Array of the same shape as `x`.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "cosh, arcsinh, sinh, arctanh, tanh",
        "notes": "`arccosh` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that `cosh(z) = x`. The convention is to return the\n`z` whose imaginary part lies in ``[-pi, pi]`` and the real part in\n``[0, inf]``.\n\nFor real-valued input data types, `arccosh` always returns real output.\nFor each value that cannot be expressed as a real number or infinity, it\nyields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arccosh` is a complex analytical function that\nhas a branch cut `[-inf, 1]` and is continuous from above on it.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n       10th printing, 1964, pp. 86.\n       https://personal.math.ubc.ca/~cbm/aands/page_86.htm\n.. [2] Wikipedia, \"Inverse hyperbolic function\",\n       https://en.wikipedia.org/wiki/Arccosh",
        "examples": ">>> np.arccosh([np.e, 10.0])\narray([ 1.65745445,  2.99322285])\n>>> np.arccosh(1)\n0.0"
      }
    },
    {
      "name": "arcsin",
      "signature": "arcsin(a, *args, **kwargs)",
      "docstring": {
        "description": "arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nInverse sine, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "`y`-coordinate on the unit circle."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "angle : ndarray\n    The inverse sine of each element in `x`, in radians and in the\n    closed interval ``[-pi/2, pi/2]``.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "sin, cos, arccos, tan, arctan, arctan2, emath.arcsin",
        "notes": "`arcsin` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that :math:`sin(z) = x`.  The convention is to\nreturn the angle `z` whose real part lies in [-pi/2, pi/2].\n\nFor real-valued input data types, *arcsin* always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arcsin` is a complex analytic function that\nhas, by convention, the branch cuts [-inf, -1] and [1, inf]  and is\ncontinuous from above on the former and from below on the latter.\n\nThe inverse sine is also known as `asin` or sin^{-1}.\n\nReferences\n----------\nAbramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,\n10th printing, New York: Dover, 1964, pp. 79ff.\nhttps://personal.math.ubc.ca/~cbm/aands/page_79.htm",
        "examples": ">>> np.arcsin(1)     # pi/2\n1.5707963267948966\n>>> np.arcsin(-1)    # -pi/2\n-1.5707963267948966\n>>> np.arcsin(0)\n0.0"
      }
    },
    {
      "name": "arcsinh",
      "signature": "arcsinh(a, *args, **kwargs)",
      "docstring": {
        "description": "arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nInverse hyperbolic sine element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : ndarray or scalar\n    Array of the same shape as `x`.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "`arcsinh` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that `sinh(z) = x`. The convention is to return the\n`z` whose imaginary part lies in `[-pi/2, pi/2]`.\n\nFor real-valued input data types, `arcsinh` always returns real output.\nFor each value that cannot be expressed as a real number or infinity, it\nreturns ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arccos` is a complex analytical function that\nhas branch cuts `[1j, infj]` and `[-1j, -infj]` and is continuous from\nthe right on the former and from the left on the latter.\n\nThe inverse hyperbolic sine is also known as `asinh` or ``sinh^-1``.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n       10th printing, 1964, pp. 86.\n       https://personal.math.ubc.ca/~cbm/aands/page_86.htm\n.. [2] Wikipedia, \"Inverse hyperbolic function\",\n       https://en.wikipedia.org/wiki/Arcsinh",
        "examples": ">>> np.arcsinh(np.array([np.e, 10.0]))\narray([ 1.72538256,  2.99822295])"
      }
    },
    {
      "name": "arctan",
      "signature": "arctan(a, *args, **kwargs)",
      "docstring": {
        "description": "arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTrigonometric inverse tangent, element-wise.\n\nThe inverse of tan, so that if ``y = tan(x)`` then ``x = arctan(y)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": ""
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : ndarray or scalar\n    Out has the same shape as `x`.  Its real part is in\n    ``[-pi/2, pi/2]`` (``arctan(+/-inf)`` returns ``+/-pi/2``).\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "arctan2 : The \"four quadrant\" arctan of the angle formed by (`x`, `y`)\n    and the positive `x`-axis.\nangle : Argument of complex values.",
        "notes": "`arctan` is a multi-valued function: for each `x` there are infinitely\nmany numbers `z` such that tan(`z`) = `x`.  The convention is to return\nthe angle `z` whose real part lies in [-pi/2, pi/2].\n\nFor real-valued input data types, `arctan` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arctan` is a complex analytic function that\nhas [``1j, infj``] and [``-1j, -infj``] as branch cuts, and is continuous\nfrom the left on the former and from the right on the latter.\n\nThe inverse tangent is also known as `atan` or tan^{-1}.\n\nReferences\n----------\nAbramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,\n10th printing, New York: Dover, 1964, pp. 79.\nhttps://personal.math.ubc.ca/~cbm/aands/page_79.htm",
        "examples": "We expect the arctan of 0 to be 0, and of 1 to be pi/4:\n\n>>> np.arctan([0, 1])\narray([ 0.        ,  0.78539816])\n\n>>> np.pi/4\n0.78539816339744828\n\nPlot arctan:\n\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-10, 10)\n>>> plt.plot(x, np.arctan(x))\n>>> plt.axis('tight')\n>>> plt.show()"
      }
    },
    {
      "name": "arctan2",
      "signature": "arctan2(a, b, *args, **kwargs)",
      "docstring": {
        "description": "arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise arc tangent of ``x1/x2`` choosing the quadrant correctly.\n\nThe quadrant (i.e., branch) is chosen so that ``arctan2(x1, x2)`` is\nthe signed angle in radians between the ray ending at the origin and\npassing through the point (1,0), and the ray ending at the origin and\npassing through the point (`x2`, `x1`).  (Note the role reversal: the\n\"`y`-coordinate\" is the first function parameter, the \"`x`-coordinate\"\nis the second.)  By IEEE convention, this function is defined for\n`x2` = +/-0 and for either or both of `x1` and `x2` = +/-inf (see\nNotes for specific values).\n\nThis function is not defined for complex-valued arguments; for the\nso-called argument of complex values, use `angle`.",
        "parameters": {
          "x1": {
            "type": "array_like, real-valued",
            "description": "`y`-coordinates."
          },
          "x2": {
            "type": "array_like, real-valued",
            "description": "`x`-coordinates.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "angle : ndarray\n    Array of angles in radians, in the range ``[-pi, pi]``.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "arctan, tan, angle",
        "notes": "*arctan2* is identical to the `atan2` function of the underlying\nC library.  The following special values are defined in the C\nstandard: [1]_\n\n====== ====== ================\n`x1`   `x2`   `arctan2(x1,x2)`\n====== ====== ================\n+/- 0  +0     +/- 0\n+/- 0  -0     +/- pi\n > 0   +/-inf +0 / +pi\n < 0   +/-inf -0 / -pi\n+/-inf +inf   +/- (pi/4)\n+/-inf -inf   +/- (3*pi/4)\n====== ====== ================\n\nNote that +0 and -0 are distinct floating point numbers, as are +inf\nand -inf.\n\nReferences\n----------\n.. [1] ISO/IEC standard 9899:1999, \"Programming language C.\"",
        "examples": "Consider four points in different quadrants:\n\n>>> x = np.array([-1, +1, +1, -1])\n>>> y = np.array([-1, -1, +1, +1])\n>>> np.arctan2(y, x) * 180 / np.pi\narray([-135.,  -45.,   45.,  135.])\n\nNote the order of the parameters. `arctan2` is defined also when `x2` = 0\nand at several other special points, obtaining values in\nthe range ``[-pi, pi]``:\n\n>>> np.arctan2([1., -1.], [0., 0.])\narray([ 1.57079633, -1.57079633])\n>>> np.arctan2([0., 0., np.inf], [+0., -0., np.inf])\narray([0.        , 3.14159265, 0.78539816])"
      }
    },
    {
      "name": "arctanh",
      "signature": "arctanh(a, *args, **kwargs)",
      "docstring": {
        "description": "arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nInverse hyperbolic tangent element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : ndarray or scalar\n    Array of the same shape as `x`.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "emath.arctanh",
        "notes": "`arctanh` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that ``tanh(z) = x``. The convention is to return\nthe `z` whose imaginary part lies in `[-pi/2, pi/2]`.\n\nFor real-valued input data types, `arctanh` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arctanh` is a complex analytical function\nthat has branch cuts `[-1, -inf]` and `[1, inf]` and is continuous from\nabove on the former and from below on the latter.\n\nThe inverse hyperbolic tangent is also known as `atanh` or ``tanh^-1``.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n       10th printing, 1964, pp. 86.\n       https://personal.math.ubc.ca/~cbm/aands/page_86.htm\n.. [2] Wikipedia, \"Inverse hyperbolic function\",\n       https://en.wikipedia.org/wiki/Arctanh",
        "examples": ">>> np.arctanh([0, -0.5])\narray([ 0.        , -0.54930614])"
      }
    },
    {
      "name": "argmax",
      "signature": "argmax(a, *args, **params)",
      "docstring": {
        "description": "argmax(self, axis=None, fill_value=None, out=None)\n\nReturns array of indices of the maximum values along the given axis.\nMasked values are treated as if they had the value fill_value.",
        "parameters": {
          "axis": {
            "type": "{None, integer}",
            "description": "If None, the index is into the flattened array, otherwise along\n    the specified axis"
          },
          "fill_value": {
            "type": "scalar or None, optional",
            "description": "Value used to fill in the masked values.  If None, the output of\n    maximum_fill_value(self._data) is used instead."
          },
          "out": {
            "type": "{None, array}, optional",
            "description": "Array into which the result can be placed. Its type is preserved\n    and it must be of the right shape to hold the output."
          }
        },
        "returns": "index_array : {integer_array}",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])"
      }
    },
    {
      "name": "argmin",
      "signature": "argmin(a, *args, **params)",
      "docstring": {
        "description": "argmin(self, axis=None, fill_value=None, out=None)\n\nReturn array of indices to the minimum values along the given axis.",
        "parameters": {
          "axis": {
            "type": "{None, integer}",
            "description": "If None, the index is into the flattened array, otherwise along\n    the specified axis"
          },
          "fill_value": {
            "type": "scalar or None, optional",
            "description": "Value used to fill in the masked values.  If None, the output of\n    minimum_fill_value(self._data) is used instead."
          },
          "out": {
            "type": "{None, array}, optional",
            "description": "Array into which the result can be placed. Its type is preserved\n    and it must be of the right shape to hold the output."
          }
        },
        "returns": "ndarray or scalar\n    If multi-dimension input, returns a new ndarray of indices to the\n    minimum values along the given axis.  Otherwise, returns a scalar\n    of index to the minimum values along the given axis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> x\nmasked_array(\n  data=[[--, --],\n        [2, 3]],\n  mask=[[ True,  True],\n        [False, False]],\n  fill_value=999999)\n>>> x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n>>> x.argmin(axis=0, fill_value=9)\narray([1, 1])"
      }
    },
    {
      "name": "argsort",
      "signature": "argsort(a, axis=<no value>, kind=None, order=None, endwith=True, fill_value=None)",
      "docstring": {
        "description": "Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\n`fill_value`.",
        "parameters": {
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to sort. If None, the default, the flattened array\n    is used.\n\n    ..  versionchanged:: 1.13.0\n        Previously, the default was documented to be -1, but that was\n        in error. At some future date, the default will change to -1, as\n        originally intended.\n        Until then, the axis should be given explicitly when\n        ``arr.ndim > 1``, to avoid a FutureWarning."
          },
          "kind": {
            "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
            "description": "The sorting algorithm used."
          },
          "order": {
            "type": "list, optional",
            "description": "When `a` is an array with fields defined, this argument specifies\n    which fields to compare first, second, etc.  Not all fields need be\n    specified."
          },
          "endwith": {
            "type": "{True, False}, optional",
            "description": "Whether missing values (if any) should be treated as the largest values\n    (True) or the smallest values (False)\n    When the array contains unmasked values at the same extremes of the\n    datatype, the ordering of these values and the masked values is\n    undefined."
          },
          "fill_value": {
            "type": "scalar or None, optional",
            "description": "Value used internally for the masked values.\n    If ``fill_value`` is not None, it supersedes ``endwith``."
          }
        },
        "returns": "index_array : ndarray, int\n    Array of indices that sort `a` along the specified axis.\n    In other words, ``a[index_array]`` yields a sorted `a`.",
        "raises": "",
        "see_also": "ma.MaskedArray.sort : Describes sorting algorithms used.\nlexsort : Indirect stable sort with multiple keys.\nnumpy.ndarray.sort : Inplace sort.",
        "notes": "See `sort` for notes on the different sorting algorithms.",
        "examples": ">>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data=[3, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n>>> a.argsort()\narray([1, 0, 2])"
      }
    },
    {
      "name": "around",
      "signature": "round_(a, *args, **kwargs)",
      "docstring": {
        "description": "Round an array to the given number of decimals.\n\n`~numpy.round_` is a disrecommended backwards-compatibility\nalias of `~numpy.around` and `~numpy.round`.\n\n.. deprecated:: 1.25.0\n    ``round_`` is deprecated as of NumPy 1.25.0, and will be\n    removed in NumPy 2.0. Please use `round` instead.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "around : equivalent function; see for details.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "array",
      "signature": "array(data, dtype=None, copy=False, order=None, mask=False, fill_value=None, keep_mask=True, hard_mask=False, shrink=True, subok=True, ndmin=0)",
      "docstring": {
        "description": "An array class with possibly masked values.\n\nMasked values of True exclude the corresponding element from any\ncomputation.\n\nConstruction::\n\n  x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\n                  ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\n                  shrink=True, order=None)",
        "parameters": {
          "data": {
            "type": "array_like",
            "description": "Input data."
          },
          "mask": {
            "type": "sequence, optional",
            "description": "Mask. Must be convertible to an array of booleans with the same\n    shape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Data type of the output.\n    If `dtype` is None, the type of the data argument (``data.dtype``)\n    is used. If `dtype` is not None and different from ``data.dtype``,\n    a copy is performed."
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to copy the input data (True), or to use a reference instead.\n    Default is False."
          },
          "subok": {
            "type": "bool, optional",
            "description": "Whether to return a subclass of `MaskedArray` if possible (True) or a\n    plain `MaskedArray`. Default is True."
          },
          "ndmin": {
            "type": "int, optional",
            "description": "Minimum number of dimensions. Default is 0."
          },
          "fill_value": {
            "type": "scalar, optional",
            "description": "Value used to fill in the masked values when necessary.\n    If None, a default based on the data-type is used."
          },
          "keep_mask": {
            "type": "bool, optional",
            "description": "Whether to combine `mask` with the mask of the input data, if any\n    (True), or to use only `mask` for the output (False). Default is True."
          },
          "hard_mask": {
            "type": "bool, optional",
            "description": "Whether to use a hard mask or not. With a hard mask, masked values\n    cannot be unmasked. Default is False."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to force compression of an empty mask. Default is True."
          },
          "order": {
            "type": "{'C', 'F', 'A'}, optional",
            "description": "Specify the order of the array.  If order is 'C', then the array\n    will be in C-contiguous order (last-index varies the fastest).\n    If order is 'F', then the returned array will be in\n    Fortran-contiguous order (first-index varies the fastest).\n    If order is 'A' (default), then the returned array may be\n    in any order (either C-, Fortran-contiguous, or even discontiguous),\n    unless a copy is required, in which case it will be C-contiguous."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "The ``mask`` can be initialized with an array of boolean values\nwith the same shape as ``data``.\n\n>>> data = np.arange(6).reshape((2, 3))\n>>> np.ma.MaskedArray(data, mask=[[False, True, False],\n...                               [False, False, True]])\nmasked_array(\n  data=[[0, --, 2],\n        [3, 4, --]],\n  mask=[[False,  True, False],\n        [False, False,  True]],\n  fill_value=999999)\n\nAlternatively, the ``mask`` can be initialized to homogeneous boolean\narray with the same shape as ``data`` by passing in a scalar\nboolean value:\n\n>>> np.ma.MaskedArray(data, mask=False)\nmasked_array(\n  data=[[0, 1, 2],\n        [3, 4, 5]],\n  mask=[[False, False, False],\n        [False, False, False]],\n  fill_value=999999)\n\n>>> np.ma.MaskedArray(data, mask=True)\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=999999,\n  dtype=int64)\n\n.. note::\n    The recommended practice for initializing ``mask`` with a scalar\n    boolean value is to use ``True``/``False`` rather than\n    ``np.True_``/``np.False_``. The reason is :attr:`nomask`\n    is represented internally as ``np.False_``.\n\n    >>> np.False_ is np.ma.nomask\n    True"
      }
    },
    {
      "name": "asanyarray",
      "signature": "asanyarray(a, dtype=None)",
      "docstring": {
        "description": "Convert the input to a masked array, conserving subclasses.\n\nIf `a` is a subclass of `MaskedArray`, its class is conserved.\nNo copy is performed if the input is already an `ndarray`.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input data, in any form that can be converted to an array."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "By default, the data-type is inferred from the input data."
          },
          "order": {
            "type": "{'C', 'F'}, optional",
            "description": "Whether to use row-major ('C') or column-major ('FORTRAN') memory\n    representation.  Default is 'C'."
          }
        },
        "returns": "out : MaskedArray\n    MaskedArray interpretation of `a`.",
        "raises": "",
        "see_also": "asarray : Similar to `asanyarray`, but does not conserve subclass.",
        "notes": "",
        "examples": ">>> x = np.arange(10.).reshape(2, 5)\n>>> x\narray([[0., 1., 2., 3., 4.],\n       [5., 6., 7., 8., 9.]])\n>>> np.ma.asanyarray(x)\nmasked_array(\n  data=[[0., 1., 2., 3., 4.],\n        [5., 6., 7., 8., 9.]],\n  mask=False,\n  fill_value=1e+20)\n>>> type(np.ma.asanyarray(x))\n<class 'numpy.ma.core.MaskedArray'>"
      }
    },
    {
      "name": "asarray",
      "signature": "asarray(a, dtype=None, order=None)",
      "docstring": {
        "description": "Convert the input to a masked array of the given data-type.\n\nNo copy is performed if the input is already an `ndarray`. If `a` is\na subclass of `MaskedArray`, a base class `MaskedArray` is returned.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input data, in any form that can be converted to a masked array. This\n    includes lists, lists of tuples, tuples, tuples of tuples, tuples\n    of lists, ndarrays and masked arrays."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "By default, the data-type is inferred from the input data."
          },
          "order": {
            "type": "{'C', 'F'}, optional",
            "description": "Whether to use row-major ('C') or column-major ('FORTRAN') memory\n    representation.  Default is 'C'."
          }
        },
        "returns": "out : MaskedArray\n    Masked array interpretation of `a`.",
        "raises": "",
        "see_also": "asanyarray : Similar to `asarray`, but conserves subclasses.",
        "notes": "",
        "examples": ">>> x = np.arange(10.).reshape(2, 5)\n>>> x\narray([[0., 1., 2., 3., 4.],\n       [5., 6., 7., 8., 9.]])\n>>> np.ma.asarray(x)\nmasked_array(\n  data=[[0., 1., 2., 3., 4.],\n        [5., 6., 7., 8., 9.]],\n  mask=False,\n  fill_value=1e+20)\n>>> type(np.ma.asarray(x))\n<class 'numpy.ma.core.MaskedArray'>"
      }
    },
    {
      "name": "atleast_1d",
      "signature": "atleast_1d(*args, **params)",
      "docstring": {
        "description": "atleast_1d\n\nConvert inputs to arrays with at least one dimension.\n\nScalar inputs are converted to 1-dimensional arrays, whilst\nhigher-dimensional inputs are preserved.",
        "parameters": {},
        "returns": "ret : ndarray\n    An array, or list of arrays, each with ``a.ndim >= 1``.\n    Copies are made only if necessary.",
        "raises": "",
        "see_also": "atleast_2d, atleast_3d",
        "notes": "The function is applied to both the _data and the _mask, if any.",
        "examples": ">>> np.atleast_1d(1.0)\narray([1.])\n\n>>> x = np.arange(9.0).reshape(3,3)\n>>> np.atleast_1d(x)\narray([[0., 1., 2.],\n       [3., 4., 5.],\n       [6., 7., 8.]])\n>>> np.atleast_1d(x) is x\nTrue\n\n>>> np.atleast_1d(1, [3, 4])\n[array([1]), array([3, 4])]"
      }
    },
    {
      "name": "atleast_2d",
      "signature": "atleast_2d(*args, **params)",
      "docstring": {
        "description": "atleast_2d\n\nView inputs as arrays with at least two dimensions.",
        "parameters": {},
        "returns": "res, res2, ... : ndarray\n    An array, or list of arrays, each with ``a.ndim >= 2``.\n    Copies are avoided where possible, and views with two or more\n    dimensions are returned.",
        "raises": "",
        "see_also": "atleast_1d, atleast_3d",
        "notes": "The function is applied to both the _data and the _mask, if any.",
        "examples": ">>> np.atleast_2d(3.0)\narray([[3.]])\n\n>>> x = np.arange(3.0)\n>>> np.atleast_2d(x)\narray([[0., 1., 2.]])\n>>> np.atleast_2d(x).base is x\nTrue\n\n>>> np.atleast_2d(1, [1, 2], [[1, 2]])\n[array([[1]]), array([[1, 2]]), array([[1, 2]])]"
      }
    },
    {
      "name": "atleast_3d",
      "signature": "atleast_3d(*args, **params)",
      "docstring": {
        "description": "atleast_3d\n\nView inputs as arrays with at least three dimensions.",
        "parameters": {},
        "returns": "res1, res2, ... : ndarray\n    An array, or list of arrays, each with ``a.ndim >= 3``.  Copies are\n    avoided where possible, and views with three or more dimensions are\n    returned.  For example, a 1-D array of shape ``(N,)`` becomes a view\n    of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a\n    view of shape ``(M, N, 1)``.",
        "raises": "",
        "see_also": "atleast_1d, atleast_2d",
        "notes": "The function is applied to both the _data and the _mask, if any.",
        "examples": ">>> np.atleast_3d(3.0)\narray([[[3.]]])\n\n>>> x = np.arange(3.0)\n>>> np.atleast_3d(x).shape\n(1, 3, 1)\n\n>>> x = np.arange(12.0).reshape(4,3)\n>>> np.atleast_3d(x).shape\n(4, 3, 1)\n>>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself\nTrue\n\n>>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n...     print(arr, arr.shape) # doctest: +SKIP\n...\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1 2]]] (1, 1, 2)"
      }
    },
    {
      "name": "average",
      "signature": "average(a, axis=None, weights=None, returned=False, *, keepdims=<no value>)",
      "docstring": {
        "description": "Return the weighted average of array over the given axis.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Data to be averaged.\n    Masked entries are not taken into account in the computation."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to average `a`. If None, averaging is done over\n    the flattened array."
          },
          "weights": {
            "type": "array_like, optional",
            "description": "The importance that each element has in the computation of the average.\n    The weights array can either be 1-D (in which case its length must be\n    the size of `a` along the given axis) or of the same shape as `a`.\n    If ``weights=None``, then all data in `a` are assumed to have a\n    weight equal to one.  The 1-D calculation is::\n\n        avg = sum(a * weights) / sum(weights)\n\n    The only constraint on `weights` is that `sum(weights)` must not be 0."
          },
          "returned": {
            "type": "bool, optional",
            "description": "Flag indicating whether a tuple ``(result, sum of weights)``\n    should be returned as output (True), or just the result (False).\n    Default is False."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the original `a`.\n    *Note:* `keepdims` will not work with instances of `numpy.matrix`\n    or other classes whose methods do not support `keepdims`.\n\n    .. versionadded:: 1.23.0"
          }
        },
        "returns": "average, [sum_of_weights] : (tuple of) scalar or MaskedArray\n    The average along the specified axis. When returned is `True`,\n    return a tuple with the average as the first element and the sum\n    of the weights as the second element. The return type is `np.float64`\n    if `a` is of integer type and floats smaller than `float64`, or the\n    input data-type, otherwise. If returned, `sum_of_weights` is always\n    `float64`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])\n>>> np.ma.average(a, weights=[3, 1, 0, 0])\n1.25\n\n>>> x = np.ma.arange(6.).reshape(3, 2)\n>>> x\nmasked_array(\n  data=[[0., 1.],\n        [2., 3.],\n        [4., 5.]],\n  mask=False,\n  fill_value=1e+20)\n>>> avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],\n...                                 returned=True)\n>>> avg\nmasked_array(data=[2.6666666666666665, 3.6666666666666665],\n             mask=[False, False],\n       fill_value=1e+20)\n\nWith ``keepdims=True``, the following result has shape (3, 1).\n\n>>> np.ma.average(x, axis=1, keepdims=True)\nmasked_array(\n  data=[[0.5],\n        [2.5],\n        [4.5]],\n  mask=False,\n  fill_value=1e+20)"
      }
    },
    {
      "name": "bitwise_and",
      "signature": "bitwise_and(a, b, *args, **kwargs)",
      "docstring": {
        "description": "bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the bit-wise AND of two arrays element-wise.\n\nComputes the bit-wise AND of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``&``.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : ndarray or scalar\n    Result.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "logical_and\nbitwise_or\nbitwise_xor\nbinary_repr :\n    Return the binary representation of the input number as a string.",
        "notes": "",
        "examples": "The number 13 is represented by ``00001101``.  Likewise, 17 is\nrepresented by ``00010001``.  The bit-wise AND of 13 and 17 is\ntherefore ``000000001``, or 1:\n\n>>> np.bitwise_and(13, 17)\n1\n\n>>> np.bitwise_and(14, 13)\n12\n>>> np.binary_repr(12)\n'1100'\n>>> np.bitwise_and([14,3], 13)\narray([12,  1])\n\n>>> np.bitwise_and([11,7], [4,25])\narray([0, 1])\n>>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))\narray([ 2,  4, 16])\n>>> np.bitwise_and([True, True], [False, True])\narray([False,  True])\n\nThe ``&`` operator can be used as a shorthand for ``np.bitwise_and`` on\nndarrays.\n\n>>> x1 = np.array([2, 5, 255])\n>>> x2 = np.array([3, 14, 16])\n>>> x1 & x2\narray([ 2,  4, 16])"
      }
    },
    {
      "name": "bitwise_or",
      "signature": "bitwise_or(a, b, *args, **kwargs)",
      "docstring": {
        "description": "bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the bit-wise OR of two arrays element-wise.\n\nComputes the bit-wise OR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``|``.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : ndarray or scalar\n    Result.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "logical_or\nbitwise_and\nbitwise_xor\nbinary_repr :\n    Return the binary representation of the input number as a string.",
        "notes": "",
        "examples": "The number 13 has the binary representation ``00001101``. Likewise,\n16 is represented by ``00010000``.  The bit-wise OR of 13 and 16 is\nthen ``00011101``, or 29:\n\n>>> np.bitwise_or(13, 16)\n29\n>>> np.binary_repr(29)\n'11101'\n\n>>> np.bitwise_or(32, 2)\n34\n>>> np.bitwise_or([33, 4], 1)\narray([33,  5])\n>>> np.bitwise_or([33, 4], [1, 2])\narray([33,  6])\n\n>>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))\narray([  6,   5, 255])\n>>> np.array([2, 5, 255]) | np.array([4, 4, 4])\narray([  6,   5, 255])\n>>> np.bitwise_or(np.array([2, 5, 255, 2147483647], dtype=np.int32),\n...               np.array([4, 4, 4, 2147483647], dtype=np.int32))\narray([         6,          5,        255, 2147483647])\n>>> np.bitwise_or([True, True], [False, True])\narray([ True,  True])\n\nThe ``|`` operator can be used as a shorthand for ``np.bitwise_or`` on\nndarrays.\n\n>>> x1 = np.array([2, 5, 255])\n>>> x2 = np.array([4, 4, 4])\n>>> x1 | x2\narray([  6,   5, 255])"
      }
    },
    {
      "name": "bitwise_xor",
      "signature": "bitwise_xor(a, b, *args, **kwargs)",
      "docstring": {
        "description": "bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the bit-wise XOR of two arrays element-wise.\n\nComputes the bit-wise XOR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``^``.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : ndarray or scalar\n    Result.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "logical_xor\nbitwise_and\nbitwise_or\nbinary_repr :\n    Return the binary representation of the input number as a string.",
        "notes": "",
        "examples": "The number 13 is represented by ``00001101``. Likewise, 17 is\nrepresented by ``00010001``.  The bit-wise XOR of 13 and 17 is\ntherefore ``00011100``, or 28:\n\n>>> np.bitwise_xor(13, 17)\n28\n>>> np.binary_repr(28)\n'11100'\n\n>>> np.bitwise_xor(31, 5)\n26\n>>> np.bitwise_xor([31,3], 5)\narray([26,  6])\n\n>>> np.bitwise_xor([31,3], [5,6])\narray([26,  5])\n>>> np.bitwise_xor([True, True], [False, True])\narray([ True, False])\n\nThe ``^`` operator can be used as a shorthand for ``np.bitwise_xor`` on\nndarrays.\n\n>>> x1 = np.array([True, True])\n>>> x2 = np.array([False, True])\n>>> x1 ^ x2\narray([ True, False])"
      }
    },
    {
      "name": "bool_",
      "signature": "bool_(...)",
      "docstring": {
        "description": "Boolean type (True or False), stored as a byte.\n\n.. warning::\n\n   The :class:`bool_` type is not a subclass of the :class:`int_` type\n   (the :class:`bool_` is not even a number type). This is different\n   than Python's default implementation of :class:`bool` as a\n   sub-class of :class:`int`.\n\n:Character code: ``'?'``",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ceil",
      "signature": "ceil(a, *args, **kwargs)",
      "docstring": {
        "description": "ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the ceiling of the input, element-wise.\n\nThe ceil of the scalar `x` is the smallest integer `i`, such that\n``i >= x``.  It is often denoted as :math:`\\lceil x \\rceil`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input data."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray or scalar\n    The ceiling of each element in `x`, with `float` dtype.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "floor, trunc, rint, fix",
        "notes": "",
        "examples": ">>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.ceil(a)\narray([-1., -1., -0.,  1.,  2.,  2.,  2.])"
      }
    },
    {
      "name": "choose",
      "signature": "choose(indices, choices, out=None, mode='raise')",
      "docstring": {
        "description": "Use an index array to construct a new array from a list of choices.\n\nGiven an array of integers and a list of n choice arrays, this method\nwill create a new array that merges each of the choice arrays.  Where a\nvalue in `index` is i, the new array will have the value that choices[i]\ncontains in the same place.",
        "parameters": {
          "indices": {
            "type": "ndarray of ints",
            "description": "This array must contain integers in ``[0, n-1]``, where n is the\n    number of choices."
          },
          "choices": {
            "type": "sequence of arrays",
            "description": "Choice arrays. The index array and all of the choices should be\n    broadcastable to the same shape."
          },
          "out": {
            "type": "array, optional",
            "description": "If provided, the result will be inserted into this array. It should\n    be of the appropriate shape and `dtype`."
          },
          "mode": {
            "type": "{'raise', 'wrap', 'clip'}, optional",
            "description": "Specifies how out-of-bounds indices will behave.\n\n    * 'raise' : raise an error\n    * 'wrap' : wrap around\n    * 'clip' : clip to the range"
          }
        },
        "returns": "merged_array : array",
        "raises": "",
        "see_also": "choose : equivalent function",
        "notes": "",
        "examples": ">>> choice = np.array([[1,1,1], [2,2,2], [3,3,3]])\n>>> a = np.array([2, 1, 0])\n>>> np.ma.choose(a, choice)\nmasked_array(data=[3, 2, 1],\n             mask=False,\n       fill_value=999999)"
      }
    },
    {
      "name": "clip",
      "signature": "clip(...)",
      "docstring": {}
    },
    {
      "name": "clump_masked",
      "signature": "clump_masked(a)",
      "docstring": {
        "description": "Returns a list of slices corresponding to the masked clumps of a 1-D array.\n(A \"clump\" is defined as a contiguous region of the array).",
        "parameters": {
          "a": {
            "type": "ndarray",
            "description": "A one-dimensional masked array."
          }
        },
        "returns": "slices : list of slice\n    The list of slices, one for each continuous region of masked elements\n    in `a`.",
        "raises": "",
        "see_also": "flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges\nnotmasked_contiguous, clump_unmasked",
        "notes": ".. versionadded:: 1.4.0",
        "examples": ">>> a = np.ma.masked_array(np.arange(10))\n>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n>>> np.ma.clump_masked(a)\n[slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]"
      }
    },
    {
      "name": "clump_unmasked",
      "signature": "clump_unmasked(a)",
      "docstring": {
        "description": "Return list of slices corresponding to the unmasked clumps of a 1-D array.\n(A \"clump\" is defined as a contiguous region of the array).",
        "parameters": {
          "a": {
            "type": "ndarray",
            "description": "A one-dimensional masked array."
          }
        },
        "returns": "slices : list of slice\n    The list of slices, one for each continuous region of unmasked\n    elements in `a`.",
        "raises": "",
        "see_also": "flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges\nnotmasked_contiguous, clump_masked",
        "notes": ".. versionadded:: 1.4.0",
        "examples": ">>> a = np.ma.masked_array(np.arange(10))\n>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n>>> np.ma.clump_unmasked(a)\n[slice(3, 6, None), slice(7, 8, None)]"
      }
    },
    {
      "name": "column_stack",
      "signature": "column_stack(x, *args, **params)",
      "docstring": {
        "description": "column_stack\n\nStack 1-D arrays as columns into a 2-D array.\n\nTake a sequence of 1-D arrays and stack them as columns\nto make a single 2-D array. 2-D arrays are stacked as-is,\njust like with `hstack`.  1-D arrays are turned into 2-D columns\nfirst.",
        "parameters": {
          "tup": {
            "type": "sequence of 1-D or 2-D arrays.",
            "description": "Arrays to stack. All of them must have the same first dimension."
          }
        },
        "returns": "stacked : 2-D array\n    The array formed by stacking the given arrays.",
        "raises": "",
        "see_also": "stack, hstack, vstack, concatenate",
        "notes": "The function is applied to both the _data and the _mask, if any.",
        "examples": ">>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.column_stack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])"
      }
    },
    {
      "name": "common_fill_value",
      "signature": "common_fill_value(a, b)",
      "docstring": {
        "description": "Return the common filling value of two masked arrays, if any.\n\nIf ``a.fill_value == b.fill_value``, return the fill value,\notherwise return None.",
        "parameters": {},
        "returns": "fill_value : scalar or None\n    The common fill value, or None.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = np.ma.array([0, 1.], fill_value=3)\n>>> y = np.ma.array([0, 1.], fill_value=3)\n>>> np.ma.common_fill_value(x, y)\n3.0"
      }
    },
    {
      "name": "compress",
      "signature": "compress(a, *args, **params)",
      "docstring": {
        "description": "compress(self, condition, axis=None, out=None)\n\nReturn `a` where condition is ``True``.\n\nIf condition is a `~ma.MaskedArray`, missing values are considered\nas ``False``.",
        "parameters": {
          "condition": {
            "type": "var",
            "description": "Boolean 1-d array selecting which entries to return. If len(condition)\n    is less than the size of a along the axis, then output is truncated\n    to length of condition array."
          },
          "axis": {
            "type": "{None, int}, optional",
            "description": "Axis along which the operation must be performed."
          },
          "out": {
            "type": "{None, ndarray}, optional",
            "description": "Alternative output array in which to place the result. It must have\n    the same shape as the expected output but the type will be cast if\n    necessary."
          }
        },
        "returns": "result : MaskedArray\n    A :class:`~ma.MaskedArray` object.",
        "raises": "",
        "see_also": "",
        "notes": "Please note the difference with :meth:`compressed` !\nThe output of :meth:`compress` has a mask, the output of\n:meth:`compressed` does not.",
        "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\n             mask=[False, False],\n       fill_value=999999)\n\n>>> x.compress([1, 0, 1], axis=1)\nmasked_array(\n  data=[[1, 3],\n        [--, --],\n        [7, 9]],\n  mask=[[False, False],\n        [ True,  True],\n        [False, False]],\n  fill_value=999999)"
      }
    },
    {
      "name": "compress_cols",
      "signature": "compress_cols(a)",
      "docstring": {
        "description": "Suppress whole columns of a 2-D array that contain masked values.\n\nThis is equivalent to ``np.ma.compress_rowcols(a, 1)``, see\n`compress_rowcols` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "compress_rowcols",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compress_nd",
      "signature": "compress_nd(x, axis=None)",
      "docstring": {
        "description": "Suppress slices from multiple dimensions which contain masked values.",
        "parameters": {
          "x": {
            "type": "array_like, MaskedArray",
            "description": "The array to operate on. If not a MaskedArray instance (or if no array\n    elements are masked), `x` is interpreted as a MaskedArray with `mask`\n    set to `nomask`."
          },
          "axis": {
            "type": "tuple of ints or int, optional",
            "description": "Which dimensions to suppress slices from can be configured with this\n    parameter.\n    - If axis is a tuple of ints, those are the axes to suppress slices from.\n    - If axis is an int, then that is the only axis to suppress slices from.\n    - If axis is None, all axis are selected."
          }
        },
        "returns": "compress_array : ndarray\n    The compressed array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compress_rowcols",
      "signature": "compress_rowcols(x, axis=None)",
      "docstring": {
        "description": "Suppress the rows and/or columns of a 2-D array that contain\nmasked values.\n\nThe suppression behavior is selected with the `axis` parameter.\n\n- If axis is None, both rows and columns are suppressed.\n- If axis is 0, only rows are suppressed.\n- If axis is 1 or -1, only columns are suppressed.",
        "parameters": {
          "x": {
            "type": "array_like, MaskedArray",
            "description": "The array to operate on.  If not a MaskedArray instance (or if no array\n    elements are masked), `x` is interpreted as a MaskedArray with\n    `mask` set to `nomask`. Must be a 2D array."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to perform the operation. Default is None."
          }
        },
        "returns": "compressed_array : ndarray\n    The compressed array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n>>> x\nmasked_array(\n  data=[[--, 1, 2],\n        [--, 4, 5],\n        [6, 7, 8]],\n  mask=[[ True, False, False],\n        [ True, False, False],\n        [False, False, False]],\n  fill_value=999999)\n\n>>> np.ma.compress_rowcols(x)\narray([[7, 8]])\n>>> np.ma.compress_rowcols(x, 0)\narray([[6, 7, 8]])\n>>> np.ma.compress_rowcols(x, 1)\narray([[1, 2],\n       [4, 5],\n       [7, 8]])"
      }
    },
    {
      "name": "compress_rows",
      "signature": "compress_rows(a)",
      "docstring": {
        "description": "Suppress whole rows of a 2-D array that contain masked values.\n\nThis is equivalent to ``np.ma.compress_rowcols(a, 0)``, see\n`compress_rowcols` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "compress_rowcols",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compressed",
      "signature": "compressed(x)",
      "docstring": {
        "description": "Return all the non-masked data as a 1-D array.\n\nThis function is equivalent to calling the \"compressed\" method of a\n`ma.MaskedArray`, see `ma.MaskedArray.compressed` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "ma.MaskedArray.compressed : Equivalent method.",
        "notes": "",
        "examples": "Create an array with negative values masked:\n\n>>> import numpy as np\n>>> x = np.array([[1, -1, 0], [2, -1, 3], [7, 4, -1]])\n>>> masked_x = np.ma.masked_array(x, mask=x < 0)\n>>> masked_x\nmasked_array(\n  data=[[1, --, 0],\n        [2, --, 3],\n        [7, 4, --]],\n  mask=[[False,  True, False],\n        [False,  True, False],\n        [False, False,  True]],\n  fill_value=999999)\n\nCompress the masked array into a 1-D array of non-masked values:\n\n>>> np.ma.compressed(masked_x)\narray([1, 0, 2, 3, 7, 4])"
      }
    },
    {
      "name": "concatenate",
      "signature": "concatenate(arrays, axis=0)",
      "docstring": {
        "description": "Concatenate a sequence of arrays along the given axis.",
        "parameters": {
          "arrays": {
            "type": "sequence of array_like",
            "description": "The arrays must have the same shape, except in the dimension\n    corresponding to `axis` (the first, by default)."
          },
          "axis": {
            "type": "int, optional",
            "description": "The axis along which the arrays will be joined. Default is 0."
          }
        },
        "returns": "result : MaskedArray\n    The concatenated array with any masked entries preserved.",
        "raises": "",
        "see_also": "numpy.concatenate : Equivalent function in the top-level NumPy module.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = ma.arange(3)\n>>> a[1] = ma.masked\n>>> b = ma.arange(2, 5)\n>>> a\nmasked_array(data=[0, --, 2],\n             mask=[False,  True, False],\n       fill_value=999999)\n>>> b\nmasked_array(data=[2, 3, 4],\n             mask=False,\n       fill_value=999999)\n>>> ma.concatenate([a, b])\nmasked_array(data=[0, --, 2, 2, 3, 4],\n             mask=[False,  True, False, False, False, False],\n       fill_value=999999)"
      }
    },
    {
      "name": "conjugate",
      "signature": "conjugate(a, *args, **kwargs)",
      "docstring": {
        "description": "conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the complex conjugate, element-wise.\n\nThe complex conjugate of a complex number is obtained by changing the\nsign of its imaginary part.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input value."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    The complex conjugate of `x`, with same dtype as `y`.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "`conj` is an alias for `conjugate`:\n\n>>> np.conj is np.conjugate\nTrue",
        "examples": ">>> np.conjugate(1+2j)\n(1-2j)\n\n>>> x = np.eye(2) + 1j * np.eye(2)\n>>> np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])"
      }
    },
    {
      "name": "convolve",
      "signature": "convolve(a, v, mode='full', propagate_mask=True)",
      "docstring": {
        "description": "Returns the discrete, linear convolution of two one-dimensional sequences.",
        "parameters": {
          "mode": {
            "type": "{'valid', 'same', 'full'}, optional",
            "description": "Refer to the `np.convolve` docstring."
          },
          "propagate_mask": {
            "type": "bool",
            "description": "If True, then if any masked element is included in the sum for a result\n    element, then the result is masked.\n    If False, then the result element is only masked if no non-masked cells\n    contribute towards it"
          }
        },
        "returns": "out : MaskedArray\n    Discrete, linear convolution of `a` and `v`.",
        "raises": "",
        "see_also": "numpy.convolve : Equivalent function in the top-level NumPy module.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "copy",
      "signature": "copy(a, *args, **params)",
      "docstring": {
        "description": "copy(self, *args, **params)\na.copy(order='C')\n\n    Return a copy of the array.\n\n    Parameters\n    ----------\n    order : {'C', 'F', 'A', 'K'}, optional\n        Controls the memory layout of the copy. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible. (Note that this function and :func:`numpy.copy` are very\n        similar but have different default values for their order=\n        arguments, and this function always passes sub-classes through.)\n\n    See also\n    --------\n    numpy.copy : Similar function with different default behavior\n    numpy.copyto\n\n    Notes\n    -----\n    This function is the preferred method for creating an array copy.  The\n    function :func:`numpy.copy` is similar, but it defaults to using order 'K',\n    and will not pass sub-classes through by default.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n    >>> y = x.copy()\n\n    >>> x.fill(0)\n\n    >>> x\n    array([[0, 0, 0],\n           [0, 0, 0]])\n\n    >>> y\n    array([[1, 2, 3],\n           [4, 5, 6]])\n\n    >>> y.flags['C_CONTIGUOUS']\n    True",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "corrcoef",
      "signature": "corrcoef(x, y=None, rowvar=True, bias=<no value>, allow_masked=True, ddof=<no value>)",
      "docstring": {
        "description": "Return Pearson product-moment correlation coefficients.\n\nExcept for the handling of missing data this function does the same as\n`numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "A 1-D or 2-D array containing multiple variables and observations.\n    Each row of `x` represents a variable, and each column a single\n    observation of all those variables. Also see `rowvar` below."
          },
          "y": {
            "type": "array_like, optional",
            "description": "An additional set of variables and observations. `y` has the same\n    shape as `x`."
          },
          "rowvar": {
            "type": "bool, optional",
            "description": "If `rowvar` is True (default), then each row represents a\n    variable, with observations in the columns. Otherwise, the relationship\n    is transposed: each column represents a variable, while the rows\n    contain observations."
          },
          "bias": {
            "type": "_NoValue, optional",
            "description": "Has no effect, do not use.\n\n    .. deprecated:: 1.10.0"
          },
          "allow_masked": {
            "type": "bool, optional",
            "description": "If True, masked values are propagated pair-wise: if a value is masked\n    in `x`, the corresponding value is masked in `y`.\n    If False, raises an exception.  Because `bias` is deprecated, this\n    argument needs to be treated as keyword only to avoid a warning."
          },
          "ddof": {
            "type": "_NoValue, optional",
            "description": "Has no effect, do not use.\n\n    .. deprecated:: 1.10.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "numpy.corrcoef : Equivalent function in top-level NumPy module.\ncov : Estimate the covariance matrix.",
        "notes": "This function accepts but discards arguments `bias` and `ddof`.  This is\nfor backwards compatibility with previous versions of this function.  These\narguments had no effect on the return values of the function and can be\nsafely ignored in this and previous versions of numpy.",
        "examples": ""
      }
    },
    {
      "name": "correlate",
      "signature": "correlate(a, v, mode='valid', propagate_mask=True)",
      "docstring": {
        "description": "Cross-correlation of two 1-dimensional sequences.",
        "parameters": {
          "mode": {
            "type": "{'valid', 'same', 'full'}, optional",
            "description": "Refer to the `np.convolve` docstring.  Note that the default\n    is 'valid', unlike `convolve`, which uses 'full'."
          },
          "propagate_mask": {
            "type": "bool",
            "description": "If True, then a result element is masked if any masked element contributes towards it.\n    If False, then a result element is only masked if no non-masked element\n    contribute towards it"
          }
        },
        "returns": "out : MaskedArray\n    Discrete cross-correlation of `a` and `v`.",
        "raises": "",
        "see_also": "numpy.correlate : Equivalent function in the top-level NumPy module.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cos",
      "signature": "cos(a, *args, **kwargs)",
      "docstring": {
        "description": "cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCosine element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array in radians."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    The corresponding cosine values.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "If `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\n\nReferences\n----------\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972.",
        "examples": ">>> np.cos(np.array([0, np.pi/2, np.pi]))\narray([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])\n>>>\n>>> # Example of providing the optional output parameter\n>>> out1 = np.array([0], dtype='d')\n>>> out2 = np.cos([0.1], out1)\n>>> out2 is out1\nTrue\n>>>\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)"
      }
    },
    {
      "name": "cosh",
      "signature": "cosh(a, *args, **kwargs)",
      "docstring": {
        "description": "cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nHyperbolic cosine, element-wise.\n\nEquivalent to ``1/2 * (np.exp(x) + np.exp(-x))`` and ``np.cos(1j*x)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : ndarray or scalar\n    Output array of same shape as `x`.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> np.cosh(0)\n1.0\n\nThe hyperbolic cosine describes the shape of a hanging cable:\n\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-4, 4, 1000)\n>>> plt.plot(x, np.cosh(x))\n>>> plt.show()"
      }
    },
    {
      "name": "count",
      "signature": "count(a, *args, **params)",
      "docstring": {
        "description": "count(self, axis=None, keepdims=<no value>)\n\nCount the non-masked elements of the array along the given axis.",
        "parameters": {
          "axis": {
            "type": "None or int or tuple of ints, optional",
            "description": "Axis or axes along which the count is performed.\n    The default, None, performs the count over all\n    the dimensions of the input array. `axis` may be negative, in\n    which case it counts from the last to the first axis.\n\n    .. versionadded:: 1.10.0\n\n    If this is a tuple of ints, the count is performed on multiple\n    axes, instead of a single axis or all the axes as before."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
          }
        },
        "returns": "result : ndarray or scalar\n    An array with the same shape as the input array, with the specified\n    axis removed. If the array is a 0-d array, or if `axis` is None, a\n    scalar is returned.",
        "raises": "",
        "see_also": "ma.count_masked : Count masked elements in array or along a given axis.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, --, --]],\n  mask=[[False, False, False],\n        [ True,  True,  True]],\n  fill_value=999999)\n>>> a.count()\n3\n\nWhen the `axis` keyword is specified an array of appropriate size is\nreturned.\n\n>>> a.count(axis=0)\narray([1, 1, 1])\n>>> a.count(axis=1)\narray([3, 0])"
      }
    },
    {
      "name": "count_masked",
      "signature": "count_masked(arr, axis=None)",
      "docstring": {
        "description": "Count the number of masked elements along the given axis.",
        "parameters": {
          "arr": {
            "type": "array_like",
            "description": "An array with (possibly) masked elements."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to count. If None (default), a flattened\n    version of the array is used."
          }
        },
        "returns": "count : int, ndarray\n    The total number of masked elements (axis=None) or the number\n    of masked elements along each slice of the given axis.",
        "raises": "",
        "see_also": "MaskedArray.count : Count non-masked elements.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.arange(9).reshape((3,3))\n>>> a = ma.array(a)\n>>> a[1, 0] = ma.masked\n>>> a[1, 2] = ma.masked\n>>> a[2, 1] = ma.masked\n>>> a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, 4, --],\n        [6, --, 8]],\n  mask=[[False, False, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> ma.count_masked(a)\n3\n\nWhen the `axis` keyword is used an array is returned.\n\n>>> ma.count_masked(a, axis=0)\narray([1, 1, 1])\n>>> ma.count_masked(a, axis=1)\narray([0, 2, 1])"
      }
    },
    {
      "name": "cov",
      "signature": "cov(x, y=None, rowvar=True, bias=False, allow_masked=True, ddof=None)",
      "docstring": {
        "description": "Estimate the covariance matrix.\n\nExcept for the handling of missing data this function does the same as\n`numpy.cov`. For more details and examples, see `numpy.cov`.\n\nBy default, masked values are recognized as such. If `x` and `y` have the\nsame shape, a common mask is allocated: if ``x[i,j]`` is masked, then\n``y[i,j]`` will also be masked.\nSetting `allow_masked` to False will raise an exception if values are\nmissing in either of the input arrays.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "A 1-D or 2-D array containing multiple variables and observations.\n    Each row of `x` represents a variable, and each column a single\n    observation of all those variables. Also see `rowvar` below."
          },
          "y": {
            "type": "array_like, optional",
            "description": "An additional set of variables and observations. `y` has the same\n    shape as `x`."
          },
          "rowvar": {
            "type": "bool, optional",
            "description": "If `rowvar` is True (default), then each row represents a\n    variable, with observations in the columns. Otherwise, the relationship\n    is transposed: each column represents a variable, while the rows\n    contain observations."
          },
          "bias": {
            "type": "bool, optional",
            "description": "Default normalization (False) is by ``(N-1)``, where ``N`` is the\n    number of observations given (unbiased estimate). If `bias` is True,\n    then normalization is by ``N``. This keyword can be overridden by\n    the keyword ``ddof`` in numpy versions >= 1.5."
          },
          "allow_masked": {
            "type": "bool, optional",
            "description": "If True, masked values are propagated pair-wise: if a value is masked\n    in `x`, the corresponding value is masked in `y`.\n    If False, raises a `ValueError` exception when some values are missing."
          },
          "ddof": {
            "type": "{None, int}, optional",
            "description": "If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is\n    the number of observations; this overrides the value implied by\n    ``bias``. The default value is ``None``.\n\n    .. versionadded:: 1.5"
          }
        },
        "returns": "",
        "raises": "ValueError\n    Raised if some values are missing and `allow_masked` is False.",
        "see_also": "numpy.cov",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cumprod",
      "signature": "cumprod(a, *args, **params)",
      "docstring": {
        "description": "cumprod(self, axis=None, dtype=None, out=None)\n\nReturn the cumulative product of the array elements over the given axis.\n\nMasked values are set to 1 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\n\nRefer to `numpy.cumprod` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.ndarray.cumprod : corresponding function for ndarrays\nnumpy.cumprod : equivalent function",
        "notes": "The mask is lost if `out` is not a valid MaskedArray !\n\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
        "examples": ""
      }
    },
    {
      "name": "cumsum",
      "signature": "cumsum(a, *args, **params)",
      "docstring": {
        "description": "cumsum(self, axis=None, dtype=None, out=None)\n\nReturn the cumulative sum of the array elements over the given axis.\n\nMasked values are set to 0 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\n\nRefer to `numpy.cumsum` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.ndarray.cumsum : corresponding function for ndarrays\nnumpy.cumsum : equivalent function",
        "notes": "The mask is lost if `out` is not a valid :class:`ma.MaskedArray` !\n\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
        "examples": ">>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n             mask=[False, False, False,  True,  True,  True, False, False,\n                   False, False],\n       fill_value=999999)"
      }
    },
    {
      "name": "default_fill_value",
      "signature": "default_fill_value(obj)",
      "docstring": {
        "description": "Return the default fill value for the argument object.\n\nThe default filling value depends on the datatype of the input\narray or the type of the input scalar:\n\n   ========  ========\n   datatype  default\n   ========  ========\n   bool      True\n   int       999999\n   float     1.e20\n   complex   1.e20+0j\n   object    '?'\n   string    'N/A'\n   ========  ========\n\nFor structured types, a structured scalar is returned, with each field the\ndefault fill value for its type.\n\nFor subarray types, the fill value is an array of the same size containing\nthe default scalar fill value.",
        "parameters": {
          "obj": {
            "type": "ndarray, dtype or scalar",
            "description": "The array data-type or scalar for which the default fill value\n    is returned."
          }
        },
        "returns": "fill_value : scalar\n    The default fill value.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> np.ma.default_fill_value(1)\n999999\n>>> np.ma.default_fill_value(np.array([1.1, 2., np.pi]))\n1e+20\n>>> np.ma.default_fill_value(np.dtype(complex))\n(1e+20+0j)"
      }
    },
    {
      "name": "diag",
      "signature": "diag(v, k=0)",
      "docstring": {
        "description": "Extract a diagonal or construct a diagonal array.\n\nThis function is the equivalent of `numpy.diag` that takes masked\nvalues into account, see `numpy.diag` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.diag : Equivalent function for ndarrays.",
        "notes": "",
        "examples": "Create an array with negative values masked:\n\n>>> import numpy as np\n>>> x = np.array([[11.2, -3.973, 18], [0.801, -1.41, 12], [7, 33, -12]])\n>>> masked_x = np.ma.masked_array(x, mask=x < 0)\n>>> masked_x\nmasked_array(\n  data=[[11.2, --, 18.0],\n        [0.801, --, 12.0],\n        [7.0, 33.0, --]],\n  mask=[[False,  True, False],\n        [False,  True, False],\n        [False, False,  True]],\n  fill_value=1e+20)\n\nIsolate the main diagonal from the masked array:\n\n>>> np.ma.diag(masked_x)\nmasked_array(data=[11.2, --, --],\n             mask=[False,  True,  True],\n       fill_value=1e+20)\n\nIsolate the first diagonal below the main diagonal:\n\n>>> np.ma.diag(masked_x, -1)\nmasked_array(data=[0.801, 33.0],\n             mask=[False, False],\n       fill_value=1e+20)"
      }
    },
    {
      "name": "diagflat",
      "signature": "diagflat(x, *args, **params)",
      "docstring": {
        "description": "diagflat\n\nCreate a two-dimensional array with the flattened input as a diagonal.",
        "parameters": {
          "v": {
            "type": "array_like",
            "description": "Input data, which is flattened and set as the `k`-th\n    diagonal of the output."
          },
          "k": {
            "type": "int, optional",
            "description": "Diagonal to set; 0, the default, corresponds to the \"main\" diagonal,\n    a positive (negative) `k` giving the number of the diagonal above\n    (below) the main."
          }
        },
        "returns": "out : ndarray\n    The 2-D output array.",
        "raises": "",
        "see_also": "diag : MATLAB work-alike for 1-D and 2-D arrays.\ndiagonal : Return specified diagonals.\ntrace : Sum along diagonals.",
        "notes": "The function is applied to both the _data and the _mask, if any.",
        "examples": ">>> np.diagflat([[1,2], [3,4]])\narray([[1, 0, 0, 0],\n       [0, 2, 0, 0],\n       [0, 0, 3, 0],\n       [0, 0, 0, 4]])\n\n>>> np.diagflat([1,2], 1)\narray([[0, 1, 0],\n       [0, 0, 2],\n       [0, 0, 0]])"
      }
    },
    {
      "name": "diagonal",
      "signature": "diagonal(a, *args, **params)",
      "docstring": {
        "description": "diagonal(self, *args, **params)\na.diagonal(offset=0, axis1=0, axis2=1)\n\n    Return specified diagonals. In NumPy 1.9 the returned array is a\n    read-only view instead of a copy as in previous NumPy versions.  In\n    a future version the read-only restriction will be removed.\n\n    Refer to :func:`numpy.diagonal` for full documentation.\n\n    See Also\n    --------\n    numpy.diagonal : equivalent function",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "diff",
      "signature": "diff(a, /, n=1, axis=-1, prepend=<no value>, append=<no value>)",
      "docstring": {
        "description": "Calculate the n-th discrete difference along the given axis.\nThe first difference is given by ``out[i] = a[i+1] - a[i]`` along\nthe given axis, higher differences are calculated by using `diff`\nrecursively.\nPreserves the input mask.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array"
          },
          "n": {
            "type": "int, optional",
            "description": "The number of times values are differenced. If zero, the input\n    is returned as-is."
          },
          "axis": {
            "type": "int, optional",
            "description": "The axis along which the difference is taken, default is the\n    last axis.\nprepend, append : array_like, optional\n    Values to prepend or append to `a` along axis prior to\n    performing the difference.  Scalar values are expanded to\n    arrays with length 1 in the direction of axis and the shape\n    of the input array in along all other axes.  Otherwise the\n    dimension and shape must match `a` except along axis."
          }
        },
        "returns": "diff : MaskedArray\n    The n-th differences. The shape of the output is the same as `a`\n    except along `axis` where the dimension is smaller by `n`. The\n    type of the output is the same as the type of the difference\n    between any two elements of `a`. This is the same as the type of\n    `a` in most cases. A notable exception is `datetime64`, which\n    results in a `timedelta64` output array.",
        "raises": "",
        "see_also": "numpy.diff : Equivalent function in the top-level NumPy module.",
        "notes": "Type is preserved for boolean arrays, so the result will contain\n`False` when consecutive elements are the same and `True` when they\ndiffer.\n\nFor unsigned integer arrays, the results will also be unsigned. This\nshould not be surprising, as the result is consistent with\ncalculating the difference directly:\n\n>>> u8_arr = np.array([1, 0], dtype=np.uint8)\n>>> np.ma.diff(u8_arr)\nmasked_array(data=[255],\n             mask=False,\n       fill_value=999999,\n            dtype=uint8)\n>>> u8_arr[1,...] - u8_arr[0,...]\n255\n\nIf this is not desirable, then the array should be cast to a larger\ninteger type first:\n\n>>> i16_arr = u8_arr.astype(np.int16)\n>>> np.ma.diff(i16_arr)\nmasked_array(data=[-1],\n             mask=False,\n       fill_value=999999,\n            dtype=int16)",
        "examples": ">>> a = np.array([1, 2, 3, 4, 7, 0, 2, 3])\n>>> x = np.ma.masked_where(a < 2, a)\n>>> np.ma.diff(x)\nmasked_array(data=[--, 1, 1, 3, --, --, 1],\n        mask=[ True, False, False, False,  True,  True, False],\n    fill_value=999999)\n\n>>> np.ma.diff(x, n=2)\nmasked_array(data=[--, 0, 2, --, --, --],\n            mask=[ True, False, False,  True,  True,  True],\n    fill_value=999999)\n\n>>> a = np.array([[1, 3, 1, 5, 10], [0, 1, 5, 6, 8]])\n>>> x = np.ma.masked_equal(a, value=1)\n>>> np.ma.diff(x)\nmasked_array(\n    data=[[--, --, --, 5],\n            [--, --, 1, 2]],\n    mask=[[ True,  True,  True, False],\n            [ True,  True, False, False]],\n    fill_value=1)\n\n>>> np.ma.diff(x, axis=0)\nmasked_array(data=[[--, --, --, 1, -2]],\n        mask=[[ True,  True,  True, False, False]],\n    fill_value=1)"
      }
    },
    {
      "name": "divide",
      "signature": "divide(a, b, *args, **kwargs)",
      "docstring": {
        "description": "divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nDivide arguments element-wise.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend array."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor array.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray or scalar\n    The quotient ``x1/x2``, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "seterr : Set whether to raise or warn on overflow, underflow and\n         division by zero.",
        "notes": "Equivalent to ``x1`` / ``x2`` in terms of array-broadcasting.\n\nThe ``true_divide(x1, x2)`` function is an alias for\n``divide(x1, x2)``.",
        "examples": ">>> np.divide(2.0, 4.0)\n0.5\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.divide(x1, x2)\narray([[nan, 1. , 1. ],\n       [inf, 4. , 2.5],\n       [inf, 7. , 4. ]])\n\nThe ``/`` operator can be used as a shorthand for ``np.divide`` on\nndarrays.\n\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = 2 * np.ones(3)\n>>> x1 / x2\narray([[0. , 0.5, 1. ],\n       [1.5, 2. , 2.5],\n       [3. , 3.5, 4. ]])"
      }
    },
    {
      "name": "dot",
      "signature": "dot(a, b, strict=False, out=None)",
      "docstring": {
        "description": "Return the dot product of two arrays.\n\nThis function is the equivalent of `numpy.dot` that takes masked values\ninto account. Note that `strict` and `out` are in different position\nthan in the method version. In order to maintain compatibility with the\ncorresponding method, it is recommended that the optional arguments be\ntreated as keyword only.  At some point that may be mandatory.",
        "parameters": {
          "strict": {
            "type": "bool, optional",
            "description": "Whether masked data are propagated (True) or set to 0 (False) for\n    the computation. Default is False.  Propagating the mask means that\n    if a masked value appears in a row or column, the whole row or\n    column is considered masked."
          },
          "out": {
            "type": "masked_array, optional",
            "description": "Output argument. This must have the exact kind that would be returned\n    if it was not used. In particular, it must have the right type, must be\n    C-contiguous, and its dtype must be the dtype that would be returned\n    for `dot(a,b)`. This is a performance feature. Therefore, if these\n    conditions are not met, an exception is raised, instead of attempting\n    to be flexible.\n\n    .. versionadded:: 1.10.2"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "numpy.dot : Equivalent function for ndarrays.",
        "notes": "",
        "examples": ">>> a = np.ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])\n>>> b = np.ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])\n>>> np.ma.dot(a, b)\nmasked_array(\n  data=[[21, 26],\n        [45, 64]],\n  mask=[[False, False],\n        [False, False]],\n  fill_value=999999)\n>>> np.ma.dot(a, b, strict=True)\nmasked_array(\n  data=[[--, --],\n        [--, 64]],\n  mask=[[ True,  True],\n        [ True, False]],\n  fill_value=999999)"
      }
    },
    {
      "name": "dstack",
      "signature": "dstack(x, *args, **params)",
      "docstring": {
        "description": "dstack\n\nStack arrays in sequence depth wise (along third axis).\n\nThis is equivalent to concatenation along the third axis after 2-D arrays\nof shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape\n`(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by\n`dsplit`.\n\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.",
        "parameters": {
          "tup": {
            "type": "sequence of arrays",
            "description": "The arrays must have the same shape along all but the third axis.\n    1-D or 2-D arrays must have the same shape."
          }
        },
        "returns": "stacked : ndarray\n    The array formed by stacking the given arrays, will be at least 3-D.",
        "raises": "",
        "see_also": "concatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nblock : Assemble an nd-array from nested lists of blocks.\nvstack : Stack arrays in sequence vertically (row wise).\nhstack : Stack arrays in sequence horizontally (column wise).\ncolumn_stack : Stack 1-D arrays as columns into a 2-D array.\ndsplit : Split array along third axis.",
        "notes": "The function is applied to both the _data and the _mask, if any.",
        "examples": ">>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.dstack((a,b))\narray([[[1, 2],\n        [2, 3],\n        [3, 4]]])\n\n>>> a = np.array([[1],[2],[3]])\n>>> b = np.array([[2],[3],[4]])\n>>> np.dstack((a,b))\narray([[[1, 2]],\n       [[2, 3]],\n       [[3, 4]]])"
      }
    },
    {
      "name": "ediff1d",
      "signature": "ediff1d(arr, to_end=None, to_begin=None)",
      "docstring": {
        "description": "Compute the differences between consecutive elements of an array.\n\nThis function is the equivalent of `numpy.ediff1d` that takes masked\nvalues into account, see `numpy.ediff1d` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.ediff1d : Equivalent function for ndarrays.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "empty",
      "signature": "empty(...)",
      "docstring": {}
    },
    {
      "name": "empty_like",
      "signature": "empty_like(...)",
      "docstring": {}
    },
    {
      "name": "equal",
      "signature": "equal(a, b, *args, **kwargs)",
      "docstring": {
        "description": "equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn (x1 == x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "not_equal, greater_equal, less_equal, greater, less",
        "notes": "",
        "examples": ">>> np.equal([0, 1, 3], np.arange(3))\narray([ True,  True, False])\n\nWhat is compared are values, not types. So an int (1) and an array of\nlength one can evaluate as True:\n\n>>> np.equal(1, np.ones(1))\narray([ True])\n\nThe ``==`` operator can be used as a shorthand for ``np.equal`` on\nndarrays.\n\n>>> a = np.array([2, 4, 6])\n>>> b = np.array([2, 4, 2])\n>>> a == b\narray([ True,  True, False])"
      }
    },
    {
      "name": "exp",
      "signature": "exp(a, *args, **kwargs)",
      "docstring": {
        "description": "exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate the exponential of all elements in the input array.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input values."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : ndarray or scalar\n    Output array, element-wise exponential of `x`.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "expm1 : Calculate ``exp(x) - 1`` for all elements in the array.\nexp2  : Calculate ``2**x`` for all elements in the array.",
        "notes": "The irrational number ``e`` is also known as Euler's number.  It is\napproximately 2.718281, and is the base of the natural logarithm,\n``ln`` (this means that, if :math:`x = \\ln y = \\log_e y`,\nthen :math:`e^x = y`. For real input, ``exp(x)`` is always positive.\n\nFor complex arguments, ``x = a + ib``, we can write\n:math:`e^x = e^a e^{ib}`.  The first term, :math:`e^a`, is already\nknown (it is the real argument, described above).  The second term,\n:math:`e^{ib}`, is :math:`\\cos b + i \\sin b`, a function with\nmagnitude 1 and a periodic phase.\n\nReferences\n----------\n.. [1] Wikipedia, \"Exponential function\",\n       https://en.wikipedia.org/wiki/Exponential_function\n.. [2] M. Abramovitz and I. A. Stegun, \"Handbook of Mathematical Functions\n       with Formulas, Graphs, and Mathematical Tables,\" Dover, 1964, p. 69,\n       https://personal.math.ubc.ca/~cbm/aands/page_69.htm",
        "examples": "Plot the magnitude and phase of ``exp(x)`` in the complex plane:\n\n>>> import matplotlib.pyplot as plt\n\n>>> x = np.linspace(-2*np.pi, 2*np.pi, 100)\n>>> xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane\n>>> out = np.exp(xx)\n\n>>> plt.subplot(121)\n>>> plt.imshow(np.abs(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')\n>>> plt.title('Magnitude of exp(x)')\n\n>>> plt.subplot(122)\n>>> plt.imshow(np.angle(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')\n>>> plt.title('Phase (angle) of exp(x)')\n>>> plt.show()"
      }
    },
    {
      "name": "expand_dims",
      "signature": "expand_dims(a, axis)",
      "docstring": {
        "description": "Expand the shape of an array.\n\nInsert a new axis that will appear at the `axis` position in the expanded\narray shape.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array."
          },
          "axis": {
            "type": "int or tuple of ints",
            "description": "Position in the expanded axes where the new axis (or axes) is placed.\n\n    .. deprecated:: 1.13.0\n        Passing an axis where ``axis > a.ndim`` will be treated as\n        ``axis == a.ndim``, and passing ``axis < -a.ndim - 1`` will\n        be treated as ``axis == 0``. This behavior is deprecated.\n\n    .. versionchanged:: 1.18.0\n        A tuple of axes is now supported.  Out of range axes as\n        described above are now forbidden and raise an `AxisError`."
          }
        },
        "returns": "result : ndarray\n    View of `a` with the number of dimensions increased.",
        "raises": "",
        "see_also": "squeeze : The inverse operation, removing singleton dimensions\nreshape : Insert, remove, and combine dimensions, and resize existing ones\ndoc.indexing, atleast_1d, atleast_2d, atleast_3d",
        "notes": "",
        "examples": ">>> x = np.array([1, 2])\n>>> x.shape\n(2,)\n\nThe following is equivalent to ``x[np.newaxis, :]`` or ``x[np.newaxis]``:\n\n>>> y = np.expand_dims(x, axis=0)\n>>> y\narray([[1, 2]])\n>>> y.shape\n(1, 2)\n\nThe following is equivalent to ``x[:, np.newaxis]``:\n\n>>> y = np.expand_dims(x, axis=1)\n>>> y\narray([[1],\n       [2]])\n>>> y.shape\n(2, 1)\n\n``axis`` may also be a tuple:\n\n>>> y = np.expand_dims(x, axis=(0, 1))\n>>> y\narray([[[1, 2]]])\n\n>>> y = np.expand_dims(x, axis=(2, 0))\n>>> y\narray([[[1],\n        [2]]])\n\nNote that some examples may use ``None`` instead of ``np.newaxis``.  These\nare the same objects:\n\n>>> np.newaxis is None\nTrue"
      }
    },
    {
      "name": "fabs",
      "signature": "fabs(a, *args, **kwargs)",
      "docstring": {
        "description": "fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the absolute values element-wise.\n\nThis function returns the absolute values (positive magnitude) of the\ndata in `x`. Complex values are not handled, use `absolute` to find the\nabsolute values of complex data.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "The array of numbers for which the absolute values are required. If\n    `x` is a scalar, the result `y` will also be a scalar."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray or scalar\n    The absolute values of `x`, the returned values are always floats.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "absolute : Absolute values including `complex` types.",
        "notes": "",
        "examples": ">>> np.fabs(-1)\n1.0\n>>> np.fabs([-1.2, 1.2])\narray([ 1.2,  1.2])"
      }
    },
    {
      "name": "filled",
      "signature": "filled(a, fill_value=None)",
      "docstring": {
        "description": "Return input as an array with masked data replaced by a fill value.\n\nIf `a` is not a `MaskedArray`, `a` itself is returned.\nIf `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to\n``a.fill_value``.",
        "parameters": {
          "a": {
            "type": "MaskedArray or array_like",
            "description": "An input object."
          },
          "fill_value": {
            "type": "array_like, optional.",
            "description": "Can be scalar or non-scalar. If non-scalar, the\n    resulting filled array should be broadcastable\n    over input array. Default is None."
          }
        },
        "returns": "a : ndarray\n    The filled array.",
        "raises": "",
        "see_also": "compressed",
        "notes": "",
        "examples": ">>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n>>> x.filled()\narray([[999999,      1,      2],\n       [999999,      4,      5],\n       [     6,      7,      8]])\n>>> x.filled(fill_value=333)\narray([[333,   1,   2],\n       [333,   4,   5],\n       [  6,   7,   8]])\n>>> x.filled(fill_value=np.arange(3))\narray([[0, 1, 2],\n       [0, 4, 5],\n       [6, 7, 8]])"
      }
    },
    {
      "name": "fix_invalid",
      "signature": "fix_invalid(a, mask=False, copy=True, fill_value=None)",
      "docstring": {
        "description": "Return input with invalid data masked and replaced by a fill value.\n\nInvalid data means values of `nan`, `inf`, etc.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array, a (subclass of) ndarray."
          },
          "mask": {
            "type": "sequence, optional",
            "description": "Mask. Must be convertible to an array of booleans with the same\n    shape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to use a copy of `a` (True) or to fix `a` in place (False).\n    Default is True."
          },
          "fill_value": {
            "type": "scalar, optional",
            "description": "Value used for fixing invalid data. Default is None, in which case\n    the ``a.fill_value`` is used."
          }
        },
        "returns": "b : MaskedArray\n    The input array with invalid entries fixed.",
        "raises": "",
        "see_also": "",
        "notes": "A copy is performed by default.",
        "examples": ">>> x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)\n>>> x\nmasked_array(data=[--, -1.0, nan, inf],\n             mask=[ True, False, False, False],\n       fill_value=1e+20)\n>>> np.ma.fix_invalid(x)\nmasked_array(data=[--, -1.0, --, --],\n             mask=[ True, False,  True,  True],\n       fill_value=1e+20)\n\n>>> fixed = np.ma.fix_invalid(x)\n>>> fixed.data\narray([ 1.e+00, -1.e+00,  1.e+20,  1.e+20])\n>>> x.data\narray([ 1., -1., nan, inf])"
      }
    },
    {
      "name": "flatnotmasked_contiguous",
      "signature": "flatnotmasked_contiguous(a)",
      "docstring": {
        "description": "Find contiguous unmasked data in a masked array.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "The input array."
          }
        },
        "returns": "slice_list : list\n    A sorted sequence of `slice` objects (start index, end index).\n\n    .. versionchanged:: 1.15.0\n        Now returns an empty list instead of None for a fully masked array",
        "raises": "",
        "see_also": "flatnotmasked_edges, notmasked_contiguous, notmasked_edges\nclump_masked, clump_unmasked",
        "notes": "Only accepts 2-D arrays at most.",
        "examples": ">>> a = np.ma.arange(10)\n>>> np.ma.flatnotmasked_contiguous(a)\n[slice(0, 10, None)]\n\n>>> mask = (a < 3) | (a > 8) | (a == 5)\n>>> a[mask] = np.ma.masked\n>>> np.array(a[~a.mask])\narray([3, 4, 6, 7, 8])\n\n>>> np.ma.flatnotmasked_contiguous(a)\n[slice(3, 5, None), slice(6, 9, None)]\n>>> a[:] = np.ma.masked\n>>> np.ma.flatnotmasked_contiguous(a)\n[]"
      }
    },
    {
      "name": "flatnotmasked_edges",
      "signature": "flatnotmasked_edges(a)",
      "docstring": {
        "description": "Find the indices of the first and last unmasked values.\n\nExpects a 1-D `MaskedArray`, returns None if all values are masked.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input 1-D `MaskedArray`"
          }
        },
        "returns": "edges : ndarray or None\n    The indices of first and last non-masked value in the array.\n    Returns None if all values are masked.",
        "raises": "",
        "see_also": "flatnotmasked_contiguous, notmasked_contiguous, notmasked_edges\nclump_masked, clump_unmasked",
        "notes": "Only accepts 1-D arrays.",
        "examples": ">>> a = np.ma.arange(10)\n>>> np.ma.flatnotmasked_edges(a)\narray([0, 9])\n\n>>> mask = (a < 3) | (a > 8) | (a == 5)\n>>> a[mask] = np.ma.masked\n>>> np.array(a[~a.mask])\narray([3, 4, 6, 7, 8])\n\n>>> np.ma.flatnotmasked_edges(a)\narray([3, 8])\n\n>>> a[:] = np.ma.masked\n>>> print(np.ma.flatnotmasked_edges(a))\nNone"
      }
    },
    {
      "name": "flatten_mask",
      "signature": "flatten_mask(mask)",
      "docstring": {
        "description": "Returns a completely flattened version of the mask, where nested fields\nare collapsed.",
        "parameters": {
          "mask": {
            "type": "array_like",
            "description": "Input array, which will be interpreted as booleans."
          }
        },
        "returns": "flattened_mask : ndarray of bools\n    The flattened input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> mask = np.array([0, 0, 1])\n>>> np.ma.flatten_mask(mask)\narray([False, False,  True])\n\n>>> mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])\n>>> np.ma.flatten_mask(mask)\narray([False, False, False,  True])\n\n>>> mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]\n>>> mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)\n>>> np.ma.flatten_mask(mask)\narray([False, False, False, False, False,  True])"
      }
    },
    {
      "name": "flatten_structured_array",
      "signature": "flatten_structured_array(a)",
      "docstring": {
        "description": "Flatten a structured array.\n\nThe data type of the output is chosen such that it can represent all of the\n(nested) fields.",
        "parameters": {
          "a": {
            "type": "structured array",
            "description": ""
          }
        },
        "returns": "output : masked array or ndarray\n    A flattened masked array if the input is a masked array, otherwise a\n    standard ndarray.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> ndtype = [('a', int), ('b', float)]\n>>> a = np.array([(1, 1), (2, 2)], dtype=ndtype)\n>>> np.ma.flatten_structured_array(a)\narray([[1., 1.],\n       [2., 2.]])"
      }
    },
    {
      "name": "floor",
      "signature": "floor(a, *args, **kwargs)",
      "docstring": {
        "description": "floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the floor of the input, element-wise.\n\nThe floor of the scalar `x` is the largest integer `i`, such that\n`i <= x`.  It is often denoted as :math:`\\lfloor x \\rfloor`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input data."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray or scalar\n    The floor of each element in `x`.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "ceil, trunc, rint, fix",
        "notes": "Some spreadsheet programs calculate the \"floor-towards-zero\", where\n``floor(-2.5) == -2``.  NumPy instead uses the definition of\n`floor` where `floor(-2.5) == -3`. The \"floor-towards-zero\"\nfunction is called ``fix`` in NumPy.",
        "examples": ">>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.floor(a)\narray([-2., -2., -1.,  0.,  1.,  1.,  2.])"
      }
    },
    {
      "name": "floor_divide",
      "signature": "floor_divide(a, b, *args, **kwargs)",
      "docstring": {
        "description": "floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the largest integer smaller or equal to the division of the inputs.\nIt is equivalent to the Python ``//`` operator and pairs with the\nPython ``%`` (`remainder`), function so that ``a = a % b + b * (a // b)``\nup to roundoff.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Numerator."
          },
          "x2": {
            "type": "array_like",
            "description": "Denominator.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    y = floor(`x1`/`x2`)\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "remainder : Remainder complementary to floor_divide.\ndivmod : Simultaneous floor division and remainder.\ndivide : Standard division.\nfloor : Round a number to the nearest integer toward minus infinity.\nceil : Round a number to the nearest integer toward infinity.",
        "notes": "",
        "examples": ">>> np.floor_divide(7,3)\n2\n>>> np.floor_divide([1., 2., 3., 4.], 2.5)\narray([ 0.,  0.,  1.,  1.])\n\nThe ``//`` operator can be used as a shorthand for ``np.floor_divide``\non ndarrays.\n\n>>> x1 = np.array([1., 2., 3., 4.])\n>>> x1 // 2.5\narray([0., 0., 1., 1.])"
      }
    },
    {
      "name": "fmod",
      "signature": "fmod(a, b, *args, **kwargs)",
      "docstring": {
        "description": "fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns the element-wise remainder of division.\n\nThis is the NumPy implementation of the C library function fmod, the\nremainder has the same sign as the dividend `x1`. It is equivalent to\nthe Matlab(TM) ``rem`` function and should not be confused with the\nPython modulus operator ``x1 % x2``.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : array_like\n    The remainder of the division of `x1` by `x2`.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "remainder : Equivalent to the Python ``%`` operator.\ndivide",
        "notes": "The result of the modulo operation for negative dividend and divisors\nis bound by conventions. For `fmod`, the sign of result is the sign of\nthe dividend, while for `remainder` the sign of the result is the sign\nof the divisor. The `fmod` function is equivalent to the Matlab(TM)\n``rem`` function.",
        "examples": ">>> np.fmod([-3, -2, -1, 1, 2, 3], 2)\narray([-1,  0, -1,  1,  0,  1])\n>>> np.remainder([-3, -2, -1, 1, 2, 3], 2)\narray([1, 0, 1, 1, 0, 1])\n\n>>> np.fmod([5, 3], [2, 2.])\narray([ 1.,  1.])\n>>> a = np.arange(-3, 3).reshape(3, 2)\n>>> a\narray([[-3, -2],\n       [-1,  0],\n       [ 1,  2]])\n>>> np.fmod(a, [2,2])\narray([[-1,  0],\n       [-1,  0],\n       [ 1,  0]])"
      }
    },
    {
      "name": "frombuffer",
      "signature": "frombuffer(...)",
      "docstring": {}
    },
    {
      "name": "fromflex",
      "signature": "fromflex(fxarray)",
      "docstring": {
        "description": "Build a masked array from a suitable flexible-type array.\n\nThe input array has to have a data-type with ``_data`` and ``_mask``\nfields. This type of array is output by `MaskedArray.toflex`.",
        "parameters": {
          "fxarray": {
            "type": "ndarray",
            "description": "The structured input array, containing ``_data`` and ``_mask``\n    fields. If present, other fields are discarded."
          }
        },
        "returns": "result : MaskedArray\n    The constructed masked array.",
        "raises": "",
        "see_also": "MaskedArray.toflex : Build a flexible-type array from a masked array.",
        "notes": "",
        "examples": ">>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[0] + [1, 0] * 4)\n>>> rec = x.toflex()\n>>> rec\narray([[(0, False), (1,  True), (2, False)],\n       [(3,  True), (4, False), (5,  True)],\n       [(6, False), (7,  True), (8, False)]],\n      dtype=[('_data', '<i8'), ('_mask', '?')])\n>>> x2 = np.ma.fromflex(rec)\n>>> x2\nmasked_array(\n  data=[[0, --, 2],\n        [--, 4, --],\n        [6, --, 8]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n\nExtra fields can be present in the structured array but are discarded:\n\n>>> dt = [('_data', '<i4'), ('_mask', '|b1'), ('field3', '<f4')]\n>>> rec2 = np.zeros((2, 2), dtype=dt)\n>>> rec2\narray([[(0, False, 0.), (0, False, 0.)],\n       [(0, False, 0.), (0, False, 0.)]],\n      dtype=[('_data', '<i4'), ('_mask', '?'), ('field3', '<f4')])\n>>> y = np.ma.fromflex(rec2)\n>>> y\nmasked_array(\n  data=[[0, 0],\n        [0, 0]],\n  mask=[[False, False],\n        [False, False]],\n  fill_value=999999,\n  dtype=int32)"
      }
    },
    {
      "name": "fromfunction",
      "signature": "fromfunction(...)",
      "docstring": {}
    },
    {
      "name": "getdata",
      "signature": "getdata(a, subok=True)",
      "docstring": {
        "description": "Return the data of a masked array as an ndarray.\n\nReturn the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,\nelse return `a` as a ndarray or subclass (depending on `subok`) if not.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input ``MaskedArray``, alternatively a ndarray or a subclass thereof."
          },
          "subok": {
            "type": "bool",
            "description": "Whether to force the output to be a `pure` ndarray (False) or to\n    return a subclass of ndarray if appropriate (True, default)."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "getmask : Return the mask of a masked array, or nomask.\ngetmaskarray : Return the mask of a masked array, or full array of False.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = ma.masked_equal([[1,2],[3,4]], 2)\n>>> a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=2)\n>>> ma.getdata(a)\narray([[1, 2],\n       [3, 4]])\n\nEquivalently use the ``MaskedArray`` `data` attribute.\n\n>>> a.data\narray([[1, 2],\n       [3, 4]])"
      }
    },
    {
      "name": "getmask",
      "signature": "getmask(a)",
      "docstring": {
        "description": "Return the mask of a masked array, or nomask.\n\nReturn the mask of `a` as an ndarray if `a` is a `MaskedArray` and the\nmask is not `nomask`, else return `nomask`. To guarantee a full array\nof booleans of the same shape as a, use `getmaskarray`.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input `MaskedArray` for which the mask is required."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "getdata : Return the data of a masked array as an ndarray.\ngetmaskarray : Return the mask of a masked array, or full array of False.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = ma.masked_equal([[1,2],[3,4]], 2)\n>>> a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=2)\n>>> ma.getmask(a)\narray([[False,  True],\n       [False, False]])\n\nEquivalently use the `MaskedArray` `mask` attribute.\n\n>>> a.mask\narray([[False,  True],\n       [False, False]])\n\nResult when mask == `nomask`\n\n>>> b = ma.masked_array([[1,2],[3,4]])\n>>> b\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n>>> ma.nomask\nFalse\n>>> ma.getmask(b) == ma.nomask\nTrue\n>>> b.mask == ma.nomask\nTrue"
      }
    },
    {
      "name": "getmaskarray",
      "signature": "getmaskarray(arr)",
      "docstring": {
        "description": "Return the mask of a masked array, or full boolean array of False.\n\nReturn the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and\nthe mask is not `nomask`, else return a full boolean array of False of\nthe same shape as `arr`.",
        "parameters": {
          "arr": {
            "type": "array_like",
            "description": "Input `MaskedArray` for which the mask is required."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "getmask : Return the mask of a masked array, or nomask.\ngetdata : Return the data of a masked array as an ndarray.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = ma.masked_equal([[1,2],[3,4]], 2)\n>>> a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=2)\n>>> ma.getmaskarray(a)\narray([[False,  True],\n       [False, False]])\n\nResult when mask == ``nomask``\n\n>>> b = ma.masked_array([[1,2],[3,4]])\n>>> b\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n>>> ma.getmaskarray(b)\narray([[False, False],\n       [False, False]])"
      }
    },
    {
      "name": "greater",
      "signature": "greater(a, b, *args, **kwargs)",
      "docstring": {
        "description": "greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 > x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "greater_equal, less, less_equal, equal, not_equal",
        "notes": "",
        "examples": ">>> np.greater([4,2],[2,2])\narray([ True, False])\n\nThe ``>`` operator can be used as a shorthand for ``np.greater`` on\nndarrays.\n\n>>> a = np.array([4, 2])\n>>> b = np.array([2, 2])\n>>> a > b\narray([ True, False])"
      }
    },
    {
      "name": "greater_equal",
      "signature": "greater_equal(a, b, *args, **kwargs)",
      "docstring": {
        "description": "greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 >= x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : bool or ndarray of bool\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "greater, less, less_equal, equal, not_equal",
        "notes": "",
        "examples": ">>> np.greater_equal([4, 2, 1], [2, 2, 2])\narray([ True, True, False])\n\nThe ``>=`` operator can be used as a shorthand for ``np.greater_equal``\non ndarrays.\n\n>>> a = np.array([4, 2, 1])\n>>> b = np.array([2, 2, 2])\n>>> a >= b\narray([ True,  True, False])"
      }
    },
    {
      "name": "harden_mask",
      "signature": "harden_mask(a, *args, **params)",
      "docstring": {
        "description": "harden_mask(self)\n\nForce the mask to hard, preventing unmasking by assignment.\n\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `harden_mask` sets\n`~ma.MaskedArray.hardmask` to ``True`` (and returns the modified\nself).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "ma.MaskedArray.hardmask\nma.MaskedArray.soften_mask",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "hsplit",
      "signature": "hsplit(x, *args, **params)",
      "docstring": {
        "description": "hsplit\n\nSplit an array into multiple sub-arrays horizontally (column-wise).\n\nPlease refer to the `split` documentation.  `hsplit` is equivalent\nto `split` with ``axis=1``, the array is always split along the second\naxis except for 1-D arrays, where it is split at ``axis=0``.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "split : Split an array into multiple sub-arrays of equal size.",
        "notes": "The function is applied to both the _data and the _mask, if any.",
        "examples": ">>> x = np.arange(16.0).reshape(4, 4)\n>>> x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n>>> np.hsplit(x, 2)\n[array([[  0.,   1.],\n       [  4.,   5.],\n       [  8.,   9.],\n       [12.,  13.]]),\n array([[  2.,   3.],\n       [  6.,   7.],\n       [10.,  11.],\n       [14.,  15.]])]\n>>> np.hsplit(x, np.array([3, 6]))\n[array([[ 0.,   1.,   2.],\n       [ 4.,   5.,   6.],\n       [ 8.,   9.,  10.],\n       [12.,  13.,  14.]]),\n array([[ 3.],\n       [ 7.],\n       [11.],\n       [15.]]),\n array([], shape=(4, 0), dtype=float64)]\n\nWith a higher dimensional array the split is still along the second axis.\n\n>>> x = np.arange(8.0).reshape(2, 2, 2)\n>>> x\narray([[[0.,  1.],\n        [2.,  3.]],\n       [[4.,  5.],\n        [6.,  7.]]])\n>>> np.hsplit(x, 2)\n[array([[[0.,  1.]],\n       [[4.,  5.]]]),\n array([[[2.,  3.]],\n       [[6.,  7.]]])]\n\nWith a 1-D array, the split is along axis 0.\n\n>>> x = np.array([0, 1, 2, 3, 4, 5])\n>>> np.hsplit(x, 2)\n[array([0, 1, 2]), array([3, 4, 5])]"
      }
    },
    {
      "name": "hstack",
      "signature": "hstack(x, *args, **params)",
      "docstring": {
        "description": "hstack\n\nStack arrays in sequence horizontally (column wise).\n\nThis is equivalent to concatenation along the second axis, except for 1-D\narrays where it concatenates along the first axis. Rebuilds arrays divided\nby `hsplit`.\n\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.",
        "parameters": {
          "tup": {
            "type": "sequence of ndarrays",
            "description": "The arrays must have the same shape along all but the second axis,\n    except 1-D arrays which can be any length."
          },
          "dtype": {
            "type": "str or dtype",
            "description": "If provided, the destination array will have this dtype. Cannot be\n    provided together with `out`.\n\n.. versionadded:: 1.24"
          },
          "casting": {
            "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
            "description": "Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n.. versionadded:: 1.24"
          }
        },
        "returns": "stacked : ndarray\n    The array formed by stacking the given arrays.",
        "raises": "",
        "see_also": "concatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nblock : Assemble an nd-array from nested lists of blocks.\nvstack : Stack arrays in sequence vertically (row wise).\ndstack : Stack arrays in sequence depth wise (along third axis).\ncolumn_stack : Stack 1-D arrays as columns into a 2-D array.\nhsplit : Split an array into multiple sub-arrays horizontally (column-wise).",
        "notes": "The function is applied to both the _data and the _mask, if any.",
        "examples": ">>> a = np.array((1,2,3))\n>>> b = np.array((4,5,6))\n>>> np.hstack((a,b))\narray([1, 2, 3, 4, 5, 6])\n>>> a = np.array([[1],[2],[3]])\n>>> b = np.array([[4],[5],[6]])\n>>> np.hstack((a,b))\narray([[1, 4],\n       [2, 5],\n       [3, 6]])"
      }
    },
    {
      "name": "hypot",
      "signature": "hypot(a, b, *args, **kwargs)",
      "docstring": {
        "description": "hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nGiven the \"legs\" of a right triangle, return its hypotenuse.\n\nEquivalent to ``sqrt(x1**2 + x2**2)``, element-wise.  If `x1` or\n`x2` is scalar_like (i.e., unambiguously cast-able to a scalar type),\nit is broadcast for use with each element of the other argument.\n(See Examples)",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "z : ndarray\n    The hypotenuse of the triangle(s).\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])\n\nExample showing broadcast of scalar_like argument:\n\n>>> np.hypot(3*np.ones((3, 3)), [4])\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])"
      }
    },
    {
      "name": "identity",
      "signature": "identity(...)",
      "docstring": {}
    },
    {
      "name": "ids",
      "signature": "ids(a, *args, **params)",
      "docstring": {
        "description": "ids(self)\n\nReturn the addresses of the data and mask areas.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n>>> x.ids()\n(166670640, 166659832) # may vary\n\nIf the array has no mask, the address of `nomask` is returned. This address\nis typically not close to the data in memory:\n\n>>> x = np.ma.array([1, 2, 3])\n>>> x.ids()\n(166691080, 3083169284) # may vary"
      }
    },
    {
      "name": "in1d",
      "signature": "in1d(ar1, ar2, assume_unique=False, invert=False)",
      "docstring": {
        "description": "Test whether each element of an array is also present in a second\narray.\n\nThe output is always a masked array. See `numpy.in1d` for more details.\n\nWe recommend using :func:`isin` instead of `in1d` for new code.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "isin       : Version of this function that preserves the shape of ar1.\nnumpy.in1d : Equivalent function for ndarrays.",
        "notes": ".. versionadded:: 1.4.0",
        "examples": ""
      }
    },
    {
      "name": "indices",
      "signature": "indices(...)",
      "docstring": {}
    },
    {
      "name": "inner",
      "signature": "inner(a, b)",
      "docstring": {
        "description": "inner(a, b, /)\n\nInner product of two arrays.\n\nOrdinary inner product of vectors for 1-D arrays (without complex\nconjugation), in higher dimensions a sum product over the last axes.",
        "parameters": {},
        "returns": "out : ndarray\n    If `a` and `b` are both\n    scalars or both 1-D arrays then a scalar is returned; otherwise\n    an array is returned.\n    ``out.shape = (*a.shape[:-1], *b.shape[:-1])``",
        "raises": "ValueError\n    If both `a` and `b` are nonscalar and their last dimensions have\n    different sizes.",
        "see_also": "tensordot : Sum products over arbitrary axes.\ndot : Generalised matrix product, using second last dimension of `b`.\neinsum : Einstein summation convention.",
        "notes": "Masked values are replaced by 0.\n\nFor vectors (1-D arrays) it computes the ordinary inner-product::\n\n    np.inner(a, b) = sum(a[:]*b[:])\n\nMore generally, if ``ndim(a) = r > 0`` and ``ndim(b) = s > 0``::\n\n    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))\n\nor explicitly::\n\n    np.inner(a, b)[i0,...,ir-2,j0,...,js-2]\n         = sum(a[i0,...,ir-2,:]*b[j0,...,js-2,:])\n\nIn addition `a` or `b` may be scalars, in which case::\n\n   np.inner(a,b) = a*b",
        "examples": "Ordinary inner product for vectors:\n\n>>> a = np.array([1,2,3])\n>>> b = np.array([0,1,0])\n>>> np.inner(a, b)\n2\n\nSome multidimensional examples:\n\n>>> a = np.arange(24).reshape((2,3,4))\n>>> b = np.arange(4)\n>>> c = np.inner(a, b)\n>>> c.shape\n(2, 3)\n>>> c\narray([[ 14,  38,  62],\n       [ 86, 110, 134]])\n\n>>> a = np.arange(2).reshape((1,1,2))\n>>> b = np.arange(6).reshape((3,2))\n>>> c = np.inner(a, b)\n>>> c.shape\n(1, 1, 3)\n>>> c\narray([[[1, 3, 5]]])\n\nAn example where `b` is a scalar:\n\n>>> np.inner(np.eye(2), 7)\narray([[7., 0.],\n       [0., 7.]])"
      }
    },
    {
      "name": "innerproduct",
      "signature": "inner(a, b)",
      "docstring": {
        "description": "inner(a, b, /)\n\nInner product of two arrays.\n\nOrdinary inner product of vectors for 1-D arrays (without complex\nconjugation), in higher dimensions a sum product over the last axes.",
        "parameters": {},
        "returns": "out : ndarray\n    If `a` and `b` are both\n    scalars or both 1-D arrays then a scalar is returned; otherwise\n    an array is returned.\n    ``out.shape = (*a.shape[:-1], *b.shape[:-1])``",
        "raises": "ValueError\n    If both `a` and `b` are nonscalar and their last dimensions have\n    different sizes.",
        "see_also": "tensordot : Sum products over arbitrary axes.\ndot : Generalised matrix product, using second last dimension of `b`.\neinsum : Einstein summation convention.",
        "notes": "Masked values are replaced by 0.\n\nFor vectors (1-D arrays) it computes the ordinary inner-product::\n\n    np.inner(a, b) = sum(a[:]*b[:])\n\nMore generally, if ``ndim(a) = r > 0`` and ``ndim(b) = s > 0``::\n\n    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))\n\nor explicitly::\n\n    np.inner(a, b)[i0,...,ir-2,j0,...,js-2]\n         = sum(a[i0,...,ir-2,:]*b[j0,...,js-2,:])\n\nIn addition `a` or `b` may be scalars, in which case::\n\n   np.inner(a,b) = a*b",
        "examples": "Ordinary inner product for vectors:\n\n>>> a = np.array([1,2,3])\n>>> b = np.array([0,1,0])\n>>> np.inner(a, b)\n2\n\nSome multidimensional examples:\n\n>>> a = np.arange(24).reshape((2,3,4))\n>>> b = np.arange(4)\n>>> c = np.inner(a, b)\n>>> c.shape\n(2, 3)\n>>> c\narray([[ 14,  38,  62],\n       [ 86, 110, 134]])\n\n>>> a = np.arange(2).reshape((1,1,2))\n>>> b = np.arange(6).reshape((3,2))\n>>> c = np.inner(a, b)\n>>> c.shape\n(1, 1, 3)\n>>> c\narray([[[1, 3, 5]]])\n\nAn example where `b` is a scalar:\n\n>>> np.inner(np.eye(2), 7)\narray([[7., 0.],\n       [0., 7.]])"
      }
    },
    {
      "name": "intersect1d",
      "signature": "intersect1d(ar1, ar2, assume_unique=False)",
      "docstring": {
        "description": "Returns the unique elements common to both arrays.\n\nMasked values are considered equal one to the other.\nThe output is always a masked array.\n\nSee `numpy.intersect1d` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.intersect1d : Equivalent function for ndarrays.",
        "notes": "",
        "examples": ">>> x = np.ma.array([1, 3, 3, 3], mask=[0, 0, 0, 1])\n>>> y = np.ma.array([3, 1, 1, 1], mask=[0, 0, 0, 1])\n>>> np.ma.intersect1d(x, y)\nmasked_array(data=[1, 3, --],\n             mask=[False, False,  True],\n       fill_value=999999)"
      }
    },
    {
      "name": "isMA",
      "signature": "isMaskedArray(x)",
      "docstring": {
        "description": "Test whether input is an instance of MaskedArray.\n\nThis function returns True if `x` is an instance of MaskedArray\nand returns False otherwise.  Any object is accepted as input.",
        "parameters": {
          "x": {
            "type": "object",
            "description": "Object to test."
          }
        },
        "returns": "result : bool\n    True if `x` is a MaskedArray.",
        "raises": "",
        "see_also": "isMA : Alias to isMaskedArray.\nisarray : Alias to isMaskedArray.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.eye(3, 3)\n>>> a\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> m = ma.masked_values(a, 0)\n>>> m\nmasked_array(\n  data=[[1.0, --, --],\n        [--, 1.0, --],\n        [--, --, 1.0]],\n  mask=[[False,  True,  True],\n        [ True, False,  True],\n        [ True,  True, False]],\n  fill_value=0.0)\n>>> ma.isMaskedArray(a)\nFalse\n>>> ma.isMaskedArray(m)\nTrue\n>>> ma.isMaskedArray([0, 1, 2])\nFalse"
      }
    },
    {
      "name": "isMaskedArray",
      "signature": "isMaskedArray(x)",
      "docstring": {
        "description": "Test whether input is an instance of MaskedArray.\n\nThis function returns True if `x` is an instance of MaskedArray\nand returns False otherwise.  Any object is accepted as input.",
        "parameters": {
          "x": {
            "type": "object",
            "description": "Object to test."
          }
        },
        "returns": "result : bool\n    True if `x` is a MaskedArray.",
        "raises": "",
        "see_also": "isMA : Alias to isMaskedArray.\nisarray : Alias to isMaskedArray.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.eye(3, 3)\n>>> a\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> m = ma.masked_values(a, 0)\n>>> m\nmasked_array(\n  data=[[1.0, --, --],\n        [--, 1.0, --],\n        [--, --, 1.0]],\n  mask=[[False,  True,  True],\n        [ True, False,  True],\n        [ True,  True, False]],\n  fill_value=0.0)\n>>> ma.isMaskedArray(a)\nFalse\n>>> ma.isMaskedArray(m)\nTrue\n>>> ma.isMaskedArray([0, 1, 2])\nFalse"
      }
    },
    {
      "name": "is_mask",
      "signature": "is_mask(m)",
      "docstring": {
        "description": "Return True if m is a valid, standard mask.\n\nThis function does not check the contents of the input, only that the\ntype is MaskType. In particular, this function returns False if the\nmask has a flexible dtype.",
        "parameters": {
          "m": {
            "type": "array_like",
            "description": "Array to test."
          }
        },
        "returns": "result : bool\n    True if `m.dtype.type` is MaskType, False otherwise.",
        "raises": "",
        "see_also": "ma.isMaskedArray : Test whether input is an instance of MaskedArray.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> m = ma.masked_equal([0, 1, 0, 2, 3], 0)\n>>> m\nmasked_array(data=[--, 1, --, 2, 3],\n             mask=[ True, False,  True, False, False],\n       fill_value=0)\n>>> ma.is_mask(m)\nFalse\n>>> ma.is_mask(m.mask)\nTrue\n\nInput must be an ndarray (or have similar attributes)\nfor it to be considered a valid mask.\n\n>>> m = [False, True, False]\n>>> ma.is_mask(m)\nFalse\n>>> m = np.array([False, True, False])\n>>> m\narray([False,  True, False])\n>>> ma.is_mask(m)\nTrue\n\nArrays with complex dtypes don't return True.\n\n>>> dtype = np.dtype({'names':['monty', 'pithon'],\n...                   'formats':[bool, bool]})\n>>> dtype\ndtype([('monty', '|b1'), ('pithon', '|b1')])\n>>> m = np.array([(True, False), (False, True), (True, False)],\n...              dtype=dtype)\n>>> m\narray([( True, False), (False,  True), ( True, False)],\n      dtype=[('monty', '?'), ('pithon', '?')])\n>>> ma.is_mask(m)\nFalse"
      }
    },
    {
      "name": "is_masked",
      "signature": "is_masked(x)",
      "docstring": {
        "description": "Determine whether input has masked values.\n\nAccepts any object as input, but always returns False unless the\ninput is a MaskedArray containing masked values.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Array to check for masked values."
          }
        },
        "returns": "result : bool\n    True if `x` is a MaskedArray with masked values, False otherwise.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> x = ma.masked_equal([0, 1, 0, 2, 3], 0)\n>>> x\nmasked_array(data=[--, 1, --, 2, 3],\n             mask=[ True, False,  True, False, False],\n       fill_value=0)\n>>> ma.is_masked(x)\nTrue\n>>> x = ma.masked_equal([0, 1, 0, 2, 3], 42)\n>>> x\nmasked_array(data=[0, 1, 0, 2, 3],\n             mask=False,\n       fill_value=42)\n>>> ma.is_masked(x)\nFalse\n\nAlways returns False if `x` isn't a MaskedArray.\n\n>>> x = [False, True, False]\n>>> ma.is_masked(x)\nFalse\n>>> x = 'a string'\n>>> ma.is_masked(x)\nFalse"
      }
    },
    {
      "name": "isarray",
      "signature": "isMaskedArray(x)",
      "docstring": {
        "description": "Test whether input is an instance of MaskedArray.\n\nThis function returns True if `x` is an instance of MaskedArray\nand returns False otherwise.  Any object is accepted as input.",
        "parameters": {
          "x": {
            "type": "object",
            "description": "Object to test."
          }
        },
        "returns": "result : bool\n    True if `x` is a MaskedArray.",
        "raises": "",
        "see_also": "isMA : Alias to isMaskedArray.\nisarray : Alias to isMaskedArray.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.eye(3, 3)\n>>> a\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> m = ma.masked_values(a, 0)\n>>> m\nmasked_array(\n  data=[[1.0, --, --],\n        [--, 1.0, --],\n        [--, --, 1.0]],\n  mask=[[False,  True,  True],\n        [ True, False,  True],\n        [ True,  True, False]],\n  fill_value=0.0)\n>>> ma.isMaskedArray(a)\nFalse\n>>> ma.isMaskedArray(m)\nTrue\n>>> ma.isMaskedArray([0, 1, 2])\nFalse"
      }
    },
    {
      "name": "isin",
      "signature": "isin(element, test_elements, assume_unique=False, invert=False)",
      "docstring": {
        "description": "Calculates `element in test_elements`, broadcasting over\n`element` only.\n\nThe output is always a masked array of the same shape as `element`.\nSee `numpy.isin` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "in1d       : Flattened version of this function.\nnumpy.isin : Equivalent function for ndarrays.",
        "notes": ".. versionadded:: 1.13.0",
        "examples": ""
      }
    },
    {
      "name": "left_shift",
      "signature": "left_shift(a, n)",
      "docstring": {
        "description": "Shift the bits of an integer to the left.\n\nThis is the masked array version of `numpy.left_shift`, for details\nsee that function.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.left_shift",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "less",
      "signature": "less(a, b, *args, **kwargs)",
      "docstring": {
        "description": "less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 < x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "greater, less_equal, greater_equal, equal, not_equal",
        "notes": "",
        "examples": ">>> np.less([1, 2], [2, 2])\narray([ True, False])\n\nThe ``<`` operator can be used as a shorthand for ``np.less`` on ndarrays.\n\n>>> a = np.array([1, 2])\n>>> b = np.array([2, 2])\n>>> a < b\narray([ True, False])"
      }
    },
    {
      "name": "less_equal",
      "signature": "less_equal(a, b, *args, **kwargs)",
      "docstring": {
        "description": "less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 <= x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "greater, less, greater_equal, equal, not_equal",
        "notes": "",
        "examples": ">>> np.less_equal([4, 2, 1], [2, 2, 2])\narray([False,  True,  True])\n\nThe ``<=`` operator can be used as a shorthand for ``np.less_equal`` on\nndarrays.\n\n>>> a = np.array([4, 2, 1])\n>>> b = np.array([2, 2, 2])\n>>> a <= b\narray([False,  True,  True])"
      }
    },
    {
      "name": "log",
      "signature": "log(a, *args, **kwargs)",
      "docstring": {
        "description": "log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nNatural logarithm, element-wise.\n\nThe natural logarithm `log` is the inverse of the exponential function,\nso that `log(exp(x)) = x`. The natural logarithm is logarithm in base\n`e`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input value."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    The natural logarithm of `x`, element-wise.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "log10, log2, log1p, emath.log",
        "notes": "Logarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `exp(z) = x`. The convention is to return the\n`z` whose imaginary part lies in `(-pi, pi]`.\n\nFor real-valued input data types, `log` always returns real output. For\neach value that cannot be expressed as a real number or infinity, it\nyields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `log` is a complex analytical function that\nhas a branch cut `[-inf, 0]` and is continuous from above on it. `log`\nhandles the floating-point negative zero as an infinitesimal negative\nnumber, conforming to the C99 standard.\n\nIn the cases where the input has a negative real part and a very small\nnegative complex part (approaching 0), the result is so close to `-pi`\nthat it evaluates to exactly `-pi`.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n       10th printing, 1964, pp. 67.\n       https://personal.math.ubc.ca/~cbm/aands/page_67.htm\n.. [2] Wikipedia, \"Logarithm\". https://en.wikipedia.org/wiki/Logarithm",
        "examples": ">>> np.log([1, np.e, np.e**2, 0])\narray([  0.,   1.,   2., -Inf])"
      }
    },
    {
      "name": "log10",
      "signature": "log10(a, *args, **kwargs)",
      "docstring": {
        "description": "log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the base 10 logarithm of the input array, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input values."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    The logarithm to the base 10 of `x`, element-wise. NaNs are\n    returned where x is negative.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "emath.log10",
        "notes": "Logarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `10**z = x`. The convention is to return the\n`z` whose imaginary part lies in `(-pi, pi]`.\n\nFor real-valued input data types, `log10` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `log10` is a complex analytical function that\nhas a branch cut `[-inf, 0]` and is continuous from above on it.\n`log10` handles the floating-point negative zero as an infinitesimal\nnegative number, conforming to the C99 standard.\n\nIn the cases where the input has a negative real part and a very small\nnegative complex part (approaching 0), the result is so close to `-pi`\nthat it evaluates to exactly `-pi`.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n       10th printing, 1964, pp. 67.\n       https://personal.math.ubc.ca/~cbm/aands/page_67.htm\n.. [2] Wikipedia, \"Logarithm\". https://en.wikipedia.org/wiki/Logarithm",
        "examples": ">>> np.log10([1e-15, -3.])\narray([-15.,  nan])"
      }
    },
    {
      "name": "log2",
      "signature": "log2(a, *args, **kwargs)",
      "docstring": {
        "description": "log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nBase-2 logarithm of `x`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input values."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    Base-2 logarithm of `x`.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "log, log10, log1p, emath.log2",
        "notes": ".. versionadded:: 1.3.0\n\nLogarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `2**z = x`. The convention is to return the `z`\nwhose imaginary part lies in `(-pi, pi]`.\n\nFor real-valued input data types, `log2` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `log2` is a complex analytical function that\nhas a branch cut `[-inf, 0]` and is continuous from above on it. `log2`\nhandles the floating-point negative zero as an infinitesimal negative\nnumber, conforming to the C99 standard.\n\nIn the cases where the input has a negative real part and a very small\nnegative complex part (approaching 0), the result is so close to `-pi`\nthat it evaluates to exactly `-pi`.",
        "examples": ">>> x = np.array([0, 1, 2, 2**4])\n>>> np.log2(x)\narray([-Inf,   0.,   1.,   4.])\n\n>>> xi = np.array([0+1.j, 1, 2+0.j, 4.j])\n>>> np.log2(xi)\narray([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])"
      }
    },
    {
      "name": "logical_and",
      "signature": "logical_and(a, b, *args, **kwargs)",
      "docstring": {
        "description": "logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of x1 AND x2 element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray or bool\n    Boolean result of the logical AND operation applied to the elements\n    of `x1` and `x2`; the shape is determined by broadcasting.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "logical_or, logical_not, logical_xor\nbitwise_and",
        "notes": "",
        "examples": ">>> np.logical_and(True, False)\nFalse\n>>> np.logical_and([True, False], [False, False])\narray([False, False])\n\n>>> x = np.arange(5)\n>>> np.logical_and(x>1, x<4)\narray([False, False,  True,  True, False])\n\n\nThe ``&`` operator can be used as a shorthand for ``np.logical_and`` on\nboolean ndarrays.\n\n>>> a = np.array([True, False])\n>>> b = np.array([False, False])\n>>> a & b\narray([False, False])"
      }
    },
    {
      "name": "logical_not",
      "signature": "logical_not(a, *args, **kwargs)",
      "docstring": {
        "description": "logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of NOT x element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Logical NOT is applied to the elements of `x`."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : bool or ndarray of bool\n    Boolean result with the same shape as `x` of the NOT operation\n    on elements of `x`.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "logical_and, logical_or, logical_xor",
        "notes": "",
        "examples": ">>> np.logical_not(3)\nFalse\n>>> np.logical_not([True, False, 0, 1])\narray([False,  True,  True, False])\n\n>>> x = np.arange(5)\n>>> np.logical_not(x<3)\narray([False, False, False,  True,  True])"
      }
    },
    {
      "name": "logical_or",
      "signature": "logical_or(a, b, *args, **kwargs)",
      "docstring": {
        "description": "logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of x1 OR x2 element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray or bool\n    Boolean result of the logical OR operation applied to the elements\n    of `x1` and `x2`; the shape is determined by broadcasting.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "logical_and, logical_not, logical_xor\nbitwise_or",
        "notes": "",
        "examples": ">>> np.logical_or(True, False)\nTrue\n>>> np.logical_or([True, False], [False, False])\narray([ True, False])\n\n>>> x = np.arange(5)\n>>> np.logical_or(x < 1, x > 3)\narray([ True, False, False, False,  True])\n\nThe ``|`` operator can be used as a shorthand for ``np.logical_or`` on\nboolean ndarrays.\n\n>>> a = np.array([True, False])\n>>> b = np.array([False, False])\n>>> a | b\narray([ True, False])"
      }
    },
    {
      "name": "logical_xor",
      "signature": "logical_xor(a, b, *args, **kwargs)",
      "docstring": {
        "description": "logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of x1 XOR x2, element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : bool or ndarray of bool\n    Boolean result of the logical XOR operation applied to the elements\n    of `x1` and `x2`; the shape is determined by broadcasting.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "logical_and, logical_or, logical_not, bitwise_xor",
        "notes": "",
        "examples": ">>> np.logical_xor(True, False)\nTrue\n>>> np.logical_xor([True, True, False, False], [True, False, True, False])\narray([False,  True,  True, False])\n\n>>> x = np.arange(5)\n>>> np.logical_xor(x < 1, x > 3)\narray([ True, False, False, False,  True])\n\nSimple example showing support of broadcasting\n\n>>> np.logical_xor(0, np.eye(2))\narray([[ True, False],\n       [False,  True]])"
      }
    },
    {
      "name": "make_mask",
      "signature": "make_mask(m, copy=False, shrink=True, dtype=<class 'numpy.bool_'>)",
      "docstring": {
        "description": "Create a boolean mask from an array.\n\nReturn `m` as a boolean mask, creating a copy if necessary or requested.\nThe function can accept any sequence that is convertible to integers,\nor ``nomask``.  Does not require that contents must be 0s and 1s, values\nof 0 are interpreted as False, everything else as True.",
        "parameters": {
          "m": {
            "type": "array_like",
            "description": "Potential mask."
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to return a copy of `m` (True) or `m` itself (False)."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to shrink `m` to ``nomask`` if all its values are False."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Data-type of the output mask. By default, the output mask has a\n    dtype of MaskType (bool). If the dtype is flexible, each field has\n    a boolean dtype. This is ignored when `m` is ``nomask``, in which\n    case ``nomask`` is always returned."
          }
        },
        "returns": "result : ndarray\n    A boolean mask derived from `m`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> m = [True, False, True, True]\n>>> ma.make_mask(m)\narray([ True, False,  True,  True])\n>>> m = [1, 0, 1, 1]\n>>> ma.make_mask(m)\narray([ True, False,  True,  True])\n>>> m = [1, 0, 2, -3]\n>>> ma.make_mask(m)\narray([ True, False,  True,  True])\n\nEffect of the `shrink` parameter.\n\n>>> m = np.zeros(4)\n>>> m\narray([0., 0., 0., 0.])\n>>> ma.make_mask(m)\nFalse\n>>> ma.make_mask(m, shrink=False)\narray([False, False, False, False])\n\nUsing a flexible `dtype`.\n\n>>> m = [1, 0, 1, 1]\n>>> n = [0, 1, 0, 0]\n>>> arr = []\n>>> for man, mouse in zip(m, n):\n...     arr.append((man, mouse))\n>>> arr\n[(1, 0), (0, 1), (1, 0), (1, 0)]\n>>> dtype = np.dtype({'names':['man', 'mouse'],\n...                   'formats':[np.int64, np.int64]})\n>>> arr = np.array(arr, dtype=dtype)\n>>> arr\narray([(1, 0), (0, 1), (1, 0), (1, 0)],\n      dtype=[('man', '<i8'), ('mouse', '<i8')])\n>>> ma.make_mask(arr, dtype=dtype)\narray([(True, False), (False, True), (True, False), (True, False)],\n      dtype=[('man', '|b1'), ('mouse', '|b1')])"
      }
    },
    {
      "name": "make_mask_descr",
      "signature": "make_mask_descr(ndtype)",
      "docstring": {
        "description": "Construct a dtype description list from a given dtype.\n\nReturns a new dtype object, with the type of all fields in `ndtype` to a\nboolean type. Field names are not altered.",
        "parameters": {
          "ndtype": {
            "type": "dtype",
            "description": "The dtype to convert."
          }
        },
        "returns": "result : dtype\n    A dtype that looks like `ndtype`, the type of all fields is boolean.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> dtype = np.dtype({'names':['foo', 'bar'],\n...                   'formats':[np.float32, np.int64]})\n>>> dtype\ndtype([('foo', '<f4'), ('bar', '<i8')])\n>>> ma.make_mask_descr(dtype)\ndtype([('foo', '|b1'), ('bar', '|b1')])\n>>> ma.make_mask_descr(np.float32)\ndtype('bool')"
      }
    },
    {
      "name": "make_mask_none",
      "signature": "make_mask_none(newshape, dtype=None)",
      "docstring": {
        "description": "Return a boolean mask of the given shape, filled with False.\n\nThis function returns a boolean ndarray with all entries False, that can\nbe used in common mask manipulations. If a complex dtype is specified, the\ntype of each field is converted to a boolean type.",
        "parameters": {
          "newshape": {
            "type": "tuple",
            "description": "A tuple indicating the shape of the mask."
          },
          "dtype": {
            "type": "{None, dtype}, optional",
            "description": "If None, use a MaskType instance. Otherwise, use a new datatype with\n    the same fields as `dtype`, converted to boolean types."
          }
        },
        "returns": "result : ndarray\n    An ndarray of appropriate shape and dtype, filled with False.",
        "raises": "",
        "see_also": "make_mask : Create a boolean mask from an array.\nmake_mask_descr : Construct a dtype description list from a given dtype.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> ma.make_mask_none((3,))\narray([False, False, False])\n\nDefining a more complex dtype.\n\n>>> dtype = np.dtype({'names':['foo', 'bar'],\n...                   'formats':[np.float32, np.int64]})\n>>> dtype\ndtype([('foo', '<f4'), ('bar', '<i8')])\n>>> ma.make_mask_none((3,), dtype=dtype)\narray([(False, False), (False, False), (False, False)],\n      dtype=[('foo', '|b1'), ('bar', '|b1')])"
      }
    },
    {
      "name": "mask_cols",
      "signature": "mask_cols(a, axis=<no value>)",
      "docstring": {
        "description": "Mask columns of a 2D array that contain masked values.\n\nThis function is a shortcut to ``mask_rowcols`` with `axis` equal to 1.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "mask_rowcols : Mask rows and/or columns of a 2D array.\nmasked_where : Mask where a condition is met.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.zeros((3, 3), dtype=int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n>>> a = ma.masked_equal(a, 1)\n>>> a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n>>> ma.mask_cols(a)\nmasked_array(\n  data=[[0, --, 0],\n        [0, --, 0],\n        [0, --, 0]],\n  mask=[[False,  True, False],\n        [False,  True, False],\n        [False,  True, False]],\n  fill_value=1)"
      }
    },
    {
      "name": "mask_or",
      "signature": "mask_or(m1, m2, copy=False, shrink=True)",
      "docstring": {
        "description": "Combine two masks with the ``logical_or`` operator.\n\nThe result may be a view on `m1` or `m2` if the other is `nomask`\n(i.e. False).",
        "parameters": {
          "copy": {
            "type": "bool, optional",
            "description": "If copy is False and one of the inputs is `nomask`, return a view\n    of the other input mask. Defaults to False."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to shrink the output to `nomask` if all its values are\n    False. Defaults to True."
          }
        },
        "returns": "mask : output mask\n    The result masks values that are masked in either `m1` or `m2`.",
        "raises": "ValueError\n    If `m1` and `m2` have different flexible dtypes.",
        "see_also": "",
        "notes": "",
        "examples": ">>> m1 = np.ma.make_mask([0, 1, 1, 0])\n>>> m2 = np.ma.make_mask([1, 0, 0, 0])\n>>> np.ma.mask_or(m1, m2)\narray([ True,  True,  True, False])"
      }
    },
    {
      "name": "mask_rowcols",
      "signature": "mask_rowcols(a, axis=None)",
      "docstring": {
        "description": "Mask rows and/or columns of a 2D array that contain masked values.\n\nMask whole rows and/or columns of a 2D array that contain\nmasked values.  The masking behavior is selected using the\n`axis` parameter.\n\n  - If `axis` is None, rows *and* columns are masked.\n  - If `axis` is 0, only rows are masked.\n  - If `axis` is 1 or -1, only columns are masked.",
        "parameters": {
          "a": {
            "type": "array_like, MaskedArray",
            "description": "The array to mask.  If not a MaskedArray instance (or if no array\n    elements are masked), the result is a MaskedArray with `mask` set\n    to `nomask` (False). Must be a 2D array."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to perform the operation. If None, applies to a\n    flattened version of the array."
          }
        },
        "returns": "a : MaskedArray\n    A modified version of the input array, masked depending on the value\n    of the `axis` parameter.",
        "raises": "NotImplementedError\n    If input array `a` is not 2D.",
        "see_also": "mask_rows : Mask rows of a 2D array that contain masked values.\nmask_cols : Mask cols of a 2D array that contain masked values.\nmasked_where : Mask where a condition is met.",
        "notes": "The input array's mask is modified by this function.",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.zeros((3, 3), dtype=int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n>>> a = ma.masked_equal(a, 1)\n>>> a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n>>> ma.mask_rowcols(a)\nmasked_array(\n  data=[[0, --, 0],\n        [--, --, --],\n        [0, --, 0]],\n  mask=[[False,  True, False],\n        [ True,  True,  True],\n        [False,  True, False]],\n  fill_value=1)"
      }
    },
    {
      "name": "mask_rows",
      "signature": "mask_rows(a, axis=<no value>)",
      "docstring": {
        "description": "Mask rows of a 2D array that contain masked values.\n\nThis function is a shortcut to ``mask_rowcols`` with `axis` equal to 0.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "mask_rowcols : Mask rows and/or columns of a 2D array.\nmasked_where : Mask where a condition is met.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.zeros((3, 3), dtype=int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n>>> a = ma.masked_equal(a, 1)\n>>> a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n\n>>> ma.mask_rows(a)\nmasked_array(\n  data=[[0, 0, 0],\n        [--, --, --],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [ True,  True,  True],\n        [False, False, False]],\n  fill_value=1)"
      }
    },
    {
      "name": "masked_all",
      "signature": "masked_all(shape, dtype=<class 'float'>)",
      "docstring": {
        "description": "Empty masked array with all elements masked.\n\nReturn an empty masked array of the given shape and dtype, where all the\ndata are masked.",
        "parameters": {
          "shape": {
            "type": "int or tuple of ints",
            "description": "Shape of the required MaskedArray, e.g., ``(2, 3)`` or ``2``."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Data type of the output."
          }
        },
        "returns": "a : MaskedArray\n    A masked array with all data masked.",
        "raises": "",
        "see_also": "masked_all_like : Empty masked array modelled on an existing array.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> ma.masked_all((3, 3))\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=1e+20,\n  dtype=float64)\n\nThe `dtype` parameter defines the underlying data type.\n\n>>> a = ma.masked_all((3, 3))\n>>> a.dtype\ndtype('float64')\n>>> a = ma.masked_all((3, 3), dtype=np.int32)\n>>> a.dtype\ndtype('int32')"
      }
    },
    {
      "name": "masked_all_like",
      "signature": "masked_all_like(arr)",
      "docstring": {
        "description": "Empty masked array with the properties of an existing array.\n\nReturn an empty masked array of the same shape and dtype as\nthe array `arr`, where all the data are masked.",
        "parameters": {
          "arr": {
            "type": "ndarray",
            "description": "An array describing the shape and dtype of the required MaskedArray."
          }
        },
        "returns": "a : MaskedArray\n    A masked array with all data masked.",
        "raises": "AttributeError\n    If `arr` doesn't have a shape attribute (i.e. not an ndarray)",
        "see_also": "masked_all : Empty masked array with all elements masked.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> arr = np.zeros((2, 3), dtype=np.float32)\n>>> arr\narray([[0., 0., 0.],\n       [0., 0., 0.]], dtype=float32)\n>>> ma.masked_all_like(arr)\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=1e+20,\n  dtype=float32)\n\nThe dtype of the masked array matches the dtype of `arr`.\n\n>>> arr.dtype\ndtype('float32')\n>>> ma.masked_all_like(arr).dtype\ndtype('float32')"
      }
    },
    {
      "name": "masked_array",
      "signature": "MaskedArray(data=None, mask=False, dtype=None, copy=False, subok=True, ndmin=0, fill_value=None, keep_mask=True, hard_mask=None, shrink=True, order=None)",
      "docstring": {
        "description": "An array class with possibly masked values.\n\nMasked values of True exclude the corresponding element from any\ncomputation.\n\nConstruction::\n\n  x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\n                  ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\n                  shrink=True, order=None)",
        "parameters": {
          "data": {
            "type": "array_like",
            "description": "Input data."
          },
          "mask": {
            "type": "sequence, optional",
            "description": "Mask. Must be convertible to an array of booleans with the same\n    shape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Data type of the output.\n    If `dtype` is None, the type of the data argument (``data.dtype``)\n    is used. If `dtype` is not None and different from ``data.dtype``,\n    a copy is performed."
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to copy the input data (True), or to use a reference instead.\n    Default is False."
          },
          "subok": {
            "type": "bool, optional",
            "description": "Whether to return a subclass of `MaskedArray` if possible (True) or a\n    plain `MaskedArray`. Default is True."
          },
          "ndmin": {
            "type": "int, optional",
            "description": "Minimum number of dimensions. Default is 0."
          },
          "fill_value": {
            "type": "scalar, optional",
            "description": "Value used to fill in the masked values when necessary.\n    If None, a default based on the data-type is used."
          },
          "keep_mask": {
            "type": "bool, optional",
            "description": "Whether to combine `mask` with the mask of the input data, if any\n    (True), or to use only `mask` for the output (False). Default is True."
          },
          "hard_mask": {
            "type": "bool, optional",
            "description": "Whether to use a hard mask or not. With a hard mask, masked values\n    cannot be unmasked. Default is False."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to force compression of an empty mask. Default is True."
          },
          "order": {
            "type": "{'C', 'F', 'A'}, optional",
            "description": "Specify the order of the array.  If order is 'C', then the array\n    will be in C-contiguous order (last-index varies the fastest).\n    If order is 'F', then the returned array will be in\n    Fortran-contiguous order (first-index varies the fastest).\n    If order is 'A' (default), then the returned array may be\n    in any order (either C-, Fortran-contiguous, or even discontiguous),\n    unless a copy is required, in which case it will be C-contiguous."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "The ``mask`` can be initialized with an array of boolean values\nwith the same shape as ``data``.\n\n>>> data = np.arange(6).reshape((2, 3))\n>>> np.ma.MaskedArray(data, mask=[[False, True, False],\n...                               [False, False, True]])\nmasked_array(\n  data=[[0, --, 2],\n        [3, 4, --]],\n  mask=[[False,  True, False],\n        [False, False,  True]],\n  fill_value=999999)\n\nAlternatively, the ``mask`` can be initialized to homogeneous boolean\narray with the same shape as ``data`` by passing in a scalar\nboolean value:\n\n>>> np.ma.MaskedArray(data, mask=False)\nmasked_array(\n  data=[[0, 1, 2],\n        [3, 4, 5]],\n  mask=[[False, False, False],\n        [False, False, False]],\n  fill_value=999999)\n\n>>> np.ma.MaskedArray(data, mask=True)\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=999999,\n  dtype=int64)\n\n.. note::\n    The recommended practice for initializing ``mask`` with a scalar\n    boolean value is to use ``True``/``False`` rather than\n    ``np.True_``/``np.False_``. The reason is :attr:`nomask`\n    is represented internally as ``np.False_``.\n\n    >>> np.False_ is np.ma.nomask\n    True"
      }
    },
    {
      "name": "masked_equal",
      "signature": "masked_equal(x, value, copy=True)",
      "docstring": {
        "description": "Mask an array where equal to a given value.\n\nReturn a MaskedArray, masked where the data in array `x` are\nequal to `value`. The fill_value of the returned MaskedArray\nis set to `value`.\n\nFor floating point arrays, consider using ``masked_values(x, value)``.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "masked_where : Mask where a condition is met.\nmasked_values : Mask using floating point equality.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_equal(a, 2)\nmasked_array(data=[0, 1, --, 3],\n             mask=[False, False,  True, False],\n       fill_value=2)"
      }
    },
    {
      "name": "masked_greater",
      "signature": "masked_greater(x, value, copy=True)",
      "docstring": {
        "description": "Mask an array where greater than a given value.\n\nThis function is a shortcut to ``masked_where``, with\n`condition` = (x > value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "masked_where : Mask where a condition is met.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_greater(a, 2)\nmasked_array(data=[0, 1, 2, --],\n             mask=[False, False, False,  True],\n       fill_value=999999)"
      }
    },
    {
      "name": "masked_greater_equal",
      "signature": "masked_greater_equal(x, value, copy=True)",
      "docstring": {
        "description": "Mask an array where greater than or equal to a given value.\n\nThis function is a shortcut to ``masked_where``, with\n`condition` = (x >= value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "masked_where : Mask where a condition is met.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_greater_equal(a, 2)\nmasked_array(data=[0, 1, --, --],\n             mask=[False, False,  True,  True],\n       fill_value=999999)"
      }
    },
    {
      "name": "masked_inside",
      "signature": "masked_inside(x, v1, v2, copy=True)",
      "docstring": {
        "description": "Mask an array inside a given interval.\n\nShortcut to ``masked_where``, where `condition` is True for `x` inside\nthe interval [v1,v2] (v1 <= x <= v2).  The boundaries `v1` and `v2`\ncan be given in either order.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "masked_where : Mask where a condition is met.",
        "notes": "The array `x` is prefilled with its filling value.",
        "examples": ">>> import numpy.ma as ma\n>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n>>> ma.masked_inside(x, -0.3, 0.3)\nmasked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n             mask=[False, False,  True,  True, False, False],\n       fill_value=1e+20)\n\nThe order of `v1` and `v2` doesn't matter.\n\n>>> ma.masked_inside(x, 0.3, -0.3)\nmasked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n             mask=[False, False,  True,  True, False, False],\n       fill_value=1e+20)"
      }
    },
    {
      "name": "masked_invalid",
      "signature": "masked_invalid(a, copy=True)",
      "docstring": {
        "description": "Mask an array where invalid values occur (NaNs or infs).\n\nThis function is a shortcut to ``masked_where``, with\n`condition` = ~(np.isfinite(a)). Any pre-existing mask is conserved.\nOnly applies to arrays with a dtype where NaNs or infs make sense\n(i.e. floating point types), but accepts any array_like object.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "masked_where : Mask where a condition is met.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.arange(5, dtype=float)\n>>> a[2] = np.NaN\n>>> a[3] = np.PINF\n>>> a\narray([ 0.,  1., nan, inf,  4.])\n>>> ma.masked_invalid(a)\nmasked_array(data=[0.0, 1.0, --, --, 4.0],\n             mask=[False, False,  True,  True, False],\n       fill_value=1e+20)"
      }
    },
    {
      "name": "masked_less",
      "signature": "masked_less(x, value, copy=True)",
      "docstring": {
        "description": "Mask an array where less than a given value.\n\nThis function is a shortcut to ``masked_where``, with\n`condition` = (x < value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "masked_where : Mask where a condition is met.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_less(a, 2)\nmasked_array(data=[--, --, 2, 3],\n             mask=[ True,  True, False, False],\n       fill_value=999999)"
      }
    },
    {
      "name": "masked_less_equal",
      "signature": "masked_less_equal(x, value, copy=True)",
      "docstring": {
        "description": "Mask an array where less than or equal to a given value.\n\nThis function is a shortcut to ``masked_where``, with\n`condition` = (x <= value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "masked_where : Mask where a condition is met.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_less_equal(a, 2)\nmasked_array(data=[--, --, --, 3],\n             mask=[ True,  True,  True, False],\n       fill_value=999999)"
      }
    },
    {
      "name": "masked_not_equal",
      "signature": "masked_not_equal(x, value, copy=True)",
      "docstring": {
        "description": "Mask an array where `not` equal to a given value.\n\nThis function is a shortcut to ``masked_where``, with\n`condition` = (x != value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "masked_where : Mask where a condition is met.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_not_equal(a, 2)\nmasked_array(data=[--, --, 2, --],\n             mask=[ True,  True, False,  True],\n       fill_value=999999)"
      }
    },
    {
      "name": "masked_object",
      "signature": "masked_object(x, value, copy=True, shrink=True)",
      "docstring": {
        "description": "Mask the array `x` where the data are exactly equal to value.\n\nThis function is similar to `masked_values`, but only suitable\nfor object arrays: for floating point, use `masked_values` instead.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Array to mask"
          },
          "value": {
            "type": "object",
            "description": "Comparison value"
          },
          "copy": {
            "type": "{True, False}, optional",
            "description": "Whether to return a copy of `x`."
          },
          "shrink": {
            "type": "{True, False}, optional",
            "description": "Whether to collapse a mask full of False to nomask"
          }
        },
        "returns": "result : MaskedArray\n    The result of masking `x` where equal to `value`.",
        "raises": "",
        "see_also": "masked_where : Mask where a condition is met.\nmasked_equal : Mask where equal to a given value (integers).\nmasked_values : Mask using floating point equality.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> food = np.array(['green_eggs', 'ham'], dtype=object)\n>>> # don't eat spoiled food\n>>> eat = ma.masked_object(food, 'green_eggs')\n>>> eat\nmasked_array(data=[--, 'ham'],\n             mask=[ True, False],\n       fill_value='green_eggs',\n            dtype=object)\n>>> # plain ol` ham is boring\n>>> fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)\n>>> eat = ma.masked_object(fresh_food, 'green_eggs')\n>>> eat\nmasked_array(data=['cheese', 'ham', 'pineapple'],\n             mask=False,\n       fill_value='green_eggs',\n            dtype=object)\n\nNote that `mask` is set to ``nomask`` if possible.\n\n>>> eat\nmasked_array(data=['cheese', 'ham', 'pineapple'],\n             mask=False,\n       fill_value='green_eggs',\n            dtype=object)"
      }
    },
    {
      "name": "masked_outside",
      "signature": "masked_outside(x, v1, v2, copy=True)",
      "docstring": {
        "description": "Mask an array outside a given interval.\n\nShortcut to ``masked_where``, where `condition` is True for `x` outside\nthe interval [v1,v2] (x < v1)|(x > v2).\nThe boundaries `v1` and `v2` can be given in either order.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "masked_where : Mask where a condition is met.",
        "notes": "The array `x` is prefilled with its filling value.",
        "examples": ">>> import numpy.ma as ma\n>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n>>> ma.masked_outside(x, -0.3, 0.3)\nmasked_array(data=[--, --, 0.01, 0.2, --, --],\n             mask=[ True,  True, False, False,  True,  True],\n       fill_value=1e+20)\n\nThe order of `v1` and `v2` doesn't matter.\n\n>>> ma.masked_outside(x, 0.3, -0.3)\nmasked_array(data=[--, --, 0.01, 0.2, --, --],\n             mask=[ True,  True, False, False,  True,  True],\n       fill_value=1e+20)"
      }
    },
    {
      "name": "masked_values",
      "signature": "masked_values(x, value, rtol=1e-05, atol=1e-08, copy=True, shrink=True)",
      "docstring": {
        "description": "Mask using floating point equality.\n\nReturn a MaskedArray, masked where the data in array `x` are approximately\nequal to `value`, determined using `isclose`. The default tolerances for\n`masked_values` are the same as those for `isclose`.\n\nFor integer types, exact equality is used, in the same way as\n`masked_equal`.\n\nThe fill_value is set to `value` and the mask is set to ``nomask`` if\npossible.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Array to mask."
          },
          "value": {
            "type": "float",
            "description": "Masking value.\nrtol, atol : float, optional\n    Tolerance parameters passed on to `isclose`"
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to return a copy of `x`."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to collapse a mask full of False to ``nomask``."
          }
        },
        "returns": "result : MaskedArray\n    The result of masking `x` where approximately equal to `value`.",
        "raises": "",
        "see_also": "masked_where : Mask where a condition is met.\nmasked_equal : Mask where equal to a given value (integers).",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> x = np.array([1, 1.1, 2, 1.1, 3])\n>>> ma.masked_values(x, 1.1)\nmasked_array(data=[1.0, --, 2.0, --, 3.0],\n             mask=[False,  True, False,  True, False],\n       fill_value=1.1)\n\nNote that `mask` is set to ``nomask`` if possible.\n\n>>> ma.masked_values(x, 2.1)\nmasked_array(data=[1. , 1.1, 2. , 1.1, 3. ],\n             mask=False,\n       fill_value=2.1)\n\nUnlike `masked_equal`, `masked_values` can perform approximate equalities.\n\n>>> ma.masked_values(x, 2.1, atol=1e-1)\nmasked_array(data=[1.0, 1.1, --, 1.1, 3.0],\n             mask=[False, False,  True, False, False],\n       fill_value=2.1)"
      }
    },
    {
      "name": "masked_where",
      "signature": "masked_where(condition, a, copy=True)",
      "docstring": {
        "description": "Mask an array where a condition is met.\n\nReturn `a` as an array masked where `condition` is True.\nAny masked values of `a` or `condition` are also masked in the output.",
        "parameters": {
          "condition": {
            "type": "array_like",
            "description": "Masking condition.  When `condition` tests floating point values for\n    equality, consider using ``masked_values`` instead."
          },
          "a": {
            "type": "array_like",
            "description": "Array to mask."
          },
          "copy": {
            "type": "bool",
            "description": "If True (default) make a copy of `a` in the result.  If False modify\n    `a` in place and return a view."
          }
        },
        "returns": "result : MaskedArray\n    The result of masking `a` where `condition` is True.",
        "raises": "",
        "see_also": "masked_values : Mask using floating point equality.\nmasked_equal : Mask where equal to a given value.\nmasked_not_equal : Mask where `not` equal to a given value.\nmasked_less_equal : Mask where less than or equal to a given value.\nmasked_greater_equal : Mask where greater than or equal to a given value.\nmasked_less : Mask where less than a given value.\nmasked_greater : Mask where greater than a given value.\nmasked_inside : Mask inside a given interval.\nmasked_outside : Mask outside a given interval.\nmasked_invalid : Mask invalid values (NaNs or infs).",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_where(a <= 2, a)\nmasked_array(data=[--, --, --, 3],\n             mask=[ True,  True,  True, False],\n       fill_value=999999)\n\nMask array `b` conditional on `a`.\n\n>>> b = ['a', 'b', 'c', 'd']\n>>> ma.masked_where(a == 2, b)\nmasked_array(data=['a', 'b', --, 'd'],\n             mask=[False, False,  True, False],\n       fill_value='N/A',\n            dtype='<U1')\n\nEffect of the `copy` argument.\n\n>>> c = ma.masked_where(a <= 2, a)\n>>> c\nmasked_array(data=[--, --, --, 3],\n             mask=[ True,  True,  True, False],\n       fill_value=999999)\n>>> c[0] = 99\n>>> c\nmasked_array(data=[99, --, --, 3],\n             mask=[False,  True,  True, False],\n       fill_value=999999)\n>>> a\narray([0, 1, 2, 3])\n>>> c = ma.masked_where(a <= 2, a, copy=False)\n>>> c[0] = 99\n>>> c\nmasked_array(data=[99, --, --, 3],\n             mask=[False,  True,  True, False],\n       fill_value=999999)\n>>> a\narray([99,  1,  2,  3])\n\nWhen `condition` or `a` contain masked values.\n\n>>> a = np.arange(4)\n>>> a = ma.masked_where(a == 2, a)\n>>> a\nmasked_array(data=[0, 1, --, 3],\n             mask=[False, False,  True, False],\n       fill_value=999999)\n>>> b = np.arange(4)\n>>> b = ma.masked_where(b == 0, b)\n>>> b\nmasked_array(data=[--, 1, 2, 3],\n             mask=[ True, False, False, False],\n       fill_value=999999)\n>>> ma.masked_where(a == 3, b)\nmasked_array(data=[--, 1, --, --],\n             mask=[ True, False,  True,  True],\n       fill_value=999999)"
      }
    },
    {
      "name": "max",
      "signature": "max(obj, axis=None, out=None, fill_value=None, keepdims=<no value>)",
      "docstring": {
        "description": "Return the maximum along a given axis.",
        "parameters": {
          "axis": {
            "type": "None or int or tuple of ints, optional",
            "description": "Axis along which to operate.  By default, ``axis`` is None and the\n    flattened input is used.\n    .. versionadded:: 1.7.0\n    If this is a tuple of ints, the maximum is selected over multiple\n    axes, instead of a single axis or all the axes as before."
          },
          "out": {
            "type": "array_like, optional",
            "description": "Alternative output array in which to place the result.  Must\n    be of the same shape and buffer length as the expected output."
          },
          "fill_value": {
            "type": "scalar or None, optional",
            "description": "Value used to fill in the masked values.\n    If None, use the output of maximum_fill_value()."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
          }
        },
        "returns": "amax : array_like\n    New array holding the result.\n    If ``out`` was specified, ``out`` is returned.",
        "raises": "",
        "see_also": "ma.maximum_fill_value\n    Returns the maximum filling value for a given datatype.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> x = [[-1., 2.5], [4., -2.], [3., 0.]]\n>>> mask = [[0, 0], [1, 0], [1, 0]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\n  data=[[-1.0, 2.5],\n        [--, -2.0],\n        [--, 0.0]],\n  mask=[[False, False],\n        [ True, False],\n        [ True, False]],\n  fill_value=1e+20)\n>>> ma.max(masked_x)\n2.5\n>>> ma.max(masked_x, axis=0)\nmasked_array(data=[-1.0, 2.5],\n             mask=[False, False],\n       fill_value=1e+20)\n>>> ma.max(masked_x, axis=1, keepdims=True)\nmasked_array(\n  data=[[2.5],\n        [-2.0],\n        [0.0]],\n  mask=[[False],\n        [False],\n        [False]],\n  fill_value=1e+20)\n>>> mask = [[1, 1], [1, 1], [1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.max(masked_x, axis=1)\nmasked_array(data=[--, --, --],\n             mask=[ True,  True,  True],\n       fill_value=1e+20,\n            dtype=float64)"
      }
    },
    {
      "name": "maximum",
      "signature": "maximum(a, b)",
      "docstring": {
        "description": "maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise maximum of array elements.\n\nCompare two arrays and return a new array containing the element-wise\nmaxima. If one of the elements being compared is a NaN, then that\nelement is returned. If both elements are NaNs then the first is\nreturned. The latter distinction is important for complex NaNs, which\nare defined as at least one of the real or imaginary parts being a NaN.\nThe net effect is that NaNs are propagated.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray or scalar\n    The maximum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "minimum :\n    Element-wise minimum of two arrays, propagates NaNs.\nfmax :\n    Element-wise maximum of two arrays, ignores NaNs.\namax :\n    The maximum value of an array along a given axis, propagates NaNs.\nnanmax :\n    The maximum value of an array along a given axis, ignores NaNs.\n\nfmin, amin, nanmin",
        "notes": "The maximum is equivalent to ``np.where(x1 >= x2, x1, x2)`` when\nneither x1 nor x2 are nans, but it is faster and does proper\nbroadcasting.",
        "examples": ">>> np.maximum([2, 3, 4], [1, 5, 2])\narray([2, 5, 4])\n\n>>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 1. ,  2. ],\n       [ 0.5,  2. ]])\n\n>>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])\narray([nan, nan, nan])\n>>> np.maximum(np.Inf, 1)\ninf"
      }
    },
    {
      "name": "maximum_fill_value",
      "signature": "maximum_fill_value(obj)",
      "docstring": {
        "description": "Return the minimum value that can be represented by the dtype of an object.\n\nThis function is useful for calculating a fill value suitable for\ntaking the maximum of an array with a given dtype.",
        "parameters": {
          "obj": {
            "type": "ndarray, dtype or scalar",
            "description": "An object that can be queried for it's numeric type."
          }
        },
        "returns": "val : scalar\n    The minimum representable value.",
        "raises": "TypeError\n    If `obj` isn't a suitable numeric type.",
        "see_also": "minimum_fill_value : The inverse function.\nset_fill_value : Set the filling value of a masked array.\nMaskedArray.fill_value : Return current fill value.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.int8()\n>>> ma.maximum_fill_value(a)\n-128\n>>> a = np.int32()\n>>> ma.maximum_fill_value(a)\n-2147483648\n\nAn array of numeric data can also be passed.\n\n>>> a = np.array([1, 2, 3], dtype=np.int8)\n>>> ma.maximum_fill_value(a)\n-128\n>>> a = np.array([1, 2, 3], dtype=np.float32)\n>>> ma.maximum_fill_value(a)\n-inf"
      }
    },
    {
      "name": "mean",
      "signature": "mean(a, *args, **params)",
      "docstring": {
        "description": "mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)\n\nReturns the average of the array elements along given axis.\n\nMasked entries are ignored, and result elements which are not\nfinite will be masked.\n\nRefer to `numpy.mean` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.ndarray.mean : corresponding function for ndarrays\nnumpy.mean : Equivalent function\nnumpy.ma.average : Weighted average.",
        "notes": "",
        "examples": ">>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data=[1, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n>>> a.mean()\n1.5"
      }
    },
    {
      "name": "median",
      "signature": "median(a, axis=None, out=None, overwrite_input=False, keepdims=False)",
      "docstring": {
        "description": "Compute the median along the specified axis.\n\nReturns the median of the array elements.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array or object that can be converted to an array."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which the medians are computed. The default (None) is\n    to compute the median along a flattened version of the array."
          },
          "out": {
            "type": "ndarray, optional",
            "description": "Alternative output array in which to place the result. It must\n    have the same shape and buffer length as the expected output\n    but the type will be cast if necessary."
          },
          "overwrite_input": {
            "type": "bool, optional",
            "description": "If True, then allow use of memory of input array (a) for\n    calculations. The input array will be modified by the call to\n    median. This will save memory when you do not need to preserve\n    the contents of the input array. Treat the input as undefined,\n    but it will probably be fully or partially sorted. Default is\n    False. Note that, if `overwrite_input` is True, and the input\n    is not already an `ndarray`, an error will be raised."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the input array.\n\n    .. versionadded:: 1.10.0"
          }
        },
        "returns": "median : ndarray\n    A new array holding the result is returned unless out is\n    specified, in which case a reference to out is returned.\n    Return data-type is `float64` for integers and floats smaller than\n    `float64`, or the input data-type, otherwise.",
        "raises": "",
        "see_also": "mean",
        "notes": "Given a vector ``V`` with ``N`` non masked values, the median of ``V``\nis the middle value of a sorted copy of ``V`` (``Vs``) - i.e.\n``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2``\nwhen ``N`` is even.",
        "examples": ">>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)\n>>> np.ma.median(x)\n1.5\n\n>>> x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)\n>>> np.ma.median(x)\n2.5\n>>> np.ma.median(x, axis=-1, overwrite_input=True)\nmasked_array(data=[2.0, 5.0],\n             mask=[False, False],\n       fill_value=1e+20)"
      }
    },
    {
      "name": "min",
      "signature": "min(obj, axis=None, out=None, fill_value=None, keepdims=<no value>)",
      "docstring": {
        "description": "Return the minimum along a given axis.",
        "parameters": {
          "axis": {
            "type": "None or int or tuple of ints, optional",
            "description": "Axis along which to operate.  By default, ``axis`` is None and the\n    flattened input is used.\n    .. versionadded:: 1.7.0\n    If this is a tuple of ints, the minimum is selected over multiple\n    axes, instead of a single axis or all the axes as before."
          },
          "out": {
            "type": "array_like, optional",
            "description": "Alternative output array in which to place the result.  Must be of\n    the same shape and buffer length as the expected output."
          },
          "fill_value": {
            "type": "scalar or None, optional",
            "description": "Value used to fill in the masked values.\n    If None, use the output of `minimum_fill_value`."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
          }
        },
        "returns": "amin : array_like\n    New array holding the result.\n    If ``out`` was specified, ``out`` is returned.",
        "raises": "",
        "see_also": "ma.minimum_fill_value\n    Returns the minimum filling value for a given datatype.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> x = [[1., -2., 3.], [0.2, -0.7, 0.1]]\n>>> mask = [[1, 1, 0], [0, 0, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\n  data=[[--, --, 3.0],\n        [0.2, -0.7, --]],\n  mask=[[ True,  True, False],\n        [False, False,  True]],\n  fill_value=1e+20)\n>>> ma.min(masked_x)\n-0.7\n>>> ma.min(masked_x, axis=-1)\nmasked_array(data=[3.0, -0.7],\n             mask=[False, False],\n        fill_value=1e+20)\n>>> ma.min(masked_x, axis=0, keepdims=True)\nmasked_array(data=[[0.2, -0.7, 3.0]],\n             mask=[[False, False, False]],\n        fill_value=1e+20)\n>>> mask = [[1, 1, 1,], [1, 1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.min(masked_x, axis=0)\nmasked_array(data=[--, --, --],\n             mask=[ True,  True,  True],\n        fill_value=1e+20,\n            dtype=float64)"
      }
    },
    {
      "name": "minimum",
      "signature": "minimum(a, b)",
      "docstring": {
        "description": "minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise minimum of array elements.\n\nCompare two arrays and return a new array containing the element-wise\nminima. If one of the elements being compared is a NaN, then that\nelement is returned. If both elements are NaNs then the first is\nreturned. The latter distinction is important for complex NaNs, which\nare defined as at least one of the real or imaginary parts being a NaN.\nThe net effect is that NaNs are propagated.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray or scalar\n    The minimum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "maximum :\n    Element-wise maximum of two arrays, propagates NaNs.\nfmin :\n    Element-wise minimum of two arrays, ignores NaNs.\namin :\n    The minimum value of an array along a given axis, propagates NaNs.\nnanmin :\n    The minimum value of an array along a given axis, ignores NaNs.\n\nfmax, amax, nanmax",
        "notes": "The minimum is equivalent to ``np.where(x1 <= x2, x1, x2)`` when\nneither x1 nor x2 are NaNs, but it is faster and does proper\nbroadcasting.",
        "examples": ">>> np.minimum([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n\n>>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 0.5,  0. ],\n       [ 0. ,  1. ]])\n\n>>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([nan, nan, nan])\n>>> np.minimum(-np.Inf, 1)\n-inf"
      }
    },
    {
      "name": "minimum_fill_value",
      "signature": "minimum_fill_value(obj)",
      "docstring": {
        "description": "Return the maximum value that can be represented by the dtype of an object.\n\nThis function is useful for calculating a fill value suitable for\ntaking the minimum of an array with a given dtype.",
        "parameters": {
          "obj": {
            "type": "ndarray, dtype or scalar",
            "description": "An object that can be queried for it's numeric type."
          }
        },
        "returns": "val : scalar\n    The maximum representable value.",
        "raises": "TypeError\n    If `obj` isn't a suitable numeric type.",
        "see_also": "maximum_fill_value : The inverse function.\nset_fill_value : Set the filling value of a masked array.\nMaskedArray.fill_value : Return current fill value.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.int8()\n>>> ma.minimum_fill_value(a)\n127\n>>> a = np.int32()\n>>> ma.minimum_fill_value(a)\n2147483647\n\nAn array of numeric data can also be passed.\n\n>>> a = np.array([1, 2, 3], dtype=np.int8)\n>>> ma.minimum_fill_value(a)\n127\n>>> a = np.array([1, 2, 3], dtype=np.float32)\n>>> ma.minimum_fill_value(a)\ninf"
      }
    },
    {
      "name": "mod",
      "signature": "remainder(a, b, *args, **kwargs)",
      "docstring": {
        "description": "remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns the element-wise remainder of division.\n\nComputes the remainder complementary to the `floor_divide` function.  It is\nequivalent to the Python modulus operator``x1 % x2`` and has the same sign\nas the divisor `x2`. The MATLAB function equivalent to ``np.remainder``\nis ``mod``.\n\n.. warning::\n\n    This should not be confused with:\n\n    * Python 3.7's `math.remainder` and C's ``remainder``, which\n      computes the IEEE remainder, which are the complement to\n      ``round(x1 / x2)``.\n    * The MATLAB ``rem`` function and or the C ``%`` operator which is the\n      complement to ``int(x1 / x2)``.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend array."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor array.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "floor_divide : Equivalent of Python ``//`` operator.\ndivmod : Simultaneous floor division and remainder.\nfmod : Equivalent of the MATLAB ``rem`` function.\ndivide, floor",
        "notes": "Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)\nintegers.\n``mod`` is an alias of ``remainder``.",
        "examples": ">>> np.remainder([4, 7], [2, 3])\narray([0, 1])\n>>> np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])\n\nThe ``%`` operator can be used as a shorthand for ``np.remainder`` on\nndarrays.\n\n>>> x1 = np.arange(7)\n>>> x1 % 5\narray([0, 1, 2, 3, 4, 0, 1])"
      }
    },
    {
      "name": "multiply",
      "signature": "multiply(a, b, *args, **kwargs)",
      "docstring": {
        "description": "multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nMultiply arguments element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    The product of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "",
        "notes": "Equivalent to `x1` * `x2` in terms of array broadcasting.",
        "examples": ">>> np.multiply(2.0, 4.0)\n8.0\n\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.multiply(x1, x2)\narray([[  0.,   1.,   4.],\n       [  0.,   4.,  10.],\n       [  0.,   7.,  16.]])\n\nThe ``*`` operator can be used as a shorthand for ``np.multiply`` on\nndarrays.\n\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> x1 * x2\narray([[  0.,   1.,   4.],\n       [  0.,   4.,  10.],\n       [  0.,   7.,  16.]])"
      }
    },
    {
      "name": "mvoid",
      "signature": "mvoid(data, mask=False, dtype=None, fill_value=None, hardmask=False, copy=False, subok=True)",
      "docstring": {
        "description": "Fake a 'void' object to use for masked array with structured dtypes.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ndenumerate",
      "signature": "ndenumerate(a, compressed=True)",
      "docstring": {
        "description": "Multidimensional index iterator.\n\nReturn an iterator yielding pairs of array coordinates and values,\nskipping elements that are masked. With `compressed=False`,\n`ma.masked` is yielded as the value of masked elements. This\nbehavior differs from that of `numpy.ndenumerate`, which yields the\nvalue of the underlying data array.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "An array with (possibly) masked elements."
          },
          "compressed": {
            "type": "bool, optional",
            "description": "If True (default), masked elements are skipped."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "numpy.ndenumerate : Equivalent function ignoring any mask.",
        "notes": ".. versionadded:: 1.23.0",
        "examples": ">>> a = np.ma.arange(9).reshape((3, 3))\n>>> a[1, 0] = np.ma.masked\n>>> a[1, 2] = np.ma.masked\n>>> a[2, 1] = np.ma.masked\n>>> a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, 4, --],\n        [6, --, 8]],\n  mask=[[False, False, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> for index, x in np.ma.ndenumerate(a):\n...     print(index, x)\n(0, 0) 0\n(0, 1) 1\n(0, 2) 2\n(1, 1) 4\n(2, 0) 6\n(2, 2) 8\n\n>>> for index, x in np.ma.ndenumerate(a, compressed=False):\n...     print(index, x)\n(0, 0) 0\n(0, 1) 1\n(0, 2) 2\n(1, 0) --\n(1, 1) 4\n(1, 2) --\n(2, 0) 6\n(2, 1) --\n(2, 2) 8"
      }
    },
    {
      "name": "ndim",
      "signature": "ndim(obj)",
      "docstring": {
        "description": "Return the number of dimensions of an array.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array.  If it is not already an ndarray, a conversion is\n    attempted."
          }
        },
        "returns": "number_of_dimensions : int\n    The number of dimensions in `a`.  Scalars are zero-dimensional.",
        "raises": "",
        "see_also": "ndarray.ndim : equivalent method\nshape : dimensions of array\nndarray.shape : dimensions of array",
        "notes": "",
        "examples": ">>> np.ndim([[1,2,3],[4,5,6]])\n2\n>>> np.ndim(np.array([[1,2,3],[4,5,6]]))\n2\n>>> np.ndim(1)\n0"
      }
    },
    {
      "name": "negative",
      "signature": "negative(a, *args, **kwargs)",
      "docstring": {
        "description": "negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nNumerical negative, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like or scalar",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray or scalar\n    Returned array or scalar: `y = -x`.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> np.negative([1.,-1.])\narray([-1.,  1.])\n\nThe unary ``-`` operator can be used as a shorthand for ``np.negative`` on\nndarrays.\n\n>>> x1 = np.array(([1., -1.]))\n>>> -x1\narray([-1.,  1.])"
      }
    },
    {
      "name": "nonzero",
      "signature": "nonzero(a, *args, **params)",
      "docstring": {
        "description": "nonzero(self)\n\nReturn the indices of unmasked elements that are not zero.\n\nReturns a tuple of arrays, one for each dimension, containing the\nindices of the non-zero elements in that dimension. The corresponding\nnon-zero values can be obtained with::\n\n    a[a.nonzero()]\n\nTo group the indices by element, rather than dimension, use\ninstead::\n\n    np.transpose(a.nonzero())\n\nThe result of this is always a 2d array, with a row for each non-zero\nelement.",
        "parameters": {},
        "returns": "tuple_of_arrays : tuple\n    Indices of elements that are non-zero.",
        "raises": "",
        "see_also": "numpy.nonzero :\n    Function operating on ndarrays.\nflatnonzero :\n    Return indices that are non-zero in the flattened version of the input\n    array.\nnumpy.ndarray.nonzero :\n    Equivalent ndarray method.\ncount_nonzero :\n    Counts the number of non-zero elements in the input array.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> x = ma.array(np.eye(3))\n>>> x\nmasked_array(\n  data=[[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]],\n  mask=False,\n  fill_value=1e+20)\n>>> x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\n\nMasked elements are ignored.\n\n>>> x[1, 1] = ma.masked\n>>> x\nmasked_array(\n  data=[[1.0, 0.0, 0.0],\n        [0.0, --, 0.0],\n        [0.0, 0.0, 1.0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1e+20)\n>>> x.nonzero()\n(array([0, 2]), array([0, 2]))\n\nIndices can also be grouped by element.\n\n>>> np.transpose(x.nonzero())\narray([[0, 0],\n       [2, 2]])\n\nA common use for ``nonzero`` is to find the indices of an array, where\na condition is True.  Given an array `a`, the condition `a` > 3 is a\nboolean array and since False is interpreted as 0, ma.nonzero(a > 3)\nyields the indices of the `a` where the condition is true.\n\n>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n>>> a > 3\nmasked_array(\n  data=[[False, False, False],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  mask=False,\n  fill_value=True)\n>>> ma.nonzero(a > 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\nThe ``nonzero`` method of the condition array can also be called.\n\n>>> (a > 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))"
      }
    },
    {
      "name": "not_equal",
      "signature": "not_equal(a, b, *args, **kwargs)",
      "docstring": {
        "description": "not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn (x1 != x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "out : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "equal, greater, greater_equal, less, less_equal",
        "notes": "",
        "examples": ">>> np.not_equal([1.,2.], [1., 3.])\narray([False,  True])\n>>> np.not_equal([1, 2], [[1, 3],[1, 4]])\narray([[False,  True],\n       [False,  True]])\n\nThe ``!=`` operator can be used as a shorthand for ``np.not_equal`` on\nndarrays.\n\n>>> a = np.array([1., 2.])\n>>> b = np.array([1., 3.])\n>>> a != b\narray([False,  True])"
      }
    },
    {
      "name": "notmasked_contiguous",
      "signature": "notmasked_contiguous(a, axis=None)",
      "docstring": {
        "description": "Find contiguous unmasked data in a masked array along the given axis.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "The input array."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to perform the operation.\n    If None (default), applies to a flattened version of the array, and this\n    is the same as `flatnotmasked_contiguous`."
          }
        },
        "returns": "endpoints : list\n    A list of slices (start and end indexes) of unmasked indexes\n    in the array.\n\n    If the input is 2d and axis is specified, the result is a list of lists.",
        "raises": "",
        "see_also": "flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges\nclump_masked, clump_unmasked",
        "notes": "Only accepts 2-D arrays at most.",
        "examples": ">>> a = np.arange(12).reshape((3, 4))\n>>> mask = np.zeros_like(a)\n>>> mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0\n>>> ma = np.ma.array(a, mask=mask)\n>>> ma\nmasked_array(\n  data=[[0, --, 2, 3],\n        [--, --, --, 7],\n        [8, --, --, 11]],\n  mask=[[False,  True, False, False],\n        [ True,  True,  True, False],\n        [False,  True,  True, False]],\n  fill_value=999999)\n>>> np.array(ma[~ma.mask])\narray([ 0,  2,  3,  7, 8, 11])\n\n>>> np.ma.notmasked_contiguous(ma)\n[slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]\n\n>>> np.ma.notmasked_contiguous(ma, axis=0)\n[[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]]\n\n>>> np.ma.notmasked_contiguous(ma, axis=1)\n[[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]]"
      }
    },
    {
      "name": "notmasked_edges",
      "signature": "notmasked_edges(a, axis=None)",
      "docstring": {
        "description": "Find the indices of the first and last unmasked values along an axis.\n\nIf all values are masked, return None.  Otherwise, return a list\nof two tuples, corresponding to the indices of the first and last\nunmasked values respectively.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "The input array."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to perform the operation.\n    If None (default), applies to a flattened version of the array."
          }
        },
        "returns": "edges : ndarray or list\n    An array of start and end indexes if there are any masked data in\n    the array. If there are no masked data in the array, `edges` is a\n    list of the first and last index.",
        "raises": "",
        "see_also": "flatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous\nclump_masked, clump_unmasked",
        "notes": "",
        "examples": ">>> a = np.arange(9).reshape((3, 3))\n>>> m = np.zeros_like(a)\n>>> m[1:, 1:] = 1\n\n>>> am = np.ma.array(a, mask=m)\n>>> np.array(am[~am.mask])\narray([0, 1, 2, 3, 6])\n\n>>> np.ma.notmasked_edges(am)\narray([0, 6])"
      }
    },
    {
      "name": "ones",
      "signature": "ones(...)",
      "docstring": {}
    },
    {
      "name": "ones_like",
      "signature": "ones_like(...)",
      "docstring": {}
    },
    {
      "name": "outer",
      "signature": "outer(a, b)",
      "docstring": {
        "description": "Compute the outer product of two vectors.\n\nGiven two vectors `a` and `b` of length ``M`` and ``N``, repsectively,\nthe outer product [1]_ is::\n\n  [[a_0*b_0  a_0*b_1 ... a_0*b_{N-1} ]\n   [a_1*b_0    .\n   [ ...          .\n   [a_{M-1}*b_0            a_{M-1}*b_{N-1} ]]",
        "parameters": {
          "a": {
            "type": "(M,) array_like",
            "description": "First input vector.  Input is flattened if\n    not already 1-dimensional."
          },
          "b": {
            "type": "(N,) array_like",
            "description": "Second input vector.  Input is flattened if\n    not already 1-dimensional."
          },
          "out": {
            "type": "(M, N) ndarray, optional",
            "description": "A location where the result is stored\n\n    .. versionadded:: 1.9.0"
          }
        },
        "returns": "out : (M, N) ndarray\n    ``out[i, j] = a[i] * b[j]``\n\nSee also\n--------\ninner\neinsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.\nufunc.outer : A generalization to dimensions other than 1D and other\n              operations. ``np.multiply.outer(a.ravel(), b.ravel())``\n              is the equivalent.\ntensordot : ``np.tensordot(a.ravel(), b.ravel(), axes=((), ()))``\n            is the equivalent.\n\nReferences\n----------\n.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd\n       ed., Baltimore, MD, Johns Hopkins University Press, 1996,\n       pg. 8.",
        "raises": "",
        "see_also": "",
        "notes": "Masked values are replaced by 0.",
        "examples": "Make a (*very* coarse) grid for computing a Mandelbrot set:\n\n>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n>>> rl\narray([[-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.]])\n>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n>>> im\narray([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n>>> grid = rl + im\n>>> grid\narray([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\nAn example using a \"vector\" of letters:\n\n>>> x = np.array(['a', 'b', 'c'], dtype=object)\n>>> np.outer(x, [1, 2, 3])\narray([['a', 'aa', 'aaa'],\n       ['b', 'bb', 'bbb'],\n       ['c', 'cc', 'ccc']], dtype=object)"
      }
    },
    {
      "name": "outerproduct",
      "signature": "outer(a, b)",
      "docstring": {
        "description": "Compute the outer product of two vectors.\n\nGiven two vectors `a` and `b` of length ``M`` and ``N``, repsectively,\nthe outer product [1]_ is::\n\n  [[a_0*b_0  a_0*b_1 ... a_0*b_{N-1} ]\n   [a_1*b_0    .\n   [ ...          .\n   [a_{M-1}*b_0            a_{M-1}*b_{N-1} ]]",
        "parameters": {
          "a": {
            "type": "(M,) array_like",
            "description": "First input vector.  Input is flattened if\n    not already 1-dimensional."
          },
          "b": {
            "type": "(N,) array_like",
            "description": "Second input vector.  Input is flattened if\n    not already 1-dimensional."
          },
          "out": {
            "type": "(M, N) ndarray, optional",
            "description": "A location where the result is stored\n\n    .. versionadded:: 1.9.0"
          }
        },
        "returns": "out : (M, N) ndarray\n    ``out[i, j] = a[i] * b[j]``\n\nSee also\n--------\ninner\neinsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.\nufunc.outer : A generalization to dimensions other than 1D and other\n              operations. ``np.multiply.outer(a.ravel(), b.ravel())``\n              is the equivalent.\ntensordot : ``np.tensordot(a.ravel(), b.ravel(), axes=((), ()))``\n            is the equivalent.\n\nReferences\n----------\n.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd\n       ed., Baltimore, MD, Johns Hopkins University Press, 1996,\n       pg. 8.",
        "raises": "",
        "see_also": "",
        "notes": "Masked values are replaced by 0.",
        "examples": "Make a (*very* coarse) grid for computing a Mandelbrot set:\n\n>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n>>> rl\narray([[-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.]])\n>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n>>> im\narray([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n>>> grid = rl + im\n>>> grid\narray([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\nAn example using a \"vector\" of letters:\n\n>>> x = np.array(['a', 'b', 'c'], dtype=object)\n>>> np.outer(x, [1, 2, 3])\narray([['a', 'aa', 'aaa'],\n       ['b', 'bb', 'bbb'],\n       ['c', 'cc', 'ccc']], dtype=object)"
      }
    },
    {
      "name": "polyfit",
      "signature": "polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False)",
      "docstring": {
        "description": "Least squares polynomial fit.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nFit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`\nto points `(x, y)`. Returns a vector of coefficients `p` that minimises\nthe squared error in the order `deg`, `deg-1`, ... `0`.\n\nThe `Polynomial.fit <numpy.polynomial.polynomial.Polynomial.fit>` class\nmethod is recommended for new code as it is more stable numerically. See\nthe documentation of the method for more information.",
        "parameters": {
          "x": {
            "type": "array_like, shape (M,)",
            "description": "x-coordinates of the M sample points ``(x[i], y[i])``."
          },
          "y": {
            "type": "array_like, shape (M,) or (M, K)",
            "description": "y-coordinates of the sample points. Several data sets of sample\n    points sharing the same x-coordinates can be fitted at once by\n    passing in a 2D-array that contains one dataset per column."
          },
          "deg": {
            "type": "int",
            "description": "Degree of the fitting polynomial"
          },
          "rcond": {
            "type": "float, optional",
            "description": "Relative condition number of the fit. Singular values smaller than\n    this relative to the largest singular value will be ignored. The\n    default value is len(x)*eps, where eps is the relative precision of\n    the float type, about 2e-16 in most cases."
          },
          "full": {
            "type": "bool, optional",
            "description": "Switch determining nature of return value. When it is False (the\n    default) just the coefficients are returned, when True diagnostic\n    information from the singular value decomposition is also returned."
          },
          "w": {
            "type": "array_like, shape (M,), optional",
            "description": "Weights. If not None, the weight ``w[i]`` applies to the unsquared\n    residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are\n    chosen so that the errors of the products ``w[i]*y[i]`` all have the\n    same variance.  When using inverse-variance weighting, use\n    ``w[i] = 1/sigma(y[i])``.  The default value is None."
          },
          "cov": {
            "type": "bool or str, optional",
            "description": "If given and not `False`, return not just the estimate but also its\n    covariance matrix. By default, the covariance are scaled by\n    chi2/dof, where dof = M - (deg + 1), i.e., the weights are presumed\n    to be unreliable except in a relative sense and everything is scaled\n    such that the reduced chi2 is unity. This scaling is omitted if\n    ``cov='unscaled'``, as is relevant for the case that the weights are\n    w = 1/sigma, with sigma known to be a reliable estimate of the\n    uncertainty."
          }
        },
        "returns": "p : ndarray, shape (deg + 1,) or (deg + 1, K)\n    Polynomial coefficients, highest power first.  If `y` was 2-D, the\n    coefficients for `k`-th data set are in ``p[:,k]``.\n\nresiduals, rank, singular_values, rcond\n    These values are only returned if ``full == True``\n\n    - residuals -- sum of squared residuals of the least squares fit\n    - rank -- the effective rank of the scaled Vandermonde\n       coefficient matrix\n    - singular_values -- singular values of the scaled Vandermonde\n       coefficient matrix\n    - rcond -- value of `rcond`.\n\n    For more details, see `numpy.linalg.lstsq`.\n\nV : ndarray, shape (M,M) or (M,M,K)\n    Present only if ``full == False`` and ``cov == True``.  The covariance\n    matrix of the polynomial coefficient estimates.  The diagonal of\n    this matrix are the variance estimates for each coefficient.  If y\n    is a 2-D array, then the covariance matrix for the `k`-th data set\n    are in ``V[:,:,k]``\n\n\nWarns\n-----\nRankWarning\n    The rank of the coefficient matrix in the least-squares fit is\n    deficient. The warning is only raised if ``full == False``.\n\n    The warnings can be turned off by\n\n    >>> import warnings\n    >>> warnings.simplefilter('ignore', np.RankWarning)",
        "raises": "",
        "see_also": "polyval : Compute polynomial values.\nlinalg.lstsq : Computes a least-squares fit.\nscipy.interpolate.UnivariateSpline : Computes spline fits.",
        "notes": "Any masked values in x is propagated in y, and vice-versa.\n\nThe solution minimizes the squared error\n\n.. math::\n    E = \\sum_{j=0}^k |p(x_j) - y_j|^2\n\nin the equations::\n\n    x[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]\n    x[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]\n    ...\n    x[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]\n\nThe coefficient matrix of the coefficients `p` is a Vandermonde matrix.\n\n`polyfit` issues a `RankWarning` when the least-squares fit is badly\nconditioned. This implies that the best fit is not well-defined due\nto numerical error. The results may be improved by lowering the polynomial\ndegree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter\ncan also be set to a value smaller than its default, but the resulting\nfit may be spurious: including contributions from the small singular\nvalues can add numerical noise to the result.\n\nNote that fitting polynomial coefficients is inherently badly conditioned\nwhen the degree of the polynomial is large or the interval of sample points\nis badly centered. The quality of the fit should always be checked in these\ncases. When polynomial fits are not satisfactory, splines may be a good\nalternative.\n\nReferences\n----------\n.. [1] Wikipedia, \"Curve fitting\",\n       https://en.wikipedia.org/wiki/Curve_fitting\n.. [2] Wikipedia, \"Polynomial interpolation\",\n       https://en.wikipedia.org/wiki/Polynomial_interpolation",
        "examples": ">>> import warnings\n>>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n>>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n>>> z = np.polyfit(x, y, 3)\n>>> z\narray([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary\n\nIt is convenient to use `poly1d` objects for dealing with polynomials:\n\n>>> p = np.poly1d(z)\n>>> p(0.5)\n0.6143849206349179 # may vary\n>>> p(3.5)\n-0.34732142857143039 # may vary\n>>> p(10)\n22.579365079365115 # may vary\n\nHigh-order polynomials may oscillate wildly:\n\n>>> with warnings.catch_warnings():\n...     warnings.simplefilter('ignore', np.RankWarning)\n...     p30 = np.poly1d(np.polyfit(x, y, 30))\n...\n>>> p30(4)\n-0.80000000000000204 # may vary\n>>> p30(5)\n-0.99999999999999445 # may vary\n>>> p30(4.5)\n-0.10547061179440398 # may vary\n\nIllustration:\n\n>>> import matplotlib.pyplot as plt\n>>> xp = np.linspace(-2, 6, 100)\n>>> _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n>>> plt.ylim(-2,2)\n(-2, 2)\n>>> plt.show()"
      }
    },
    {
      "name": "power",
      "signature": "power(a, b, third=None)",
      "docstring": {
        "description": "Returns element-wise base array raised to power from second array.\n\nThis is the masked array version of `numpy.power`. For details see\n`numpy.power`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.power",
        "notes": "The *out* argument to `numpy.power` is not supported, `third` has to be\nNone.",
        "examples": ">>> import numpy.ma as ma\n>>> x = [11.2, -3.973, 0.801, -1.41]\n>>> mask = [0, 0, 0, 1]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(data=[11.2, -3.973, 0.801, --],\n         mask=[False, False, False,  True],\n   fill_value=1e+20)\n>>> ma.power(masked_x, 2)\nmasked_array(data=[125.43999999999998, 15.784728999999999,\n               0.6416010000000001, --],\n         mask=[False, False, False,  True],\n   fill_value=1e+20)\n>>> y = [-0.5, 2, 0, 17]\n>>> masked_y = ma.masked_array(y, mask)\n>>> masked_y\nmasked_array(data=[-0.5, 2.0, 0.0, --],\n         mask=[False, False, False,  True],\n   fill_value=1e+20)\n>>> ma.power(masked_x, masked_y)\nmasked_array(data=[0.29880715233359845, 15.784728999999999, 1.0, --],\n         mask=[False, False, False,  True],\n   fill_value=1e+20)"
      }
    },
    {
      "name": "prod",
      "signature": "prod(a, *args, **params)",
      "docstring": {
        "description": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)\n\nReturn the product of the array elements over the given axis.\n\nMasked elements are set to 1 internally for computation.\n\nRefer to `numpy.prod` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
        "notes": "Arithmetic is modular when using integer types, and no error is raised\non overflow.",
        "examples": ""
      }
    },
    {
      "name": "product",
      "signature": "prod(a, *args, **params)",
      "docstring": {
        "description": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)\n\nReturn the product of the array elements over the given axis.\n\nMasked elements are set to 1 internally for computation.\n\nRefer to `numpy.prod` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
        "notes": "Arithmetic is modular when using integer types, and no error is raised\non overflow.",
        "examples": ""
      }
    },
    {
      "name": "ptp",
      "signature": "ptp(obj, axis=None, out=None, fill_value=None, keepdims=<no value>)",
      "docstring": {
        "description": "Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).\n\n.. warning::\n    `ptp` preserves the data type of the array. This means the\n    return value for an input of signed integers with n bits\n    (e.g. `np.int8`, `np.int16`, etc) is also a signed integer\n    with n bits.  In that case, peak-to-peak values greater than\n    ``2**(n-1)-1`` will be returned as negative values. An example\n    with a work-around is shown below.",
        "parameters": {
          "axis": {
            "type": "{None, int}, optional",
            "description": "Axis along which to find the peaks.  If None (default) the\n    flattened array is used."
          },
          "out": {
            "type": "{None, array_like}, optional",
            "description": "Alternative output array in which to place the result. It must\n    have the same shape and buffer length as the expected output\n    but the type will be cast if necessary."
          },
          "fill_value": {
            "type": "scalar or None, optional",
            "description": "Value used to fill in the masked values."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
          }
        },
        "returns": "ptp : ndarray.\n    A new array holding the result, unless ``out`` was\n    specified, in which case a reference to ``out`` is returned.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = np.ma.MaskedArray([[4, 9, 2, 10],\n...                        [6, 9, 7, 12]])\n\n>>> x.ptp(axis=1)\nmasked_array(data=[8, 6],\n             mask=False,\n       fill_value=999999)\n\n>>> x.ptp(axis=0)\nmasked_array(data=[2, 0, 5, 2],\n             mask=False,\n       fill_value=999999)\n\n>>> x.ptp()\n10\n\nThis example shows that a negative value can be returned when\nthe input is an array of signed integers.\n\n>>> y = np.ma.MaskedArray([[1, 127],\n...                        [0, 127],\n...                        [-1, 127],\n...                        [-2, 127]], dtype=np.int8)\n>>> y.ptp(axis=1)\nmasked_array(data=[ 126,  127, -128, -127],\n             mask=False,\n       fill_value=999999,\n            dtype=int8)\n\nA work-around is to use the `view()` method to view the result as\nunsigned integers with the same bit width:\n\n>>> y.ptp(axis=1).view(np.uint8)\nmasked_array(data=[126, 127, 128, 129],\n             mask=False,\n       fill_value=999999,\n            dtype=uint8)"
      }
    },
    {
      "name": "put",
      "signature": "put(a, indices, values, mode='raise')",
      "docstring": {
        "description": "Set storage-indexed locations to corresponding values.\n\nThis function is equivalent to `MaskedArray.put`, see that method\nfor details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "MaskedArray.put",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "putmask",
      "signature": "putmask(a, mask, values)",
      "docstring": {
        "description": "Changes elements of an array based on conditional and input values.\n\nThis is the masked array version of `numpy.putmask`, for details see\n`numpy.putmask`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.putmask",
        "notes": "Using a masked array as `values` will **not** transform a `ndarray` into\na `MaskedArray`.",
        "examples": ""
      }
    },
    {
      "name": "ravel",
      "signature": "ravel(a, *args, **params)",
      "docstring": {
        "description": "ravel(self, order='C')\n\nReturns a 1D version of self, as a view.",
        "parameters": {
          "order": {
            "type": "{'C', 'F', 'A', 'K'}, optional",
            "description": "The elements of `a` are read using this index order. 'C' means to\n    index the elements in C-like order, with the last axis index\n    changing fastest, back to the first axis index changing slowest.\n    'F' means to index the elements in Fortran-like index order, with\n    the first index changing fastest, and the last index changing\n    slowest. Note that the 'C' and 'F' options take no account of the\n    memory layout of the underlying array, and only refer to the order\n    of axis indexing.  'A' means to read the elements in Fortran-like\n    index order if `m` is Fortran *contiguous* in memory, C-like order\n    otherwise.  'K' means to read the elements in the order they occur\n    in memory, except for reversing the data when strides are negative.\n    By default, 'C' index order is used.\n    (Masked arrays currently use 'A' on the data when 'K' is passed.)"
          }
        },
        "returns": "MaskedArray\n    Output view is of shape ``(self.size,)`` (or\n    ``(np.ma.product(self.shape),)``).",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\n             mask=[False,  True, False,  True, False,  True, False,  True,\n                   False],\n       fill_value=999999)"
      }
    },
    {
      "name": "remainder",
      "signature": "remainder(a, b, *args, **kwargs)",
      "docstring": {
        "description": "remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns the element-wise remainder of division.\n\nComputes the remainder complementary to the `floor_divide` function.  It is\nequivalent to the Python modulus operator``x1 % x2`` and has the same sign\nas the divisor `x2`. The MATLAB function equivalent to ``np.remainder``\nis ``mod``.\n\n.. warning::\n\n    This should not be confused with:\n\n    * Python 3.7's `math.remainder` and C's ``remainder``, which\n      computes the IEEE remainder, which are the complement to\n      ``round(x1 / x2)``.\n    * The MATLAB ``rem`` function and or the C ``%`` operator which is the\n      complement to ``int(x1 / x2)``.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend array."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor array.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "floor_divide : Equivalent of Python ``//`` operator.\ndivmod : Simultaneous floor division and remainder.\nfmod : Equivalent of the MATLAB ``rem`` function.\ndivide, floor",
        "notes": "Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)\nintegers.\n``mod`` is an alias of ``remainder``.",
        "examples": ">>> np.remainder([4, 7], [2, 3])\narray([0, 1])\n>>> np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])\n\nThe ``%`` operator can be used as a shorthand for ``np.remainder`` on\nndarrays.\n\n>>> x1 = np.arange(7)\n>>> x1 % 5\narray([0, 1, 2, 3, 4, 0, 1])"
      }
    },
    {
      "name": "repeat",
      "signature": "repeat(a, *args, **params)",
      "docstring": {
        "description": "repeat(self, *args, **params)\na.repeat(repeats, axis=None)\n\n    Repeat elements of an array.\n\n    Refer to `numpy.repeat` for full documentation.\n\n    See Also\n    --------\n    numpy.repeat : equivalent function",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "reshape",
      "signature": "reshape(a, new_shape, order='C')",
      "docstring": {
        "description": "Returns an array containing the same data with a new shape.\n\nRefer to `MaskedArray.reshape` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "MaskedArray.reshape : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "resize",
      "signature": "resize(x, new_shape)",
      "docstring": {
        "description": "Return a new masked array with the specified size and shape.\n\nThis is the masked equivalent of the `numpy.resize` function. The new\narray is filled with repeated copies of `x` (in the order that the\ndata are stored in memory). If `x` is masked, the new array will be\nmasked, and the new mask will be a repetition of the old one.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.resize : Equivalent function in the top level NumPy module.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = ma.array([[1, 2] ,[3, 4]])\n>>> a[0, 1] = ma.masked\n>>> a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=999999)\n>>> np.resize(a, (3, 3))\nmasked_array(\n  data=[[1, 2, 3],\n        [4, 1, 2],\n        [3, 4, 1]],\n  mask=False,\n  fill_value=999999)\n>>> ma.resize(a, (3, 3))\nmasked_array(\n  data=[[1, --, 3],\n        [4, 1, --],\n        [3, 4, 1]],\n  mask=[[False,  True, False],\n        [False, False,  True],\n        [False, False, False]],\n  fill_value=999999)\n\nA MaskedArray is always returned, regardless of the input type.\n\n>>> a = np.array([[1, 2] ,[3, 4]])\n>>> ma.resize(a, (3, 3))\nmasked_array(\n  data=[[1, 2, 3],\n        [4, 1, 2],\n        [3, 4, 1]],\n  mask=False,\n  fill_value=999999)"
      }
    },
    {
      "name": "right_shift",
      "signature": "right_shift(a, n)",
      "docstring": {
        "description": "Shift the bits of an integer to the right.\n\nThis is the masked array version of `numpy.right_shift`, for details\nsee that function.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.right_shift",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> x = [11, 3, 8, 1]\n>>> mask = [0, 0, 0, 1]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(data=[11, 3, 8, --],\n             mask=[False, False, False,  True],\n       fill_value=999999)\n>>> ma.right_shift(masked_x,1)\nmasked_array(data=[5, 1, 4, --],\n             mask=[False, False, False,  True],\n       fill_value=999999)"
      }
    },
    {
      "name": "round",
      "signature": "round_(a, decimals=0, out=None)",
      "docstring": {
        "description": "Return a copy of a, rounded to 'decimals' places.\n\nWhen 'decimals' is negative, it specifies the number of positions\nto the left of the decimal point.  The real and imaginary parts of\ncomplex numbers are rounded separately. Nothing is done if the\narray is not of float type and 'decimals' is greater than or equal\nto 0.",
        "parameters": {
          "decimals": {
            "type": "int",
            "description": "Number of decimals to round to. May be negative."
          },
          "out": {
            "type": "array_like",
            "description": "Existing array to use for output.\n    If not given, returns a default copy of a."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "If out is given and does not have a mask attribute, the mask of a\nis lost!",
        "examples": ">>> import numpy.ma as ma\n>>> x = [11.2, -3.973, 0.801, -1.41]\n>>> mask = [0, 0, 0, 1]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(data=[11.2, -3.973, 0.801, --],\n             mask=[False, False, False, True],\n    fill_value=1e+20)\n>>> ma.round_(masked_x)\nmasked_array(data=[11.0, -4.0, 1.0, --],\n             mask=[False, False, False, True],\n    fill_value=1e+20)\n>>> ma.round(masked_x, decimals=1)\nmasked_array(data=[11.2, -4.0, 0.8, --],\n             mask=[False, False, False, True],\n    fill_value=1e+20)\n>>> ma.round_(masked_x, decimals=-1)\nmasked_array(data=[10.0, -0.0, 0.0, --],\n             mask=[False, False, False, True],\n    fill_value=1e+20)"
      }
    },
    {
      "name": "round_",
      "signature": "round_(a, decimals=0, out=None)",
      "docstring": {
        "description": "Return a copy of a, rounded to 'decimals' places.\n\nWhen 'decimals' is negative, it specifies the number of positions\nto the left of the decimal point.  The real and imaginary parts of\ncomplex numbers are rounded separately. Nothing is done if the\narray is not of float type and 'decimals' is greater than or equal\nto 0.",
        "parameters": {
          "decimals": {
            "type": "int",
            "description": "Number of decimals to round to. May be negative."
          },
          "out": {
            "type": "array_like",
            "description": "Existing array to use for output.\n    If not given, returns a default copy of a."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "If out is given and does not have a mask attribute, the mask of a\nis lost!",
        "examples": ">>> import numpy.ma as ma\n>>> x = [11.2, -3.973, 0.801, -1.41]\n>>> mask = [0, 0, 0, 1]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(data=[11.2, -3.973, 0.801, --],\n             mask=[False, False, False, True],\n    fill_value=1e+20)\n>>> ma.round_(masked_x)\nmasked_array(data=[11.0, -4.0, 1.0, --],\n             mask=[False, False, False, True],\n    fill_value=1e+20)\n>>> ma.round(masked_x, decimals=1)\nmasked_array(data=[11.2, -4.0, 0.8, --],\n             mask=[False, False, False, True],\n    fill_value=1e+20)\n>>> ma.round_(masked_x, decimals=-1)\nmasked_array(data=[10.0, -0.0, 0.0, --],\n             mask=[False, False, False, True],\n    fill_value=1e+20)"
      }
    },
    {
      "name": "row_stack",
      "signature": "vstack(x, *args, **params)",
      "docstring": {
        "description": "vstack\n\nStack arrays in sequence vertically (row wise).\n\nThis is equivalent to concatenation along the first axis after 1-D arrays\nof shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by\n`vsplit`.\n\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.\n\n``np.row_stack`` is an alias for `vstack`. They are the same function.",
        "parameters": {
          "tup": {
            "type": "sequence of ndarrays",
            "description": "The arrays must have the same shape along all but the first axis.\n    1-D arrays must have the same length."
          },
          "dtype": {
            "type": "str or dtype",
            "description": "If provided, the destination array will have this dtype. Cannot be\n    provided together with `out`.\n\n.. versionadded:: 1.24"
          },
          "casting": {
            "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
            "description": "Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n.. versionadded:: 1.24"
          }
        },
        "returns": "stacked : ndarray\n    The array formed by stacking the given arrays, will be at least 2-D.",
        "raises": "",
        "see_also": "concatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nblock : Assemble an nd-array from nested lists of blocks.\nhstack : Stack arrays in sequence horizontally (column wise).\ndstack : Stack arrays in sequence depth wise (along third axis).\ncolumn_stack : Stack 1-D arrays as columns into a 2-D array.\nvsplit : Split an array into multiple sub-arrays vertically (row-wise).",
        "notes": "The function is applied to both the _data and the _mask, if any.",
        "examples": ">>> a = np.array([1, 2, 3])\n>>> b = np.array([4, 5, 6])\n>>> np.vstack((a,b))\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n>>> a = np.array([[1], [2], [3]])\n>>> b = np.array([[4], [5], [6]])\n>>> np.vstack((a,b))\narray([[1],\n       [2],\n       [3],\n       [4],\n       [5],\n       [6]])"
      }
    },
    {
      "name": "set_fill_value",
      "signature": "set_fill_value(a, fill_value)",
      "docstring": {
        "description": "Set the filling value of a, if a is a masked array.\n\nThis function changes the fill value of the masked array `a` in place.\nIf `a` is not a masked array, the function returns silently, without\ndoing anything.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array."
          },
          "fill_value": {
            "type": "dtype",
            "description": "Filling value. A consistency test is performed to make sure\n    the value is compatible with the dtype of `a`."
          }
        },
        "returns": "None\n    Nothing returned by this function.",
        "raises": "",
        "see_also": "maximum_fill_value : Return the default fill value for a dtype.\nMaskedArray.fill_value : Return current fill value.\nMaskedArray.set_fill_value : Equivalent method.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = np.arange(5)\n>>> a\narray([0, 1, 2, 3, 4])\n>>> a = ma.masked_where(a < 3, a)\n>>> a\nmasked_array(data=[--, --, --, 3, 4],\n             mask=[ True,  True,  True, False, False],\n       fill_value=999999)\n>>> ma.set_fill_value(a, -999)\n>>> a\nmasked_array(data=[--, --, --, 3, 4],\n             mask=[ True,  True,  True, False, False],\n       fill_value=-999)\n\nNothing happens if `a` is not a masked array.\n\n>>> a = list(range(5))\n>>> a\n[0, 1, 2, 3, 4]\n>>> ma.set_fill_value(a, 100)\n>>> a\n[0, 1, 2, 3, 4]\n>>> a = np.arange(5)\n>>> a\narray([0, 1, 2, 3, 4])\n>>> ma.set_fill_value(a, 100)\n>>> a\narray([0, 1, 2, 3, 4])"
      }
    },
    {
      "name": "setdiff1d",
      "signature": "setdiff1d(ar1, ar2, assume_unique=False)",
      "docstring": {
        "description": "Set difference of 1D arrays with unique elements.\n\nThe output is always a masked array. See `numpy.setdiff1d` for more\ndetails.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.setdiff1d : Equivalent function for ndarrays.",
        "notes": "",
        "examples": ">>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])\n>>> np.ma.setdiff1d(x, [1, 2])\nmasked_array(data=[3, --],\n             mask=[False,  True],\n       fill_value=999999)"
      }
    },
    {
      "name": "setxor1d",
      "signature": "setxor1d(ar1, ar2, assume_unique=False)",
      "docstring": {
        "description": "Set exclusive-or of 1-D arrays with unique elements.\n\nThe output is always a masked array. See `numpy.setxor1d` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.setxor1d : Equivalent function for ndarrays.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "shape",
      "signature": "shape(obj)",
      "docstring": {
        "description": "Return the shape of an array.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array."
          }
        },
        "returns": "shape : tuple of ints\n    The elements of the shape tuple give the lengths of the\n    corresponding array dimensions.",
        "raises": "",
        "see_also": "len : ``len(a)`` is equivalent to ``np.shape(a)[0]`` for N-D arrays with\n      ``N>=1``.\nndarray.shape : Equivalent array method.",
        "notes": "",
        "examples": ">>> np.shape(np.eye(3))\n(3, 3)\n>>> np.shape([[1, 3]])\n(1, 2)\n>>> np.shape([0])\n(1,)\n>>> np.shape(0)\n()\n\n>>> a = np.array([(1, 2), (3, 4), (5, 6)],\n...              dtype=[('x', 'i4'), ('y', 'i4')])\n>>> np.shape(a)\n(3,)\n>>> a.shape\n(3,)"
      }
    },
    {
      "name": "sin",
      "signature": "sin(a, *args, **kwargs)",
      "docstring": {
        "description": "sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTrigonometric sine, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Angle, in radians (:math:`2 \\pi` rad equals 360 degrees)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : array_like\n    The sine of each element of x.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "arcsin, sinh, cos",
        "notes": "The sine is one of the fundamental functions of trigonometry (the\nmathematical study of triangles).  Consider a circle of radius 1\ncentered on the origin.  A ray comes in from the :math:`+x` axis, makes\nan angle at the origin (measured counter-clockwise from that axis), and\ndeparts from the origin.  The :math:`y` coordinate of the outgoing\nray's intersection with the unit circle is the sine of that angle.  It\nranges from -1 for :math:`x=3\\pi / 2` to +1 for :math:`\\pi / 2.`  The\nfunction has zeroes where the angle is a multiple of :math:`\\pi`.\nSines of angles between :math:`\\pi` and :math:`2\\pi` are negative.\nThe numerous properties of the sine and related functions are included\nin any standard trigonometry text.",
        "examples": "Print sine of one angle:\n\n>>> np.sin(np.pi/2.)\n1.0\n\nPrint sines of an array of angles given in degrees:\n\n>>> np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )\narray([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])\n\nPlot the sine function:\n\n>>> import matplotlib.pylab as plt\n>>> x = np.linspace(-np.pi, np.pi, 201)\n>>> plt.plot(x, np.sin(x))\n>>> plt.xlabel('Angle [rad]')\n>>> plt.ylabel('sin(x)')\n>>> plt.axis('tight')\n>>> plt.show()"
      }
    },
    {
      "name": "sinh",
      "signature": "sinh(a, *args, **kwargs)",
      "docstring": {
        "description": "sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nHyperbolic sine, element-wise.\n\nEquivalent to ``1/2 * (np.exp(x) - np.exp(-x))`` or\n``-1j * np.sin(1j*x)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    The corresponding hyperbolic sine values.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "If `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\n\nReferences\n----------\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972, pg. 83.",
        "examples": ">>> np.sinh(0)\n0.0\n>>> np.sinh(np.pi*1j/2)\n1j\n>>> np.sinh(np.pi*1j) # (exact value is 0)\n1.2246063538223773e-016j\n>>> # Discrepancy due to vagaries of floating point arithmetic.\n\n>>> # Example of providing the optional output parameter\n>>> out1 = np.array([0], dtype='d')\n>>> out2 = np.sinh([0.1], out1)\n>>> out2 is out1\nTrue\n\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.sinh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)"
      }
    },
    {
      "name": "size",
      "signature": "size(obj, axis=None)",
      "docstring": {
        "description": "Return the number of elements along a given axis.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input data."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which the elements are counted.  By default, give\n    the total number of elements."
          }
        },
        "returns": "element_count : int\n    Number of elements along the specified axis.",
        "raises": "",
        "see_also": "shape : dimensions of array\nndarray.shape : dimensions of array\nndarray.size : number of elements in array",
        "notes": "",
        "examples": ">>> a = np.array([[1,2,3],[4,5,6]])\n>>> np.size(a)\n6\n>>> np.size(a,1)\n3\n>>> np.size(a,0)\n2"
      }
    },
    {
      "name": "soften_mask",
      "signature": "soften_mask(a, *args, **params)",
      "docstring": {
        "description": "soften_mask(self)\n\nForce the mask to soft (default), allowing unmasking by assignment.\n\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `soften_mask` sets\n`~ma.MaskedArray.hardmask` to ``False`` (and returns the modified\nself).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "ma.MaskedArray.hardmask\nma.MaskedArray.harden_mask",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sometrue",
      "signature": "reduce(target, axis=0, dtype=None)",
      "docstring": {
        "description": "Reduce `target` along the given `axis`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sort",
      "signature": "sort(a, axis=-1, kind=None, order=None, endwith=True, fill_value=None)",
      "docstring": {
        "description": "Return a sorted copy of the masked array.\n\nEquivalent to creating a copy of the array\nand applying the  MaskedArray ``sort()`` method.\n\nRefer to ``MaskedArray.sort`` for the full documentation",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "MaskedArray.sort : equivalent method",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> x = [11.2, -3.973, 0.801, -1.41]\n>>> mask = [0, 0, 0, 1]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(data=[11.2, -3.973, 0.801, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)\n>>> ma.sort(masked_x)\nmasked_array(data=[-3.973, 0.801, 11.2, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)"
      }
    },
    {
      "name": "sqrt",
      "signature": "sqrt(a, *args, **kwargs)",
      "docstring": {
        "description": "sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the non-negative square-root of an array, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "The values whose square-roots are required."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    An array of the same shape as `x`, containing the positive\n    square-root of each element in `x`.  If any element in `x` is\n    complex, a complex array is returned (and the square-roots of\n    negative reals are calculated).  If all of the elements in `x`\n    are real, so is `y`, with negative elements returning ``nan``.\n    If `out` was provided, `y` is a reference to it.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "emath.sqrt\n    A version which returns complex numbers when given negative reals.\n    Note that 0.0 and -0.0 are handled differently for complex inputs.",
        "notes": "*sqrt* has--consistent with common convention--as its branch cut the\nreal \"interval\" [`-inf`, 0), and is continuous from above on it.\nA branch cut is a curve in the complex plane across which a given\ncomplex function fails to be continuous.",
        "examples": ">>> np.sqrt([1,4,9])\narray([ 1.,  2.,  3.])\n\n>>> np.sqrt([4, -1, -3+4J])\narray([ 2.+0.j,  0.+1.j,  1.+2.j])\n\n>>> np.sqrt([4, -1, np.inf])\narray([ 2., nan, inf])"
      }
    },
    {
      "name": "squeeze",
      "signature": "squeeze(...)",
      "docstring": {}
    },
    {
      "name": "stack",
      "signature": "stack(x, *args, **params)",
      "docstring": {
        "description": "stack\n\nJoin a sequence of arrays along a new axis.\n\nThe ``axis`` parameter specifies the index of the new axis in the\ndimensions of the result. For example, if ``axis=0`` it will be the first\ndimension and if ``axis=-1`` it will be the last dimension.\n\n.. versionadded:: 1.10.0",
        "parameters": {
          "arrays": {
            "type": "sequence of array_like",
            "description": "Each array must have the same shape."
          },
          "axis": {
            "type": "int, optional",
            "description": "The axis in the result array along which the input arrays are stacked."
          },
          "out": {
            "type": "ndarray, optional",
            "description": "If provided, the destination to place the result. The shape must be\n    correct, matching that of what stack would have returned if no\n    out argument were specified."
          },
          "dtype": {
            "type": "str or dtype",
            "description": "If provided, the destination array will have this dtype. Cannot be\n    provided together with `out`.\n\n    .. versionadded:: 1.24"
          },
          "casting": {
            "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
            "description": "Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n    .. versionadded:: 1.24"
          }
        },
        "returns": "stacked : ndarray\n    The stacked array has one more dimension than the input arrays.",
        "raises": "",
        "see_also": "concatenate : Join a sequence of arrays along an existing axis.\nblock : Assemble an nd-array from nested lists of blocks.\nsplit : Split array into a list of multiple sub-arrays of equal size.",
        "notes": "The function is applied to both the _data and the _mask, if any.",
        "examples": ">>> arrays = [np.random.randn(3, 4) for _ in range(10)]\n>>> np.stack(arrays, axis=0).shape\n(10, 3, 4)\n\n>>> np.stack(arrays, axis=1).shape\n(3, 10, 4)\n\n>>> np.stack(arrays, axis=2).shape\n(3, 4, 10)\n\n>>> a = np.array([1, 2, 3])\n>>> b = np.array([4, 5, 6])\n>>> np.stack((a, b))\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n>>> np.stack((a, b), axis=-1)\narray([[1, 4],\n       [2, 5],\n       [3, 6]])"
      }
    },
    {
      "name": "std",
      "signature": "std(a, *args, **params)",
      "docstring": {
        "description": "std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)\n\nReturns the standard deviation of the array elements along given axis.\n\nMasked entries are ignored.\n\nRefer to `numpy.std` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.ndarray.std : corresponding function for ndarrays\nnumpy.std : Equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "subtract",
      "signature": "subtract(a, b, *args, **kwargs)",
      "docstring": {
        "description": "subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nSubtract arguments, element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    The difference of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "",
        "notes": "Equivalent to ``x1 - x2`` in terms of array broadcasting.",
        "examples": ">>> np.subtract(1.0, 4.0)\n-3.0\n\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.subtract(x1, x2)\narray([[ 0.,  0.,  0.],\n       [ 3.,  3.,  3.],\n       [ 6.,  6.,  6.]])\n\nThe ``-`` operator can be used as a shorthand for ``np.subtract`` on\nndarrays.\n\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> x1 - x2\narray([[0., 0., 0.],\n       [3., 3., 3.],\n       [6., 6., 6.]])"
      }
    },
    {
      "name": "sum",
      "signature": "sum(a, *args, **params)",
      "docstring": {
        "description": "sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)\n\nReturn the sum of the array elements over the given axis.\n\nMasked elements are set to 0 internally.\n\nRefer to `numpy.sum` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.ndarray.sum : corresponding function for ndarrays\nnumpy.sum : equivalent function",
        "notes": "",
        "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.sum()\n25\n>>> x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\n             mask=[False, False, False],\n       fill_value=999999)\n>>> x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\n             mask=[False, False, False],\n       fill_value=999999)\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<class 'numpy.int64'>"
      }
    },
    {
      "name": "swapaxes",
      "signature": "swapaxes(a, *args, **params)",
      "docstring": {
        "description": "swapaxes(self, *args, **params)\na.swapaxes(axis1, axis2)\n\n    Return a view of the array with `axis1` and `axis2` interchanged.\n\n    Refer to `numpy.swapaxes` for full documentation.\n\n    See Also\n    --------\n    numpy.swapaxes : equivalent function",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "take",
      "signature": "take(a, indices, axis=None, out=None, mode='raise')",
      "docstring": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "tan",
      "signature": "tan(a, *args, **kwargs)",
      "docstring": {
        "description": "tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute tangent element-wise.\n\nEquivalent to ``np.sin(x)/np.cos(x)`` element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    The corresponding tangent values.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "If `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\n\nReferences\n----------\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972.",
        "examples": ">>> from math import pi\n>>> np.tan(np.array([-pi,pi/2,pi]))\narray([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])\n>>>\n>>> # Example of providing the optional output parameter illustrating\n>>> # that what is returned is a reference to said parameter\n>>> out1 = np.array([0], dtype='d')\n>>> out2 = np.cos([0.1], out1)\n>>> out2 is out1\nTrue\n>>>\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)"
      }
    },
    {
      "name": "tanh",
      "signature": "tanh(a, *args, **kwargs)",
      "docstring": {
        "description": "tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute hyperbolic tangent element-wise.\n\nEquivalent to ``np.sinh(x)/np.cosh(x)`` or ``-1j * np.tan(1j*x)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray\n    The corresponding hyperbolic tangent values.\n    This is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "If `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\n\nReferences\n----------\n.. [1] M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\n       New York, NY: Dover, 1972, pg. 83.\n       https://personal.math.ubc.ca/~cbm/aands/page_83.htm\n\n.. [2] Wikipedia, \"Hyperbolic function\",\n       https://en.wikipedia.org/wiki/Hyperbolic_function",
        "examples": ">>> np.tanh((0, np.pi*1j, np.pi*1j/2))\narray([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])\n\n>>> # Example of providing the optional output parameter illustrating\n>>> # that what is returned is a reference to said parameter\n>>> out1 = np.array([0], dtype='d')\n>>> out2 = np.tanh([0.1], out1)\n>>> out2 is out1\nTrue\n\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.tanh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)"
      }
    },
    {
      "name": "test",
      "signature": "test(...)",
      "docstring": {}
    },
    {
      "name": "trace",
      "signature": "trace(a, *args, **params)",
      "docstring": {
        "description": "trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)\na.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\n\n    Return the sum along diagonals of the array.\n\n    Refer to `numpy.trace` for full documentation.\n\n    See Also\n    --------\n    numpy.trace : equivalent function",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "transpose",
      "signature": "transpose(a, axes=None)",
      "docstring": {
        "description": "Permute the dimensions of an array.\n\nThis function is exactly equivalent to `numpy.transpose`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.transpose : Equivalent function in top-level NumPy module.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> x = ma.arange(4).reshape((2,2))\n>>> x[1, 1] = ma.masked\n>>> x\nmasked_array(\n  data=[[0, 1],\n        [2, --]],\n  mask=[[False, False],\n        [False,  True]],\n  fill_value=999999)\n\n>>> ma.transpose(x)\nmasked_array(\n  data=[[0, 2],\n        [1, --]],\n  mask=[[False, False],\n        [False,  True]],\n  fill_value=999999)"
      }
    },
    {
      "name": "true_divide",
      "signature": "divide(a, b, *args, **kwargs)",
      "docstring": {
        "description": "divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nDivide arguments element-wise.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend array."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor array.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "y : ndarray or scalar\n    The quotient ``x1/x2``, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "seterr : Set whether to raise or warn on overflow, underflow and\n         division by zero.",
        "notes": "Equivalent to ``x1`` / ``x2`` in terms of array-broadcasting.\n\nThe ``true_divide(x1, x2)`` function is an alias for\n``divide(x1, x2)``.",
        "examples": ">>> np.divide(2.0, 4.0)\n0.5\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.divide(x1, x2)\narray([[nan, 1. , 1. ],\n       [inf, 4. , 2.5],\n       [inf, 7. , 4. ]])\n\nThe ``/`` operator can be used as a shorthand for ``np.divide`` on\nndarrays.\n\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = 2 * np.ones(3)\n>>> x1 / x2\narray([[0. , 0.5, 1. ],\n       [1.5, 2. , 2.5],\n       [3. , 3.5, 4. ]])"
      }
    },
    {
      "name": "union1d",
      "signature": "union1d(ar1, ar2)",
      "docstring": {
        "description": "Union of two arrays.\n\nThe output is always a masked array. See `numpy.union1d` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.union1d : Equivalent function for ndarrays.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "unique",
      "signature": "unique(ar1, return_index=False, return_inverse=False)",
      "docstring": {
        "description": "Finds the unique elements of an array.\n\nMasked values are considered the same element (masked). The output array\nis always a masked array. See `numpy.unique` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.unique : Equivalent function for ndarrays.",
        "notes": "",
        "examples": ">>> import numpy.ma as ma\n>>> a = [1, 2, 1000, 2, 3]\n>>> mask = [0, 0, 1, 0, 0]\n>>> masked_a = ma.masked_array(a, mask)\n>>> masked_a\nmasked_array(data=[1, 2, --, 2, 3],\n            mask=[False, False,  True, False, False],\n    fill_value=999999)\n>>> ma.unique(masked_a)\nmasked_array(data=[1, 2, 3, --],\n            mask=[False, False, False,  True],\n    fill_value=999999)\n>>> ma.unique(masked_a, return_index=True)\n(masked_array(data=[1, 2, 3, --],\n            mask=[False, False, False,  True],\n    fill_value=999999), array([0, 1, 4, 2]))\n>>> ma.unique(masked_a, return_inverse=True)\n(masked_array(data=[1, 2, 3, --],\n            mask=[False, False, False,  True],\n    fill_value=999999), array([0, 1, 3, 1, 2]))\n>>> ma.unique(masked_a, return_index=True, return_inverse=True)\n(masked_array(data=[1, 2, 3, --],\n            mask=[False, False, False,  True],\n    fill_value=999999), array([0, 1, 4, 2]), array([0, 1, 3, 1, 2]))"
      }
    },
    {
      "name": "vander",
      "signature": "vander(x, n=None)",
      "docstring": {
        "description": "Generate a Vandermonde matrix.\n\nThe columns of the output matrix are powers of the input vector. The\norder of the powers is determined by the `increasing` boolean argument.\nSpecifically, when `increasing` is False, the `i`-th output column is\nthe input vector raised element-wise to the power of ``N - i - 1``. Such\na matrix with a geometric progression in each row is named for Alexandre-\nTheophile Vandermonde.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "1-D input array."
          },
          "N": {
            "type": "int, optional",
            "description": "Number of columns in the output.  If `N` is not specified, a square\n    array is returned (``N = len(x)``)."
          },
          "increasing": {
            "type": "bool, optional",
            "description": "Order of the powers of the columns.  If True, the powers increase\n    from left to right, if False (the default) they are reversed.\n\n    .. versionadded:: 1.9.0"
          }
        },
        "returns": "out : ndarray\n    Vandermonde matrix.  If `increasing` is False, the first column is\n    ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is\n    True, the columns are ``x^0, x^1, ..., x^(N-1)``.",
        "raises": "",
        "see_also": "polynomial.polynomial.polyvander",
        "notes": "Masked values in the input array result in rows of zeros.",
        "examples": ">>> x = np.array([1, 2, 3, 5])\n>>> N = 3\n>>> np.vander(x, N)\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n>>> np.column_stack([x**(N-1-i) for i in range(N)])\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n>>> x = np.array([1, 2, 3, 5])\n>>> np.vander(x)\narray([[  1,   1,   1,   1],\n       [  8,   4,   2,   1],\n       [ 27,   9,   3,   1],\n       [125,  25,   5,   1]])\n>>> np.vander(x, increasing=True)\narray([[  1,   1,   1,   1],\n       [  1,   2,   4,   8],\n       [  1,   3,   9,  27],\n       [  1,   5,  25, 125]])\n\nThe determinant of a square Vandermonde matrix is the product\nof the differences between the values of the input vector:\n\n>>> np.linalg.det(np.vander(x))\n48.000000000000043 # may vary\n>>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n48"
      }
    },
    {
      "name": "var",
      "signature": "var(a, *args, **params)",
      "docstring": {
        "description": "var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)\n\nCompute the variance along the specified axis.\n\nReturns the variance of the array elements, a measure of the spread of a\ndistribution.  The variance is computed for the flattened array by\ndefault, otherwise over the specified axis.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Array containing numbers whose variance is desired.  If `a` is not an\n    array, a conversion is attempted."
          },
          "axis": {
            "type": "None or int or tuple of ints, optional",
            "description": "Axis or axes along which the variance is computed.  The default is to\n    compute the variance of the flattened array.\n\n    .. versionadded:: 1.7.0\n\n    If this is a tuple of ints, a variance is performed over multiple axes,\n    instead of a single axis or all the axes as before."
          },
          "dtype": {
            "type": "data-type, optional",
            "description": "Type to use in computing the variance.  For arrays of integer type\n    the default is `float64`; for arrays of float types it is the same as\n    the array type."
          },
          "out": {
            "type": "ndarray, optional",
            "description": "Alternate output array in which to place the result.  It must have\n    the same shape as the expected output, but the type is cast if\n    necessary."
          },
          "ddof": {
            "type": "int, optional",
            "description": "\"Delta Degrees of Freedom\": the divisor used in the calculation is\n    ``N - ddof``, where ``N`` represents the number of elements. By\n    default `ddof` is zero."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the input array.\n\n    If the default value is passed, then `keepdims` will not be\n    passed through to the `var` method of sub-classes of\n    `ndarray`, however any non-default value will be.  If the\n    sub-class' method does not implement `keepdims` any\n    exceptions will be raised."
          },
          "where": {
            "type": "array_like of bool, optional",
            "description": "Elements to include in the variance. See `~numpy.ufunc.reduce` for\n    details.\n\n    .. versionadded:: 1.20.0"
          }
        },
        "returns": "variance : ndarray, see dtype parameter above\n    If ``out=None``, returns a new array containing the variance;\n    otherwise, a reference to the output array is returned.",
        "raises": "",
        "see_also": "std, mean, nanmean, nanstd, nanvar\n:ref:`ufuncs-output-type`",
        "notes": "The variance is the average of the squared deviations from the mean,\ni.e.,  ``var = mean(x)``, where ``x = abs(a - a.mean())**2``.\n\nThe mean is typically calculated as ``x.sum() / N``, where ``N = len(x)``.\nIf, however, `ddof` is specified, the divisor ``N - ddof`` is used\ninstead.  In standard statistical practice, ``ddof=1`` provides an\nunbiased estimator of the variance of a hypothetical infinite population.\n``ddof=0`` provides a maximum likelihood estimate of the variance for\nnormally distributed variables.\n\nNote that for complex numbers, the absolute value is taken before\nsquaring, so that the result is always real and nonnegative.\n\nFor floating-point input, the variance is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for `float32` (see example\nbelow).  Specifying a higher-accuracy accumulator using the ``dtype``\nkeyword can alleviate this issue.",
        "examples": ">>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([1.,  1.])\n>>> np.var(a, axis=1)\narray([0.25,  0.25])\n\nIn single precision, var() can be inaccurate:\n\n>>> a = np.zeros((2, 512*512), dtype=np.float32)\n>>> a[0, :] = 1.0\n>>> a[1, :] = 0.1\n>>> np.var(a)\n0.20250003\n\nComputing the variance in float64 is more accurate:\n\n>>> np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n>>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n\nSpecifying a where argument:\n\n>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])\n>>> np.var(a)\n6.833333333333333 # may vary\n>>> np.var(a, where=[[True], [True], [False]])\n4.0"
      }
    },
    {
      "name": "vstack",
      "signature": "vstack(x, *args, **params)",
      "docstring": {
        "description": "vstack\n\nStack arrays in sequence vertically (row wise).\n\nThis is equivalent to concatenation along the first axis after 1-D arrays\nof shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by\n`vsplit`.\n\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.\n\n``np.row_stack`` is an alias for `vstack`. They are the same function.",
        "parameters": {
          "tup": {
            "type": "sequence of ndarrays",
            "description": "The arrays must have the same shape along all but the first axis.\n    1-D arrays must have the same length."
          },
          "dtype": {
            "type": "str or dtype",
            "description": "If provided, the destination array will have this dtype. Cannot be\n    provided together with `out`.\n\n.. versionadded:: 1.24"
          },
          "casting": {
            "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
            "description": "Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n.. versionadded:: 1.24"
          }
        },
        "returns": "stacked : ndarray\n    The array formed by stacking the given arrays, will be at least 2-D.",
        "raises": "",
        "see_also": "concatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nblock : Assemble an nd-array from nested lists of blocks.\nhstack : Stack arrays in sequence horizontally (column wise).\ndstack : Stack arrays in sequence depth wise (along third axis).\ncolumn_stack : Stack 1-D arrays as columns into a 2-D array.\nvsplit : Split an array into multiple sub-arrays vertically (row-wise).",
        "notes": "The function is applied to both the _data and the _mask, if any.",
        "examples": ">>> a = np.array([1, 2, 3])\n>>> b = np.array([4, 5, 6])\n>>> np.vstack((a,b))\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n>>> a = np.array([[1], [2], [3]])\n>>> b = np.array([[4], [5], [6]])\n>>> np.vstack((a,b))\narray([[1],\n       [2],\n       [3],\n       [4],\n       [5],\n       [6]])"
      }
    },
    {
      "name": "where",
      "signature": "where(condition, x=<no value>, y=<no value>)",
      "docstring": {
        "description": "Return a masked array with elements from `x` or `y`, depending on condition.\n\n.. note::\n    When only `condition` is provided, this function is identical to\n    `nonzero`. The rest of this documentation covers only the case where\n    all three arguments are provided.",
        "parameters": {
          "condition": {
            "type": "array_like, bool",
            "description": "Where True, yield `x`, otherwise yield `y`.\nx, y : array_like, optional\n    Values from which to choose. `x`, `y` and `condition` need to be\n    broadcastable to some shape."
          }
        },
        "returns": "out : MaskedArray\n    An masked array with `masked` elements where the condition is masked,\n    elements from `x` where `condition` is True, and elements from `y`\n    elsewhere.",
        "raises": "",
        "see_also": "numpy.where : Equivalent function in the top-level NumPy module.\nnonzero : The function that is called when x and y are omitted",
        "notes": "",
        "examples": ">>> x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],\n...                                                    [1, 0, 1],\n...                                                    [0, 1, 0]])\n>>> x\nmasked_array(\n  data=[[0.0, --, 2.0],\n        [--, 4.0, --],\n        [6.0, --, 8.0]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=1e+20)\n>>> np.ma.where(x > 5, x, -3.1416)\nmasked_array(\n  data=[[-3.1416, --, -3.1416],\n        [--, -3.1416, --],\n        [6.0, --, 8.0]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=1e+20)"
      }
    },
    {
      "name": "zeros",
      "signature": "zeros(...)",
      "docstring": {}
    },
    {
      "name": "zeros_like",
      "signature": "zeros_like(...)",
      "docstring": {}
    }
  ],
  "classes": [
    {
      "name": "MAError",
      "docstring": {
        "description": "Class for masked array related errors.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "docstring": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "docstring": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "MaskError",
      "docstring": {
        "description": "Class for mask related errors.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "docstring": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "docstring": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "MaskType",
      "docstring": {
        "description": "Boolean type (True or False), stored as a byte.\n\n.. warning::\n\n   The :class:`bool_` type is not a subclass of the :class:`int_` type\n   (the :class:`bool_` is not even a number type). This is different\n   than Python's default implementation of :class:`bool` as a\n   sub-class of :class:`int`.\n\n:Character code: ``'?'``",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "docstring": {}
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(...)",
          "docstring": {
            "description": "newbyteorder(new_order='S', /)\n\nReturn a new `dtype` with a different byte order.\n\nChanges are also made in all fields and sub-arrays of the data type.\n\nThe `new_order` code can be any from the following:\n\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\n    above.  The default value ('S') results in swapping the current\n    byte order."
              }
            },
            "returns": "new_dtype : dtype\n    New `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "docstring": {}
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "MaskedArray",
      "docstring": {
        "description": "An array class with possibly masked values.\n\nMasked values of True exclude the corresponding element from any\ncomputation.\n\nConstruction::\n\n  x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\n                  ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\n                  shrink=True, order=None)",
        "parameters": {
          "data": {
            "type": "array_like",
            "description": "Input data."
          },
          "mask": {
            "type": "sequence, optional",
            "description": "Mask. Must be convertible to an array of booleans with the same\n    shape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Data type of the output.\n    If `dtype` is None, the type of the data argument (``data.dtype``)\n    is used. If `dtype` is not None and different from ``data.dtype``,\n    a copy is performed."
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to copy the input data (True), or to use a reference instead.\n    Default is False."
          },
          "subok": {
            "type": "bool, optional",
            "description": "Whether to return a subclass of `MaskedArray` if possible (True) or a\n    plain `MaskedArray`. Default is True."
          },
          "ndmin": {
            "type": "int, optional",
            "description": "Minimum number of dimensions. Default is 0."
          },
          "fill_value": {
            "type": "scalar, optional",
            "description": "Value used to fill in the masked values when necessary.\n    If None, a default based on the data-type is used."
          },
          "keep_mask": {
            "type": "bool, optional",
            "description": "Whether to combine `mask` with the mask of the input data, if any\n    (True), or to use only `mask` for the output (False). Default is True."
          },
          "hard_mask": {
            "type": "bool, optional",
            "description": "Whether to use a hard mask or not. With a hard mask, masked values\n    cannot be unmasked. Default is False."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to force compression of an empty mask. Default is True."
          },
          "order": {
            "type": "{'C', 'F', 'A'}, optional",
            "description": "Specify the order of the array.  If order is 'C', then the array\n    will be in C-contiguous order (last-index varies the fastest).\n    If order is 'F', then the returned array will be in\n    Fortran-contiguous order (first-index varies the fastest).\n    If order is 'A' (default), then the returned array may be\n    in any order (either C-, Fortran-contiguous, or even discontiguous),\n    unless a copy is required, in which case it will be C-contiguous."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "The ``mask`` can be initialized with an array of boolean values\nwith the same shape as ``data``.\n\n>>> data = np.arange(6).reshape((2, 3))\n>>> np.ma.MaskedArray(data, mask=[[False, True, False],\n...                               [False, False, True]])\nmasked_array(\n  data=[[0, --, 2],\n        [3, 4, --]],\n  mask=[[False,  True, False],\n        [False, False,  True]],\n  fill_value=999999)\n\nAlternatively, the ``mask`` can be initialized to homogeneous boolean\narray with the same shape as ``data`` by passing in a scalar\nboolean value:\n\n>>> np.ma.MaskedArray(data, mask=False)\nmasked_array(\n  data=[[0, 1, 2],\n        [3, 4, 5]],\n  mask=[[False, False, False],\n        [False, False, False]],\n  fill_value=999999)\n\n>>> np.ma.MaskedArray(data, mask=True)\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=999999,\n  dtype=int64)\n\n.. note::\n    The recommended practice for initializing ``mask`` with a scalar\n    boolean value is to use ``True``/``False`` rather than\n    ``np.True_``/``np.False_``. The reason is :attr:`nomask`\n    is represented internally as ``np.False_``.\n\n    >>> np.False_ is np.ma.nomask\n    True"
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(self, axis=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Returns True if all elements evaluate to True.\n\nThe output array is masked where all the values along the given axis\nare masked: if the output would have been a scalar and that all the\nvalues are masked, then the output is `masked`.\n\nRefer to `numpy.all` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.all : corresponding function for ndarrays\nnumpy.all : equivalent function",
            "notes": "",
            "examples": ">>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue"
          }
        },
        {
          "name": "anom",
          "signature": "anom(self, axis=None, dtype=None)",
          "docstring": {
            "description": "Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.\n\nReturns an array of anomalies, with the same shape as the input and\nwhere the arithmetic mean is computed along the given axis.",
            "parameters": {
              "axis": {
                "type": "int, optional",
                "description": "Axis over which the anomalies are taken.\n    The default is to use the mean of the flattened array as reference."
              },
              "dtype": {
                "type": "dtype, optional",
                "description": "Type to use in computing the variance. For arrays of integer type\n     the default is float32; for arrays of float types it is the same as\n     the array type."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "mean : Compute the mean of the array.",
            "notes": "",
            "examples": ">>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)"
          }
        },
        {
          "name": "any",
          "signature": "any(self, axis=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Returns True if any of the elements of `a` evaluate to True.\n\nMasked values are considered as False during computation.\n\nRefer to `numpy.any` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.any : corresponding function for ndarrays\nnumpy.any : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "docstring": {
            "description": "Returns array of indices of the maximum values along the given axis.\nMasked values are treated as if they had the value fill_value.",
            "parameters": {
              "axis": {
                "type": "{None, integer}",
                "description": "If None, the index is into the flattened array, otherwise along\n    the specified axis"
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.  If None, the output of\n    maximum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None, array}, optional",
                "description": "Array into which the result can be placed. Its type is preserved\n    and it must be of the right shape to hold the output."
              }
            },
            "returns": "index_array : {integer_array}",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])"
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "docstring": {
            "description": "Return array of indices to the minimum values along the given axis.",
            "parameters": {
              "axis": {
                "type": "{None, integer}",
                "description": "If None, the index is into the flattened array, otherwise along\n    the specified axis"
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.  If None, the output of\n    minimum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None, array}, optional",
                "description": "Array into which the result can be placed. Its type is preserved\n    and it must be of the right shape to hold the output."
              }
            },
            "returns": "ndarray or scalar\n    If multi-dimension input, returns a new ndarray of indices to the\n    minimum values along the given axis.  Otherwise, returns a scalar\n    of index to the minimum values along the given axis.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> x\nmasked_array(\n  data=[[--, --],\n        [2, 3]],\n  mask=[[ True,  True],\n        [False, False]],\n  fill_value=999999)\n>>> x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n>>> x.argmin(axis=0, fill_value=9)\narray([1, 1])"
          }
        },
        {
          "name": "argpartition",
          "signature": "argpartition(self, *args, **kwargs)",
          "docstring": {
            "description": "a.argpartition(kth, axis=-1, kind='introselect', order=None)\n\nReturns the indices that would partition this array.\n\nRefer to `numpy.argpartition` for full documentation.\n\n.. versionadded:: 1.8.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.argpartition : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(self, axis=<no value>, kind=None, order=None, endwith=True, fill_value=None)",
          "docstring": {
            "description": "Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\n`fill_value`.",
            "parameters": {
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. If None, the default, the flattened array\n    is used.\n\n    ..  versionchanged:: 1.13.0\n        Previously, the default was documented to be -1, but that was\n        in error. At some future date, the default will change to -1, as\n        originally intended.\n        Until then, the axis should be given explicitly when\n        ``arr.ndim > 1``, to avoid a FutureWarning."
              },
              "kind": {
                "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
                "description": "The sorting algorithm used."
              },
              "order": {
                "type": "list, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\n    which fields to compare first, second, etc.  Not all fields need be\n    specified."
              },
              "endwith": {
                "type": "{True, False}, optional",
                "description": "Whether missing values (if any) should be treated as the largest values\n    (True) or the smallest values (False)\n    When the array contains unmasked values at the same extremes of the\n    datatype, the ordering of these values and the masked values is\n    undefined."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used internally for the masked values.\n    If ``fill_value`` is not None, it supersedes ``endwith``."
              }
            },
            "returns": "index_array : ndarray, int\n    Array of indices that sort `a` along the specified axis.\n    In other words, ``a[index_array]`` yields a sorted `a`.",
            "raises": "",
            "see_also": "ma.MaskedArray.sort : Describes sorting algorithms used.\nlexsort : Indirect stable sort with multiple keys.\nnumpy.ndarray.sort : Inplace sort.",
            "notes": "See `sort` for notes on the different sorting algorithms.",
            "examples": ">>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data=[3, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n>>> a.argsort()\narray([1, 0, 2])"
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "docstring": {
            "description": "a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\n\nCopy of the array, cast to a specified type.",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "Typecode or data-type to which the array is cast."
              },
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout order of the result.\n    'C' means C order, 'F' means Fortran order, 'A'\n    means 'F' order if all the arrays are Fortran contiguous,\n    'C' order otherwise, and 'K' means as close to the\n    order the array elements appear in memory as possible.\n    Default is 'K'."
              },
              "casting": {
                "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
                "description": "Controls what kind of data casting may occur. Defaults to 'unsafe'\n    for backwards compatibility.\n\n      * 'no' means the data types should not be cast at all.\n      * 'equiv' means only byte-order changes are allowed.\n      * 'safe' means only casts which can preserve values are allowed.\n      * 'same_kind' means only safe casts or casts within a kind,\n        like float64 to float32, are allowed.\n      * 'unsafe' means any data conversions may be done."
              },
              "subok": {
                "type": "bool, optional",
                "description": "If True, then sub-classes will be passed-through (default), otherwise\n    the returned array will be forced to be a base-class array."
              },
              "copy": {
                "type": "bool, optional",
                "description": "By default, astype always returns a newly allocated array. If this\n    is set to false, and the `dtype`, `order`, and `subok`\n    requirements are satisfied, the input array is returned instead\n    of a copy."
              }
            },
            "returns": "arr_t : ndarray\n    Unless `copy` is False and the other conditions for returning the input\n    array are satisfied (see description for `copy` input parameter), `arr_t`\n    is a new array of the same shape as the input array, with dtype, order\n    given by `dtype`, `order`.",
            "raises": "ComplexWarning\n    When casting from complex to float or int. To avoid this,\n    one should use ``a.real.astype(t)``.",
            "see_also": "",
            "notes": ".. versionchanged:: 1.17.0\n   Casting between a simple data type and a structured one is possible only\n   for \"unsafe\" casting.  Casting to multiple fields is allowed, but\n   casting from multiple fields is not.\n\n.. versionchanged:: 1.9.0\n   Casting from numeric to string types in 'safe' casting mode requires\n   that the string dtype length is long enough to store the max\n   integer/float value converted.",
            "examples": ">>> x = np.array([1, 2, 2.5])\n>>> x\narray([1. ,  2. ,  2.5])\n\n>>> x.astype(int)\narray([1, 2, 2])"
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "docstring": {
            "description": "a.byteswap(inplace=False)\n\nSwap the bytes of the array elements\n\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.",
            "parameters": {
              "inplace": {
                "type": "bool, optional",
                "description": "If ``True``, swap bytes in-place, default is ``False``."
              }
            },
            "returns": "out : ndarray\n    The byteswapped array. If `inplace` is ``True``, this is\n    a view to self.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> list(map(hex, A))\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n>>> list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\nArrays of byte-strings are not swapped\n\n>>> A = np.array([b'ceg', b'fac'])\n>>> A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n``A.newbyteorder().byteswap()`` produces an array with the same values\n  but different representation in memory\n\n>>> A = np.array([1, 2, 3])\n>>> A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n>>> A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n>>> A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)"
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "docstring": {
            "description": "a.choose(choices, out=None, mode='raise')\n\nUse an index array to construct a new array from a set of choices.\n\nRefer to `numpy.choose` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.choose : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "docstring": {
            "description": "a.clip(min=None, max=None, out=None, **kwargs)\n\nReturn an array whose values are limited to ``[min, max]``.\nOne of max or min must be given.\n\nRefer to `numpy.clip` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.clip : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(self, condition, axis=None, out=None)",
          "docstring": {
            "description": "Return `a` where condition is ``True``.\n\nIf condition is a `~ma.MaskedArray`, missing values are considered\nas ``False``.",
            "parameters": {
              "condition": {
                "type": "var",
                "description": "Boolean 1-d array selecting which entries to return. If len(condition)\n    is less than the size of a along the axis, then output is truncated\n    to length of condition array."
              },
              "axis": {
                "type": "{None, int}, optional",
                "description": "Axis along which the operation must be performed."
              },
              "out": {
                "type": "{None, ndarray}, optional",
                "description": "Alternative output array in which to place the result. It must have\n    the same shape as the expected output but the type will be cast if\n    necessary."
              }
            },
            "returns": "result : MaskedArray\n    A :class:`~ma.MaskedArray` object.",
            "raises": "",
            "see_also": "",
            "notes": "Please note the difference with :meth:`compressed` !\nThe output of :meth:`compress` has a mask, the output of\n:meth:`compressed` does not.",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\n             mask=[False, False],\n       fill_value=999999)\n\n>>> x.compress([1, 0, 1], axis=1)\nmasked_array(\n  data=[[1, 3],\n        [--, --],\n        [7, 9]],\n  mask=[[False, False],\n        [ True,  True],\n        [False, False]],\n  fill_value=999999)"
          }
        },
        {
          "name": "compressed",
          "signature": "compressed(self)",
          "docstring": {
            "description": "Return all the non-masked data as a 1-D array.",
            "parameters": {},
            "returns": "data : ndarray\n    A new `ndarray` holding the non-masked data is returned.",
            "raises": "",
            "see_also": "",
            "notes": "The result is **not** a MaskedArray!",
            "examples": ">>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n>>> x.compressed()\narray([0, 1])\n>>> type(x.compressed())\n<class 'numpy.ndarray'>"
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "docstring": {
            "description": "a.conj()\n\nComplex-conjugate all elements.\n\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "docstring": {
            "description": "a.conjugate()\n\nReturn the complex conjugate, element-wise.\n\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(self, *args, **params)",
          "docstring": {
            "description": "a.copy(order='C')\n\nReturn a copy of the array.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout of the copy. 'C' means C-order,\n    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n    'C' otherwise. 'K' means match the layout of `a` as closely\n    as possible. (Note that this function and :func:`numpy.copy` are very\n    similar but have different default values for their order=\n    arguments, and this function always passes sub-classes through.)\n\nSee also\n--------"
              },
              "numpy.copy": {
                "type": "Similar function with different default behavior",
                "description": "numpy.copyto"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "This function is the preferred method for creating an array copy.  The\nfunction :func:`numpy.copy` is similar, but it defaults to using order 'K',\nand will not pass sub-classes through by default.",
            "examples": ">>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n>>> y = x.copy()\n\n>>> x.fill(0)\n\n>>> x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n>>> y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n>>> y.flags['C_CONTIGUOUS']\nTrue"
          }
        },
        {
          "name": "count",
          "signature": "count(self, axis=None, keepdims=<no value>)",
          "docstring": {
            "description": "Count the non-masked elements of the array along the given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis or axes along which the count is performed.\n    The default, None, performs the count over all\n    the dimensions of the input array. `axis` may be negative, in\n    which case it counts from the last to the first axis.\n\n    .. versionadded:: 1.10.0\n\n    If this is a tuple of ints, the count is performed on multiple\n    axes, instead of a single axis or all the axes as before."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
              }
            },
            "returns": "result : ndarray or scalar\n    An array with the same shape as the input array, with the specified\n    axis removed. If the array is a 0-d array, or if `axis` is None, a\n    scalar is returned.",
            "raises": "",
            "see_also": "ma.count_masked : Count masked elements in array or along a given axis.",
            "notes": "",
            "examples": ">>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, --, --]],\n  mask=[[False, False, False],\n        [ True,  True,  True]],\n  fill_value=999999)\n>>> a.count()\n3\n\nWhen the `axis` keyword is specified an array of appropriate size is\nreturned.\n\n>>> a.count(axis=0)\narray([1, 1, 1])\n>>> a.count(axis=1)\narray([3, 0])"
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(self, axis=None, dtype=None, out=None)",
          "docstring": {
            "description": "Return the cumulative product of the array elements over the given axis.\n\nMasked values are set to 1 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\n\nRefer to `numpy.cumprod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.cumprod : corresponding function for ndarrays\nnumpy.cumprod : equivalent function",
            "notes": "The mask is lost if `out` is not a valid MaskedArray !\n\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(self, axis=None, dtype=None, out=None)",
          "docstring": {
            "description": "Return the cumulative sum of the array elements over the given axis.\n\nMasked values are set to 0 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\n\nRefer to `numpy.cumsum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.cumsum : corresponding function for ndarrays\nnumpy.cumsum : equivalent function",
            "notes": "The mask is lost if `out` is not a valid :class:`ma.MaskedArray` !\n\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
            "examples": ">>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n             mask=[False, False, False,  True,  True,  True, False, False,\n                   False, False],\n       fill_value=999999)"
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(self, *args, **params)",
          "docstring": {
            "description": "a.diagonal(offset=0, axis1=0, axis2=1)\n\nReturn specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\n\nRefer to :func:`numpy.diagonal` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.diagonal : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dot",
          "signature": "dot(self, b, out=None, strict=False)",
          "docstring": {
            "description": "a.dot(b, out=None)\n\nMasked dot product of two arrays. Note that `out` and `strict` are\nlocated in different positions than in `ma.dot`. In order to\nmaintain compatibility with the functional version, it is\nrecommended that the optional arguments be treated as keyword only.\nAt some point that may be mandatory.\n\n.. versionadded:: 1.10.0",
            "parameters": {
              "b": {
                "type": "masked_array_like",
                "description": "Inputs array."
              },
              "out": {
                "type": "masked_array, optional",
                "description": "Output argument. This must have the exact kind that would be\n    returned if it was not used. In particular, it must have the\n    right type, must be C-contiguous, and its dtype must be the\n    dtype that would be returned for `ma.dot(a,b)`. This is a\n    performance feature. Therefore, if these conditions are not\n    met, an exception is raised, instead of attempting to be\n    flexible."
              },
              "strict": {
                "type": "bool, optional",
                "description": "Whether masked data are propagated (True) or set to 0 (False)\n    for the computation. Default is False.  Propagating the mask\n    means that if a masked value appears in a row or column, the\n    whole row or column is considered masked.\n\n    .. versionadded:: 1.10.2"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "numpy.ma.dot : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "docstring": {
            "description": "a.dump(file)\n\nDump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.",
            "parameters": {
              "file": {
                "type": "str or Path",
                "description": "A string naming the dump file.\n\n    .. versionchanged:: 1.17.0\n        `pathlib.Path` objects are now accepted."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "docstring": {
            "description": "a.dumps()\n\nReturns the pickle of the array as a string.\npickle.loads will convert the string back to an array.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "docstring": {
            "description": "a.fill(value)\n\nFill the array with a scalar value.",
            "parameters": {
              "value": {
                "type": "scalar",
                "description": "All elements of `a` will be assigned this value."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([1.,  1.])\n\nFill expects a scalar value and always behaves the same as assigning\nto a single array element.  The following is a rare example where this\ndistinction is important:\n\n>>> a = np.array([None, None], dtype=object)\n>>> a[0] = np.array(3)\n>>> a\narray([array(3), None], dtype=object)\n>>> a.fill(np.array(3))\n>>> a\narray([array(3), array(3)], dtype=object)\n\nWhere other forms of assignments will unpack the array being assigned:\n\n>>> a[...] = np.array(3)\n>>> a\narray([3, 3], dtype=object)"
          }
        },
        {
          "name": "filled",
          "signature": "filled(self, fill_value=None)",
          "docstring": {
            "description": "Return a copy of self, with masked values filled with a given value.\n**However**, if there are no masked values to fill, self will be\nreturned instead as an ndarray.",
            "parameters": {
              "fill_value": {
                "type": "array_like, optional",
                "description": "The value to use for invalid entries. Can be scalar or non-scalar.\n    If non-scalar, the resulting ndarray must be broadcastable over\n    input array. Default is None, in which case, the `fill_value`\n    attribute of the array is used instead."
              }
            },
            "returns": "filled_array : ndarray\n    A copy of ``self`` with invalid entries replaced by *fill_value*\n    (be it the function argument or the attribute of ``self``), or\n    ``self`` itself as an ndarray if there are no invalid entries to\n    be replaced.",
            "raises": "",
            "see_also": "",
            "notes": "The result is **not** a MaskedArray!",
            "examples": ">>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n>>> x.filled()\narray([   1,    2, -999,    4, -999])\n>>> x.filled(fill_value=1000)\narray([   1,    2, 1000,    4, 1000])\n>>> type(x.filled())\n<class 'numpy.ndarray'>\n\nSubclassing is preserved. This means that if, e.g., the data part of\nthe masked array is a recarray, `filled` returns a recarray:\n\n>>> x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)\n>>> m = np.ma.array(x, mask=[(True, False), (False, True)])\n>>> m.filled()\nrec.array([(999999,      2), (    -3, 999999)],\n          dtype=[('f0', '<i8'), ('f1', '<i8')])"
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(self, *args, **params)",
          "docstring": {
            "description": "a.flatten(order='C')\n\nReturn a copy of the array collapsed into one dimension.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "'C' means to flatten in row-major (C-style) order.\n    'F' means to flatten in column-major (Fortran-\n    style) order. 'A' means to flatten in column-major\n    order if `a` is Fortran *contiguous* in memory,\n    row-major order otherwise. 'K' means to flatten\n    `a` in the order the elements occur in memory.\n    The default is 'C'."
              }
            },
            "returns": "y : ndarray\n    A copy of the input array, flattened to one dimension.",
            "raises": "",
            "see_also": "ravel : Return a flattened array.\nflat : A 1-D flat iterator over the array.",
            "notes": "",
            "examples": ">>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])"
          }
        },
        {
          "name": "get_fill_value",
          "signature": "fill_value(self)",
          "docstring": {
            "description": "The filling value of the masked array is a scalar. When setting, None\nwill set to a default based on the data type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n\n>>> x = np.ma.array([0, 1.], fill_value=-np.inf)\n>>> x.fill_value\n-inf\n>>> x.fill_value = np.pi\n>>> x.fill_value\n3.1415926535897931 # may vary\n\nReset to default:\n\n>>> x.fill_value = None\n>>> x.fill_value\n1e+20"
          }
        },
        {
          "name": "get_imag",
          "signature": "imag(self)",
          "docstring": {
            "description": "The imaginary part of the masked array.\n\nThis property is a view on the imaginary part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "real",
            "notes": "",
            "examples": ">>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.imag\nmasked_array(data=[1.0, --, 1.6],\n             mask=[False,  True, False],\n       fill_value=1e+20)"
          }
        },
        {
          "name": "get_real",
          "signature": "real(self)",
          "docstring": {
            "description": "The real part of the masked array.\n\nThis property is a view on the real part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "imag",
            "notes": "",
            "examples": ">>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.real\nmasked_array(data=[1.0, --, 3.45],\n             mask=[False,  True, False],\n       fill_value=1e+20)"
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "docstring": {
            "description": "a.getfield(dtype, offset=0)\n\nReturns a field of the given array as a certain type.\n\nA field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "The data type of the view. The dtype size of the view can not be larger\n    than that of the array itself."
              },
              "offset": {
                "type": "int",
                "description": "Number of bytes to skip before beginning the element view."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n\n>>> x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])"
          }
        },
        {
          "name": "harden_mask",
          "signature": "harden_mask(self)",
          "docstring": {
            "description": "Force the mask to hard, preventing unmasking by assignment.\n\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `harden_mask` sets\n`~ma.MaskedArray.hardmask` to ``True`` (and returns the modified\nself).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "ma.MaskedArray.hardmask\nma.MaskedArray.soften_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ids",
          "signature": "ids(self)",
          "docstring": {
            "description": "Return the addresses of the data and mask areas.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n>>> x.ids()\n(166670640, 166659832) # may vary\n\nIf the array has no mask, the address of `nomask` is returned. This address\nis typically not close to the data in memory:\n\n>>> x = np.ma.array([1, 2, 3])\n>>> x.ids()\n(166691080, 3083169284) # may vary"
          }
        },
        {
          "name": "iscontiguous",
          "signature": "iscontiguous(self)",
          "docstring": {
            "description": "Return a boolean indicating whether the data is contiguous.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([1, 2, 3])\n>>> x.iscontiguous()\nTrue\n\n`iscontiguous` returns one of the flags of the masked array:\n\n>>> x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : True\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False"
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "docstring": {
            "description": "a.item(*args)\n\nCopy an element of an array to a standard Python scalar and return it.",
            "parameters": {
              "\\*args": {
                "type": "Arguments (variable number and type)",
                "description": "* none: in this case, the method only works for arrays\n      with one element (`a.size == 1`), which element is\n      copied into a standard Python scalar object and returned.\n\n    * int_type: this argument is interpreted as a flat index into\n      the array, specifying which element to copy and return.\n\n    * tuple of int_types: functions as does a single int_type argument,\n      except that the argument is interpreted as an nd-index into the\n      array."
              }
            },
            "returns": "z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable\n    Python scalar",
            "raises": "",
            "see_also": "",
            "notes": "When the data type of `a` is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\n\n`item` is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python's optimized math.",
            "examples": ">>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n>>> x.item(3)\n1\n>>> x.item(7)\n0\n>>> x.item((0, 1))\n2\n>>> x.item((2, 2))\n1"
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "docstring": {
            "description": "a.itemset(*args)\n\nInsert scalar into an array (scalar is cast to array's dtype, if possible)\n\nThere must be at least 1 argument, and define the last argument\nas *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster\nthan ``a[args] = item``.  The item should be a scalar value and `args`\nmust select a single item in the array `a`.",
            "parameters": {
              "\\*args": {
                "type": "Arguments",
                "description": "If one argument: a scalar, only used in case `a` is of size 1.\n    If two arguments: the last argument is the value to be set\n    and must be a scalar, the first argument specifies a single array\n    element location. It is either an int or a tuple."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "Compared to indexing syntax, `itemset` provides some speed increase\nfor placing a scalar into a particular location in an `ndarray`,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using `itemset` (and `item`) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.",
            "examples": ">>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])"
          }
        },
        {
          "name": "max",
          "signature": "max(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the maximum along a given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis along which to operate.  By default, ``axis`` is None and the\n    flattened input is used.\n    .. versionadded:: 1.7.0\n    If this is a tuple of ints, the maximum is selected over multiple\n    axes, instead of a single axis or all the axes as before."
              },
              "out": {
                "type": "array_like, optional",
                "description": "Alternative output array in which to place the result.  Must\n    be of the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.\n    If None, use the output of maximum_fill_value()."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
              }
            },
            "returns": "amax : array_like\n    New array holding the result.\n    If ``out`` was specified, ``out`` is returned.",
            "raises": "",
            "see_also": "ma.maximum_fill_value\n    Returns the maximum filling value for a given datatype.",
            "notes": "",
            "examples": ">>> import numpy.ma as ma\n>>> x = [[-1., 2.5], [4., -2.], [3., 0.]]\n>>> mask = [[0, 0], [1, 0], [1, 0]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\n  data=[[-1.0, 2.5],\n        [--, -2.0],\n        [--, 0.0]],\n  mask=[[False, False],\n        [ True, False],\n        [ True, False]],\n  fill_value=1e+20)\n>>> ma.max(masked_x)\n2.5\n>>> ma.max(masked_x, axis=0)\nmasked_array(data=[-1.0, 2.5],\n             mask=[False, False],\n       fill_value=1e+20)\n>>> ma.max(masked_x, axis=1, keepdims=True)\nmasked_array(\n  data=[[2.5],\n        [-2.0],\n        [0.0]],\n  mask=[[False],\n        [False],\n        [False]],\n  fill_value=1e+20)\n>>> mask = [[1, 1], [1, 1], [1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.max(masked_x, axis=1)\nmasked_array(data=[--, --, --],\n             mask=[ True,  True,  True],\n       fill_value=1e+20,\n            dtype=float64)"
          }
        },
        {
          "name": "mean",
          "signature": "mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Returns the average of the array elements along given axis.\n\nMasked entries are ignored, and result elements which are not\nfinite will be masked.\n\nRefer to `numpy.mean` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.mean : corresponding function for ndarrays\nnumpy.mean : Equivalent function\nnumpy.ma.average : Weighted average.",
            "notes": "",
            "examples": ">>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data=[1, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n>>> a.mean()\n1.5"
          }
        },
        {
          "name": "min",
          "signature": "min(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the minimum along a given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis along which to operate.  By default, ``axis`` is None and the\n    flattened input is used.\n    .. versionadded:: 1.7.0\n    If this is a tuple of ints, the minimum is selected over multiple\n    axes, instead of a single axis or all the axes as before."
              },
              "out": {
                "type": "array_like, optional",
                "description": "Alternative output array in which to place the result.  Must be of\n    the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.\n    If None, use the output of `minimum_fill_value`."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
              }
            },
            "returns": "amin : array_like\n    New array holding the result.\n    If ``out`` was specified, ``out`` is returned.",
            "raises": "",
            "see_also": "ma.minimum_fill_value\n    Returns the minimum filling value for a given datatype.",
            "notes": "",
            "examples": ">>> import numpy.ma as ma\n>>> x = [[1., -2., 3.], [0.2, -0.7, 0.1]]\n>>> mask = [[1, 1, 0], [0, 0, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\n  data=[[--, --, 3.0],\n        [0.2, -0.7, --]],\n  mask=[[ True,  True, False],\n        [False, False,  True]],\n  fill_value=1e+20)\n>>> ma.min(masked_x)\n-0.7\n>>> ma.min(masked_x, axis=-1)\nmasked_array(data=[3.0, -0.7],\n             mask=[False, False],\n        fill_value=1e+20)\n>>> ma.min(masked_x, axis=0, keepdims=True)\nmasked_array(data=[[0.2, -0.7, 3.0]],\n             mask=[[False, False, False]],\n        fill_value=1e+20)\n>>> mask = [[1, 1, 1,], [1, 1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.min(masked_x, axis=0)\nmasked_array(data=[--, --, --],\n             mask=[ True,  True,  True],\n        fill_value=1e+20,\n            dtype=float64)"
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(...)",
          "docstring": {
            "description": "arr.newbyteorder(new_order='S', /)\n\nReturn the array with the same data viewed with a different byte order.\n\nEquivalent to::\n\n    arr.view(arr.dtype.newbytorder(new_order))\n\nChanges are also made in all fields and sub-arrays of the array data\ntype.",
            "parameters": {
              "new_order": {
                "type": "string, optional",
                "description": "Byte order to force; a value from the byte order specifications\n    below. `new_order` codes can be any of:\n\n    * 'S' - swap dtype from current to opposite endian\n    * {'<', 'little'} - little endian\n    * {'>', 'big'} - big endian\n    * {'=', 'native'} - native order, equivalent to `sys.byteorder`\n    * {'|', 'I'} - ignore (no change to byte order)\n\n    The default value ('S') results in swapping the current\n    byte order."
              }
            },
            "returns": "new_arr : array\n    New array object with the dtype reflecting given change to the\n    byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(self)",
          "docstring": {
            "description": "Return the indices of unmasked elements that are not zero.\n\nReturns a tuple of arrays, one for each dimension, containing the\nindices of the non-zero elements in that dimension. The corresponding\nnon-zero values can be obtained with::\n\n    a[a.nonzero()]\n\nTo group the indices by element, rather than dimension, use\ninstead::\n\n    np.transpose(a.nonzero())\n\nThe result of this is always a 2d array, with a row for each non-zero\nelement.",
            "parameters": {},
            "returns": "tuple_of_arrays : tuple\n    Indices of elements that are non-zero.",
            "raises": "",
            "see_also": "numpy.nonzero :\n    Function operating on ndarrays.\nflatnonzero :\n    Return indices that are non-zero in the flattened version of the input\n    array.\nnumpy.ndarray.nonzero :\n    Equivalent ndarray method.\ncount_nonzero :\n    Counts the number of non-zero elements in the input array.",
            "notes": "",
            "examples": ">>> import numpy.ma as ma\n>>> x = ma.array(np.eye(3))\n>>> x\nmasked_array(\n  data=[[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]],\n  mask=False,\n  fill_value=1e+20)\n>>> x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\n\nMasked elements are ignored.\n\n>>> x[1, 1] = ma.masked\n>>> x\nmasked_array(\n  data=[[1.0, 0.0, 0.0],\n        [0.0, --, 0.0],\n        [0.0, 0.0, 1.0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1e+20)\n>>> x.nonzero()\n(array([0, 2]), array([0, 2]))\n\nIndices can also be grouped by element.\n\n>>> np.transpose(x.nonzero())\narray([[0, 0],\n       [2, 2]])\n\nA common use for ``nonzero`` is to find the indices of an array, where\na condition is True.  Given an array `a`, the condition `a` > 3 is a\nboolean array and since False is interpreted as 0, ma.nonzero(a > 3)\nyields the indices of the `a` where the condition is true.\n\n>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n>>> a > 3\nmasked_array(\n  data=[[False, False, False],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  mask=False,\n  fill_value=True)\n>>> ma.nonzero(a > 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\nThe ``nonzero`` method of the condition array can also be called.\n\n>>> (a > 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))"
          }
        },
        {
          "name": "partition",
          "signature": "partition(self, *args, **kwargs)",
          "docstring": {
            "description": "a.partition(kth, axis=-1, kind='introselect', order=None)\n\nRearranges the elements in the array in such a way that the value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.\n\n.. versionadded:: 1.8.0",
            "parameters": {
              "kth": {
                "type": "int or sequence of ints",
                "description": "Element index to partition by. The kth element value will be in its\n    final sorted position and all smaller elements will be moved before it\n    and all equal or greater elements behind it.\n    The order of all elements in the partitions is undefined.\n    If provided with a sequence of kth it will partition all elements\n    indexed by kth of them into their sorted position at once.\n\n    .. deprecated:: 1.22.0\n        Passing booleans as index is deprecated."
              },
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. Default is -1, which means sort along the\n    last axis."
              },
              "kind": {
                "type": "{'introselect'}, optional",
                "description": "Selection algorithm. Default is 'introselect'."
              },
              "order": {
                "type": "str or list of str, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\n    which fields to compare first, second, etc. A single field can\n    be specified as a string, and not all fields need to be specified,\n    but unspecified fields will still be used, in the order in which\n    they come up in the dtype, to break ties."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "numpy.partition : Return a partitioned copy of an array.\nargpartition : Indirect partition.\nsort : Full sort.",
            "notes": "See ``np.partition`` for notes on the different algorithms.",
            "examples": ">>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])\n\n>>> a.partition((1, 3))\n>>> a\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "prod",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the product of the array elements over the given axis.\n\nMasked elements are set to 1 internally for computation.\n\nRefer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
            "notes": "Arithmetic is modular when using integer types, and no error is raised\non overflow.",
            "examples": ""
          }
        },
        {
          "name": "product",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the product of the array elements over the given axis.\n\nMasked elements are set to 1 internally for computation.\n\nRefer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
            "notes": "Arithmetic is modular when using integer types, and no error is raised\non overflow.",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(self, axis=None, out=None, fill_value=None, keepdims=False)",
          "docstring": {
            "description": "Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).\n\n.. warning::\n    `ptp` preserves the data type of the array. This means the\n    return value for an input of signed integers with n bits\n    (e.g. `np.int8`, `np.int16`, etc) is also a signed integer\n    with n bits.  In that case, peak-to-peak values greater than\n    ``2**(n-1)-1`` will be returned as negative values. An example\n    with a work-around is shown below.",
            "parameters": {
              "axis": {
                "type": "{None, int}, optional",
                "description": "Axis along which to find the peaks.  If None (default) the\n    flattened array is used."
              },
              "out": {
                "type": "{None, array_like}, optional",
                "description": "Alternative output array in which to place the result. It must\n    have the same shape and buffer length as the expected output\n    but the type will be cast if necessary."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
              }
            },
            "returns": "ptp : ndarray.\n    A new array holding the result, unless ``out`` was\n    specified, in which case a reference to ``out`` is returned.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.MaskedArray([[4, 9, 2, 10],\n...                        [6, 9, 7, 12]])\n\n>>> x.ptp(axis=1)\nmasked_array(data=[8, 6],\n             mask=False,\n       fill_value=999999)\n\n>>> x.ptp(axis=0)\nmasked_array(data=[2, 0, 5, 2],\n             mask=False,\n       fill_value=999999)\n\n>>> x.ptp()\n10\n\nThis example shows that a negative value can be returned when\nthe input is an array of signed integers.\n\n>>> y = np.ma.MaskedArray([[1, 127],\n...                        [0, 127],\n...                        [-1, 127],\n...                        [-2, 127]], dtype=np.int8)\n>>> y.ptp(axis=1)\nmasked_array(data=[ 126,  127, -128, -127],\n             mask=False,\n       fill_value=999999,\n            dtype=int8)\n\nA work-around is to use the `view()` method to view the result as\nunsigned integers with the same bit width:\n\n>>> y.ptp(axis=1).view(np.uint8)\nmasked_array(data=[126, 127, 128, 129],\n             mask=False,\n       fill_value=999999,\n            dtype=uint8)"
          }
        },
        {
          "name": "put",
          "signature": "put(self, indices, values, mode='raise')",
          "docstring": {
            "description": "Set storage-indexed locations to corresponding values.\n\nSets self._data.flat[n] = values[n] for each n in indices.\nIf `values` is shorter than `indices` then it will repeat.\nIf `values` has some masked values, the initial mask is updated\nin consequence, else the corresponding values are unmasked.",
            "parameters": {
              "indices": {
                "type": "1-D array_like",
                "description": "Target indices, interpreted as integers."
              },
              "values": {
                "type": "array_like",
                "description": "Values to place in self._data copy at target indices."
              },
              "mode": {
                "type": "{'raise', 'wrap', 'clip'}, optional",
                "description": "Specifies how out-of-bounds indices will behave.\n    'raise' : raise an error.\n    'wrap' : wrap around.\n    'clip' : clip to the range."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "`values` can be a scalar or length 1 array.",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.put([0,4,8],[10,20,30])\n>>> x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 20, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n\n>>> x.put(4,999)\n>>> x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 999, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)"
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(self, order='C')",
          "docstring": {
            "description": "Returns a 1D version of self, as a view.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "The elements of `a` are read using this index order. 'C' means to\n    index the elements in C-like order, with the last axis index\n    changing fastest, back to the first axis index changing slowest.\n    'F' means to index the elements in Fortran-like index order, with\n    the first index changing fastest, and the last index changing\n    slowest. Note that the 'C' and 'F' options take no account of the\n    memory layout of the underlying array, and only refer to the order\n    of axis indexing.  'A' means to read the elements in Fortran-like\n    index order if `m` is Fortran *contiguous* in memory, C-like order\n    otherwise.  'K' means to read the elements in the order they occur\n    in memory, except for reversing the data when strides are negative.\n    By default, 'C' index order is used.\n    (Masked arrays currently use 'A' on the data when 'K' is passed.)"
              }
            },
            "returns": "MaskedArray\n    Output view is of shape ``(self.size,)`` (or\n    ``(np.ma.product(self.shape),)``).",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\n             mask=[False,  True, False,  True, False,  True, False,  True,\n                   False],\n       fill_value=999999)"
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(self, *args, **params)",
          "docstring": {
            "description": "a.repeat(repeats, axis=None)\n\nRepeat elements of an array.\n\nRefer to `numpy.repeat` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.repeat : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(self, *s, **kwargs)",
          "docstring": {
            "description": "Give a new shape to the array without changing its data.\n\nReturns a masked array containing the same data, but with a new shape.\nThe result is a view on the original array; if this is not possible, a\nValueError is raised.",
            "parameters": {
              "shape": {
                "type": "int or tuple of ints",
                "description": "The new shape should be compatible with the original shape. If an\n    integer is supplied, then the result will be a 1-D array of that\n    length."
              },
              "order": {
                "type": "{'C', 'F'}, optional",
                "description": "Determines whether the array data should be viewed as in C\n    (row-major) or FORTRAN (column-major) order."
              }
            },
            "returns": "reshaped_array : array\n    A new view on the array.",
            "raises": "",
            "see_also": "reshape : Equivalent function in the masked array module.\nnumpy.ndarray.reshape : Equivalent method on ndarray object.\nnumpy.reshape : Equivalent function in the NumPy module.",
            "notes": "The reshaping operation cannot guarantee that a copy will not be made,\nto modify the shape in place, use ``a.shape = s``",
            "examples": ">>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n>>> x\nmasked_array(\n  data=[[--, 2],\n        [3, --]],\n  mask=[[ True, False],\n        [False,  True]],\n  fill_value=999999)\n>>> x = x.reshape((4,1))\n>>> x\nmasked_array(\n  data=[[--],\n        [2],\n        [3],\n        [--]],\n  mask=[[ True],\n        [False],\n        [False],\n        [ True]],\n  fill_value=999999)"
          }
        },
        {
          "name": "resize",
          "signature": "resize(self, newshape, refcheck=True, order=False)",
          "docstring": {
            "description": ".. warning::\n\n    This method does nothing, except raise a ValueError exception. A\n    masked array does not own its data and therefore cannot safely be\n    resized in place. Use the `numpy.ma.resize` function instead.\n\nThis method is difficult to implement safely and may be deprecated in\nfuture releases of NumPy.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(self, decimals=0, out=None)",
          "docstring": {
            "description": "Return each element rounded to the given number of decimals.\n\nRefer to `numpy.around` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.round : corresponding function for ndarrays\nnumpy.around : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "docstring": {
            "description": "a.searchsorted(v, side='left', sorter=None)\n\nFind indices where elements of v should be inserted in a to maintain order.\n\nFor full documentation, see `numpy.searchsorted`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.searchsorted : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_fill_value",
          "signature": "fill_value(self, value=None)",
          "docstring": {}
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "docstring": {
            "description": "a.setfield(val, dtype, offset=0)\n\nPut a value into a specified place in a field defined by a data-type.\n\nPlace `val` into `a`'s field defined by `dtype` and beginning `offset`\nbytes into the field.",
            "parameters": {
              "val": {
                "type": "object",
                "description": "Value to be placed in field."
              },
              "dtype": {
                "type": "dtype object",
                "description": "Data-type of the field in which to place `val`."
              },
              "offset": {
                "type": "int, optional",
                "description": "The number of bytes into the field at which to place `val`."
              }
            },
            "returns": "None",
            "raises": "",
            "see_also": "getfield",
            "notes": "",
            "examples": ">>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n>>> x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])"
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "docstring": {
            "description": "a.setflags(write=None, align=None, uic=None)\n\nSet array flags WRITEABLE, ALIGNED, WRITEBACKIFCOPY,\nrespectively.\n\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by `a` (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and flag can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)",
            "parameters": {
              "write": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` can be written to."
              },
              "align": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is aligned properly for its type."
              },
              "uic": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is a copy of another \"base\" array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "Array flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, WRITEABLE, and ALIGNED.\n\nWRITEABLE (W) the data area can be written to;\n\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\n\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\n\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.",
            "examples": ">>> y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: cannot set WRITEBACKIFCOPY flag to True"
          }
        },
        {
          "name": "shrink_mask",
          "signature": "shrink_mask(self)",
          "docstring": {
            "description": "Reduce a mask to nomask when possible.",
            "parameters": {},
            "returns": "None",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n>>> x.mask\narray([[False, False],\n       [False, False]])\n>>> x.shrink_mask()\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n>>> x.mask\nFalse"
          }
        },
        {
          "name": "soften_mask",
          "signature": "soften_mask(self)",
          "docstring": {
            "description": "Force the mask to soft (default), allowing unmasking by assignment.\n\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `soften_mask` sets\n`~ma.MaskedArray.hardmask` to ``False`` (and returns the modified\nself).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "ma.MaskedArray.hardmask\nma.MaskedArray.harden_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(self, axis=-1, kind=None, order=None, endwith=True, fill_value=None)",
          "docstring": {
            "description": "Sort the array, in-place",
            "parameters": {
              "a": {
                "type": "array_like",
                "description": "Array to be sorted."
              },
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. If None, the array is flattened before\n    sorting. The default is -1, which sorts along the last axis."
              },
              "kind": {
                "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
                "description": "The sorting algorithm used."
              },
              "order": {
                "type": "list, optional",
                "description": "When `a` is a structured array, this argument specifies which fields\n    to compare first, second, and so on.  This list does not need to\n    include all of the fields."
              },
              "endwith": {
                "type": "{True, False}, optional",
                "description": "Whether missing values (if any) should be treated as the largest values\n    (True) or the smallest values (False)\n    When the array contains unmasked values sorting at the same extremes of the\n    datatype, the ordering of these values and the masked values is\n    undefined."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used internally for the masked values.\n    If ``fill_value`` is not None, it supersedes ``endwith``."
              }
            },
            "returns": "sorted_array : ndarray\n    Array of the same type and shape as `a`.",
            "raises": "",
            "see_also": "numpy.ndarray.sort : Method to sort an array in-place.\nargsort : Indirect sort.\nlexsort : Indirect stable sort on multiple keys.\nsearchsorted : Find elements in a sorted array.",
            "notes": "See ``sort`` for notes on the different sorting algorithms.",
            "examples": ">>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Default\n>>> a.sort()\n>>> a\nmasked_array(data=[1, 3, 5, --, --],\n             mask=[False, False, False,  True,  True],\n       fill_value=999999)\n\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Put missing values in the front\n>>> a.sort(endwith=False)\n>>> a\nmasked_array(data=[--, --, 1, 3, 5],\n             mask=[ True,  True, False, False, False],\n       fill_value=999999)\n\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # fill_value takes over endwith\n>>> a.sort(endwith=False, fill_value=3)\n>>> a\nmasked_array(data=[1, --, --, 3, 5],\n             mask=[False,  True,  True, False, False],\n       fill_value=999999)"
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(self, *args, **params)",
          "docstring": {
            "description": "a.squeeze(axis=None)\n\nRemove axes of length one from `a`.\n\nRefer to `numpy.squeeze` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.squeeze : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "docstring": {
            "description": "Returns the standard deviation of the array elements along given axis.\n\nMasked entries are ignored.\n\nRefer to `numpy.std` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.std : corresponding function for ndarrays\nnumpy.std : Equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the sum of the array elements over the given axis.\n\nMasked elements are set to 0 internally.\n\nRefer to `numpy.sum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.sum : corresponding function for ndarrays\nnumpy.sum : equivalent function",
            "notes": "",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.sum()\n25\n>>> x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\n             mask=[False, False, False],\n       fill_value=999999)\n>>> x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\n             mask=[False, False, False],\n       fill_value=999999)\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<class 'numpy.int64'>"
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(self, *args, **params)",
          "docstring": {
            "description": "a.swapaxes(axis1, axis2)\n\nReturn a view of the array with `axis1` and `axis2` interchanged.\n\nRefer to `numpy.swapaxes` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.swapaxes : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(self, indices, axis=None, out=None, mode='raise')",
          "docstring": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(self, fill_value=None, order='C')",
          "docstring": {
            "description": "Return the array data as a string containing the raw bytes in the array.\n\nThe array is filled with a fill value before the string conversion.\n\n.. versionadded:: 1.9.0",
            "parameters": {
              "fill_value": {
                "type": "scalar, optional",
                "description": "Value used to fill in the masked values. Default is None, in which\n    case `MaskedArray.fill_value` is used."
              },
              "order": {
                "type": "{'C','F','A'}, optional",
                "description": "Order of the data item in the copy. Default is 'C'.\n\n    - 'C'   -- C order (row major).\n    - 'F'   -- Fortran order (column major).\n    - 'A'   -- Any, current order of array.\n    - None  -- Same as 'A'."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.tobytes\ntolist, tofile",
            "notes": "As for `ndarray.tobytes`, information about the shape, dtype, etc.,\nbut also about `fill_value`, will be lost.",
            "examples": ">>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n>>> x.tobytes()\nb'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(self, fid, sep='', format='%s')",
          "docstring": {
            "description": "Save a masked array to a file in binary format.\n\n.. warning::\n  This function is not implemented yet.",
            "parameters": {},
            "returns": "",
            "raises": "NotImplementedError\n    When `tofile` is called.",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "toflex",
          "signature": "toflex(self)",
          "docstring": {
            "description": "Transforms a masked array into a flexible-type array.\n\nThe flexible type array that is returned will have two fields:\n\n* the ``_data`` field stores the ``_data`` part of the array.\n* the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "record : ndarray\n    A new flexible-type `ndarray` with two fields: the first element\n    containing a value, the second element containing the corresponding\n    mask boolean. The returned record shape matches self.shape.",
            "raises": "",
            "see_also": "",
            "notes": "A side-effect of transforming a masked array into a flexible `ndarray` is\nthat meta information (``fill_value``, ...) will be lost.",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '<i8'), ('_mask', '?')])"
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(self, fill_value=None)",
          "docstring": {
            "description": "Return the data portion of the masked array as a hierarchical Python list.\n\nData items are converted to the nearest compatible Python type.\nMasked values are converted to `fill_value`. If `fill_value` is None,\nthe corresponding entries in the output list will be ``None``.",
            "parameters": {
              "fill_value": {
                "type": "scalar, optional",
                "description": "The value to use for invalid entries. Default is None."
              }
            },
            "returns": "result : list\n    The Python list representation of the masked array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n>>> x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n>>> x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]"
          }
        },
        {
          "name": "torecords",
          "signature": "toflex(self)",
          "docstring": {
            "description": "Transforms a masked array into a flexible-type array.\n\nThe flexible type array that is returned will have two fields:\n\n* the ``_data`` field stores the ``_data`` part of the array.\n* the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "record : ndarray\n    A new flexible-type `ndarray` with two fields: the first element\n    containing a value, the second element containing the corresponding\n    mask boolean. The returned record shape matches self.shape.",
            "raises": "",
            "see_also": "",
            "notes": "A side-effect of transforming a masked array into a flexible `ndarray` is\nthat meta information (``fill_value``, ...) will be lost.",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '<i8'), ('_mask', '?')])"
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(self, fill_value=None, order='C')",
          "docstring": {
            "description": "A compatibility alias for `tobytes`, with exactly the same behavior.\n\nDespite its name, it returns `bytes` not `str`\\ s.\n\n.. deprecated:: 1.19.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)",
          "docstring": {
            "description": "a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\n\nReturn the sum along diagonals of the array.\n\nRefer to `numpy.trace` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.trace : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(self, *args, **params)",
          "docstring": {
            "description": "a.transpose(*axes)\n\nReturns a view of the array with axes transposed.\n\nRefer to `numpy.transpose` for full documentation.",
            "parameters": {
              "axes": {
                "type": "None, tuple of ints, or `n` ints",
                "description": "* None or no argument: reverses the order of the axes.\n\n * tuple of ints: `i` in the `j`-th place in the tuple means that the\n   array's `i`-th axis becomes the transposed array's `j`-th axis.\n\n * `n` ints: same as an n-tuple of the same ints (this form is\n   intended simply as a \"convenience\" alternative to the tuple form)."
              }
            },
            "returns": "p : ndarray\n    View of the array with its axes suitably permuted.",
            "raises": "",
            "see_also": "transpose : Equivalent function.\nndarray.T : Array property returning the array transposed.\nndarray.reshape : Give a new shape to an array without changing its data.",
            "notes": "",
            "examples": ">>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n>>> a = np.array([1, 2, 3, 4])\n>>> a\narray([1, 2, 3, 4])\n>>> a.transpose()\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "unshare_mask",
          "signature": "unshare_mask(self)",
          "docstring": {
            "description": "Copy the mask and set the `sharedmask` flag to ``False``.\n\nWhether the mask is shared between masked arrays can be seen from\nthe `sharedmask` property. `unshare_mask` ensures the mask is not\nshared. A copy of the mask is only made if it was shared.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "sharedmask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "docstring": {
            "description": "Compute the variance along the specified axis.\n\nReturns the variance of the array elements, a measure of the spread of a\ndistribution.  The variance is computed for the flattened array by\ndefault, otherwise over the specified axis.",
            "parameters": {
              "a": {
                "type": "array_like",
                "description": "Array containing numbers whose variance is desired.  If `a` is not an\n    array, a conversion is attempted."
              },
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis or axes along which the variance is computed.  The default is to\n    compute the variance of the flattened array.\n\n    .. versionadded:: 1.7.0\n\n    If this is a tuple of ints, a variance is performed over multiple axes,\n    instead of a single axis or all the axes as before."
              },
              "dtype": {
                "type": "data-type, optional",
                "description": "Type to use in computing the variance.  For arrays of integer type\n    the default is `float64`; for arrays of float types it is the same as\n    the array type."
              },
              "out": {
                "type": "ndarray, optional",
                "description": "Alternate output array in which to place the result.  It must have\n    the same shape as the expected output, but the type is cast if\n    necessary."
              },
              "ddof": {
                "type": "int, optional",
                "description": "\"Delta Degrees of Freedom\": the divisor used in the calculation is\n    ``N - ddof``, where ``N`` represents the number of elements. By\n    default `ddof` is zero."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the input array.\n\n    If the default value is passed, then `keepdims` will not be\n    passed through to the `var` method of sub-classes of\n    `ndarray`, however any non-default value will be.  If the\n    sub-class' method does not implement `keepdims` any\n    exceptions will be raised."
              },
              "where": {
                "type": "array_like of bool, optional",
                "description": "Elements to include in the variance. See `~numpy.ufunc.reduce` for\n    details.\n\n    .. versionadded:: 1.20.0"
              }
            },
            "returns": "variance : ndarray, see dtype parameter above\n    If ``out=None``, returns a new array containing the variance;\n    otherwise, a reference to the output array is returned.",
            "raises": "",
            "see_also": "std, mean, nanmean, nanstd, nanvar\n:ref:`ufuncs-output-type`",
            "notes": "The variance is the average of the squared deviations from the mean,\ni.e.,  ``var = mean(x)``, where ``x = abs(a - a.mean())**2``.\n\nThe mean is typically calculated as ``x.sum() / N``, where ``N = len(x)``.\nIf, however, `ddof` is specified, the divisor ``N - ddof`` is used\ninstead.  In standard statistical practice, ``ddof=1`` provides an\nunbiased estimator of the variance of a hypothetical infinite population.\n``ddof=0`` provides a maximum likelihood estimate of the variance for\nnormally distributed variables.\n\nNote that for complex numbers, the absolute value is taken before\nsquaring, so that the result is always real and nonnegative.\n\nFor floating-point input, the variance is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for `float32` (see example\nbelow).  Specifying a higher-accuracy accumulator using the ``dtype``\nkeyword can alleviate this issue.",
            "examples": ">>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([1.,  1.])\n>>> np.var(a, axis=1)\narray([0.25,  0.25])\n\nIn single precision, var() can be inaccurate:\n\n>>> a = np.zeros((2, 512*512), dtype=np.float32)\n>>> a[0, :] = 1.0\n>>> a[1, :] = 0.1\n>>> np.var(a)\n0.20250003\n\nComputing the variance in float64 is more accurate:\n\n>>> np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n>>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n\nSpecifying a where argument:\n\n>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])\n>>> np.var(a)\n6.833333333333333 # may vary\n>>> np.var(a, where=[[True], [True], [False]])\n4.0"
          }
        },
        {
          "name": "view",
          "signature": "view(self, dtype=None, type=None, fill_value=None)",
          "docstring": {
            "description": "Return a view of the MaskedArray data.",
            "parameters": {
              "dtype": {
                "type": "data-type or ndarray sub-class, optional",
                "description": "Data-type descriptor of the returned view, e.g., float32 or int16.\n    The default, None, results in the view having the same data-type\n    as `a`. As with ``ndarray.view``, dtype can also be specified as\n    an ndarray sub-class, which then specifies the type of the\n    returned object (this is equivalent to setting the ``type``\n    parameter)."
              },
              "type": {
                "type": "Python type, optional",
                "description": "Type of the returned view, either ndarray or a subclass.  The\n    default None results in type preservation."
              },
              "fill_value": {
                "type": "scalar, optional",
                "description": "The value to use for invalid entries (None by default).\n    If None, then this argument is inferred from the passed `dtype`, or\n    in its absence the original array, as discussed in the notes below."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.view : Equivalent method on ndarray object.",
            "notes": "``a.view()`` is used two different ways:\n\n``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view\nof the array's memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\n\n``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just\nreturns an instance of `ndarray_subclass` that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\n\nIf `fill_value` is not specified, but `dtype` is specified (and is not\nan ndarray sub-class), the `fill_value` of the MaskedArray will be\nreset. If neither `fill_value` nor `dtype` are specified (or if\n`dtype` is an ndarray sub-class), then the fill value is preserved.\nFinally, if `fill_value` is specified, but `dtype` is not, the fill\nvalue is set to the specified value.\n\nFor ``a.view(some_dtype)``, if ``some_dtype`` has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of ``a`` (shown\nby ``print(a)``). It also depends on exactly how ``a`` is stored in\nmemory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "bool_",
      "docstring": {
        "description": "Boolean type (True or False), stored as a byte.\n\n.. warning::\n\n   The :class:`bool_` type is not a subclass of the :class:`int_` type\n   (the :class:`bool_` is not even a number type). This is different\n   than Python's default implementation of :class:`bool` as a\n   sub-class of :class:`int`.\n\n:Character code: ``'?'``",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "docstring": {}
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(...)",
          "docstring": {
            "description": "newbyteorder(new_order='S', /)\n\nReturn a new `dtype` with a different byte order.\n\nChanges are also made in all fields and sub-arrays of the data type.\n\nThe `new_order` code can be any from the following:\n\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\n    above.  The default value ('S') results in swapping the current\n    byte order."
              }
            },
            "returns": "new_dtype : dtype\n    New `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "docstring": {}
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "docstring": {
            "description": "Scalar method identical to the corresponding array attribute.\n\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "masked_array",
      "docstring": {
        "description": "An array class with possibly masked values.\n\nMasked values of True exclude the corresponding element from any\ncomputation.\n\nConstruction::\n\n  x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\n                  ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\n                  shrink=True, order=None)",
        "parameters": {
          "data": {
            "type": "array_like",
            "description": "Input data."
          },
          "mask": {
            "type": "sequence, optional",
            "description": "Mask. Must be convertible to an array of booleans with the same\n    shape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Data type of the output.\n    If `dtype` is None, the type of the data argument (``data.dtype``)\n    is used. If `dtype` is not None and different from ``data.dtype``,\n    a copy is performed."
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to copy the input data (True), or to use a reference instead.\n    Default is False."
          },
          "subok": {
            "type": "bool, optional",
            "description": "Whether to return a subclass of `MaskedArray` if possible (True) or a\n    plain `MaskedArray`. Default is True."
          },
          "ndmin": {
            "type": "int, optional",
            "description": "Minimum number of dimensions. Default is 0."
          },
          "fill_value": {
            "type": "scalar, optional",
            "description": "Value used to fill in the masked values when necessary.\n    If None, a default based on the data-type is used."
          },
          "keep_mask": {
            "type": "bool, optional",
            "description": "Whether to combine `mask` with the mask of the input data, if any\n    (True), or to use only `mask` for the output (False). Default is True."
          },
          "hard_mask": {
            "type": "bool, optional",
            "description": "Whether to use a hard mask or not. With a hard mask, masked values\n    cannot be unmasked. Default is False."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to force compression of an empty mask. Default is True."
          },
          "order": {
            "type": "{'C', 'F', 'A'}, optional",
            "description": "Specify the order of the array.  If order is 'C', then the array\n    will be in C-contiguous order (last-index varies the fastest).\n    If order is 'F', then the returned array will be in\n    Fortran-contiguous order (first-index varies the fastest).\n    If order is 'A' (default), then the returned array may be\n    in any order (either C-, Fortran-contiguous, or even discontiguous),\n    unless a copy is required, in which case it will be C-contiguous."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "The ``mask`` can be initialized with an array of boolean values\nwith the same shape as ``data``.\n\n>>> data = np.arange(6).reshape((2, 3))\n>>> np.ma.MaskedArray(data, mask=[[False, True, False],\n...                               [False, False, True]])\nmasked_array(\n  data=[[0, --, 2],\n        [3, 4, --]],\n  mask=[[False,  True, False],\n        [False, False,  True]],\n  fill_value=999999)\n\nAlternatively, the ``mask`` can be initialized to homogeneous boolean\narray with the same shape as ``data`` by passing in a scalar\nboolean value:\n\n>>> np.ma.MaskedArray(data, mask=False)\nmasked_array(\n  data=[[0, 1, 2],\n        [3, 4, 5]],\n  mask=[[False, False, False],\n        [False, False, False]],\n  fill_value=999999)\n\n>>> np.ma.MaskedArray(data, mask=True)\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=999999,\n  dtype=int64)\n\n.. note::\n    The recommended practice for initializing ``mask`` with a scalar\n    boolean value is to use ``True``/``False`` rather than\n    ``np.True_``/``np.False_``. The reason is :attr:`nomask`\n    is represented internally as ``np.False_``.\n\n    >>> np.False_ is np.ma.nomask\n    True"
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(self, axis=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Returns True if all elements evaluate to True.\n\nThe output array is masked where all the values along the given axis\nare masked: if the output would have been a scalar and that all the\nvalues are masked, then the output is `masked`.\n\nRefer to `numpy.all` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.all : corresponding function for ndarrays\nnumpy.all : equivalent function",
            "notes": "",
            "examples": ">>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue"
          }
        },
        {
          "name": "anom",
          "signature": "anom(self, axis=None, dtype=None)",
          "docstring": {
            "description": "Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.\n\nReturns an array of anomalies, with the same shape as the input and\nwhere the arithmetic mean is computed along the given axis.",
            "parameters": {
              "axis": {
                "type": "int, optional",
                "description": "Axis over which the anomalies are taken.\n    The default is to use the mean of the flattened array as reference."
              },
              "dtype": {
                "type": "dtype, optional",
                "description": "Type to use in computing the variance. For arrays of integer type\n     the default is float32; for arrays of float types it is the same as\n     the array type."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "mean : Compute the mean of the array.",
            "notes": "",
            "examples": ">>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)"
          }
        },
        {
          "name": "any",
          "signature": "any(self, axis=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Returns True if any of the elements of `a` evaluate to True.\n\nMasked values are considered as False during computation.\n\nRefer to `numpy.any` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.any : corresponding function for ndarrays\nnumpy.any : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "docstring": {
            "description": "Returns array of indices of the maximum values along the given axis.\nMasked values are treated as if they had the value fill_value.",
            "parameters": {
              "axis": {
                "type": "{None, integer}",
                "description": "If None, the index is into the flattened array, otherwise along\n    the specified axis"
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.  If None, the output of\n    maximum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None, array}, optional",
                "description": "Array into which the result can be placed. Its type is preserved\n    and it must be of the right shape to hold the output."
              }
            },
            "returns": "index_array : {integer_array}",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])"
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "docstring": {
            "description": "Return array of indices to the minimum values along the given axis.",
            "parameters": {
              "axis": {
                "type": "{None, integer}",
                "description": "If None, the index is into the flattened array, otherwise along\n    the specified axis"
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.  If None, the output of\n    minimum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None, array}, optional",
                "description": "Array into which the result can be placed. Its type is preserved\n    and it must be of the right shape to hold the output."
              }
            },
            "returns": "ndarray or scalar\n    If multi-dimension input, returns a new ndarray of indices to the\n    minimum values along the given axis.  Otherwise, returns a scalar\n    of index to the minimum values along the given axis.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> x\nmasked_array(\n  data=[[--, --],\n        [2, 3]],\n  mask=[[ True,  True],\n        [False, False]],\n  fill_value=999999)\n>>> x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n>>> x.argmin(axis=0, fill_value=9)\narray([1, 1])"
          }
        },
        {
          "name": "argpartition",
          "signature": "argpartition(self, *args, **kwargs)",
          "docstring": {
            "description": "a.argpartition(kth, axis=-1, kind='introselect', order=None)\n\nReturns the indices that would partition this array.\n\nRefer to `numpy.argpartition` for full documentation.\n\n.. versionadded:: 1.8.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.argpartition : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(self, axis=<no value>, kind=None, order=None, endwith=True, fill_value=None)",
          "docstring": {
            "description": "Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\n`fill_value`.",
            "parameters": {
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. If None, the default, the flattened array\n    is used.\n\n    ..  versionchanged:: 1.13.0\n        Previously, the default was documented to be -1, but that was\n        in error. At some future date, the default will change to -1, as\n        originally intended.\n        Until then, the axis should be given explicitly when\n        ``arr.ndim > 1``, to avoid a FutureWarning."
              },
              "kind": {
                "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
                "description": "The sorting algorithm used."
              },
              "order": {
                "type": "list, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\n    which fields to compare first, second, etc.  Not all fields need be\n    specified."
              },
              "endwith": {
                "type": "{True, False}, optional",
                "description": "Whether missing values (if any) should be treated as the largest values\n    (True) or the smallest values (False)\n    When the array contains unmasked values at the same extremes of the\n    datatype, the ordering of these values and the masked values is\n    undefined."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used internally for the masked values.\n    If ``fill_value`` is not None, it supersedes ``endwith``."
              }
            },
            "returns": "index_array : ndarray, int\n    Array of indices that sort `a` along the specified axis.\n    In other words, ``a[index_array]`` yields a sorted `a`.",
            "raises": "",
            "see_also": "ma.MaskedArray.sort : Describes sorting algorithms used.\nlexsort : Indirect stable sort with multiple keys.\nnumpy.ndarray.sort : Inplace sort.",
            "notes": "See `sort` for notes on the different sorting algorithms.",
            "examples": ">>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data=[3, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n>>> a.argsort()\narray([1, 0, 2])"
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "docstring": {
            "description": "a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\n\nCopy of the array, cast to a specified type.",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "Typecode or data-type to which the array is cast."
              },
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout order of the result.\n    'C' means C order, 'F' means Fortran order, 'A'\n    means 'F' order if all the arrays are Fortran contiguous,\n    'C' order otherwise, and 'K' means as close to the\n    order the array elements appear in memory as possible.\n    Default is 'K'."
              },
              "casting": {
                "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
                "description": "Controls what kind of data casting may occur. Defaults to 'unsafe'\n    for backwards compatibility.\n\n      * 'no' means the data types should not be cast at all.\n      * 'equiv' means only byte-order changes are allowed.\n      * 'safe' means only casts which can preserve values are allowed.\n      * 'same_kind' means only safe casts or casts within a kind,\n        like float64 to float32, are allowed.\n      * 'unsafe' means any data conversions may be done."
              },
              "subok": {
                "type": "bool, optional",
                "description": "If True, then sub-classes will be passed-through (default), otherwise\n    the returned array will be forced to be a base-class array."
              },
              "copy": {
                "type": "bool, optional",
                "description": "By default, astype always returns a newly allocated array. If this\n    is set to false, and the `dtype`, `order`, and `subok`\n    requirements are satisfied, the input array is returned instead\n    of a copy."
              }
            },
            "returns": "arr_t : ndarray\n    Unless `copy` is False and the other conditions for returning the input\n    array are satisfied (see description for `copy` input parameter), `arr_t`\n    is a new array of the same shape as the input array, with dtype, order\n    given by `dtype`, `order`.",
            "raises": "ComplexWarning\n    When casting from complex to float or int. To avoid this,\n    one should use ``a.real.astype(t)``.",
            "see_also": "",
            "notes": ".. versionchanged:: 1.17.0\n   Casting between a simple data type and a structured one is possible only\n   for \"unsafe\" casting.  Casting to multiple fields is allowed, but\n   casting from multiple fields is not.\n\n.. versionchanged:: 1.9.0\n   Casting from numeric to string types in 'safe' casting mode requires\n   that the string dtype length is long enough to store the max\n   integer/float value converted.",
            "examples": ">>> x = np.array([1, 2, 2.5])\n>>> x\narray([1. ,  2. ,  2.5])\n\n>>> x.astype(int)\narray([1, 2, 2])"
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "docstring": {
            "description": "a.byteswap(inplace=False)\n\nSwap the bytes of the array elements\n\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.",
            "parameters": {
              "inplace": {
                "type": "bool, optional",
                "description": "If ``True``, swap bytes in-place, default is ``False``."
              }
            },
            "returns": "out : ndarray\n    The byteswapped array. If `inplace` is ``True``, this is\n    a view to self.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> list(map(hex, A))\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n>>> list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\nArrays of byte-strings are not swapped\n\n>>> A = np.array([b'ceg', b'fac'])\n>>> A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n``A.newbyteorder().byteswap()`` produces an array with the same values\n  but different representation in memory\n\n>>> A = np.array([1, 2, 3])\n>>> A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n>>> A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n>>> A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)"
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "docstring": {
            "description": "a.choose(choices, out=None, mode='raise')\n\nUse an index array to construct a new array from a set of choices.\n\nRefer to `numpy.choose` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.choose : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "docstring": {
            "description": "a.clip(min=None, max=None, out=None, **kwargs)\n\nReturn an array whose values are limited to ``[min, max]``.\nOne of max or min must be given.\n\nRefer to `numpy.clip` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.clip : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(self, condition, axis=None, out=None)",
          "docstring": {
            "description": "Return `a` where condition is ``True``.\n\nIf condition is a `~ma.MaskedArray`, missing values are considered\nas ``False``.",
            "parameters": {
              "condition": {
                "type": "var",
                "description": "Boolean 1-d array selecting which entries to return. If len(condition)\n    is less than the size of a along the axis, then output is truncated\n    to length of condition array."
              },
              "axis": {
                "type": "{None, int}, optional",
                "description": "Axis along which the operation must be performed."
              },
              "out": {
                "type": "{None, ndarray}, optional",
                "description": "Alternative output array in which to place the result. It must have\n    the same shape as the expected output but the type will be cast if\n    necessary."
              }
            },
            "returns": "result : MaskedArray\n    A :class:`~ma.MaskedArray` object.",
            "raises": "",
            "see_also": "",
            "notes": "Please note the difference with :meth:`compressed` !\nThe output of :meth:`compress` has a mask, the output of\n:meth:`compressed` does not.",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\n             mask=[False, False],\n       fill_value=999999)\n\n>>> x.compress([1, 0, 1], axis=1)\nmasked_array(\n  data=[[1, 3],\n        [--, --],\n        [7, 9]],\n  mask=[[False, False],\n        [ True,  True],\n        [False, False]],\n  fill_value=999999)"
          }
        },
        {
          "name": "compressed",
          "signature": "compressed(self)",
          "docstring": {
            "description": "Return all the non-masked data as a 1-D array.",
            "parameters": {},
            "returns": "data : ndarray\n    A new `ndarray` holding the non-masked data is returned.",
            "raises": "",
            "see_also": "",
            "notes": "The result is **not** a MaskedArray!",
            "examples": ">>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n>>> x.compressed()\narray([0, 1])\n>>> type(x.compressed())\n<class 'numpy.ndarray'>"
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "docstring": {
            "description": "a.conj()\n\nComplex-conjugate all elements.\n\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "docstring": {
            "description": "a.conjugate()\n\nReturn the complex conjugate, element-wise.\n\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(self, *args, **params)",
          "docstring": {
            "description": "a.copy(order='C')\n\nReturn a copy of the array.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout of the copy. 'C' means C-order,\n    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n    'C' otherwise. 'K' means match the layout of `a` as closely\n    as possible. (Note that this function and :func:`numpy.copy` are very\n    similar but have different default values for their order=\n    arguments, and this function always passes sub-classes through.)\n\nSee also\n--------"
              },
              "numpy.copy": {
                "type": "Similar function with different default behavior",
                "description": "numpy.copyto"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "This function is the preferred method for creating an array copy.  The\nfunction :func:`numpy.copy` is similar, but it defaults to using order 'K',\nand will not pass sub-classes through by default.",
            "examples": ">>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n>>> y = x.copy()\n\n>>> x.fill(0)\n\n>>> x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n>>> y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n>>> y.flags['C_CONTIGUOUS']\nTrue"
          }
        },
        {
          "name": "count",
          "signature": "count(self, axis=None, keepdims=<no value>)",
          "docstring": {
            "description": "Count the non-masked elements of the array along the given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis or axes along which the count is performed.\n    The default, None, performs the count over all\n    the dimensions of the input array. `axis` may be negative, in\n    which case it counts from the last to the first axis.\n\n    .. versionadded:: 1.10.0\n\n    If this is a tuple of ints, the count is performed on multiple\n    axes, instead of a single axis or all the axes as before."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
              }
            },
            "returns": "result : ndarray or scalar\n    An array with the same shape as the input array, with the specified\n    axis removed. If the array is a 0-d array, or if `axis` is None, a\n    scalar is returned.",
            "raises": "",
            "see_also": "ma.count_masked : Count masked elements in array or along a given axis.",
            "notes": "",
            "examples": ">>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, --, --]],\n  mask=[[False, False, False],\n        [ True,  True,  True]],\n  fill_value=999999)\n>>> a.count()\n3\n\nWhen the `axis` keyword is specified an array of appropriate size is\nreturned.\n\n>>> a.count(axis=0)\narray([1, 1, 1])\n>>> a.count(axis=1)\narray([3, 0])"
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(self, axis=None, dtype=None, out=None)",
          "docstring": {
            "description": "Return the cumulative product of the array elements over the given axis.\n\nMasked values are set to 1 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\n\nRefer to `numpy.cumprod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.cumprod : corresponding function for ndarrays\nnumpy.cumprod : equivalent function",
            "notes": "The mask is lost if `out` is not a valid MaskedArray !\n\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(self, axis=None, dtype=None, out=None)",
          "docstring": {
            "description": "Return the cumulative sum of the array elements over the given axis.\n\nMasked values are set to 0 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\n\nRefer to `numpy.cumsum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.cumsum : corresponding function for ndarrays\nnumpy.cumsum : equivalent function",
            "notes": "The mask is lost if `out` is not a valid :class:`ma.MaskedArray` !\n\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
            "examples": ">>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n             mask=[False, False, False,  True,  True,  True, False, False,\n                   False, False],\n       fill_value=999999)"
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(self, *args, **params)",
          "docstring": {
            "description": "a.diagonal(offset=0, axis1=0, axis2=1)\n\nReturn specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\n\nRefer to :func:`numpy.diagonal` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.diagonal : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dot",
          "signature": "dot(self, b, out=None, strict=False)",
          "docstring": {
            "description": "a.dot(b, out=None)\n\nMasked dot product of two arrays. Note that `out` and `strict` are\nlocated in different positions than in `ma.dot`. In order to\nmaintain compatibility with the functional version, it is\nrecommended that the optional arguments be treated as keyword only.\nAt some point that may be mandatory.\n\n.. versionadded:: 1.10.0",
            "parameters": {
              "b": {
                "type": "masked_array_like",
                "description": "Inputs array."
              },
              "out": {
                "type": "masked_array, optional",
                "description": "Output argument. This must have the exact kind that would be\n    returned if it was not used. In particular, it must have the\n    right type, must be C-contiguous, and its dtype must be the\n    dtype that would be returned for `ma.dot(a,b)`. This is a\n    performance feature. Therefore, if these conditions are not\n    met, an exception is raised, instead of attempting to be\n    flexible."
              },
              "strict": {
                "type": "bool, optional",
                "description": "Whether masked data are propagated (True) or set to 0 (False)\n    for the computation. Default is False.  Propagating the mask\n    means that if a masked value appears in a row or column, the\n    whole row or column is considered masked.\n\n    .. versionadded:: 1.10.2"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "numpy.ma.dot : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "docstring": {
            "description": "a.dump(file)\n\nDump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.",
            "parameters": {
              "file": {
                "type": "str or Path",
                "description": "A string naming the dump file.\n\n    .. versionchanged:: 1.17.0\n        `pathlib.Path` objects are now accepted."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "docstring": {
            "description": "a.dumps()\n\nReturns the pickle of the array as a string.\npickle.loads will convert the string back to an array.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "docstring": {
            "description": "a.fill(value)\n\nFill the array with a scalar value.",
            "parameters": {
              "value": {
                "type": "scalar",
                "description": "All elements of `a` will be assigned this value."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([1.,  1.])\n\nFill expects a scalar value and always behaves the same as assigning\nto a single array element.  The following is a rare example where this\ndistinction is important:\n\n>>> a = np.array([None, None], dtype=object)\n>>> a[0] = np.array(3)\n>>> a\narray([array(3), None], dtype=object)\n>>> a.fill(np.array(3))\n>>> a\narray([array(3), array(3)], dtype=object)\n\nWhere other forms of assignments will unpack the array being assigned:\n\n>>> a[...] = np.array(3)\n>>> a\narray([3, 3], dtype=object)"
          }
        },
        {
          "name": "filled",
          "signature": "filled(self, fill_value=None)",
          "docstring": {
            "description": "Return a copy of self, with masked values filled with a given value.\n**However**, if there are no masked values to fill, self will be\nreturned instead as an ndarray.",
            "parameters": {
              "fill_value": {
                "type": "array_like, optional",
                "description": "The value to use for invalid entries. Can be scalar or non-scalar.\n    If non-scalar, the resulting ndarray must be broadcastable over\n    input array. Default is None, in which case, the `fill_value`\n    attribute of the array is used instead."
              }
            },
            "returns": "filled_array : ndarray\n    A copy of ``self`` with invalid entries replaced by *fill_value*\n    (be it the function argument or the attribute of ``self``), or\n    ``self`` itself as an ndarray if there are no invalid entries to\n    be replaced.",
            "raises": "",
            "see_also": "",
            "notes": "The result is **not** a MaskedArray!",
            "examples": ">>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n>>> x.filled()\narray([   1,    2, -999,    4, -999])\n>>> x.filled(fill_value=1000)\narray([   1,    2, 1000,    4, 1000])\n>>> type(x.filled())\n<class 'numpy.ndarray'>\n\nSubclassing is preserved. This means that if, e.g., the data part of\nthe masked array is a recarray, `filled` returns a recarray:\n\n>>> x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)\n>>> m = np.ma.array(x, mask=[(True, False), (False, True)])\n>>> m.filled()\nrec.array([(999999,      2), (    -3, 999999)],\n          dtype=[('f0', '<i8'), ('f1', '<i8')])"
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(self, *args, **params)",
          "docstring": {
            "description": "a.flatten(order='C')\n\nReturn a copy of the array collapsed into one dimension.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "'C' means to flatten in row-major (C-style) order.\n    'F' means to flatten in column-major (Fortran-\n    style) order. 'A' means to flatten in column-major\n    order if `a` is Fortran *contiguous* in memory,\n    row-major order otherwise. 'K' means to flatten\n    `a` in the order the elements occur in memory.\n    The default is 'C'."
              }
            },
            "returns": "y : ndarray\n    A copy of the input array, flattened to one dimension.",
            "raises": "",
            "see_also": "ravel : Return a flattened array.\nflat : A 1-D flat iterator over the array.",
            "notes": "",
            "examples": ">>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])"
          }
        },
        {
          "name": "get_fill_value",
          "signature": "fill_value(self)",
          "docstring": {
            "description": "The filling value of the masked array is a scalar. When setting, None\nwill set to a default based on the data type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n\n>>> x = np.ma.array([0, 1.], fill_value=-np.inf)\n>>> x.fill_value\n-inf\n>>> x.fill_value = np.pi\n>>> x.fill_value\n3.1415926535897931 # may vary\n\nReset to default:\n\n>>> x.fill_value = None\n>>> x.fill_value\n1e+20"
          }
        },
        {
          "name": "get_imag",
          "signature": "imag(self)",
          "docstring": {
            "description": "The imaginary part of the masked array.\n\nThis property is a view on the imaginary part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "real",
            "notes": "",
            "examples": ">>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.imag\nmasked_array(data=[1.0, --, 1.6],\n             mask=[False,  True, False],\n       fill_value=1e+20)"
          }
        },
        {
          "name": "get_real",
          "signature": "real(self)",
          "docstring": {
            "description": "The real part of the masked array.\n\nThis property is a view on the real part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "imag",
            "notes": "",
            "examples": ">>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.real\nmasked_array(data=[1.0, --, 3.45],\n             mask=[False,  True, False],\n       fill_value=1e+20)"
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "docstring": {
            "description": "a.getfield(dtype, offset=0)\n\nReturns a field of the given array as a certain type.\n\nA field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "The data type of the view. The dtype size of the view can not be larger\n    than that of the array itself."
              },
              "offset": {
                "type": "int",
                "description": "Number of bytes to skip before beginning the element view."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n\n>>> x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])"
          }
        },
        {
          "name": "harden_mask",
          "signature": "harden_mask(self)",
          "docstring": {
            "description": "Force the mask to hard, preventing unmasking by assignment.\n\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `harden_mask` sets\n`~ma.MaskedArray.hardmask` to ``True`` (and returns the modified\nself).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "ma.MaskedArray.hardmask\nma.MaskedArray.soften_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ids",
          "signature": "ids(self)",
          "docstring": {
            "description": "Return the addresses of the data and mask areas.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n>>> x.ids()\n(166670640, 166659832) # may vary\n\nIf the array has no mask, the address of `nomask` is returned. This address\nis typically not close to the data in memory:\n\n>>> x = np.ma.array([1, 2, 3])\n>>> x.ids()\n(166691080, 3083169284) # may vary"
          }
        },
        {
          "name": "iscontiguous",
          "signature": "iscontiguous(self)",
          "docstring": {
            "description": "Return a boolean indicating whether the data is contiguous.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([1, 2, 3])\n>>> x.iscontiguous()\nTrue\n\n`iscontiguous` returns one of the flags of the masked array:\n\n>>> x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : True\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False"
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "docstring": {
            "description": "a.item(*args)\n\nCopy an element of an array to a standard Python scalar and return it.",
            "parameters": {
              "\\*args": {
                "type": "Arguments (variable number and type)",
                "description": "* none: in this case, the method only works for arrays\n      with one element (`a.size == 1`), which element is\n      copied into a standard Python scalar object and returned.\n\n    * int_type: this argument is interpreted as a flat index into\n      the array, specifying which element to copy and return.\n\n    * tuple of int_types: functions as does a single int_type argument,\n      except that the argument is interpreted as an nd-index into the\n      array."
              }
            },
            "returns": "z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable\n    Python scalar",
            "raises": "",
            "see_also": "",
            "notes": "When the data type of `a` is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\n\n`item` is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python's optimized math.",
            "examples": ">>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n>>> x.item(3)\n1\n>>> x.item(7)\n0\n>>> x.item((0, 1))\n2\n>>> x.item((2, 2))\n1"
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "docstring": {
            "description": "a.itemset(*args)\n\nInsert scalar into an array (scalar is cast to array's dtype, if possible)\n\nThere must be at least 1 argument, and define the last argument\nas *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster\nthan ``a[args] = item``.  The item should be a scalar value and `args`\nmust select a single item in the array `a`.",
            "parameters": {
              "\\*args": {
                "type": "Arguments",
                "description": "If one argument: a scalar, only used in case `a` is of size 1.\n    If two arguments: the last argument is the value to be set\n    and must be a scalar, the first argument specifies a single array\n    element location. It is either an int or a tuple."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "Compared to indexing syntax, `itemset` provides some speed increase\nfor placing a scalar into a particular location in an `ndarray`,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using `itemset` (and `item`) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.",
            "examples": ">>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])"
          }
        },
        {
          "name": "max",
          "signature": "max(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the maximum along a given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis along which to operate.  By default, ``axis`` is None and the\n    flattened input is used.\n    .. versionadded:: 1.7.0\n    If this is a tuple of ints, the maximum is selected over multiple\n    axes, instead of a single axis or all the axes as before."
              },
              "out": {
                "type": "array_like, optional",
                "description": "Alternative output array in which to place the result.  Must\n    be of the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.\n    If None, use the output of maximum_fill_value()."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
              }
            },
            "returns": "amax : array_like\n    New array holding the result.\n    If ``out`` was specified, ``out`` is returned.",
            "raises": "",
            "see_also": "ma.maximum_fill_value\n    Returns the maximum filling value for a given datatype.",
            "notes": "",
            "examples": ">>> import numpy.ma as ma\n>>> x = [[-1., 2.5], [4., -2.], [3., 0.]]\n>>> mask = [[0, 0], [1, 0], [1, 0]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\n  data=[[-1.0, 2.5],\n        [--, -2.0],\n        [--, 0.0]],\n  mask=[[False, False],\n        [ True, False],\n        [ True, False]],\n  fill_value=1e+20)\n>>> ma.max(masked_x)\n2.5\n>>> ma.max(masked_x, axis=0)\nmasked_array(data=[-1.0, 2.5],\n             mask=[False, False],\n       fill_value=1e+20)\n>>> ma.max(masked_x, axis=1, keepdims=True)\nmasked_array(\n  data=[[2.5],\n        [-2.0],\n        [0.0]],\n  mask=[[False],\n        [False],\n        [False]],\n  fill_value=1e+20)\n>>> mask = [[1, 1], [1, 1], [1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.max(masked_x, axis=1)\nmasked_array(data=[--, --, --],\n             mask=[ True,  True,  True],\n       fill_value=1e+20,\n            dtype=float64)"
          }
        },
        {
          "name": "mean",
          "signature": "mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Returns the average of the array elements along given axis.\n\nMasked entries are ignored, and result elements which are not\nfinite will be masked.\n\nRefer to `numpy.mean` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.mean : corresponding function for ndarrays\nnumpy.mean : Equivalent function\nnumpy.ma.average : Weighted average.",
            "notes": "",
            "examples": ">>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data=[1, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n>>> a.mean()\n1.5"
          }
        },
        {
          "name": "min",
          "signature": "min(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the minimum along a given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis along which to operate.  By default, ``axis`` is None and the\n    flattened input is used.\n    .. versionadded:: 1.7.0\n    If this is a tuple of ints, the minimum is selected over multiple\n    axes, instead of a single axis or all the axes as before."
              },
              "out": {
                "type": "array_like, optional",
                "description": "Alternative output array in which to place the result.  Must be of\n    the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.\n    If None, use the output of `minimum_fill_value`."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
              }
            },
            "returns": "amin : array_like\n    New array holding the result.\n    If ``out`` was specified, ``out`` is returned.",
            "raises": "",
            "see_also": "ma.minimum_fill_value\n    Returns the minimum filling value for a given datatype.",
            "notes": "",
            "examples": ">>> import numpy.ma as ma\n>>> x = [[1., -2., 3.], [0.2, -0.7, 0.1]]\n>>> mask = [[1, 1, 0], [0, 0, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\n  data=[[--, --, 3.0],\n        [0.2, -0.7, --]],\n  mask=[[ True,  True, False],\n        [False, False,  True]],\n  fill_value=1e+20)\n>>> ma.min(masked_x)\n-0.7\n>>> ma.min(masked_x, axis=-1)\nmasked_array(data=[3.0, -0.7],\n             mask=[False, False],\n        fill_value=1e+20)\n>>> ma.min(masked_x, axis=0, keepdims=True)\nmasked_array(data=[[0.2, -0.7, 3.0]],\n             mask=[[False, False, False]],\n        fill_value=1e+20)\n>>> mask = [[1, 1, 1,], [1, 1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.min(masked_x, axis=0)\nmasked_array(data=[--, --, --],\n             mask=[ True,  True,  True],\n        fill_value=1e+20,\n            dtype=float64)"
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(...)",
          "docstring": {
            "description": "arr.newbyteorder(new_order='S', /)\n\nReturn the array with the same data viewed with a different byte order.\n\nEquivalent to::\n\n    arr.view(arr.dtype.newbytorder(new_order))\n\nChanges are also made in all fields and sub-arrays of the array data\ntype.",
            "parameters": {
              "new_order": {
                "type": "string, optional",
                "description": "Byte order to force; a value from the byte order specifications\n    below. `new_order` codes can be any of:\n\n    * 'S' - swap dtype from current to opposite endian\n    * {'<', 'little'} - little endian\n    * {'>', 'big'} - big endian\n    * {'=', 'native'} - native order, equivalent to `sys.byteorder`\n    * {'|', 'I'} - ignore (no change to byte order)\n\n    The default value ('S') results in swapping the current\n    byte order."
              }
            },
            "returns": "new_arr : array\n    New array object with the dtype reflecting given change to the\n    byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(self)",
          "docstring": {
            "description": "Return the indices of unmasked elements that are not zero.\n\nReturns a tuple of arrays, one for each dimension, containing the\nindices of the non-zero elements in that dimension. The corresponding\nnon-zero values can be obtained with::\n\n    a[a.nonzero()]\n\nTo group the indices by element, rather than dimension, use\ninstead::\n\n    np.transpose(a.nonzero())\n\nThe result of this is always a 2d array, with a row for each non-zero\nelement.",
            "parameters": {},
            "returns": "tuple_of_arrays : tuple\n    Indices of elements that are non-zero.",
            "raises": "",
            "see_also": "numpy.nonzero :\n    Function operating on ndarrays.\nflatnonzero :\n    Return indices that are non-zero in the flattened version of the input\n    array.\nnumpy.ndarray.nonzero :\n    Equivalent ndarray method.\ncount_nonzero :\n    Counts the number of non-zero elements in the input array.",
            "notes": "",
            "examples": ">>> import numpy.ma as ma\n>>> x = ma.array(np.eye(3))\n>>> x\nmasked_array(\n  data=[[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]],\n  mask=False,\n  fill_value=1e+20)\n>>> x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\n\nMasked elements are ignored.\n\n>>> x[1, 1] = ma.masked\n>>> x\nmasked_array(\n  data=[[1.0, 0.0, 0.0],\n        [0.0, --, 0.0],\n        [0.0, 0.0, 1.0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1e+20)\n>>> x.nonzero()\n(array([0, 2]), array([0, 2]))\n\nIndices can also be grouped by element.\n\n>>> np.transpose(x.nonzero())\narray([[0, 0],\n       [2, 2]])\n\nA common use for ``nonzero`` is to find the indices of an array, where\na condition is True.  Given an array `a`, the condition `a` > 3 is a\nboolean array and since False is interpreted as 0, ma.nonzero(a > 3)\nyields the indices of the `a` where the condition is true.\n\n>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n>>> a > 3\nmasked_array(\n  data=[[False, False, False],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  mask=False,\n  fill_value=True)\n>>> ma.nonzero(a > 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\nThe ``nonzero`` method of the condition array can also be called.\n\n>>> (a > 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))"
          }
        },
        {
          "name": "partition",
          "signature": "partition(self, *args, **kwargs)",
          "docstring": {
            "description": "a.partition(kth, axis=-1, kind='introselect', order=None)\n\nRearranges the elements in the array in such a way that the value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.\n\n.. versionadded:: 1.8.0",
            "parameters": {
              "kth": {
                "type": "int or sequence of ints",
                "description": "Element index to partition by. The kth element value will be in its\n    final sorted position and all smaller elements will be moved before it\n    and all equal or greater elements behind it.\n    The order of all elements in the partitions is undefined.\n    If provided with a sequence of kth it will partition all elements\n    indexed by kth of them into their sorted position at once.\n\n    .. deprecated:: 1.22.0\n        Passing booleans as index is deprecated."
              },
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. Default is -1, which means sort along the\n    last axis."
              },
              "kind": {
                "type": "{'introselect'}, optional",
                "description": "Selection algorithm. Default is 'introselect'."
              },
              "order": {
                "type": "str or list of str, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\n    which fields to compare first, second, etc. A single field can\n    be specified as a string, and not all fields need to be specified,\n    but unspecified fields will still be used, in the order in which\n    they come up in the dtype, to break ties."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "numpy.partition : Return a partitioned copy of an array.\nargpartition : Indirect partition.\nsort : Full sort.",
            "notes": "See ``np.partition`` for notes on the different algorithms.",
            "examples": ">>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])\n\n>>> a.partition((1, 3))\n>>> a\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "prod",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the product of the array elements over the given axis.\n\nMasked elements are set to 1 internally for computation.\n\nRefer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
            "notes": "Arithmetic is modular when using integer types, and no error is raised\non overflow.",
            "examples": ""
          }
        },
        {
          "name": "product",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the product of the array elements over the given axis.\n\nMasked elements are set to 1 internally for computation.\n\nRefer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
            "notes": "Arithmetic is modular when using integer types, and no error is raised\non overflow.",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(self, axis=None, out=None, fill_value=None, keepdims=False)",
          "docstring": {
            "description": "Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).\n\n.. warning::\n    `ptp` preserves the data type of the array. This means the\n    return value for an input of signed integers with n bits\n    (e.g. `np.int8`, `np.int16`, etc) is also a signed integer\n    with n bits.  In that case, peak-to-peak values greater than\n    ``2**(n-1)-1`` will be returned as negative values. An example\n    with a work-around is shown below.",
            "parameters": {
              "axis": {
                "type": "{None, int}, optional",
                "description": "Axis along which to find the peaks.  If None (default) the\n    flattened array is used."
              },
              "out": {
                "type": "{None, array_like}, optional",
                "description": "Alternative output array in which to place the result. It must\n    have the same shape and buffer length as the expected output\n    but the type will be cast if necessary."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
              }
            },
            "returns": "ptp : ndarray.\n    A new array holding the result, unless ``out`` was\n    specified, in which case a reference to ``out`` is returned.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.MaskedArray([[4, 9, 2, 10],\n...                        [6, 9, 7, 12]])\n\n>>> x.ptp(axis=1)\nmasked_array(data=[8, 6],\n             mask=False,\n       fill_value=999999)\n\n>>> x.ptp(axis=0)\nmasked_array(data=[2, 0, 5, 2],\n             mask=False,\n       fill_value=999999)\n\n>>> x.ptp()\n10\n\nThis example shows that a negative value can be returned when\nthe input is an array of signed integers.\n\n>>> y = np.ma.MaskedArray([[1, 127],\n...                        [0, 127],\n...                        [-1, 127],\n...                        [-2, 127]], dtype=np.int8)\n>>> y.ptp(axis=1)\nmasked_array(data=[ 126,  127, -128, -127],\n             mask=False,\n       fill_value=999999,\n            dtype=int8)\n\nA work-around is to use the `view()` method to view the result as\nunsigned integers with the same bit width:\n\n>>> y.ptp(axis=1).view(np.uint8)\nmasked_array(data=[126, 127, 128, 129],\n             mask=False,\n       fill_value=999999,\n            dtype=uint8)"
          }
        },
        {
          "name": "put",
          "signature": "put(self, indices, values, mode='raise')",
          "docstring": {
            "description": "Set storage-indexed locations to corresponding values.\n\nSets self._data.flat[n] = values[n] for each n in indices.\nIf `values` is shorter than `indices` then it will repeat.\nIf `values` has some masked values, the initial mask is updated\nin consequence, else the corresponding values are unmasked.",
            "parameters": {
              "indices": {
                "type": "1-D array_like",
                "description": "Target indices, interpreted as integers."
              },
              "values": {
                "type": "array_like",
                "description": "Values to place in self._data copy at target indices."
              },
              "mode": {
                "type": "{'raise', 'wrap', 'clip'}, optional",
                "description": "Specifies how out-of-bounds indices will behave.\n    'raise' : raise an error.\n    'wrap' : wrap around.\n    'clip' : clip to the range."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "`values` can be a scalar or length 1 array.",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.put([0,4,8],[10,20,30])\n>>> x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 20, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n\n>>> x.put(4,999)\n>>> x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 999, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)"
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(self, order='C')",
          "docstring": {
            "description": "Returns a 1D version of self, as a view.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "The elements of `a` are read using this index order. 'C' means to\n    index the elements in C-like order, with the last axis index\n    changing fastest, back to the first axis index changing slowest.\n    'F' means to index the elements in Fortran-like index order, with\n    the first index changing fastest, and the last index changing\n    slowest. Note that the 'C' and 'F' options take no account of the\n    memory layout of the underlying array, and only refer to the order\n    of axis indexing.  'A' means to read the elements in Fortran-like\n    index order if `m` is Fortran *contiguous* in memory, C-like order\n    otherwise.  'K' means to read the elements in the order they occur\n    in memory, except for reversing the data when strides are negative.\n    By default, 'C' index order is used.\n    (Masked arrays currently use 'A' on the data when 'K' is passed.)"
              }
            },
            "returns": "MaskedArray\n    Output view is of shape ``(self.size,)`` (or\n    ``(np.ma.product(self.shape),)``).",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\n             mask=[False,  True, False,  True, False,  True, False,  True,\n                   False],\n       fill_value=999999)"
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(self, *args, **params)",
          "docstring": {
            "description": "a.repeat(repeats, axis=None)\n\nRepeat elements of an array.\n\nRefer to `numpy.repeat` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.repeat : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(self, *s, **kwargs)",
          "docstring": {
            "description": "Give a new shape to the array without changing its data.\n\nReturns a masked array containing the same data, but with a new shape.\nThe result is a view on the original array; if this is not possible, a\nValueError is raised.",
            "parameters": {
              "shape": {
                "type": "int or tuple of ints",
                "description": "The new shape should be compatible with the original shape. If an\n    integer is supplied, then the result will be a 1-D array of that\n    length."
              },
              "order": {
                "type": "{'C', 'F'}, optional",
                "description": "Determines whether the array data should be viewed as in C\n    (row-major) or FORTRAN (column-major) order."
              }
            },
            "returns": "reshaped_array : array\n    A new view on the array.",
            "raises": "",
            "see_also": "reshape : Equivalent function in the masked array module.\nnumpy.ndarray.reshape : Equivalent method on ndarray object.\nnumpy.reshape : Equivalent function in the NumPy module.",
            "notes": "The reshaping operation cannot guarantee that a copy will not be made,\nto modify the shape in place, use ``a.shape = s``",
            "examples": ">>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n>>> x\nmasked_array(\n  data=[[--, 2],\n        [3, --]],\n  mask=[[ True, False],\n        [False,  True]],\n  fill_value=999999)\n>>> x = x.reshape((4,1))\n>>> x\nmasked_array(\n  data=[[--],\n        [2],\n        [3],\n        [--]],\n  mask=[[ True],\n        [False],\n        [False],\n        [ True]],\n  fill_value=999999)"
          }
        },
        {
          "name": "resize",
          "signature": "resize(self, newshape, refcheck=True, order=False)",
          "docstring": {
            "description": ".. warning::\n\n    This method does nothing, except raise a ValueError exception. A\n    masked array does not own its data and therefore cannot safely be\n    resized in place. Use the `numpy.ma.resize` function instead.\n\nThis method is difficult to implement safely and may be deprecated in\nfuture releases of NumPy.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(self, decimals=0, out=None)",
          "docstring": {
            "description": "Return each element rounded to the given number of decimals.\n\nRefer to `numpy.around` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.round : corresponding function for ndarrays\nnumpy.around : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "docstring": {
            "description": "a.searchsorted(v, side='left', sorter=None)\n\nFind indices where elements of v should be inserted in a to maintain order.\n\nFor full documentation, see `numpy.searchsorted`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.searchsorted : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_fill_value",
          "signature": "fill_value(self, value=None)",
          "docstring": {}
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "docstring": {
            "description": "a.setfield(val, dtype, offset=0)\n\nPut a value into a specified place in a field defined by a data-type.\n\nPlace `val` into `a`'s field defined by `dtype` and beginning `offset`\nbytes into the field.",
            "parameters": {
              "val": {
                "type": "object",
                "description": "Value to be placed in field."
              },
              "dtype": {
                "type": "dtype object",
                "description": "Data-type of the field in which to place `val`."
              },
              "offset": {
                "type": "int, optional",
                "description": "The number of bytes into the field at which to place `val`."
              }
            },
            "returns": "None",
            "raises": "",
            "see_also": "getfield",
            "notes": "",
            "examples": ">>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n>>> x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])"
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "docstring": {
            "description": "a.setflags(write=None, align=None, uic=None)\n\nSet array flags WRITEABLE, ALIGNED, WRITEBACKIFCOPY,\nrespectively.\n\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by `a` (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and flag can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)",
            "parameters": {
              "write": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` can be written to."
              },
              "align": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is aligned properly for its type."
              },
              "uic": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is a copy of another \"base\" array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "Array flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, WRITEABLE, and ALIGNED.\n\nWRITEABLE (W) the data area can be written to;\n\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\n\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\n\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.",
            "examples": ">>> y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: cannot set WRITEBACKIFCOPY flag to True"
          }
        },
        {
          "name": "shrink_mask",
          "signature": "shrink_mask(self)",
          "docstring": {
            "description": "Reduce a mask to nomask when possible.",
            "parameters": {},
            "returns": "None",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n>>> x.mask\narray([[False, False],\n       [False, False]])\n>>> x.shrink_mask()\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n>>> x.mask\nFalse"
          }
        },
        {
          "name": "soften_mask",
          "signature": "soften_mask(self)",
          "docstring": {
            "description": "Force the mask to soft (default), allowing unmasking by assignment.\n\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `soften_mask` sets\n`~ma.MaskedArray.hardmask` to ``False`` (and returns the modified\nself).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "ma.MaskedArray.hardmask\nma.MaskedArray.harden_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(self, axis=-1, kind=None, order=None, endwith=True, fill_value=None)",
          "docstring": {
            "description": "Sort the array, in-place",
            "parameters": {
              "a": {
                "type": "array_like",
                "description": "Array to be sorted."
              },
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. If None, the array is flattened before\n    sorting. The default is -1, which sorts along the last axis."
              },
              "kind": {
                "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
                "description": "The sorting algorithm used."
              },
              "order": {
                "type": "list, optional",
                "description": "When `a` is a structured array, this argument specifies which fields\n    to compare first, second, and so on.  This list does not need to\n    include all of the fields."
              },
              "endwith": {
                "type": "{True, False}, optional",
                "description": "Whether missing values (if any) should be treated as the largest values\n    (True) or the smallest values (False)\n    When the array contains unmasked values sorting at the same extremes of the\n    datatype, the ordering of these values and the masked values is\n    undefined."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used internally for the masked values.\n    If ``fill_value`` is not None, it supersedes ``endwith``."
              }
            },
            "returns": "sorted_array : ndarray\n    Array of the same type and shape as `a`.",
            "raises": "",
            "see_also": "numpy.ndarray.sort : Method to sort an array in-place.\nargsort : Indirect sort.\nlexsort : Indirect stable sort on multiple keys.\nsearchsorted : Find elements in a sorted array.",
            "notes": "See ``sort`` for notes on the different sorting algorithms.",
            "examples": ">>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Default\n>>> a.sort()\n>>> a\nmasked_array(data=[1, 3, 5, --, --],\n             mask=[False, False, False,  True,  True],\n       fill_value=999999)\n\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Put missing values in the front\n>>> a.sort(endwith=False)\n>>> a\nmasked_array(data=[--, --, 1, 3, 5],\n             mask=[ True,  True, False, False, False],\n       fill_value=999999)\n\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # fill_value takes over endwith\n>>> a.sort(endwith=False, fill_value=3)\n>>> a\nmasked_array(data=[1, --, --, 3, 5],\n             mask=[False,  True,  True, False, False],\n       fill_value=999999)"
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(self, *args, **params)",
          "docstring": {
            "description": "a.squeeze(axis=None)\n\nRemove axes of length one from `a`.\n\nRefer to `numpy.squeeze` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.squeeze : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "docstring": {
            "description": "Returns the standard deviation of the array elements along given axis.\n\nMasked entries are ignored.\n\nRefer to `numpy.std` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.std : corresponding function for ndarrays\nnumpy.std : Equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the sum of the array elements over the given axis.\n\nMasked elements are set to 0 internally.\n\nRefer to `numpy.sum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.sum : corresponding function for ndarrays\nnumpy.sum : equivalent function",
            "notes": "",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.sum()\n25\n>>> x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\n             mask=[False, False, False],\n       fill_value=999999)\n>>> x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\n             mask=[False, False, False],\n       fill_value=999999)\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<class 'numpy.int64'>"
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(self, *args, **params)",
          "docstring": {
            "description": "a.swapaxes(axis1, axis2)\n\nReturn a view of the array with `axis1` and `axis2` interchanged.\n\nRefer to `numpy.swapaxes` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.swapaxes : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(self, indices, axis=None, out=None, mode='raise')",
          "docstring": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(self, fill_value=None, order='C')",
          "docstring": {
            "description": "Return the array data as a string containing the raw bytes in the array.\n\nThe array is filled with a fill value before the string conversion.\n\n.. versionadded:: 1.9.0",
            "parameters": {
              "fill_value": {
                "type": "scalar, optional",
                "description": "Value used to fill in the masked values. Default is None, in which\n    case `MaskedArray.fill_value` is used."
              },
              "order": {
                "type": "{'C','F','A'}, optional",
                "description": "Order of the data item in the copy. Default is 'C'.\n\n    - 'C'   -- C order (row major).\n    - 'F'   -- Fortran order (column major).\n    - 'A'   -- Any, current order of array.\n    - None  -- Same as 'A'."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.tobytes\ntolist, tofile",
            "notes": "As for `ndarray.tobytes`, information about the shape, dtype, etc.,\nbut also about `fill_value`, will be lost.",
            "examples": ">>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n>>> x.tobytes()\nb'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(self, fid, sep='', format='%s')",
          "docstring": {
            "description": "Save a masked array to a file in binary format.\n\n.. warning::\n  This function is not implemented yet.",
            "parameters": {},
            "returns": "",
            "raises": "NotImplementedError\n    When `tofile` is called.",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "toflex",
          "signature": "toflex(self)",
          "docstring": {
            "description": "Transforms a masked array into a flexible-type array.\n\nThe flexible type array that is returned will have two fields:\n\n* the ``_data`` field stores the ``_data`` part of the array.\n* the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "record : ndarray\n    A new flexible-type `ndarray` with two fields: the first element\n    containing a value, the second element containing the corresponding\n    mask boolean. The returned record shape matches self.shape.",
            "raises": "",
            "see_also": "",
            "notes": "A side-effect of transforming a masked array into a flexible `ndarray` is\nthat meta information (``fill_value``, ...) will be lost.",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '<i8'), ('_mask', '?')])"
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(self, fill_value=None)",
          "docstring": {
            "description": "Return the data portion of the masked array as a hierarchical Python list.\n\nData items are converted to the nearest compatible Python type.\nMasked values are converted to `fill_value`. If `fill_value` is None,\nthe corresponding entries in the output list will be ``None``.",
            "parameters": {
              "fill_value": {
                "type": "scalar, optional",
                "description": "The value to use for invalid entries. Default is None."
              }
            },
            "returns": "result : list\n    The Python list representation of the masked array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n>>> x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n>>> x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]"
          }
        },
        {
          "name": "torecords",
          "signature": "toflex(self)",
          "docstring": {
            "description": "Transforms a masked array into a flexible-type array.\n\nThe flexible type array that is returned will have two fields:\n\n* the ``_data`` field stores the ``_data`` part of the array.\n* the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "record : ndarray\n    A new flexible-type `ndarray` with two fields: the first element\n    containing a value, the second element containing the corresponding\n    mask boolean. The returned record shape matches self.shape.",
            "raises": "",
            "see_also": "",
            "notes": "A side-effect of transforming a masked array into a flexible `ndarray` is\nthat meta information (``fill_value``, ...) will be lost.",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '<i8'), ('_mask', '?')])"
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(self, fill_value=None, order='C')",
          "docstring": {
            "description": "A compatibility alias for `tobytes`, with exactly the same behavior.\n\nDespite its name, it returns `bytes` not `str`\\ s.\n\n.. deprecated:: 1.19.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)",
          "docstring": {
            "description": "a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\n\nReturn the sum along diagonals of the array.\n\nRefer to `numpy.trace` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.trace : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(self, *args, **params)",
          "docstring": {
            "description": "a.transpose(*axes)\n\nReturns a view of the array with axes transposed.\n\nRefer to `numpy.transpose` for full documentation.",
            "parameters": {
              "axes": {
                "type": "None, tuple of ints, or `n` ints",
                "description": "* None or no argument: reverses the order of the axes.\n\n * tuple of ints: `i` in the `j`-th place in the tuple means that the\n   array's `i`-th axis becomes the transposed array's `j`-th axis.\n\n * `n` ints: same as an n-tuple of the same ints (this form is\n   intended simply as a \"convenience\" alternative to the tuple form)."
              }
            },
            "returns": "p : ndarray\n    View of the array with its axes suitably permuted.",
            "raises": "",
            "see_also": "transpose : Equivalent function.\nndarray.T : Array property returning the array transposed.\nndarray.reshape : Give a new shape to an array without changing its data.",
            "notes": "",
            "examples": ">>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n>>> a = np.array([1, 2, 3, 4])\n>>> a\narray([1, 2, 3, 4])\n>>> a.transpose()\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "unshare_mask",
          "signature": "unshare_mask(self)",
          "docstring": {
            "description": "Copy the mask and set the `sharedmask` flag to ``False``.\n\nWhether the mask is shared between masked arrays can be seen from\nthe `sharedmask` property. `unshare_mask` ensures the mask is not\nshared. A copy of the mask is only made if it was shared.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "sharedmask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "docstring": {
            "description": "Compute the variance along the specified axis.\n\nReturns the variance of the array elements, a measure of the spread of a\ndistribution.  The variance is computed for the flattened array by\ndefault, otherwise over the specified axis.",
            "parameters": {
              "a": {
                "type": "array_like",
                "description": "Array containing numbers whose variance is desired.  If `a` is not an\n    array, a conversion is attempted."
              },
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis or axes along which the variance is computed.  The default is to\n    compute the variance of the flattened array.\n\n    .. versionadded:: 1.7.0\n\n    If this is a tuple of ints, a variance is performed over multiple axes,\n    instead of a single axis or all the axes as before."
              },
              "dtype": {
                "type": "data-type, optional",
                "description": "Type to use in computing the variance.  For arrays of integer type\n    the default is `float64`; for arrays of float types it is the same as\n    the array type."
              },
              "out": {
                "type": "ndarray, optional",
                "description": "Alternate output array in which to place the result.  It must have\n    the same shape as the expected output, but the type is cast if\n    necessary."
              },
              "ddof": {
                "type": "int, optional",
                "description": "\"Delta Degrees of Freedom\": the divisor used in the calculation is\n    ``N - ddof``, where ``N`` represents the number of elements. By\n    default `ddof` is zero."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the input array.\n\n    If the default value is passed, then `keepdims` will not be\n    passed through to the `var` method of sub-classes of\n    `ndarray`, however any non-default value will be.  If the\n    sub-class' method does not implement `keepdims` any\n    exceptions will be raised."
              },
              "where": {
                "type": "array_like of bool, optional",
                "description": "Elements to include in the variance. See `~numpy.ufunc.reduce` for\n    details.\n\n    .. versionadded:: 1.20.0"
              }
            },
            "returns": "variance : ndarray, see dtype parameter above\n    If ``out=None``, returns a new array containing the variance;\n    otherwise, a reference to the output array is returned.",
            "raises": "",
            "see_also": "std, mean, nanmean, nanstd, nanvar\n:ref:`ufuncs-output-type`",
            "notes": "The variance is the average of the squared deviations from the mean,\ni.e.,  ``var = mean(x)``, where ``x = abs(a - a.mean())**2``.\n\nThe mean is typically calculated as ``x.sum() / N``, where ``N = len(x)``.\nIf, however, `ddof` is specified, the divisor ``N - ddof`` is used\ninstead.  In standard statistical practice, ``ddof=1`` provides an\nunbiased estimator of the variance of a hypothetical infinite population.\n``ddof=0`` provides a maximum likelihood estimate of the variance for\nnormally distributed variables.\n\nNote that for complex numbers, the absolute value is taken before\nsquaring, so that the result is always real and nonnegative.\n\nFor floating-point input, the variance is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for `float32` (see example\nbelow).  Specifying a higher-accuracy accumulator using the ``dtype``\nkeyword can alleviate this issue.",
            "examples": ">>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([1.,  1.])\n>>> np.var(a, axis=1)\narray([0.25,  0.25])\n\nIn single precision, var() can be inaccurate:\n\n>>> a = np.zeros((2, 512*512), dtype=np.float32)\n>>> a[0, :] = 1.0\n>>> a[1, :] = 0.1\n>>> np.var(a)\n0.20250003\n\nComputing the variance in float64 is more accurate:\n\n>>> np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n>>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n\nSpecifying a where argument:\n\n>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])\n>>> np.var(a)\n6.833333333333333 # may vary\n>>> np.var(a, where=[[True], [True], [False]])\n4.0"
          }
        },
        {
          "name": "view",
          "signature": "view(self, dtype=None, type=None, fill_value=None)",
          "docstring": {
            "description": "Return a view of the MaskedArray data.",
            "parameters": {
              "dtype": {
                "type": "data-type or ndarray sub-class, optional",
                "description": "Data-type descriptor of the returned view, e.g., float32 or int16.\n    The default, None, results in the view having the same data-type\n    as `a`. As with ``ndarray.view``, dtype can also be specified as\n    an ndarray sub-class, which then specifies the type of the\n    returned object (this is equivalent to setting the ``type``\n    parameter)."
              },
              "type": {
                "type": "Python type, optional",
                "description": "Type of the returned view, either ndarray or a subclass.  The\n    default None results in type preservation."
              },
              "fill_value": {
                "type": "scalar, optional",
                "description": "The value to use for invalid entries (None by default).\n    If None, then this argument is inferred from the passed `dtype`, or\n    in its absence the original array, as discussed in the notes below."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.view : Equivalent method on ndarray object.",
            "notes": "``a.view()`` is used two different ways:\n\n``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view\nof the array's memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\n\n``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just\nreturns an instance of `ndarray_subclass` that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\n\nIf `fill_value` is not specified, but `dtype` is specified (and is not\nan ndarray sub-class), the `fill_value` of the MaskedArray will be\nreset. If neither `fill_value` nor `dtype` are specified (or if\n`dtype` is an ndarray sub-class), then the fill value is preserved.\nFinally, if `fill_value` is specified, but `dtype` is not, the fill\nvalue is set to the specified value.\n\nFor ``a.view(some_dtype)``, if ``some_dtype`` has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of ``a`` (shown\nby ``print(a)``). It also depends on exactly how ``a`` is stored in\nmemory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "mvoid",
      "docstring": {
        "description": "Fake a 'void' object to use for masked array with structured dtypes.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(self, axis=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Returns True if all elements evaluate to True.\n\nThe output array is masked where all the values along the given axis\nare masked: if the output would have been a scalar and that all the\nvalues are masked, then the output is `masked`.\n\nRefer to `numpy.all` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.all : corresponding function for ndarrays\nnumpy.all : equivalent function",
            "notes": "",
            "examples": ">>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue"
          }
        },
        {
          "name": "anom",
          "signature": "anom(self, axis=None, dtype=None)",
          "docstring": {
            "description": "Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.\n\nReturns an array of anomalies, with the same shape as the input and\nwhere the arithmetic mean is computed along the given axis.",
            "parameters": {
              "axis": {
                "type": "int, optional",
                "description": "Axis over which the anomalies are taken.\n    The default is to use the mean of the flattened array as reference."
              },
              "dtype": {
                "type": "dtype, optional",
                "description": "Type to use in computing the variance. For arrays of integer type\n     the default is float32; for arrays of float types it is the same as\n     the array type."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "mean : Compute the mean of the array.",
            "notes": "",
            "examples": ">>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)"
          }
        },
        {
          "name": "any",
          "signature": "any(self, axis=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Returns True if any of the elements of `a` evaluate to True.\n\nMasked values are considered as False during computation.\n\nRefer to `numpy.any` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.any : corresponding function for ndarrays\nnumpy.any : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "docstring": {
            "description": "Returns array of indices of the maximum values along the given axis.\nMasked values are treated as if they had the value fill_value.",
            "parameters": {
              "axis": {
                "type": "{None, integer}",
                "description": "If None, the index is into the flattened array, otherwise along\n    the specified axis"
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.  If None, the output of\n    maximum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None, array}, optional",
                "description": "Array into which the result can be placed. Its type is preserved\n    and it must be of the right shape to hold the output."
              }
            },
            "returns": "index_array : {integer_array}",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])"
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "docstring": {
            "description": "Return array of indices to the minimum values along the given axis.",
            "parameters": {
              "axis": {
                "type": "{None, integer}",
                "description": "If None, the index is into the flattened array, otherwise along\n    the specified axis"
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.  If None, the output of\n    minimum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None, array}, optional",
                "description": "Array into which the result can be placed. Its type is preserved\n    and it must be of the right shape to hold the output."
              }
            },
            "returns": "ndarray or scalar\n    If multi-dimension input, returns a new ndarray of indices to the\n    minimum values along the given axis.  Otherwise, returns a scalar\n    of index to the minimum values along the given axis.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> x\nmasked_array(\n  data=[[--, --],\n        [2, 3]],\n  mask=[[ True,  True],\n        [False, False]],\n  fill_value=999999)\n>>> x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n>>> x.argmin(axis=0, fill_value=9)\narray([1, 1])"
          }
        },
        {
          "name": "argpartition",
          "signature": "argpartition(self, *args, **kwargs)",
          "docstring": {
            "description": "a.argpartition(kth, axis=-1, kind='introselect', order=None)\n\nReturns the indices that would partition this array.\n\nRefer to `numpy.argpartition` for full documentation.\n\n.. versionadded:: 1.8.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.argpartition : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(self, axis=<no value>, kind=None, order=None, endwith=True, fill_value=None)",
          "docstring": {
            "description": "Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\n`fill_value`.",
            "parameters": {
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. If None, the default, the flattened array\n    is used.\n\n    ..  versionchanged:: 1.13.0\n        Previously, the default was documented to be -1, but that was\n        in error. At some future date, the default will change to -1, as\n        originally intended.\n        Until then, the axis should be given explicitly when\n        ``arr.ndim > 1``, to avoid a FutureWarning."
              },
              "kind": {
                "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
                "description": "The sorting algorithm used."
              },
              "order": {
                "type": "list, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\n    which fields to compare first, second, etc.  Not all fields need be\n    specified."
              },
              "endwith": {
                "type": "{True, False}, optional",
                "description": "Whether missing values (if any) should be treated as the largest values\n    (True) or the smallest values (False)\n    When the array contains unmasked values at the same extremes of the\n    datatype, the ordering of these values and the masked values is\n    undefined."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used internally for the masked values.\n    If ``fill_value`` is not None, it supersedes ``endwith``."
              }
            },
            "returns": "index_array : ndarray, int\n    Array of indices that sort `a` along the specified axis.\n    In other words, ``a[index_array]`` yields a sorted `a`.",
            "raises": "",
            "see_also": "ma.MaskedArray.sort : Describes sorting algorithms used.\nlexsort : Indirect stable sort with multiple keys.\nnumpy.ndarray.sort : Inplace sort.",
            "notes": "See `sort` for notes on the different sorting algorithms.",
            "examples": ">>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data=[3, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n>>> a.argsort()\narray([1, 0, 2])"
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "docstring": {
            "description": "a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\n\nCopy of the array, cast to a specified type.",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "Typecode or data-type to which the array is cast."
              },
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout order of the result.\n    'C' means C order, 'F' means Fortran order, 'A'\n    means 'F' order if all the arrays are Fortran contiguous,\n    'C' order otherwise, and 'K' means as close to the\n    order the array elements appear in memory as possible.\n    Default is 'K'."
              },
              "casting": {
                "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
                "description": "Controls what kind of data casting may occur. Defaults to 'unsafe'\n    for backwards compatibility.\n\n      * 'no' means the data types should not be cast at all.\n      * 'equiv' means only byte-order changes are allowed.\n      * 'safe' means only casts which can preserve values are allowed.\n      * 'same_kind' means only safe casts or casts within a kind,\n        like float64 to float32, are allowed.\n      * 'unsafe' means any data conversions may be done."
              },
              "subok": {
                "type": "bool, optional",
                "description": "If True, then sub-classes will be passed-through (default), otherwise\n    the returned array will be forced to be a base-class array."
              },
              "copy": {
                "type": "bool, optional",
                "description": "By default, astype always returns a newly allocated array. If this\n    is set to false, and the `dtype`, `order`, and `subok`\n    requirements are satisfied, the input array is returned instead\n    of a copy."
              }
            },
            "returns": "arr_t : ndarray\n    Unless `copy` is False and the other conditions for returning the input\n    array are satisfied (see description for `copy` input parameter), `arr_t`\n    is a new array of the same shape as the input array, with dtype, order\n    given by `dtype`, `order`.",
            "raises": "ComplexWarning\n    When casting from complex to float or int. To avoid this,\n    one should use ``a.real.astype(t)``.",
            "see_also": "",
            "notes": ".. versionchanged:: 1.17.0\n   Casting between a simple data type and a structured one is possible only\n   for \"unsafe\" casting.  Casting to multiple fields is allowed, but\n   casting from multiple fields is not.\n\n.. versionchanged:: 1.9.0\n   Casting from numeric to string types in 'safe' casting mode requires\n   that the string dtype length is long enough to store the max\n   integer/float value converted.",
            "examples": ">>> x = np.array([1, 2, 2.5])\n>>> x\narray([1. ,  2. ,  2.5])\n\n>>> x.astype(int)\narray([1, 2, 2])"
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "docstring": {
            "description": "a.byteswap(inplace=False)\n\nSwap the bytes of the array elements\n\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.",
            "parameters": {
              "inplace": {
                "type": "bool, optional",
                "description": "If ``True``, swap bytes in-place, default is ``False``."
              }
            },
            "returns": "out : ndarray\n    The byteswapped array. If `inplace` is ``True``, this is\n    a view to self.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> list(map(hex, A))\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n>>> list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\nArrays of byte-strings are not swapped\n\n>>> A = np.array([b'ceg', b'fac'])\n>>> A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n``A.newbyteorder().byteswap()`` produces an array with the same values\n  but different representation in memory\n\n>>> A = np.array([1, 2, 3])\n>>> A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n>>> A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n>>> A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)"
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "docstring": {
            "description": "a.choose(choices, out=None, mode='raise')\n\nUse an index array to construct a new array from a set of choices.\n\nRefer to `numpy.choose` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.choose : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "docstring": {
            "description": "a.clip(min=None, max=None, out=None, **kwargs)\n\nReturn an array whose values are limited to ``[min, max]``.\nOne of max or min must be given.\n\nRefer to `numpy.clip` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.clip : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(self, condition, axis=None, out=None)",
          "docstring": {
            "description": "Return `a` where condition is ``True``.\n\nIf condition is a `~ma.MaskedArray`, missing values are considered\nas ``False``.",
            "parameters": {
              "condition": {
                "type": "var",
                "description": "Boolean 1-d array selecting which entries to return. If len(condition)\n    is less than the size of a along the axis, then output is truncated\n    to length of condition array."
              },
              "axis": {
                "type": "{None, int}, optional",
                "description": "Axis along which the operation must be performed."
              },
              "out": {
                "type": "{None, ndarray}, optional",
                "description": "Alternative output array in which to place the result. It must have\n    the same shape as the expected output but the type will be cast if\n    necessary."
              }
            },
            "returns": "result : MaskedArray\n    A :class:`~ma.MaskedArray` object.",
            "raises": "",
            "see_also": "",
            "notes": "Please note the difference with :meth:`compressed` !\nThe output of :meth:`compress` has a mask, the output of\n:meth:`compressed` does not.",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\n             mask=[False, False],\n       fill_value=999999)\n\n>>> x.compress([1, 0, 1], axis=1)\nmasked_array(\n  data=[[1, 3],\n        [--, --],\n        [7, 9]],\n  mask=[[False, False],\n        [ True,  True],\n        [False, False]],\n  fill_value=999999)"
          }
        },
        {
          "name": "compressed",
          "signature": "compressed(self)",
          "docstring": {
            "description": "Return all the non-masked data as a 1-D array.",
            "parameters": {},
            "returns": "data : ndarray\n    A new `ndarray` holding the non-masked data is returned.",
            "raises": "",
            "see_also": "",
            "notes": "The result is **not** a MaskedArray!",
            "examples": ">>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n>>> x.compressed()\narray([0, 1])\n>>> type(x.compressed())\n<class 'numpy.ndarray'>"
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "docstring": {
            "description": "a.conj()\n\nComplex-conjugate all elements.\n\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "docstring": {
            "description": "a.conjugate()\n\nReturn the complex conjugate, element-wise.\n\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(self, *args, **params)",
          "docstring": {
            "description": "a.copy(order='C')\n\nReturn a copy of the array.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout of the copy. 'C' means C-order,\n    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n    'C' otherwise. 'K' means match the layout of `a` as closely\n    as possible. (Note that this function and :func:`numpy.copy` are very\n    similar but have different default values for their order=\n    arguments, and this function always passes sub-classes through.)\n\nSee also\n--------"
              },
              "numpy.copy": {
                "type": "Similar function with different default behavior",
                "description": "numpy.copyto"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "This function is the preferred method for creating an array copy.  The\nfunction :func:`numpy.copy` is similar, but it defaults to using order 'K',\nand will not pass sub-classes through by default.",
            "examples": ">>> x = np.array([[1,2,3],[4,5,6]], order='F')\n\n>>> y = x.copy()\n\n>>> x.fill(0)\n\n>>> x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n>>> y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n>>> y.flags['C_CONTIGUOUS']\nTrue"
          }
        },
        {
          "name": "count",
          "signature": "count(self, axis=None, keepdims=<no value>)",
          "docstring": {
            "description": "Count the non-masked elements of the array along the given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis or axes along which the count is performed.\n    The default, None, performs the count over all\n    the dimensions of the input array. `axis` may be negative, in\n    which case it counts from the last to the first axis.\n\n    .. versionadded:: 1.10.0\n\n    If this is a tuple of ints, the count is performed on multiple\n    axes, instead of a single axis or all the axes as before."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
              }
            },
            "returns": "result : ndarray or scalar\n    An array with the same shape as the input array, with the specified\n    axis removed. If the array is a 0-d array, or if `axis` is None, a\n    scalar is returned.",
            "raises": "",
            "see_also": "ma.count_masked : Count masked elements in array or along a given axis.",
            "notes": "",
            "examples": ">>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, --, --]],\n  mask=[[False, False, False],\n        [ True,  True,  True]],\n  fill_value=999999)\n>>> a.count()\n3\n\nWhen the `axis` keyword is specified an array of appropriate size is\nreturned.\n\n>>> a.count(axis=0)\narray([1, 1, 1])\n>>> a.count(axis=1)\narray([3, 0])"
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(self, axis=None, dtype=None, out=None)",
          "docstring": {
            "description": "Return the cumulative product of the array elements over the given axis.\n\nMasked values are set to 1 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\n\nRefer to `numpy.cumprod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.cumprod : corresponding function for ndarrays\nnumpy.cumprod : equivalent function",
            "notes": "The mask is lost if `out` is not a valid MaskedArray !\n\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(self, axis=None, dtype=None, out=None)",
          "docstring": {
            "description": "Return the cumulative sum of the array elements over the given axis.\n\nMasked values are set to 0 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\n\nRefer to `numpy.cumsum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.cumsum : corresponding function for ndarrays\nnumpy.cumsum : equivalent function",
            "notes": "The mask is lost if `out` is not a valid :class:`ma.MaskedArray` !\n\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
            "examples": ">>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n             mask=[False, False, False,  True,  True,  True, False, False,\n                   False, False],\n       fill_value=999999)"
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(self, *args, **params)",
          "docstring": {
            "description": "a.diagonal(offset=0, axis1=0, axis2=1)\n\nReturn specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\n\nRefer to :func:`numpy.diagonal` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.diagonal : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dot",
          "signature": "dot(self, b, out=None, strict=False)",
          "docstring": {
            "description": "a.dot(b, out=None)\n\nMasked dot product of two arrays. Note that `out` and `strict` are\nlocated in different positions than in `ma.dot`. In order to\nmaintain compatibility with the functional version, it is\nrecommended that the optional arguments be treated as keyword only.\nAt some point that may be mandatory.\n\n.. versionadded:: 1.10.0",
            "parameters": {
              "b": {
                "type": "masked_array_like",
                "description": "Inputs array."
              },
              "out": {
                "type": "masked_array, optional",
                "description": "Output argument. This must have the exact kind that would be\n    returned if it was not used. In particular, it must have the\n    right type, must be C-contiguous, and its dtype must be the\n    dtype that would be returned for `ma.dot(a,b)`. This is a\n    performance feature. Therefore, if these conditions are not\n    met, an exception is raised, instead of attempting to be\n    flexible."
              },
              "strict": {
                "type": "bool, optional",
                "description": "Whether masked data are propagated (True) or set to 0 (False)\n    for the computation. Default is False.  Propagating the mask\n    means that if a masked value appears in a row or column, the\n    whole row or column is considered masked.\n\n    .. versionadded:: 1.10.2"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "numpy.ma.dot : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "docstring": {
            "description": "a.dump(file)\n\nDump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.",
            "parameters": {
              "file": {
                "type": "str or Path",
                "description": "A string naming the dump file.\n\n    .. versionchanged:: 1.17.0\n        `pathlib.Path` objects are now accepted."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "docstring": {
            "description": "a.dumps()\n\nReturns the pickle of the array as a string.\npickle.loads will convert the string back to an array.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "docstring": {
            "description": "a.fill(value)\n\nFill the array with a scalar value.",
            "parameters": {
              "value": {
                "type": "scalar",
                "description": "All elements of `a` will be assigned this value."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([1.,  1.])\n\nFill expects a scalar value and always behaves the same as assigning\nto a single array element.  The following is a rare example where this\ndistinction is important:\n\n>>> a = np.array([None, None], dtype=object)\n>>> a[0] = np.array(3)\n>>> a\narray([array(3), None], dtype=object)\n>>> a.fill(np.array(3))\n>>> a\narray([array(3), array(3)], dtype=object)\n\nWhere other forms of assignments will unpack the array being assigned:\n\n>>> a[...] = np.array(3)\n>>> a\narray([3, 3], dtype=object)"
          }
        },
        {
          "name": "filled",
          "signature": "filled(self, fill_value=None)",
          "docstring": {
            "description": "Return a copy with masked fields filled with a given value.",
            "parameters": {
              "fill_value": {
                "type": "array_like, optional",
                "description": "The value to use for invalid entries. Can be scalar or\n    non-scalar. If latter is the case, the filled array should\n    be broadcastable over input array. Default is None, in\n    which case the `fill_value` attribute is used instead."
              }
            },
            "returns": "filled_void\n    A `np.void` object",
            "raises": "",
            "see_also": "MaskedArray.filled",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(self, *args, **params)",
          "docstring": {
            "description": "a.flatten(order='C')\n\nReturn a copy of the array collapsed into one dimension.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "'C' means to flatten in row-major (C-style) order.\n    'F' means to flatten in column-major (Fortran-\n    style) order. 'A' means to flatten in column-major\n    order if `a` is Fortran *contiguous* in memory,\n    row-major order otherwise. 'K' means to flatten\n    `a` in the order the elements occur in memory.\n    The default is 'C'."
              }
            },
            "returns": "y : ndarray\n    A copy of the input array, flattened to one dimension.",
            "raises": "",
            "see_also": "ravel : Return a flattened array.\nflat : A 1-D flat iterator over the array.",
            "notes": "",
            "examples": ">>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])"
          }
        },
        {
          "name": "get_fill_value",
          "signature": "fill_value(self)",
          "docstring": {
            "description": "The filling value of the masked array is a scalar. When setting, None\nwill set to a default based on the data type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n\n>>> x = np.ma.array([0, 1.], fill_value=-np.inf)\n>>> x.fill_value\n-inf\n>>> x.fill_value = np.pi\n>>> x.fill_value\n3.1415926535897931 # may vary\n\nReset to default:\n\n>>> x.fill_value = None\n>>> x.fill_value\n1e+20"
          }
        },
        {
          "name": "get_imag",
          "signature": "imag(self)",
          "docstring": {
            "description": "The imaginary part of the masked array.\n\nThis property is a view on the imaginary part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "real",
            "notes": "",
            "examples": ">>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.imag\nmasked_array(data=[1.0, --, 1.6],\n             mask=[False,  True, False],\n       fill_value=1e+20)"
          }
        },
        {
          "name": "get_real",
          "signature": "real(self)",
          "docstring": {
            "description": "The real part of the masked array.\n\nThis property is a view on the real part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "imag",
            "notes": "",
            "examples": ">>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.real\nmasked_array(data=[1.0, --, 3.45],\n             mask=[False,  True, False],\n       fill_value=1e+20)"
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "docstring": {
            "description": "a.getfield(dtype, offset=0)\n\nReturns a field of the given array as a certain type.\n\nA field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "The data type of the view. The dtype size of the view can not be larger\n    than that of the array itself."
              },
              "offset": {
                "type": "int",
                "description": "Number of bytes to skip before beginning the element view."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n\n>>> x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])"
          }
        },
        {
          "name": "harden_mask",
          "signature": "harden_mask(self)",
          "docstring": {
            "description": "Force the mask to hard, preventing unmasking by assignment.\n\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `harden_mask` sets\n`~ma.MaskedArray.hardmask` to ``True`` (and returns the modified\nself).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "ma.MaskedArray.hardmask\nma.MaskedArray.soften_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ids",
          "signature": "ids(self)",
          "docstring": {
            "description": "Return the addresses of the data and mask areas.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n>>> x.ids()\n(166670640, 166659832) # may vary\n\nIf the array has no mask, the address of `nomask` is returned. This address\nis typically not close to the data in memory:\n\n>>> x = np.ma.array([1, 2, 3])\n>>> x.ids()\n(166691080, 3083169284) # may vary"
          }
        },
        {
          "name": "iscontiguous",
          "signature": "iscontiguous(self)",
          "docstring": {
            "description": "Return a boolean indicating whether the data is contiguous.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([1, 2, 3])\n>>> x.iscontiguous()\nTrue\n\n`iscontiguous` returns one of the flags of the masked array:\n\n>>> x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : True\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False"
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "docstring": {
            "description": "a.item(*args)\n\nCopy an element of an array to a standard Python scalar and return it.",
            "parameters": {
              "\\*args": {
                "type": "Arguments (variable number and type)",
                "description": "* none: in this case, the method only works for arrays\n      with one element (`a.size == 1`), which element is\n      copied into a standard Python scalar object and returned.\n\n    * int_type: this argument is interpreted as a flat index into\n      the array, specifying which element to copy and return.\n\n    * tuple of int_types: functions as does a single int_type argument,\n      except that the argument is interpreted as an nd-index into the\n      array."
              }
            },
            "returns": "z : Standard Python scalar object\n    A copy of the specified element of the array as a suitable\n    Python scalar",
            "raises": "",
            "see_also": "",
            "notes": "When the data type of `a` is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\n\n`item` is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python's optimized math.",
            "examples": ">>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n>>> x.item(3)\n1\n>>> x.item(7)\n0\n>>> x.item((0, 1))\n2\n>>> x.item((2, 2))\n1"
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "docstring": {
            "description": "a.itemset(*args)\n\nInsert scalar into an array (scalar is cast to array's dtype, if possible)\n\nThere must be at least 1 argument, and define the last argument\nas *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster\nthan ``a[args] = item``.  The item should be a scalar value and `args`\nmust select a single item in the array `a`.",
            "parameters": {
              "\\*args": {
                "type": "Arguments",
                "description": "If one argument: a scalar, only used in case `a` is of size 1.\n    If two arguments: the last argument is the value to be set\n    and must be a scalar, the first argument specifies a single array\n    element location. It is either an int or a tuple."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "Compared to indexing syntax, `itemset` provides some speed increase\nfor placing a scalar into a particular location in an `ndarray`,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using `itemset` (and `item`) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.",
            "examples": ">>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])"
          }
        },
        {
          "name": "max",
          "signature": "max(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the maximum along a given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis along which to operate.  By default, ``axis`` is None and the\n    flattened input is used.\n    .. versionadded:: 1.7.0\n    If this is a tuple of ints, the maximum is selected over multiple\n    axes, instead of a single axis or all the axes as before."
              },
              "out": {
                "type": "array_like, optional",
                "description": "Alternative output array in which to place the result.  Must\n    be of the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.\n    If None, use the output of maximum_fill_value()."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
              }
            },
            "returns": "amax : array_like\n    New array holding the result.\n    If ``out`` was specified, ``out`` is returned.",
            "raises": "",
            "see_also": "ma.maximum_fill_value\n    Returns the maximum filling value for a given datatype.",
            "notes": "",
            "examples": ">>> import numpy.ma as ma\n>>> x = [[-1., 2.5], [4., -2.], [3., 0.]]\n>>> mask = [[0, 0], [1, 0], [1, 0]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\n  data=[[-1.0, 2.5],\n        [--, -2.0],\n        [--, 0.0]],\n  mask=[[False, False],\n        [ True, False],\n        [ True, False]],\n  fill_value=1e+20)\n>>> ma.max(masked_x)\n2.5\n>>> ma.max(masked_x, axis=0)\nmasked_array(data=[-1.0, 2.5],\n             mask=[False, False],\n       fill_value=1e+20)\n>>> ma.max(masked_x, axis=1, keepdims=True)\nmasked_array(\n  data=[[2.5],\n        [-2.0],\n        [0.0]],\n  mask=[[False],\n        [False],\n        [False]],\n  fill_value=1e+20)\n>>> mask = [[1, 1], [1, 1], [1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.max(masked_x, axis=1)\nmasked_array(data=[--, --, --],\n             mask=[ True,  True,  True],\n       fill_value=1e+20,\n            dtype=float64)"
          }
        },
        {
          "name": "mean",
          "signature": "mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Returns the average of the array elements along given axis.\n\nMasked entries are ignored, and result elements which are not\nfinite will be masked.\n\nRefer to `numpy.mean` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.mean : corresponding function for ndarrays\nnumpy.mean : Equivalent function\nnumpy.ma.average : Weighted average.",
            "notes": "",
            "examples": ">>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data=[1, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n>>> a.mean()\n1.5"
          }
        },
        {
          "name": "min",
          "signature": "min(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the minimum along a given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis along which to operate.  By default, ``axis`` is None and the\n    flattened input is used.\n    .. versionadded:: 1.7.0\n    If this is a tuple of ints, the minimum is selected over multiple\n    axes, instead of a single axis or all the axes as before."
              },
              "out": {
                "type": "array_like, optional",
                "description": "Alternative output array in which to place the result.  Must be of\n    the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.\n    If None, use the output of `minimum_fill_value`."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
              }
            },
            "returns": "amin : array_like\n    New array holding the result.\n    If ``out`` was specified, ``out`` is returned.",
            "raises": "",
            "see_also": "ma.minimum_fill_value\n    Returns the minimum filling value for a given datatype.",
            "notes": "",
            "examples": ">>> import numpy.ma as ma\n>>> x = [[1., -2., 3.], [0.2, -0.7, 0.1]]\n>>> mask = [[1, 1, 0], [0, 0, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\n  data=[[--, --, 3.0],\n        [0.2, -0.7, --]],\n  mask=[[ True,  True, False],\n        [False, False,  True]],\n  fill_value=1e+20)\n>>> ma.min(masked_x)\n-0.7\n>>> ma.min(masked_x, axis=-1)\nmasked_array(data=[3.0, -0.7],\n             mask=[False, False],\n        fill_value=1e+20)\n>>> ma.min(masked_x, axis=0, keepdims=True)\nmasked_array(data=[[0.2, -0.7, 3.0]],\n             mask=[[False, False, False]],\n        fill_value=1e+20)\n>>> mask = [[1, 1, 1,], [1, 1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.min(masked_x, axis=0)\nmasked_array(data=[--, --, --],\n             mask=[ True,  True,  True],\n        fill_value=1e+20,\n            dtype=float64)"
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(...)",
          "docstring": {
            "description": "arr.newbyteorder(new_order='S', /)\n\nReturn the array with the same data viewed with a different byte order.\n\nEquivalent to::\n\n    arr.view(arr.dtype.newbytorder(new_order))\n\nChanges are also made in all fields and sub-arrays of the array data\ntype.",
            "parameters": {
              "new_order": {
                "type": "string, optional",
                "description": "Byte order to force; a value from the byte order specifications\n    below. `new_order` codes can be any of:\n\n    * 'S' - swap dtype from current to opposite endian\n    * {'<', 'little'} - little endian\n    * {'>', 'big'} - big endian\n    * {'=', 'native'} - native order, equivalent to `sys.byteorder`\n    * {'|', 'I'} - ignore (no change to byte order)\n\n    The default value ('S') results in swapping the current\n    byte order."
              }
            },
            "returns": "new_arr : array\n    New array object with the dtype reflecting given change to the\n    byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(self)",
          "docstring": {
            "description": "Return the indices of unmasked elements that are not zero.\n\nReturns a tuple of arrays, one for each dimension, containing the\nindices of the non-zero elements in that dimension. The corresponding\nnon-zero values can be obtained with::\n\n    a[a.nonzero()]\n\nTo group the indices by element, rather than dimension, use\ninstead::\n\n    np.transpose(a.nonzero())\n\nThe result of this is always a 2d array, with a row for each non-zero\nelement.",
            "parameters": {},
            "returns": "tuple_of_arrays : tuple\n    Indices of elements that are non-zero.",
            "raises": "",
            "see_also": "numpy.nonzero :\n    Function operating on ndarrays.\nflatnonzero :\n    Return indices that are non-zero in the flattened version of the input\n    array.\nnumpy.ndarray.nonzero :\n    Equivalent ndarray method.\ncount_nonzero :\n    Counts the number of non-zero elements in the input array.",
            "notes": "",
            "examples": ">>> import numpy.ma as ma\n>>> x = ma.array(np.eye(3))\n>>> x\nmasked_array(\n  data=[[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]],\n  mask=False,\n  fill_value=1e+20)\n>>> x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\n\nMasked elements are ignored.\n\n>>> x[1, 1] = ma.masked\n>>> x\nmasked_array(\n  data=[[1.0, 0.0, 0.0],\n        [0.0, --, 0.0],\n        [0.0, 0.0, 1.0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1e+20)\n>>> x.nonzero()\n(array([0, 2]), array([0, 2]))\n\nIndices can also be grouped by element.\n\n>>> np.transpose(x.nonzero())\narray([[0, 0],\n       [2, 2]])\n\nA common use for ``nonzero`` is to find the indices of an array, where\na condition is True.  Given an array `a`, the condition `a` > 3 is a\nboolean array and since False is interpreted as 0, ma.nonzero(a > 3)\nyields the indices of the `a` where the condition is true.\n\n>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n>>> a > 3\nmasked_array(\n  data=[[False, False, False],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  mask=False,\n  fill_value=True)\n>>> ma.nonzero(a > 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\nThe ``nonzero`` method of the condition array can also be called.\n\n>>> (a > 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))"
          }
        },
        {
          "name": "partition",
          "signature": "partition(self, *args, **kwargs)",
          "docstring": {
            "description": "a.partition(kth, axis=-1, kind='introselect', order=None)\n\nRearranges the elements in the array in such a way that the value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.\n\n.. versionadded:: 1.8.0",
            "parameters": {
              "kth": {
                "type": "int or sequence of ints",
                "description": "Element index to partition by. The kth element value will be in its\n    final sorted position and all smaller elements will be moved before it\n    and all equal or greater elements behind it.\n    The order of all elements in the partitions is undefined.\n    If provided with a sequence of kth it will partition all elements\n    indexed by kth of them into their sorted position at once.\n\n    .. deprecated:: 1.22.0\n        Passing booleans as index is deprecated."
              },
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. Default is -1, which means sort along the\n    last axis."
              },
              "kind": {
                "type": "{'introselect'}, optional",
                "description": "Selection algorithm. Default is 'introselect'."
              },
              "order": {
                "type": "str or list of str, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\n    which fields to compare first, second, etc. A single field can\n    be specified as a string, and not all fields need to be specified,\n    but unspecified fields will still be used, in the order in which\n    they come up in the dtype, to break ties."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "numpy.partition : Return a partitioned copy of an array.\nargpartition : Indirect partition.\nsort : Full sort.",
            "notes": "See ``np.partition`` for notes on the different algorithms.",
            "examples": ">>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])\n\n>>> a.partition((1, 3))\n>>> a\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "prod",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the product of the array elements over the given axis.\n\nMasked elements are set to 1 internally for computation.\n\nRefer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
            "notes": "Arithmetic is modular when using integer types, and no error is raised\non overflow.",
            "examples": ""
          }
        },
        {
          "name": "product",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the product of the array elements over the given axis.\n\nMasked elements are set to 1 internally for computation.\n\nRefer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
            "notes": "Arithmetic is modular when using integer types, and no error is raised\non overflow.",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(self, axis=None, out=None, fill_value=None, keepdims=False)",
          "docstring": {
            "description": "Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).\n\n.. warning::\n    `ptp` preserves the data type of the array. This means the\n    return value for an input of signed integers with n bits\n    (e.g. `np.int8`, `np.int16`, etc) is also a signed integer\n    with n bits.  In that case, peak-to-peak values greater than\n    ``2**(n-1)-1`` will be returned as negative values. An example\n    with a work-around is shown below.",
            "parameters": {
              "axis": {
                "type": "{None, int}, optional",
                "description": "Axis along which to find the peaks.  If None (default) the\n    flattened array is used."
              },
              "out": {
                "type": "{None, array_like}, optional",
                "description": "Alternative output array in which to place the result. It must\n    have the same shape and buffer length as the expected output\n    but the type will be cast if necessary."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the array."
              }
            },
            "returns": "ptp : ndarray.\n    A new array holding the result, unless ``out`` was\n    specified, in which case a reference to ``out`` is returned.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.MaskedArray([[4, 9, 2, 10],\n...                        [6, 9, 7, 12]])\n\n>>> x.ptp(axis=1)\nmasked_array(data=[8, 6],\n             mask=False,\n       fill_value=999999)\n\n>>> x.ptp(axis=0)\nmasked_array(data=[2, 0, 5, 2],\n             mask=False,\n       fill_value=999999)\n\n>>> x.ptp()\n10\n\nThis example shows that a negative value can be returned when\nthe input is an array of signed integers.\n\n>>> y = np.ma.MaskedArray([[1, 127],\n...                        [0, 127],\n...                        [-1, 127],\n...                        [-2, 127]], dtype=np.int8)\n>>> y.ptp(axis=1)\nmasked_array(data=[ 126,  127, -128, -127],\n             mask=False,\n       fill_value=999999,\n            dtype=int8)\n\nA work-around is to use the `view()` method to view the result as\nunsigned integers with the same bit width:\n\n>>> y.ptp(axis=1).view(np.uint8)\nmasked_array(data=[126, 127, 128, 129],\n             mask=False,\n       fill_value=999999,\n            dtype=uint8)"
          }
        },
        {
          "name": "put",
          "signature": "put(self, indices, values, mode='raise')",
          "docstring": {
            "description": "Set storage-indexed locations to corresponding values.\n\nSets self._data.flat[n] = values[n] for each n in indices.\nIf `values` is shorter than `indices` then it will repeat.\nIf `values` has some masked values, the initial mask is updated\nin consequence, else the corresponding values are unmasked.",
            "parameters": {
              "indices": {
                "type": "1-D array_like",
                "description": "Target indices, interpreted as integers."
              },
              "values": {
                "type": "array_like",
                "description": "Values to place in self._data copy at target indices."
              },
              "mode": {
                "type": "{'raise', 'wrap', 'clip'}, optional",
                "description": "Specifies how out-of-bounds indices will behave.\n    'raise' : raise an error.\n    'wrap' : wrap around.\n    'clip' : clip to the range."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "`values` can be a scalar or length 1 array.",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.put([0,4,8],[10,20,30])\n>>> x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 20, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n\n>>> x.put(4,999)\n>>> x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 999, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)"
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(self, order='C')",
          "docstring": {
            "description": "Returns a 1D version of self, as a view.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "The elements of `a` are read using this index order. 'C' means to\n    index the elements in C-like order, with the last axis index\n    changing fastest, back to the first axis index changing slowest.\n    'F' means to index the elements in Fortran-like index order, with\n    the first index changing fastest, and the last index changing\n    slowest. Note that the 'C' and 'F' options take no account of the\n    memory layout of the underlying array, and only refer to the order\n    of axis indexing.  'A' means to read the elements in Fortran-like\n    index order if `m` is Fortran *contiguous* in memory, C-like order\n    otherwise.  'K' means to read the elements in the order they occur\n    in memory, except for reversing the data when strides are negative.\n    By default, 'C' index order is used.\n    (Masked arrays currently use 'A' on the data when 'K' is passed.)"
              }
            },
            "returns": "MaskedArray\n    Output view is of shape ``(self.size,)`` (or\n    ``(np.ma.product(self.shape),)``).",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\n             mask=[False,  True, False,  True, False,  True, False,  True,\n                   False],\n       fill_value=999999)"
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(self, *args, **params)",
          "docstring": {
            "description": "a.repeat(repeats, axis=None)\n\nRepeat elements of an array.\n\nRefer to `numpy.repeat` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.repeat : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(self, *s, **kwargs)",
          "docstring": {
            "description": "Give a new shape to the array without changing its data.\n\nReturns a masked array containing the same data, but with a new shape.\nThe result is a view on the original array; if this is not possible, a\nValueError is raised.",
            "parameters": {
              "shape": {
                "type": "int or tuple of ints",
                "description": "The new shape should be compatible with the original shape. If an\n    integer is supplied, then the result will be a 1-D array of that\n    length."
              },
              "order": {
                "type": "{'C', 'F'}, optional",
                "description": "Determines whether the array data should be viewed as in C\n    (row-major) or FORTRAN (column-major) order."
              }
            },
            "returns": "reshaped_array : array\n    A new view on the array.",
            "raises": "",
            "see_also": "reshape : Equivalent function in the masked array module.\nnumpy.ndarray.reshape : Equivalent method on ndarray object.\nnumpy.reshape : Equivalent function in the NumPy module.",
            "notes": "The reshaping operation cannot guarantee that a copy will not be made,\nto modify the shape in place, use ``a.shape = s``",
            "examples": ">>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n>>> x\nmasked_array(\n  data=[[--, 2],\n        [3, --]],\n  mask=[[ True, False],\n        [False,  True]],\n  fill_value=999999)\n>>> x = x.reshape((4,1))\n>>> x\nmasked_array(\n  data=[[--],\n        [2],\n        [3],\n        [--]],\n  mask=[[ True],\n        [False],\n        [False],\n        [ True]],\n  fill_value=999999)"
          }
        },
        {
          "name": "resize",
          "signature": "resize(self, newshape, refcheck=True, order=False)",
          "docstring": {
            "description": ".. warning::\n\n    This method does nothing, except raise a ValueError exception. A\n    masked array does not own its data and therefore cannot safely be\n    resized in place. Use the `numpy.ma.resize` function instead.\n\nThis method is difficult to implement safely and may be deprecated in\nfuture releases of NumPy.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(self, decimals=0, out=None)",
          "docstring": {
            "description": "Return each element rounded to the given number of decimals.\n\nRefer to `numpy.around` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.round : corresponding function for ndarrays\nnumpy.around : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "docstring": {
            "description": "a.searchsorted(v, side='left', sorter=None)\n\nFind indices where elements of v should be inserted in a to maintain order.\n\nFor full documentation, see `numpy.searchsorted`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.searchsorted : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_fill_value",
          "signature": "fill_value(self, value=None)",
          "docstring": {}
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "docstring": {
            "description": "a.setfield(val, dtype, offset=0)\n\nPut a value into a specified place in a field defined by a data-type.\n\nPlace `val` into `a`'s field defined by `dtype` and beginning `offset`\nbytes into the field.",
            "parameters": {
              "val": {
                "type": "object",
                "description": "Value to be placed in field."
              },
              "dtype": {
                "type": "dtype object",
                "description": "Data-type of the field in which to place `val`."
              },
              "offset": {
                "type": "int, optional",
                "description": "The number of bytes into the field at which to place `val`."
              }
            },
            "returns": "None",
            "raises": "",
            "see_also": "getfield",
            "notes": "",
            "examples": ">>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n>>> x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])"
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "docstring": {
            "description": "a.setflags(write=None, align=None, uic=None)\n\nSet array flags WRITEABLE, ALIGNED, WRITEBACKIFCOPY,\nrespectively.\n\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by `a` (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and flag can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)",
            "parameters": {
              "write": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` can be written to."
              },
              "align": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is aligned properly for its type."
              },
              "uic": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is a copy of another \"base\" array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "Array flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, WRITEABLE, and ALIGNED.\n\nWRITEABLE (W) the data area can be written to;\n\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\n\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\n\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.",
            "examples": ">>> y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n>>> y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: cannot set WRITEBACKIFCOPY flag to True"
          }
        },
        {
          "name": "shrink_mask",
          "signature": "shrink_mask(self)",
          "docstring": {
            "description": "Reduce a mask to nomask when possible.",
            "parameters": {},
            "returns": "None",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n>>> x.mask\narray([[False, False],\n       [False, False]])\n>>> x.shrink_mask()\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n>>> x.mask\nFalse"
          }
        },
        {
          "name": "soften_mask",
          "signature": "soften_mask(self)",
          "docstring": {
            "description": "Force the mask to soft (default), allowing unmasking by assignment.\n\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `soften_mask` sets\n`~ma.MaskedArray.hardmask` to ``False`` (and returns the modified\nself).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "ma.MaskedArray.hardmask\nma.MaskedArray.harden_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(self, axis=-1, kind=None, order=None, endwith=True, fill_value=None)",
          "docstring": {
            "description": "Sort the array, in-place",
            "parameters": {
              "a": {
                "type": "array_like",
                "description": "Array to be sorted."
              },
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. If None, the array is flattened before\n    sorting. The default is -1, which sorts along the last axis."
              },
              "kind": {
                "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
                "description": "The sorting algorithm used."
              },
              "order": {
                "type": "list, optional",
                "description": "When `a` is a structured array, this argument specifies which fields\n    to compare first, second, and so on.  This list does not need to\n    include all of the fields."
              },
              "endwith": {
                "type": "{True, False}, optional",
                "description": "Whether missing values (if any) should be treated as the largest values\n    (True) or the smallest values (False)\n    When the array contains unmasked values sorting at the same extremes of the\n    datatype, the ordering of these values and the masked values is\n    undefined."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used internally for the masked values.\n    If ``fill_value`` is not None, it supersedes ``endwith``."
              }
            },
            "returns": "sorted_array : ndarray\n    Array of the same type and shape as `a`.",
            "raises": "",
            "see_also": "numpy.ndarray.sort : Method to sort an array in-place.\nargsort : Indirect sort.\nlexsort : Indirect stable sort on multiple keys.\nsearchsorted : Find elements in a sorted array.",
            "notes": "See ``sort`` for notes on the different sorting algorithms.",
            "examples": ">>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Default\n>>> a.sort()\n>>> a\nmasked_array(data=[1, 3, 5, --, --],\n             mask=[False, False, False,  True,  True],\n       fill_value=999999)\n\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Put missing values in the front\n>>> a.sort(endwith=False)\n>>> a\nmasked_array(data=[--, --, 1, 3, 5],\n             mask=[ True,  True, False, False, False],\n       fill_value=999999)\n\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # fill_value takes over endwith\n>>> a.sort(endwith=False, fill_value=3)\n>>> a\nmasked_array(data=[1, --, --, 3, 5],\n             mask=[False,  True,  True, False, False],\n       fill_value=999999)"
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(self, *args, **params)",
          "docstring": {
            "description": "a.squeeze(axis=None)\n\nRemove axes of length one from `a`.\n\nRefer to `numpy.squeeze` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.squeeze : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "docstring": {
            "description": "Returns the standard deviation of the array elements along given axis.\n\nMasked entries are ignored.\n\nRefer to `numpy.std` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.std : corresponding function for ndarrays\nnumpy.std : Equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "docstring": {
            "description": "Return the sum of the array elements over the given axis.\n\nMasked elements are set to 0 internally.\n\nRefer to `numpy.sum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.sum : corresponding function for ndarrays\nnumpy.sum : equivalent function",
            "notes": "",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.sum()\n25\n>>> x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\n             mask=[False, False, False],\n       fill_value=999999)\n>>> x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\n             mask=[False, False, False],\n       fill_value=999999)\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<class 'numpy.int64'>"
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(self, *args, **params)",
          "docstring": {
            "description": "a.swapaxes(axis1, axis2)\n\nReturn a view of the array with `axis1` and `axis2` interchanged.\n\nRefer to `numpy.swapaxes` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.swapaxes : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(self, indices, axis=None, out=None, mode='raise')",
          "docstring": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(self, fill_value=None, order='C')",
          "docstring": {
            "description": "Return the array data as a string containing the raw bytes in the array.\n\nThe array is filled with a fill value before the string conversion.\n\n.. versionadded:: 1.9.0",
            "parameters": {
              "fill_value": {
                "type": "scalar, optional",
                "description": "Value used to fill in the masked values. Default is None, in which\n    case `MaskedArray.fill_value` is used."
              },
              "order": {
                "type": "{'C','F','A'}, optional",
                "description": "Order of the data item in the copy. Default is 'C'.\n\n    - 'C'   -- C order (row major).\n    - 'F'   -- Fortran order (column major).\n    - 'A'   -- Any, current order of array.\n    - None  -- Same as 'A'."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.tobytes\ntolist, tofile",
            "notes": "As for `ndarray.tobytes`, information about the shape, dtype, etc.,\nbut also about `fill_value`, will be lost.",
            "examples": ">>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n>>> x.tobytes()\nb'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(self, fid, sep='', format='%s')",
          "docstring": {
            "description": "Save a masked array to a file in binary format.\n\n.. warning::\n  This function is not implemented yet.",
            "parameters": {},
            "returns": "",
            "raises": "NotImplementedError\n    When `tofile` is called.",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "toflex",
          "signature": "toflex(self)",
          "docstring": {
            "description": "Transforms a masked array into a flexible-type array.\n\nThe flexible type array that is returned will have two fields:\n\n* the ``_data`` field stores the ``_data`` part of the array.\n* the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "record : ndarray\n    A new flexible-type `ndarray` with two fields: the first element\n    containing a value, the second element containing the corresponding\n    mask boolean. The returned record shape matches self.shape.",
            "raises": "",
            "see_also": "",
            "notes": "A side-effect of transforming a masked array into a flexible `ndarray` is\nthat meta information (``fill_value``, ...) will be lost.",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '<i8'), ('_mask', '?')])"
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(self)",
          "docstring": {
            "description": "Transforms the mvoid object into a tuple.\n\nMasked fields are replaced by None.",
            "parameters": {},
            "returns": "returned_tuple\n    Tuple of fields",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "torecords",
          "signature": "toflex(self)",
          "docstring": {
            "description": "Transforms a masked array into a flexible-type array.\n\nThe flexible type array that is returned will have two fields:\n\n* the ``_data`` field stores the ``_data`` part of the array.\n* the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "record : ndarray\n    A new flexible-type `ndarray` with two fields: the first element\n    containing a value, the second element containing the corresponding\n    mask boolean. The returned record shape matches self.shape.",
            "raises": "",
            "see_also": "",
            "notes": "A side-effect of transforming a masked array into a flexible `ndarray` is\nthat meta information (``fill_value``, ...) will be lost.",
            "examples": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n>>> x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '<i8'), ('_mask', '?')])"
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(self, fill_value=None, order='C')",
          "docstring": {
            "description": "A compatibility alias for `tobytes`, with exactly the same behavior.\n\nDespite its name, it returns `bytes` not `str`\\ s.\n\n.. deprecated:: 1.19.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)",
          "docstring": {
            "description": "a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\n\nReturn the sum along diagonals of the array.\n\nRefer to `numpy.trace` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.trace : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(self, *args, **params)",
          "docstring": {
            "description": "a.transpose(*axes)\n\nReturns a view of the array with axes transposed.\n\nRefer to `numpy.transpose` for full documentation.",
            "parameters": {
              "axes": {
                "type": "None, tuple of ints, or `n` ints",
                "description": "* None or no argument: reverses the order of the axes.\n\n * tuple of ints: `i` in the `j`-th place in the tuple means that the\n   array's `i`-th axis becomes the transposed array's `j`-th axis.\n\n * `n` ints: same as an n-tuple of the same ints (this form is\n   intended simply as a \"convenience\" alternative to the tuple form)."
              }
            },
            "returns": "p : ndarray\n    View of the array with its axes suitably permuted.",
            "raises": "",
            "see_also": "transpose : Equivalent function.\nndarray.T : Array property returning the array transposed.\nndarray.reshape : Give a new shape to an array without changing its data.",
            "notes": "",
            "examples": ">>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n       [3, 4]])\n>>> a.transpose()\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n>>> a = np.array([1, 2, 3, 4])\n>>> a\narray([1, 2, 3, 4])\n>>> a.transpose()\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "unshare_mask",
          "signature": "unshare_mask(self)",
          "docstring": {
            "description": "Copy the mask and set the `sharedmask` flag to ``False``.\n\nWhether the mask is shared between masked arrays can be seen from\nthe `sharedmask` property. `unshare_mask` ensures the mask is not\nshared. A copy of the mask is only made if it was shared.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "sharedmask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "docstring": {
            "description": "Compute the variance along the specified axis.\n\nReturns the variance of the array elements, a measure of the spread of a\ndistribution.  The variance is computed for the flattened array by\ndefault, otherwise over the specified axis.",
            "parameters": {
              "a": {
                "type": "array_like",
                "description": "Array containing numbers whose variance is desired.  If `a` is not an\n    array, a conversion is attempted."
              },
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis or axes along which the variance is computed.  The default is to\n    compute the variance of the flattened array.\n\n    .. versionadded:: 1.7.0\n\n    If this is a tuple of ints, a variance is performed over multiple axes,\n    instead of a single axis or all the axes as before."
              },
              "dtype": {
                "type": "data-type, optional",
                "description": "Type to use in computing the variance.  For arrays of integer type\n    the default is `float64`; for arrays of float types it is the same as\n    the array type."
              },
              "out": {
                "type": "ndarray, optional",
                "description": "Alternate output array in which to place the result.  It must have\n    the same shape as the expected output, but the type is cast if\n    necessary."
              },
              "ddof": {
                "type": "int, optional",
                "description": "\"Delta Degrees of Freedom\": the divisor used in the calculation is\n    ``N - ddof``, where ``N`` represents the number of elements. By\n    default `ddof` is zero."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the input array.\n\n    If the default value is passed, then `keepdims` will not be\n    passed through to the `var` method of sub-classes of\n    `ndarray`, however any non-default value will be.  If the\n    sub-class' method does not implement `keepdims` any\n    exceptions will be raised."
              },
              "where": {
                "type": "array_like of bool, optional",
                "description": "Elements to include in the variance. See `~numpy.ufunc.reduce` for\n    details.\n\n    .. versionadded:: 1.20.0"
              }
            },
            "returns": "variance : ndarray, see dtype parameter above\n    If ``out=None``, returns a new array containing the variance;\n    otherwise, a reference to the output array is returned.",
            "raises": "",
            "see_also": "std, mean, nanmean, nanstd, nanvar\n:ref:`ufuncs-output-type`",
            "notes": "The variance is the average of the squared deviations from the mean,\ni.e.,  ``var = mean(x)``, where ``x = abs(a - a.mean())**2``.\n\nThe mean is typically calculated as ``x.sum() / N``, where ``N = len(x)``.\nIf, however, `ddof` is specified, the divisor ``N - ddof`` is used\ninstead.  In standard statistical practice, ``ddof=1`` provides an\nunbiased estimator of the variance of a hypothetical infinite population.\n``ddof=0`` provides a maximum likelihood estimate of the variance for\nnormally distributed variables.\n\nNote that for complex numbers, the absolute value is taken before\nsquaring, so that the result is always real and nonnegative.\n\nFor floating-point input, the variance is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for `float32` (see example\nbelow).  Specifying a higher-accuracy accumulator using the ``dtype``\nkeyword can alleviate this issue.",
            "examples": ">>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([1.,  1.])\n>>> np.var(a, axis=1)\narray([0.25,  0.25])\n\nIn single precision, var() can be inaccurate:\n\n>>> a = np.zeros((2, 512*512), dtype=np.float32)\n>>> a[0, :] = 1.0\n>>> a[1, :] = 0.1\n>>> np.var(a)\n0.20250003\n\nComputing the variance in float64 is more accurate:\n\n>>> np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n>>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n\nSpecifying a where argument:\n\n>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])\n>>> np.var(a)\n6.833333333333333 # may vary\n>>> np.var(a, where=[[True], [True], [False]])\n4.0"
          }
        },
        {
          "name": "view",
          "signature": "view(self, dtype=None, type=None, fill_value=None)",
          "docstring": {
            "description": "Return a view of the MaskedArray data.",
            "parameters": {
              "dtype": {
                "type": "data-type or ndarray sub-class, optional",
                "description": "Data-type descriptor of the returned view, e.g., float32 or int16.\n    The default, None, results in the view having the same data-type\n    as `a`. As with ``ndarray.view``, dtype can also be specified as\n    an ndarray sub-class, which then specifies the type of the\n    returned object (this is equivalent to setting the ``type``\n    parameter)."
              },
              "type": {
                "type": "Python type, optional",
                "description": "Type of the returned view, either ndarray or a subclass.  The\n    default None results in type preservation."
              },
              "fill_value": {
                "type": "scalar, optional",
                "description": "The value to use for invalid entries (None by default).\n    If None, then this argument is inferred from the passed `dtype`, or\n    in its absence the original array, as discussed in the notes below."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.view : Equivalent method on ndarray object.",
            "notes": "``a.view()`` is used two different ways:\n\n``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view\nof the array's memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\n\n``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just\nreturns an instance of `ndarray_subclass` that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\n\nIf `fill_value` is not specified, but `dtype` is specified (and is not\nan ndarray sub-class), the `fill_value` of the MaskedArray will be\nreset. If neither `fill_value` nor `dtype` are specified (or if\n`dtype` is an ndarray sub-class), then the fill value is preserved.\nFinally, if `fill_value` is specified, but `dtype` is not, the fill\nvalue is set to the specified value.\n\nFor ``a.view(some_dtype)``, if ``some_dtype`` has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of ``a`` (shown\nby ``print(a)``). It also depends on exactly how ``a`` is stored in\nmemory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.",
            "examples": ""
          }
        }
      ]
    }
  ],
  "constants": []
}