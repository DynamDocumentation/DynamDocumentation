{
  "description": "============================\nTyping (:mod:`numpy.typing`)\n============================\n\n.. versionadded:: 1.20\n\nLarge parts of the NumPy API have :pep:`484`-style type annotations. In\naddition a number of type aliases are available to users, most prominently\nthe two below:\n\n- `ArrayLike`: objects that can be converted to arrays\n- `DTypeLike`: objects that can be converted to dtypes\n\n.. _typing-extensions: https://pypi.org/project/typing-extensions/\n\nMypy plugin\n-----------\n\n.. versionadded:: 1.21\n\n.. automodule:: numpy.typing.mypy_plugin\n\n.. currentmodule:: numpy.typing\n\nDifferences from the runtime NumPy API\n--------------------------------------\n\nNumPy is very flexible. Trying to describe the full range of\npossibilities statically would result in types that are not very\nhelpful. For that reason, the typed NumPy API is often stricter than\nthe runtime NumPy API. This section describes some notable\ndifferences.\n\nArrayLike\n~~~~~~~~~\n\nThe `ArrayLike` type tries to avoid creating object arrays. For\nexample,\n\n.. code-block:: python\n\n    >>> np.array(x**2 for x in range(10))\n    array(<generator object <genexpr> at ...>, dtype=object)\n\nis valid NumPy code which will create a 0-dimensional object\narray. Type checkers will complain about the above example when using\nthe NumPy types however. If you really intended to do the above, then\nyou can either use a ``# type: ignore`` comment:\n\n.. code-block:: python\n\n    >>> np.array(x**2 for x in range(10))  # type: ignore\n\nor explicitly type the array like object as `~typing.Any`:\n\n.. code-block:: python\n\n    >>> from typing import Any\n    >>> array_like: Any = (x**2 for x in range(10))\n    >>> np.array(array_like)\n    array(<generator object <genexpr> at ...>, dtype=object)\n\nndarray\n~~~~~~~\n\nIt's possible to mutate the dtype of an array at runtime. For example,\nthe following code is valid:\n\n.. code-block:: python\n\n    >>> x = np.array([1, 2])\n    >>> x.dtype = np.bool_\n\nThis sort of mutation is not allowed by the types. Users who want to\nwrite statically typed code should instead use the `numpy.ndarray.view`\nmethod to create a view of the array with a different dtype.\n\nDTypeLike\n~~~~~~~~~\n\nThe `DTypeLike` type tries to avoid creation of dtype objects using\ndictionary of fields like below:\n\n.. code-block:: python\n\n    >>> x = np.dtype({\"field1\": (float, 1), \"field2\": (int, 3)})\n\nAlthough this is valid NumPy code, the type checker will complain about it,\nsince its usage is discouraged.\nPlease see : :ref:`Data type objects <arrays.dtypes>`\n\nNumber precision\n~~~~~~~~~~~~~~~~\n\nThe precision of `numpy.number` subclasses is treated as a covariant generic\nparameter (see :class:`~NBitBase`), simplifying the annotating of processes\ninvolving precision-based casting.\n\n.. code-block:: python\n\n    >>> from typing import TypeVar\n    >>> import numpy as np\n    >>> import numpy.typing as npt\n\n    >>> T = TypeVar(\"T\", bound=npt.NBitBase)\n    >>> def func(a: \"np.floating[T]\", b: \"np.floating[T]\") -> \"np.floating[T]\":\n    ...     ...\n\nConsequently, the likes of `~numpy.float16`, `~numpy.float32` and\n`~numpy.float64` are still sub-types of `~numpy.floating`, but, contrary to\nruntime, they're not necessarily considered as sub-classes.\n\nTimedelta64\n~~~~~~~~~~~\n\nThe `~numpy.timedelta64` class is not considered a subclass of\n`~numpy.signedinteger`, the former only inheriting from `~numpy.generic`\nwhile static type checking.\n\n0D arrays\n~~~~~~~~~\n\nDuring runtime numpy aggressively casts any passed 0D arrays into their\ncorresponding `~numpy.generic` instance. Until the introduction of shape\ntyping (see :pep:`646`) it is unfortunately not possible to make the\nnecessary distinction between 0D and >0D arrays. While thus not strictly\ncorrect, all operations are that can potentially perform a 0D-array -> scalar\ncast are currently annotated as exclusively returning an `ndarray`.\n\nIf it is known in advance that an operation _will_ perform a\n0D-array -> scalar cast, then one can consider manually remedying the\nsituation with either `typing.cast` or a ``# type: ignore`` comment.\n\nRecord array dtypes\n~~~~~~~~~~~~~~~~~~~\n\nThe dtype of `numpy.recarray`, and the `numpy.rec` functions in general,\ncan be specified in one of two ways:\n\n* Directly via the ``dtype`` argument.\n* With up to five helper arguments that operate via `numpy.format_parser`:\n  ``formats``, ``names``, ``titles``, ``aligned`` and ``byteorder``.\n\nThese two approaches are currently typed as being mutually exclusive,\n*i.e.* if ``dtype`` is specified than one may not specify ``formats``.\nWhile this mutual exclusivity is not (strictly) enforced during runtime,\ncombining both dtype specifiers can lead to unexpected or even downright\nbuggy behavior.\n\nAPI\n---\n\n.. data:: ArrayLike\n    :value: typing.Union[...]\n    \n    A `~typing.Union` representing objects that can be coerced\n    into an `~numpy.ndarray`.\n    \n    Among others this includes the likes of:\n    \n    * Scalars.\n    * (Nested) sequences.\n    * Objects implementing the `~class.__array__` protocol.\n    \n    .. versionadded:: 1.20\n    \n    .. admonition:: See Also\n\n        :term:`array_like`:\n            Any scalar or sequence that can be interpreted as an ndarray.\n        \n    .. rubric:: Examples\n\n    .. code-block:: python\n    \n        >>> import numpy as np\n        >>> import numpy.typing as npt\n    \n        >>> def as_array(a: npt.ArrayLike) -> np.ndarray:\n        ...     return np.array(a)\n    \n    \n.. data:: DTypeLike\n    :value: typing.Union[...]\n    \n    A `~typing.Union` representing objects that can be coerced\n    into a `~numpy.dtype`.\n    \n    Among others this includes the likes of:\n    \n    * :class:`type` objects.\n    * Character codes or the names of :class:`type` objects.\n    * Objects with the ``.dtype`` attribute.\n    \n    .. versionadded:: 1.20\n    \n    .. admonition:: See Also\n\n        :ref:`Specifying and constructing data types <arrays.dtypes.constructing>`\n            A comprehensive overview of all objects that can be coerced\n            into data types.\n        \n    .. rubric:: Examples\n\n    .. code-block:: python\n    \n        >>> import numpy as np\n        >>> import numpy.typing as npt\n    \n        >>> def as_dtype(d: npt.DTypeLike) -> np.dtype:\n        ...     return np.dtype(d)\n    \n    \n.. data:: NDArray\n    :value: numpy.ndarray[typing.Any, numpy.dtype[+_ScalarType_co]]\n    \n    A :term:`generic <generic type>` version of\n    `np.ndarray[Any, np.dtype[+ScalarType]] <numpy.ndarray>`.\n    \n    Can be used during runtime for typing arrays with a given dtype\n    and unspecified shape.\n    \n    .. versionadded:: 1.21\n    \n    .. rubric:: Examples\n\n    .. code-block:: python\n    \n        >>> import numpy as np\n        >>> import numpy.typing as npt\n    \n        >>> print(npt.NDArray)\n        numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]\n    \n        >>> print(npt.NDArray[np.float64])\n        numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]\n    \n        >>> NDArrayInt = npt.NDArray[np.int_]\n        >>> a: NDArrayInt = np.arange(10)\n    \n        >>> def func(a: npt.ArrayLike) -> npt.NDArray[Any]:\n        ...     return np.array(a)\n    \n    \n.. autoclass:: numpy.typing.NBitBase",
  "functions": [
    {
      "name": "ArrayLike",
      "signature": "Union(*args, **kwargs)",
      "docstring": {}
    },
    {
      "name": "DTypeLike",
      "signature": "Union(*args, **kwargs)",
      "docstring": {}
    },
    {
      "name": "NBitBase",
      "signature": "NBitBase()",
      "docstring": {
        "description": "A type representing `numpy.number` precision during static type checking.\n\nUsed exclusively for the purpose static type checking, `NBitBase`\nrepresents the base of a hierarchical set of subclasses.\nEach subsequent subclass is herein used for representing a lower level\nof precision, *e.g.* ``64Bit > 32Bit > 16Bit``.\n\n.. versionadded:: 1.20",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Below is a typical usage example: `NBitBase` is herein used for annotating\na function that takes a float and integer of arbitrary precision\nas arguments and returns a new float of whichever precision is largest\n(*e.g.* ``np.float16 + np.int64 -> np.float64``).\n\n.. code-block:: python\n\n    >>> from __future__ import annotations\n    >>> from typing import TypeVar, TYPE_CHECKING\n    >>> import numpy as np\n    >>> import numpy.typing as npt\n\n    >>> T1 = TypeVar(\"T1\", bound=npt.NBitBase)\n    >>> T2 = TypeVar(\"T2\", bound=npt.NBitBase)\n\n    >>> def add(a: np.floating[T1], b: np.integer[T2]) -> np.floating[T1 | T2]:\n    ...     return a + b\n\n    >>> a = np.float16()\n    >>> b = np.int64()\n    >>> out = add(a, b)\n\n    >>> if TYPE_CHECKING:\n    ...     reveal_locals()\n    ...     # note: Revealed local types are:\n    ...     # note:     a: numpy.floating[numpy.typing._16Bit*]\n    ...     # note:     b: numpy.signedinteger[numpy.typing._64Bit*]\n    ...     # note:     out: numpy.floating[numpy.typing._64Bit*]"
      }
    },
    {
      "name": "NDArray",
      "signature": "ndarray(*args, **kwargs)",
      "docstring": {
        "description": "ndarray(shape, dtype=float, buffer=None, offset=0,\n        strides=None, order=None)\n\nAn array object represents a multidimensional, homogeneous array\nof fixed-size items.  An associated data-type object describes the\nformat of each element in the array (its byte-order, how many bytes it\noccupies in memory, whether it is an integer, a floating point number,\nor something else, etc.)\n\nArrays should be constructed using `array`, `zeros` or `empty` (refer\nto the See Also section below).  The parameters given here refer to\na low-level method (`ndarray(...)`) for instantiating an array.\n\nFor more information, refer to the `numpy` module and examine the\nmethods and attributes of an array.",
        "parameters": {
          "shape": {
            "type": "tuple of ints",
            "description": "Shape of the array."
          },
          "dtype": {
            "type": "dtype object",
            "description": "Describes the format of the elements in the array."
          },
          "buffer": {
            "type": "object exposing buffer interface, optional",
            "description": "Used to fill the array with data."
          },
          "offset": {
            "type": "int, optional",
            "description": "Offset of array data in buffer."
          },
          "strides": {
            "type": "tuple of ints",
            "description": "The step-size required to move from one element to the next in\n    memory. For example, a contiguous ``(3, 4)`` array of type\n    ``int16`` in C-order has strides ``(8, 2)``.  This implies that\n    to move from element to element in memory requires jumps of 2 bytes.\n    To move from row-to-row, one needs to jump 8 bytes at a time\n    (``2 * 4``)."
          },
          "order": {
            "type": "{'C', 'F'}, optional",
            "description": "Row-major (C-style) or column-major (Fortran-style) order.\n\nAttributes\n----------"
          },
          "T": {
            "type": "ndarray",
            "description": "Transpose of the array."
          },
          "data": {
            "type": "buffer",
            "description": "The array's elements, in memory."
          },
          "flags": {
            "type": "dict",
            "description": "Dictionary containing information related to memory use, e.g.,\n    'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc."
          },
          "flat": {
            "type": "numpy.flatiter object",
            "description": "Flattened version of the array as an iterator.  The iterator\n    allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for\n    assignment examples; TODO)."
          },
          "imag": {
            "type": "ndarray",
            "description": "Imaginary part of the array."
          },
          "real": {
            "type": "ndarray",
            "description": "Real part of the array."
          },
          "size": {
            "type": "int",
            "description": "Number of elements in the array."
          },
          "itemsize": {
            "type": "int",
            "description": "The memory use of each array element in bytes."
          },
          "nbytes": {
            "type": "int",
            "description": "The total number of bytes required to store the array data,\n    i.e., ``itemsize * size``."
          },
          "ndim": {
            "type": "int",
            "description": "The array's number of dimensions."
          },
          "ctypes": {
            "type": "ctypes object",
            "description": "Class containing properties of the array needed for interaction\n    with ctypes."
          },
          "base": {
            "type": "ndarray",
            "description": "If the array is a view into another array, that array is its `base`\n    (unless that array is also a view).  The `base` array is where the\n    array data is actually stored."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "array : Construct an array.\nzeros : Create an array, each element of which is zero.\nempty : Create an array, but leave its allocated memory unchanged (i.e.,\n        it contains \"garbage\").\ndtype : Create a data-type.\nnumpy.typing.NDArray : An ndarray alias :term:`generic <generic type>`\n                       w.r.t. its `dtype.type <numpy.dtype.type>`.",
        "notes": "There are two modes of creating an array using ``__new__``:\n\n1. If `buffer` is None, then only `shape`, `dtype`, and `order`\n   are used.\n2. If `buffer` is an object exposing the buffer interface, then\n   all keywords are interpreted.\n\nNo ``__init__`` method is needed because the array is fully initialized\nafter the ``__new__`` method.",
        "examples": "These examples illustrate the low-level `ndarray` constructor.  Refer\nto the `See Also` section above for easier ways of constructing an\nndarray.\n\nFirst mode, `buffer` is None:\n\n>>> np.ndarray(shape=(2,2), dtype=float, order='F')\narray([[0.0e+000, 0.0e+000], # random\n       [     nan, 2.5e-323]])\n\nSecond mode:\n\n>>> np.ndarray((2,), buffer=np.array([1,2,3]),\n...            offset=np.int_().itemsize,\n...            dtype=int) # offset = 1*itemsize, i.e. skip first element\narray([2, 3])"
      }
    },
    {
      "name": "test",
      "signature": "test(...)",
      "docstring": {}
    }
  ],
  "classes": [
    {
      "name": "NBitBase",
      "docstring": {
        "description": "A type representing `numpy.number` precision during static type checking.\n\nUsed exclusively for the purpose static type checking, `NBitBase`\nrepresents the base of a hierarchical set of subclasses.\nEach subsequent subclass is herein used for representing a lower level\nof precision, *e.g.* ``64Bit > 32Bit > 16Bit``.\n\n.. versionadded:: 1.20",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Below is a typical usage example: `NBitBase` is herein used for annotating\na function that takes a float and integer of arbitrary precision\nas arguments and returns a new float of whichever precision is largest\n(*e.g.* ``np.float16 + np.int64 -> np.float64``).\n\n.. code-block:: python\n\n    >>> from __future__ import annotations\n    >>> from typing import TypeVar, TYPE_CHECKING\n    >>> import numpy as np\n    >>> import numpy.typing as npt\n\n    >>> T1 = TypeVar(\"T1\", bound=npt.NBitBase)\n    >>> T2 = TypeVar(\"T2\", bound=npt.NBitBase)\n\n    >>> def add(a: np.floating[T1], b: np.integer[T2]) -> np.floating[T1 | T2]:\n    ...     return a + b\n\n    >>> a = np.float16()\n    >>> b = np.int64()\n    >>> out = add(a, b)\n\n    >>> if TYPE_CHECKING:\n    ...     reveal_locals()\n    ...     # note: Revealed local types are:\n    ...     # note:     a: numpy.floating[numpy.typing._16Bit*]\n    ...     # note:     b: numpy.signedinteger[numpy.typing._64Bit*]\n    ...     # note:     out: numpy.floating[numpy.typing._64Bit*]"
      },
      "methods": []
    }
  ],
  "constants": []
}