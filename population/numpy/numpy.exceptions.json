{
  "description": "Exceptions and Warnings (:mod:`numpy.exceptions`)\n=================================================\n\nGeneral exceptions used by NumPy.  Note that some exceptions may be module\nspecific, such as linear algebra errors.\n\n.. versionadded:: NumPy 1.25\n\n    The exceptions module is new in NumPy 1.25.  Older exceptions remain\n    available through the main NumPy namespace for compatibility.\n\n.. currentmodule:: numpy.exceptions\n\nWarnings\n--------\n.. autosummary::\n   :toctree: generated/\n\n   ComplexWarning             Given when converting complex to real.\n   VisibleDeprecationWarning  Same as a DeprecationWarning, but more visible.\n\nExceptions\n----------\n.. autosummary::\n   :toctree: generated/\n\n    AxisError          Given when an axis was invalid.\n    DTypePromotionError   Given when no common dtype could be found.\n    TooHardError       Error specific to `numpy.shares_memory`.",
  "functions": [
    {
      "name": "AxisError",
      "signature": "AxisError(axis, ndim=None, msg_prefix=None)",
      "docstring": {
        "description": "Axis supplied was invalid.\n\nThis is raised whenever an ``axis`` parameter is specified that is larger\nthan the number of array dimensions.\nFor compatibility with code written against older numpy versions, which\nraised a mixture of `ValueError` and `IndexError` for this situation, this\nexception subclasses both to ensure that ``except ValueError`` and\n``except IndexError`` statements continue to catch `AxisError`.\n\n.. versionadded:: 1.13",
        "parameters": {
          "axis": {
            "type": "int, optional",
            "description": "The out of bounds axis or ``None`` if a custom exception\n    message was provided. This should be the axis as passed by\n    the user, before any normalization to resolve negative indices.\n\n    .. versionadded:: 1.22"
          },
          "ndim": {
            "type": "int, optional",
            "description": "The number of array dimensions or ``None`` if a custom exception\n    message was provided.\n\n    .. versionadded:: 1.22"
          },
          "msg_prefix": {
            "type": "str, optional",
            "description": "A prefix for the exception message.\n\nAttributes\n----------"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> array_1d = np.arange(10)\n>>> np.cumsum(array_1d, axis=1)\nTraceback (most recent call last):\n  ...\nnumpy.exceptions.AxisError: axis 1 is out of bounds for array of dimension 1\n\nNegative axes are preserved:\n\n>>> np.cumsum(array_1d, axis=-2)\nTraceback (most recent call last):\n  ...\nnumpy.exceptions.AxisError: axis -2 is out of bounds for array of dimension 1\n\nThe class constructor generally takes the axis and arrays'\ndimensionality as arguments:\n\n>>> print(np.AxisError(2, 1, msg_prefix='error'))\nerror: axis 2 is out of bounds for array of dimension 1\n\nAlternatively, a custom exception message can be passed:\n\n>>> print(np.AxisError('Custom error message'))\nCustom error message"
      }
    },
    {
      "name": "ComplexWarning",
      "signature": "ComplexWarning(...)",
      "docstring": {
        "description": "The warning raised when casting a complex dtype to a real dtype.\n\nAs implemented, casting a complex number to a real discards its imaginary\npart, but this behavior may not be what the user actually wants.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "DTypePromotionError",
      "signature": "DTypePromotionError(...)",
      "docstring": {
        "description": "Multiple DTypes could not be converted to a common one.\n\nThis exception derives from ``TypeError`` and is raised whenever dtypes\ncannot be converted to a single common one.  This can be because they\nare of a different category/class or incompatible instances of the same\none (see Examples).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "Many functions will use promotion to find the correct result and\nimplementation.  For these functions the error will typically be chained\nwith a more specific error indicating that no implementation was found\nfor the input dtypes.\n\nTypically promotion should be considered \"invalid\" between the dtypes of\ntwo arrays when `arr1 == arr2` can safely return all ``False`` because the\ndtypes are fundamentally different.",
        "examples": "Datetimes and complex numbers are incompatible classes and cannot be\npromoted:\n\n>>> np.result_type(np.dtype(\"M8[s]\"), np.complex128)\nDTypePromotionError: The DType <class 'numpy.dtype[datetime64]'> could not\nbe promoted by <class 'numpy.dtype[complex128]'>. This means that no common\nDType exists for the given inputs. For example they cannot be stored in a\nsingle array unless the dtype is `object`. The full list of DTypes is:\n(<class 'numpy.dtype[datetime64]'>, <class 'numpy.dtype[complex128]'>)\n\nFor example for structured dtypes, the structure can mismatch and the\nsame ``DTypePromotionError`` is given when two structured dtypes with\na mismatch in their number of fields is given:\n\n>>> dtype1 = np.dtype([(\"field1\", np.float64), (\"field2\", np.int64)])\n>>> dtype2 = np.dtype([(\"field1\", np.float64)])\n>>> np.promote_types(dtype1, dtype2)\nDTypePromotionError: field names `('field1', 'field2')` and `('field1',)`\nmismatch."
      }
    },
    {
      "name": "ModuleDeprecationWarning",
      "signature": "ModuleDeprecationWarning(...)",
      "docstring": {
        "description": "Module deprecation warning.\n\n.. warning::\n\n    This warning should not be used, since nose testing is not relevant\n    anymore.\n\nThe nose tester turns ordinary Deprecation warnings into test failures.\nThat makes it hard to deprecate whole modules, because they get\nimported by default. So this is a special Deprecation warning that the\nnose tester will let pass without making tests fail.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "TooHardError",
      "signature": "TooHardError(...)",
      "docstring": {
        "description": "max_work was exceeded.\n\nThis is raised whenever the maximum number of candidate solutions\nto consider specified by the ``max_work`` parameter is exceeded.\nAssigning a finite number to max_work may have caused the operation\nto fail.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "VisibleDeprecationWarning",
      "signature": "VisibleDeprecationWarning(...)",
      "docstring": {
        "description": "Visible deprecation warning.\n\nBy default, python will not show deprecation warnings, so this class\ncan be used when a very visible warning is helpful, for example because\nthe usage is most likely a user bug.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": [
    {
      "name": "AxisError",
      "docstring": {
        "description": "Axis supplied was invalid.\n\nThis is raised whenever an ``axis`` parameter is specified that is larger\nthan the number of array dimensions.\nFor compatibility with code written against older numpy versions, which\nraised a mixture of `ValueError` and `IndexError` for this situation, this\nexception subclasses both to ensure that ``except ValueError`` and\n``except IndexError`` statements continue to catch `AxisError`.\n\n.. versionadded:: 1.13",
        "parameters": {
          "axis": {
            "type": "int, optional",
            "description": "The out of bounds axis or ``None`` if a custom exception\n    message was provided. This should be the axis as passed by\n    the user, before any normalization to resolve negative indices.\n\n    .. versionadded:: 1.22"
          },
          "ndim": {
            "type": "int, optional",
            "description": "The number of array dimensions or ``None`` if a custom exception\n    message was provided.\n\n    .. versionadded:: 1.22"
          },
          "msg_prefix": {
            "type": "str, optional",
            "description": "A prefix for the exception message.\n\nAttributes\n----------"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> array_1d = np.arange(10)\n>>> np.cumsum(array_1d, axis=1)\nTraceback (most recent call last):\n  ...\nnumpy.exceptions.AxisError: axis 1 is out of bounds for array of dimension 1\n\nNegative axes are preserved:\n\n>>> np.cumsum(array_1d, axis=-2)\nTraceback (most recent call last):\n  ...\nnumpy.exceptions.AxisError: axis -2 is out of bounds for array of dimension 1\n\nThe class constructor generally takes the axis and arrays'\ndimensionality as arguments:\n\n>>> print(np.AxisError(2, 1, msg_prefix='error'))\nerror: axis 2 is out of bounds for array of dimension 1\n\nAlternatively, a custom exception message can be passed:\n\n>>> print(np.AxisError('Custom error message'))\nCustom error message"
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "docstring": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "docstring": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ComplexWarning",
      "docstring": {
        "description": "The warning raised when casting a complex dtype to a real dtype.\n\nAs implemented, casting a complex number to a real discards its imaginary\npart, but this behavior may not be what the user actually wants.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "docstring": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "docstring": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "DTypePromotionError",
      "docstring": {
        "description": "Multiple DTypes could not be converted to a common one.\n\nThis exception derives from ``TypeError`` and is raised whenever dtypes\ncannot be converted to a single common one.  This can be because they\nare of a different category/class or incompatible instances of the same\none (see Examples).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "Many functions will use promotion to find the correct result and\nimplementation.  For these functions the error will typically be chained\nwith a more specific error indicating that no implementation was found\nfor the input dtypes.\n\nTypically promotion should be considered \"invalid\" between the dtypes of\ntwo arrays when `arr1 == arr2` can safely return all ``False`` because the\ndtypes are fundamentally different.",
        "examples": "Datetimes and complex numbers are incompatible classes and cannot be\npromoted:\n\n>>> np.result_type(np.dtype(\"M8[s]\"), np.complex128)\nDTypePromotionError: The DType <class 'numpy.dtype[datetime64]'> could not\nbe promoted by <class 'numpy.dtype[complex128]'>. This means that no common\nDType exists for the given inputs. For example they cannot be stored in a\nsingle array unless the dtype is `object`. The full list of DTypes is:\n(<class 'numpy.dtype[datetime64]'>, <class 'numpy.dtype[complex128]'>)\n\nFor example for structured dtypes, the structure can mismatch and the\nsame ``DTypePromotionError`` is given when two structured dtypes with\na mismatch in their number of fields is given:\n\n>>> dtype1 = np.dtype([(\"field1\", np.float64), (\"field2\", np.int64)])\n>>> dtype2 = np.dtype([(\"field1\", np.float64)])\n>>> np.promote_types(dtype1, dtype2)\nDTypePromotionError: field names `('field1', 'field2')` and `('field1',)`\nmismatch."
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "docstring": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "docstring": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ModuleDeprecationWarning",
      "docstring": {
        "description": "Module deprecation warning.\n\n.. warning::\n\n    This warning should not be used, since nose testing is not relevant\n    anymore.\n\nThe nose tester turns ordinary Deprecation warnings into test failures.\nThat makes it hard to deprecate whole modules, because they get\nimported by default. So this is a special Deprecation warning that the\nnose tester will let pass without making tests fail.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "docstring": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "docstring": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "TooHardError",
      "docstring": {
        "description": "max_work was exceeded.\n\nThis is raised whenever the maximum number of candidate solutions\nto consider specified by the ``max_work`` parameter is exceeded.\nAssigning a finite number to max_work may have caused the operation\nto fail.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "docstring": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "docstring": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "VisibleDeprecationWarning",
      "docstring": {
        "description": "Visible deprecation warning.\n\nBy default, python will not show deprecation warnings, so this class\ncan be used when a very visible warning is helpful, for example because\nthe usage is most likely a user bug.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "docstring": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "docstring": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    }
  ],
  "constants": []
}