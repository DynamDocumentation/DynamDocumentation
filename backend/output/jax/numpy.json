{
  "description": "No description available",
  "functions": [
    {
      "name": "abs",
      "signature": "abs(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.absolute`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "absolute",
      "signature": "absolute(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate the absolute value element-wise.\nJAX implementation of :obj:`numpy.absolute`.\nThis is the same function as :func:`jax.numpy.abs`.\nArgs:\nx: Input array",
        "parameters": {},
        "returns": "An array-like object containing the absolute value of each element in ``x``,\nwith the same shape as ``x``. For complex valued input, :math:`a + ib`,\nthe absolute value is :math:`\\sqrt{a^2+b^2}`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([5, -2, 0, 12])\n>>> jnp.absolute(x1)\nArray([ 5,  2,  0, 12], dtype=int32)\n>>> x2 = jnp.array([[ 8, -3, 1],[ 0, 9, -6]])\n>>> jnp.absolute(x2)\nArray([[8, 3, 1],\n[0, 9, 6]], dtype=int32)\n>>> x3 = jnp.array([8 + 15j, 3 - 4j, -5 + 0j])\n>>> jnp.absolute(x3)\nArray([17.,  5.,  5.], dtype=float32)"
      }
    },
    {
      "name": "acos",
      "signature": "acos(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.arccos`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "acosh",
      "signature": "acosh(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.arccosh`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "add",
      "signature": "add(*args: 'ArrayLike', out: 'None' = None, where: 'None' = None) -> 'Any'",
      "documentation": {
        "description": "Add two arrays element-wise.\nJAX implementation of :obj:`numpy.add`. This is a universal function,\nand supports the additional APIs described at :class:`jax.numpy.ufunc`.\nThis function provides the implementation of the ``+`` operator for\nJAX arrays.\nArgs:\nx, y: arrays to add. Must be broadcastable to a common shape.",
        "parameters": {},
        "returns": "Array containing the result of the element-wise addition.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Calling ``add`` explicitly:\n>>> x = jnp.arange(4)\n>>> jnp.add(x, 10)\nArray([10, 11, 12, 13], dtype=int32)\nCalling ``add`` via the ``+`` operator:\n>>> x + 10\nArray([10, 11, 12, 13], dtype=int32)"
      }
    },
    {
      "name": "all",
      "signature": "all(a: 'ArrayLike', axis: 'Axis' = None, out: 'None' = None, keepdims: 'bool' = False, *, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Test whether all array elements along a given axis evaluate to True.\nJAX implementation of :func:`numpy.all`.\nArgs:\na: Input array.\naxis: int or array, default=None. Axis along which to be tested. If None,\ntests along all the axes.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\nwhere: int or array of boolean dtype, default=None. The elements to be used\nin the test. Array should be broadcast compatible to the input.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array of boolean values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.all`` tests for True values along all the axes.\n>>> x = jnp.array([[True, True, True, False],\n...                [True, False, True, False],\n...                [True, True, False, False]])\n>>> jnp.all(x)\nArray(False, dtype=bool)\nIf ``axis=0``, tests for True values along axis 0.\n>>> jnp.all(x, axis=0)\nArray([ True, False, False, False], dtype=bool)\nIf ``keepdims=True``, ``ndim`` of the output will be same of that of the input.\n>>> jnp.all(x, axis=0, keepdims=True)\nArray([[ True, False, False, False]], dtype=bool)\nTo include specific elements in testing for True values, you can use a``where``.\n>>> where=jnp.array([[1, 0, 1, 0],\n...                  [0, 0, 1, 1],\n...                  [1, 1, 1, 0]], dtype=bool)\n>>> jnp.all(x, axis=0, keepdims=True, where=where)\nArray([[ True,  True, False, False]], dtype=bool)"
      }
    },
    {
      "name": "allclose",
      "signature": "allclose(a: 'ArrayLike', b: 'ArrayLike', rtol: 'ArrayLike' = 1e-05, atol: 'ArrayLike' = 1e-08, equal_nan: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "Check if two arrays are element-wise approximately equal within a tolerance.\nJAX implementation of :func:`numpy.allclose`.\nEssentially this function evaluates the following condition:\n.. math::\n|a - b| \\le \\mathtt{atol} + \\mathtt{rtol} * |b|\n``jnp.inf`` in ``a`` will be considered equal to ``jnp.inf`` in ``b``.\nArgs:\na: first input array to compare.\nb: second input array to compare.\nrtol: relative tolerance used for approximate equality. Default = 1e-05.\natol: absolute tolerance used for approximate equality. Default = 1e-08.\nequal_nan: Boolean. If ``True``, NaNs in ``a`` will be considered\nequal to NaNs in ``b``. Default is ``False``.",
        "parameters": {},
        "returns": "Boolean scalar array indicating whether the input arrays are element-wise\napproximately equal within the specified tolerances.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.isclose`\n- :func:`jax.numpy.equal`",
        "notes": "",
        "examples": ">>> jnp.allclose(jnp.array([1e6, 2e6, 3e6]), jnp.array([1e6, 2e6, 3e7]))\nArray(False, dtype=bool)\n>>> jnp.allclose(jnp.array([1e6, 2e6, 3e6]),\n...              jnp.array([1.00008e6, 2.00008e7, 3.00008e8]), rtol=1e3)\nArray(True, dtype=bool)\n>>> jnp.allclose(jnp.array([1e6, 2e6, 3e6]),\n...              jnp.array([1.00001e6, 2.00002e6, 3.00009e6]), atol=1e3)\nArray(True, dtype=bool)\n>>> jnp.allclose(jnp.array([jnp.nan, 1, 2]),\n...              jnp.array([jnp.nan, 1, 2]), equal_nan=True)\nArray(True, dtype=bool)"
      }
    },
    {
      "name": "amax",
      "signature": "amax(a: 'ArrayLike', axis: 'Axis' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.max`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "amin",
      "signature": "amin(a: 'ArrayLike', axis: 'Axis' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.min`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "angle",
      "signature": "angle(z: 'ArrayLike', deg: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "Return the angle of a complex valued number or array.\nJAX implementation of :func:`numpy.angle`.\nArgs:\nz: A complex number or an array of complex numbers.\ndeg: Boolean. If ``True``, returns the result in degrees else returns\nin radians. Default is ``False``.",
        "parameters": {},
        "returns": "An array of counterclockwise angle of each element of ``z``, with the same\nshape as ``z`` of dtype float.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "If ``z`` is a number\n>>> z1 = 2+3j\n>>> jnp.angle(z1)\nArray(0.98279375, dtype=float32, weak_type=True)\nIf ``z`` is an array\n>>> z2 = jnp.array([[1+3j, 2-5j],\n...                 [4-3j, 3+2j]])\n>>> with jnp.printoptions(precision=2, suppress=True):\n...     print(jnp.angle(z2))\n[[ 1.25 -1.19]\n[-0.64  0.59]]\nIf ``deg=True``.\n>>> with jnp.printoptions(precision=2, suppress=True):\n...     print(jnp.angle(z2, deg=True))\n[[ 71.57 -68.2 ]\n[-36.87  33.69]]"
      }
    },
    {
      "name": "any",
      "signature": "any(a: 'ArrayLike', axis: 'Axis' = None, out: 'None' = None, keepdims: 'bool' = False, *, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Test whether any of the array elements along a given axis evaluate to True.\nJAX implementation of :func:`numpy.any`.\nArgs:\na: Input array.\naxis: int or array, default=None. Axis along which to be tested. If None,\ntests along all the axes.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\nwhere: int or array of boolean dtype, default=None. The elements to be used\nin the test. Array should be broadcast compatible to the input.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array of boolean values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.any`` tests along all the axes.\n>>> x = jnp.array([[True, True, True, False],\n...                [True, False, True, False],\n...                [True, True, False, False]])\n>>> jnp.any(x)\nArray(True, dtype=bool)\nIf ``axis=0``, tests along axis 0.\n>>> jnp.any(x, axis=0)\nArray([ True,  True,  True, False], dtype=bool)\nIf ``keepdims=True``, ``ndim`` of the output will be same of that of the input.\n>>> jnp.any(x, axis=0, keepdims=True)\nArray([[ True,  True,  True, False]], dtype=bool)\nTo include specific elements in testing for True values, you can use a``where``.\n>>> where=jnp.array([[1, 0, 1, 0],\n...                  [0, 1, 0, 1],\n...                  [1, 0, 1, 0]], dtype=bool)\n>>> jnp.any(x, axis=0, keepdims=True, where=where)\nArray([[ True, False,  True, False]], dtype=bool)"
      }
    },
    {
      "name": "append",
      "signature": "append(arr: 'ArrayLike', values: 'ArrayLike', axis: 'int | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return a new array with values appended to the end of the original array.\nJAX implementation of :func:`numpy.append`.\nArgs:\narr: original array.\nvalues: values to be appended to the array. The ``values`` must have\nthe same number of dimensions as ``arr``, and all dimensions must\nmatch except in the specified axis.\naxis: axis along which to append values. If None (default), both ``arr``\nand ``values`` will be flattened before appending.",
        "parameters": {},
        "returns": "A new array with values appended to ``arr``.\nSee also:\n- :func:`jax.numpy.insert`\n- :func:`jax.numpy.delete`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> a = jnp.array([1, 2, 3])\n>>> b = jnp.array([4, 5, 6])\n>>> jnp.append(a, b)\nArray([1, 2, 3, 4, 5, 6], dtype=int32)\nAppending along a specific axis:\n>>> a = jnp.array([[1, 2],\n...                [3, 4]])\n>>> b = jnp.array([[5, 6]])\n>>> jnp.append(a, b, axis=0)\nArray([[1, 2],\n[3, 4],\n[5, 6]], dtype=int32)\nAppending along a trailing axis:\n>>> a = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> b = jnp.array([[7], [8]])\n>>> jnp.append(a, b, axis=1)\nArray([[1, 2, 3, 7],\n[4, 5, 6, 8]], dtype=int32)"
      }
    },
    {
      "name": "apply_along_axis",
      "signature": "apply_along_axis(func1d: 'Callable', axis: 'int', arr: 'ArrayLike', *args, **kwargs) -> 'Array'",
      "documentation": {
        "description": "Apply a function to 1D array slices along an axis.\nJAX implementation of :func:`numpy.apply_along_axis`. While NumPy implements\nthis iteratively, JAX implements this via :func:`jax.vmap`, and so ``func1d``\nmust be compatible with ``vmap``.\nArgs:\nfunc1d: a callable function with signature ``func1d(arr, /, *args, **kwargs)``\nwhere ``*args`` and ``**kwargs`` are the additional positional and keyword\narguments passed to :func:`apply_along_axis`.\naxis: integer axis along which to apply the function.\narr: the array over which to apply the function.\nargs, kwargs: additional positional and keyword arguments are passed through\nto ``func1d``.",
        "parameters": {},
        "returns": "The result of ``func1d`` applied along the specified axis.\nSee also:\n- :func:`jax.vmap`: a more direct way to create a vectorized version of a function.\n- :func:`jax.numpy.apply_over_axes`: repeatedly apply a function over multiple axes.\n- :func:`jax.numpy.vectorize`: create a vectorized version of a function.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "A simple example in two dimensions, where the function is applied either row-wise\nor column-wise:\n>>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> def func1d(x):\n...   return jnp.sum(x ** 2)\n>>> jnp.apply_along_axis(func1d, 0, x)\nArray([17, 29, 45], dtype=int32)\n>>> jnp.apply_along_axis(func1d, 1, x)\nArray([14, 77], dtype=int32)\nFor 2D inputs, this can be equivalently expressed using :func:`jax.vmap`,\nthough note that `vmap` specifies the mapped axis rather than the applied axis:\n>>> jax.vmap(func1d, in_axes=1)(x)  # same as applying along axis 0\nArray([17, 29, 45], dtype=int32)\n>>> jax.vmap(func1d, in_axes=0)(x)  # same as applying along axis 1\nArray([14, 77], dtype=int32)\nFor 3D inputs, :func:`apply_along_axis` is equivalent to mapping over two\ndimensions:\n>>> x_3d = jnp.arange(24).reshape(2, 3, 4)\n>>> jnp.apply_along_axis(func1d, 2, x_3d)\nArray([[  14,  126,  366],\n[ 734, 1230, 1854]], dtype=int32)\n>>> jax.vmap(jax.vmap(func1d))(x_3d)\nArray([[  14,  126,  366],\n[ 734, 1230, 1854]], dtype=int32)\nThe applied function may also take arbitrary positional or keyword arguments,\nwhich should be passed directly as additional arguments to :func:`apply_along_axis`:\n>>> def func1d(x, exponent):\n...   return jnp.sum(x ** exponent)\n>>> jnp.apply_along_axis(func1d, 0, x, exponent=3)\nArray([ 65, 133, 243], dtype=int32)"
      }
    },
    {
      "name": "apply_over_axes",
      "signature": "apply_over_axes(func: 'Callable[[ArrayLike, int], Array]', a: 'ArrayLike', axes: 'Sequence[int]') -> 'Array'",
      "documentation": {
        "description": "Apply a function repeatedly over specified axes.\nJAX implementation of :func:`numpy.apply_over_axes`.\nArgs:\nfunc: the function to apply, with signature ``func(Array, int) -> Array``, and\nwhere ``y = func(x, axis)`` must satisfy ``y.ndim in [x.ndim, x.ndim - 1]``.\na: N-dimensional array over which to apply the function.\naxes: the sequence of axes over which to apply the function.",
        "parameters": {},
        "returns": "An N-dimensional array containing the result of the repeated function application.\nSee also:\n- :func:`jax.numpy.apply_along_axis`: apply a 1D function along a single axis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "This function is designed to have similar semantics to typical associative\n:mod:`jax.numpy` reductions over one or more axes with ``keepdims=True``.\nFor example:\n>>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> jnp.apply_over_axes(jnp.sum, x, [0])\nArray([[5, 7, 9]], dtype=int32)\n>>> jnp.sum(x, [0], keepdims=True)\nArray([[5, 7, 9]], dtype=int32)\n>>> jnp.apply_over_axes(jnp.min, x, [1])\nArray([[1],\n[4]], dtype=int32)\n>>> jnp.min(x, [1], keepdims=True)\nArray([[1],\n[4]], dtype=int32)\n>>> jnp.apply_over_axes(jnp.prod, x, [0, 1])\nArray([[720]], dtype=int32)\n>>> jnp.prod(x, [0, 1], keepdims=True)\nArray([[720]], dtype=int32)"
      }
    },
    {
      "name": "arange",
      "signature": "arange(start: 'ArrayLike | DimSize', stop: 'ArrayLike | DimSize | None' = None, step: 'ArrayLike | None' = None, dtype: 'DTypeLike | None' = None, *, device: 'xc.Device | Sharding | None' = None) -> 'Array'",
      "documentation": {
        "description": "Create an array of evenly-spaced values.\nJAX implementation of :func:`numpy.arange`, implemented in terms of\n:func:`jax.lax.iota`.\nSimilar to Python's :func:`range` function, this can be called with a few\ndifferent positional signatures:\n- ``jnp.arange(stop)``: generate values from 0 to ``stop``, stepping by 1.\n- ``jnp.arange(start, stop)``: generate values from ``start`` to ``stop``,\nstepping by 1.\n- ``jnp.arange(start, stop, step)``: generate values from ``start`` to ``stop``,\nstepping by ``step``.\nLike with Python's :func:`range` function, the starting value is inclusive,\nand the stop value is exclusive.\nArgs:\nstart: start of the interval, inclusive.\nstop: optional end of the interval, exclusive. If not specified, then\n``(start, stop) = (0, start)``\nstep: optional step size for the interval. Default = 1.\ndtype: optional dtype for the returned array; if not specified it will\nbe determined via type promotion of `start`, `stop`, and `step`.\ndevice: (optional) :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.",
        "parameters": {},
        "returns": "Array of evenly-spaced values from ``start`` to ``stop``, separated by ``step``.\nNote:\nUsing ``arange`` with a floating-point ``step`` argument can lead to unexpected\nresults due to accumulation of floating-point errors, especially with\nlower-precision data types like ``float8_*`` and ``bfloat16``.\nTo avoid precision errors, consider generating a range of integers, and scaling\nit to the desired range. For example, instead of this::\njnp.arange(-1, 1, 0.01, dtype='bfloat16')\nit can be more accurate to generate a sequence of integers, and scale them::\n(jnp.arange(-100, 100) * 0.01).astype('bfloat16')",
        "raises": "",
        "see_also": "- :func:`jax.numpy.linspace`: generate a fixed number of evenly-spaced values.\n- :func:`jax.lax.iota`: directly generate integer sequences in XLA.",
        "notes": "",
        "examples": "Single-argument version specifies only the ``stop`` value:\n>>> jnp.arange(4)\nArray([0, 1, 2, 3], dtype=int32)\nPassing a floating-point ``stop`` value leads to a floating-point result:\n>>> jnp.arange(4.0)\nArray([0., 1., 2., 3.], dtype=float32)\nTwo-argument version specifies ``start`` and ``stop``, with ``step=1``:\n>>> jnp.arange(1, 6)\nArray([1, 2, 3, 4, 5], dtype=int32)\nThree-argument version specifies ``start``, ``stop``, and ``step``:\n>>> jnp.arange(0, 2, 0.5)\nArray([0. , 0.5, 1. , 1.5], dtype=float32)"
      }
    },
    {
      "name": "arccos",
      "signature": "arccos(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Compute element-wise inverse of trigonometric cosine of input.\nJAX implementation of :obj:`numpy.arccos`.\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array containing the inverse trigonometric cosine of each element of ``x``\nin radians in the range ``[0, pi]``, promoting to inexact dtype.\nNote:\n- ``jnp.arccos`` returns ``nan`` when ``x`` is real-valued and not in the closed\ninterval ``[-1, 1]``.\n- ``jnp.arccos`` follows the branch cut convention of :obj:`numpy.arccos` for\ncomplex inputs.\nSee also:\n- :func:`jax.numpy.cos`: Computes a trigonometric cosine of each element of\ninput.\n- :func:`jax.numpy.arcsin` and :func:`jax.numpy.asin`: Computes the inverse of\ntrigonometric sine of each element of input.\n- :func:`jax.numpy.arctan` and :func:`jax.numpy.atan`: Computes the inverse of\ntrigonometric tangent of each element of input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([-2, -1, -0.5, 0, 0.5, 1, 2])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.arccos(x)\nArray([  nan, 3.142, 2.094, 1.571, 1.047, 0.   ,   nan], dtype=float32)\nFor complex inputs:\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.arccos(4-1j)\nArray(0.252+2.097j, dtype=complex64, weak_type=True)"
      }
    },
    {
      "name": "arccosh",
      "signature": "arccosh(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise inverse of hyperbolic cosine of input.\nJAX implementation of :obj:`numpy.arccosh`.\nThe inverse of hyperbolic cosine is defined by:\n.. math::\narccosh(x) = \\ln(x + \\sqrt{x^2 - 1})\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array of same shape as ``x`` containing the inverse of hyperbolic cosine\nof each element of ``x``, promoting to inexact dtype.\nNote:\n- ``jnp.arccosh`` returns ``nan`` for real-values in the range ``[-inf, 1)``.\n- ``jnp.arccosh`` follows the branch cut convention of :obj:`numpy.arccosh`\nfor complex inputs.\nSee also:\n- :func:`jax.numpy.cosh`: Computes the element-wise hyperbolic cosine of the\ninput.\n- :func:`jax.numpy.arcsinh`: Computes the element-wise inverse of hyperbolic\nsine of the input.\n- :func:`jax.numpy.arctanh`: Computes the element-wise inverse of hyperbolic\ntangent of the input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[1, 3, -4],\n...                [-5, 2, 7]])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.arccosh(x)\nArray([[0.   , 1.763,   nan],\n[  nan, 1.317, 2.634]], dtype=float32)\nFor complex-valued input:\n>>> x1 = jnp.array([-jnp.inf+0j, 1+2j, -5+0j])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.arccosh(x1)\nArray([  inf+3.142j, 1.529+1.144j, 2.292+3.142j], dtype=complex64)"
      }
    },
    {
      "name": "arcsin",
      "signature": "arcsin(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Compute element-wise inverse of trigonometric sine of input.\nJAX implementation of :obj:`numpy.arcsin`.\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array containing the inverse trigonometric sine of each element of ``x``\nin radians in the range ``[-pi/2, pi/2]``, promoting to inexact dtype.\nNote:\n- ``jnp.arcsin`` returns ``nan`` when ``x`` is real-valued and not in the closed\ninterval ``[-1, 1]``.\n- ``jnp.arcsin`` follows the branch cut convention of :obj:`numpy.arcsin` for\ncomplex inputs.\nSee also:\n- :func:`jax.numpy.sin`: Computes a trigonometric sine of each element of input.\n- :func:`jax.numpy.arccos` and :func:`jax.numpy.acos`: Computes the inverse of\ntrigonometric cosine of each element of input.\n- :func:`jax.numpy.arctan` and :func:`jax.numpy.atan`: Computes the inverse of\ntrigonometric tangent of each element of input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([-2, -1, -0.5, 0, 0.5, 1, 2])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.arcsin(x)\nArray([   nan, -1.571, -0.524,  0.   ,  0.524,  1.571,    nan], dtype=float32)\nFor complex-valued inputs:\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.arcsin(3+4j)\nArray(0.634+2.306j, dtype=complex64, weak_type=True)"
      }
    },
    {
      "name": "arcsinh",
      "signature": "arcsinh(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise inverse of hyperbolic sine of input.\nJAX implementation of :obj:`numpy.arcsinh`.\nThe inverse of hyperbolic sine is defined by:\n.. math::\narcsinh(x) = \\ln(x + \\sqrt{1 + x^2})\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array of same shape as ``x`` containing the inverse of hyperbolic sine of\neach element of ``x``, promoting to inexact dtype.\nNote:\n- ``jnp.arcsinh`` returns ``nan`` for values outside the range ``(-inf, inf)``.\n- ``jnp.arcsinh`` follows the branch cut convention of :obj:`numpy.arcsinh`\nfor complex inputs.\nSee also:\n- :func:`jax.numpy.sinh`: Computes the element-wise hyperbolic sine of the input.\n- :func:`jax.numpy.arccosh`: Computes the element-wise inverse of hyperbolic\ncosine of the input.\n- :func:`jax.numpy.arctanh`: Computes the element-wise inverse of hyperbolic\ntangent of the input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[-2, 3, 1],\n...                [4, 9, -5]])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.arcsinh(x)\nArray([[-1.444,  1.818,  0.881],\n[ 2.095,  2.893, -2.312]], dtype=float32)\nFor complex-valued inputs:\n>>> x1 = jnp.array([4-3j, 2j])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.arcsinh(x1)\nArray([2.306-0.634j, 1.317+1.571j], dtype=complex64)"
      }
    },
    {
      "name": "arctan",
      "signature": "arctan(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Compute element-wise inverse of trigonometric tangent of input.\nJAX implement of :obj:`numpy.arctan`.\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array containing the inverse trigonometric tangent of each element ``x``\nin radians in the range ``[-pi/2, pi/2]``, promoting to inexact dtype.\nNote:\n``jnp.arctan`` follows the branch cut convention of :obj:`numpy.arctan` for\ncomplex inputs.\nSee also:\n- :func:`jax.numpy.tan`: Computes a trigonometric tangent of each element of\ninput.\n- :func:`jax.numpy.arcsin` and :func:`jax.numpy.asin`: Computes the inverse of\ntrigonometric sine of each element of input.\n- :func:`jax.numpy.arccos` and :func:`jax.numpy.atan`: Computes the inverse of\ntrigonometric cosine of each element of input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([-jnp.inf, -20, -1, 0, 1, 20, jnp.inf])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.arctan(x)\nArray([-1.571, -1.521, -0.785,  0.   ,  0.785,  1.521,  1.571], dtype=float32)\nFor complex-valued inputs:\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.arctan(2+7j)\nArray(1.532+0.133j, dtype=complex64, weak_type=True)"
      }
    },
    {
      "name": "arctan2",
      "signature": "arctan2(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Compute the arctangent of x1/x2, choosing the correct quadrant.\nJAX implementation of :func:`numpy.arctan2`\nArgs:\nx1: numerator array.\nx2: denomniator array; should be broadcast-compatible with x1.",
        "parameters": {},
        "returns": "The elementwise arctangent of x1 / x2, tracking the correct quadrant.\nSee also:\n- :func:`jax.numpy.tan`: compute the tangent of an angle\n- :func:`jax.numpy.atan2`: the array API version of this function.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Consider a sequence of angles in radians between 0 and :math:`2\\pi`:\n>>> theta = jnp.linspace(-jnp.pi, jnp.pi, 9)\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(theta)\n[-3.14 -2.36 -1.57 -0.79  0.    0.79  1.57  2.36  3.14]\nThese angles can equivalently be represented by ``(x, y)`` coordinates\non a unit circle:\n>>> x, y = jnp.cos(theta), jnp.sin(theta)\nTo reconstruct the input angle, we might be tempted to use the identity\n:math:`\\tan(\\theta) = y / x`, and compute :math:`\\theta = \\tan^{-1}(y/x)`.\nUnfortunately, this does not recover the input angle:\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.arctan(y / x))\n[-0.    0.79  1.57 -0.79  0.    0.79  1.57 -0.79  0.  ]\nThe problem is that :math:`y/x` contains some ambiguity: although\n:math:`(y, x) = (-1, -1)` and :math:`(y, x) = (1, 1)` represent different points in\nCartesian space, in both cases :math:`y / x = 1`, and so the simple arctan\napproach loses information about which quadrant the angle lies in. :func:`arctan2`\nis built to address this:\n>>> with jnp.printoptions(precision=2, suppress=True):\n...  print(jnp.arctan2(y, x))\n[ 3.14 -2.36 -1.57 -0.79  0.    0.79  1.57  2.36 -3.14]\nThe results match the input ``theta``, except at the endpoints where :math:`+\\pi`\nand :math:`-\\pi` represent indistinguishable points on the unit circle. By convention,\n:func:`arctan2` alwasy returns values between :math:`-\\pi` and :math:`+\\pi` inclusive."
      }
    },
    {
      "name": "arctanh",
      "signature": "arctanh(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise inverse of hyperbolic tangent of input.\nJAX implementation of :obj:`numpy.arctanh`.\nThe inverse of hyperbolic tangent is defined by:\n.. math::\narctanh(x) = \\frac{1}{2} [\\ln(1 + x) - \\ln(1 - x)]\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array of same shape as ``x`` containing the inverse of hyperbolic tangent\nof each element of ``x``, promoting to inexact dtype.\nNote:\n- ``jnp.arctanh`` returns ``nan`` for real-values outside the range ``[-1, 1]``.\n- ``jnp.arctanh`` follows the branch cut convention of :obj:`numpy.arctanh`\nfor complex inputs.\nSee also:\n- :func:`jax.numpy.tanh`: Computes the element-wise hyperbolic tangent of the\ninput.\n- :func:`jax.numpy.arcsinh`: Computes the element-wise inverse of hyperbolic\nsine of the input.\n- :func:`jax.numpy.arccosh`: Computes the element-wise inverse of hyperbolic\ncosine of the input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([-2, -1, -0.5, 0, 0.5, 1, 2])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.arctanh(x)\nArray([   nan,   -inf, -0.549,  0.   ,  0.549,    inf,    nan], dtype=float32)\nFor complex-valued input:\n>>> x1 = jnp.array([-2+0j, 3+0j, 4-1j])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.arctanh(x1)\nArray([-0.549+1.571j,  0.347+1.571j,  0.239-1.509j], dtype=complex64)"
      }
    },
    {
      "name": "argmax",
      "signature": "argmax(a: 'ArrayLike', axis: 'int | None' = None, out: 'None' = None, keepdims: 'bool | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return the index of the maximum value of an array.\nJAX implementation of :func:`numpy.argmax`.\nArgs:\na: input array\naxis: optional integer specifying the axis along which to find the maximum\nvalue. If ``axis`` is not specified, ``a`` will be flattened.\nout: unused by JAX\nkeepdims: if True, then return an array with the same number of dimensions\nas ``a``.",
        "parameters": {},
        "returns": "an array containing the index of the maximum value along the specified axis.\nSee also:\n- :func:`jax.numpy.argmin`: return the index of the minimum value.\n- :func:`jax.numpy.nanargmax`: compute ``argmax`` while ignoring NaN values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([1, 3, 5, 4, 2])\n>>> jnp.argmax(x)\nArray(2, dtype=int32)\n>>> x = jnp.array([[1, 3, 2],\n...                [5, 4, 1]])\n>>> jnp.argmax(x, axis=1)\nArray([1, 0], dtype=int32)\n>>> jnp.argmax(x, axis=1, keepdims=True)\nArray([[1],\n[0]], dtype=int32)"
      }
    },
    {
      "name": "argmin",
      "signature": "argmin(a: 'ArrayLike', axis: 'int | None' = None, out: 'None' = None, keepdims: 'bool | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return the index of the minimum value of an array.\nJAX implementation of :func:`numpy.argmin`.\nArgs:\na: input array\naxis: optional integer specifying the axis along which to find the minimum\nvalue. If ``axis`` is not specified, ``a`` will be flattened.\nout: unused by JAX\nkeepdims: if True, then return an array with the same number of dimensions\nas ``a``.",
        "parameters": {},
        "returns": "an array containing the index of the minimum value along the specified axis.\nSee also:\n- :func:`jax.numpy.argmax`: return the index of the maximum value.\n- :func:`jax.numpy.nanargmin`: compute ``argmin`` while ignoring NaN values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([1, 3, 5, 4, 2])\n>>> jnp.argmin(x)\nArray(0, dtype=int32)\n>>> x = jnp.array([[1, 3, 2],\n...                [5, 4, 1]])\n>>> jnp.argmin(x, axis=1)\nArray([0, 2], dtype=int32)\n>>> jnp.argmin(x, axis=1, keepdims=True)\nArray([[0],\n[2]], dtype=int32)"
      }
    },
    {
      "name": "argpartition",
      "signature": "argpartition(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], kth: int, axis: int = -1) -> jax.Array",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :func:`numpy.argpartition`. The JAX version differs from\nNumPy in the treatment of NaN entries: NaNs which have the negative bit set are\nsorted to the beginning of the array.\nArgs:\na: array to be partitioned.\nkth: static integer index about which to partition the array.\naxis: static integer axis along which to partition the array; default is -1.\nIndices which partition ``a`` at the ``kth`` value along ``axis``. The entries\nbefore ``kth`` are indices of values smaller than ``take(a, kth, axis)``, and\nentries after ``kth`` are indices of values larger than ``take(a, kth, axis)``\nNote:\nThe JAX version requires the ``kth`` argument to be a static integer rather than\na general array. This is implemented via two calls to :func:`jax.lax.top_k`. If\nyou're only accessing the top or bottom k values of the output, it may be more\nefficient to call :func:`jax.lax.top_k` directly.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.partition`: direct partial sort\n- :func:`jax.numpy.argsort`: full indirect sort\n- :func:`jax.lax.top_k`: directly find the top k entries\n- :func:`jax.lax.approx_max_k`: compute the approximate top k entries\n- :func:`jax.lax.approx_min_k`: compute the approximate bottom k entries",
        "notes": "",
        "examples": ">>> x = jnp.array([6, 8, 4, 3, 1, 9, 7, 5, 2, 3])\n>>> kth = 4\n>>> idx = jnp.argpartition(x, kth)\n>>> idx\nArray([4, 8, 3, 9, 2, 0, 1, 5, 6, 7], dtype=int32)\nThe result is a sequence of indices that partially sort the input. All indices\nbefore ``kth`` are of values smaller than the pivot value, and all indices\nafter ``kth`` are of values larger than the pivot value:\n>>> x_partitioned = x[idx]\n>>> smallest_values = x_partitioned[:kth]\n>>> pivot_value = x_partitioned[kth]\n>>> largest_values = x_partitioned[kth + 1:]\n>>> print(smallest_values, pivot_value, largest_values)\n[1 2 3 3] 4 [6 8 9 7 5]\nNotice that among ``smallest_values`` and ``largest_values``, the returned\norder is arbitrary and implementation-dependent."
      }
    },
    {
      "name": "argsort",
      "signature": "argsort(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: int | None = -1, *, kind: None = None, order: None = None, stable: bool = True, descending: bool = False) -> jax.Array",
      "documentation": {
        "description": "Return indices that sort an array.\nJAX implementation of :func:`numpy.argsort`.\nArgs:\na: array to sort\naxis: integer axis along which to sort. Defaults to ``-1``, i.e. the last\naxis. If ``None``, then ``a`` is flattened before being sorted.\nstable: boolean specifying whether a stable sort should be used. Default=True.\ndescending: boolean specifying whether to sort in descending order. Default=False.\nkind: deprecated; instead specify sort algorithm using stable=True or stable=False.\norder: not supported by JAX",
        "parameters": {},
        "returns": "Array of indices that sort an array. Returned array will be of shape ``a.shape``\n(if ``axis`` is an integer) or of shape ``(a.size,)`` (if ``axis`` is None).",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Simple 1-dimensional sort\n>>> x = jnp.array([1, 3, 5, 4, 2, 1])\n>>> indices = jnp.argsort(x)\n>>> indices\nArray([0, 5, 4, 1, 3, 2], dtype=int32)\n>>> x[indices]\nArray([1, 1, 2, 3, 4, 5], dtype=int32)\nSort along the last axis of an array:\n>>> x = jnp.array([[2, 1, 3],\n...                [6, 4, 3]])\n>>> indices = jnp.argsort(x, axis=1)\n>>> indices\nArray([[1, 0, 2],\n[2, 1, 0]], dtype=int32)\n>>> jnp.take_along_axis(x, indices, axis=1)\nArray([[1, 2, 3],\n[3, 4, 6]], dtype=int32)\nSee also:\n- :func:`jax.numpy.sort`: return sorted values directly.\n- :func:`jax.numpy.lexsort`: lexicographical sort of multiple arrays.\n- :func:`jax.lax.sort`: lower-level function wrapping XLA's Sort operator."
      }
    },
    {
      "name": "argwhere",
      "signature": "argwhere(a: 'ArrayLike', *, size: 'int | None' = None, fill_value: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Find the indices of nonzero array elements\nJAX implementation of :func:`numpy.argwhere`.\n``jnp.argwhere(x)`` is essentially equivalent to ``jnp.column_stack(jnp.nonzero(x))``\nwith special handling for zero-dimensional (i.e. scalar) inputs.\nBecause the size of the output of ``argwhere`` is data-dependent, the function is not\ntypically compatible with JIT. The JAX version adds the optional ``size`` argument, which\nspecifies the size of the leading dimension of the output - it must be specified statically\nfor ``jnp.argwhere`` to be compiled with non-static operands. See :func:`jax.numpy.nonzero`\nfor a full discussion of ``size`` and its semantics.\nArgs:\na: array for which to find nonzero elements\nsize: optional integer specifying statically the number of expected nonzero elements.\nThis must be specified in order to use ``argwhere`` within JAX transformations like\n:func:`jax.jit`. See :func:`jax.numpy.nonzero` for more information.\nfill_value: optional array specifying the fill value when ``size`` is specified.\nSee :func:`jax.numpy.nonzero` for more information.",
        "parameters": {},
        "returns": "a two-dimensional array of shape ``[size, x.ndim]``. If ``size`` is not specified as\nan argument, it is equal to the number of nonzero elements in ``x``.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.where`\n- :func:`jax.numpy.nonzero`",
        "notes": "",
        "examples": "Two-dimensional array:\n>>> x = jnp.array([[1, 0, 2],\n...                [0, 3, 0]])\n>>> jnp.argwhere(x)\nArray([[0, 0],\n[0, 2],\n[1, 1]], dtype=int32)\nEquivalent computation using :func:`jax.numpy.column_stack` and :func:`jax.numpy.nonzero`:\n>>> jnp.column_stack(jnp.nonzero(x))\nArray([[0, 0],\n[0, 2],\n[1, 1]], dtype=int32)\nSpecial case for zero-dimensional (i.e. scalar) inputs:\n>>> jnp.argwhere(1)\nArray([], shape=(1, 0), dtype=int32)\n>>> jnp.argwhere(0)\nArray([], shape=(0, 0), dtype=int32)"
      }
    },
    {
      "name": "around",
      "signature": "around(a: 'ArrayLike', decimals: 'int' = 0, out: 'None' = None) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.round`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "array",
      "signature": "array(object: 'Any', dtype: 'DTypeLike | None' = None, copy: 'bool' = True, order: 'str | None' = 'K', ndmin: 'int' = 0, *, device: 'xc.Device | Sharding | None' = None) -> 'Array'",
      "documentation": {
        "description": "Convert an object to a JAX array.\nJAX implementation of :func:`numpy.array`.\nArgs:\nobject: an object that is convertible to an array. This includes JAX\narrays, NumPy arrays, Python scalars, Python collections like lists\nand tuples, objects with an ``__array__`` method, and objects\nsupporting the Python buffer protocol.\ndtype: optionally specify the dtype of the output array. If not\nspecified it will be inferred from the input.\ncopy: specify whether to force a copy of the input. Default: True.\norder: not implemented in JAX\nndmin: integer specifying the minimum number of dimensions in the\noutput array.\ndevice: optional :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.",
        "parameters": {},
        "returns": "A JAX array constructed from the input.\nSee also:\n- :func:`jax.numpy.asarray`: like `array`, but by default only copies\nwhen necessary.\n- :func:`jax.numpy.from_dlpack`: construct a JAX array from an object\nthat implements the dlpack interface.\n- :func:`jax.numpy.frombuffer`: construct a JAX array from an object\nthat implements the buffer interface.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Constructing JAX arrays from Python scalars:\n>>> jnp.array(True)\nArray(True, dtype=bool)\n>>> jnp.array(42)\nArray(42, dtype=int32, weak_type=True)\n>>> jnp.array(3.5)\nArray(3.5, dtype=float32, weak_type=True)\n>>> jnp.array(1 + 1j)\nArray(1.+1.j, dtype=complex64, weak_type=True)\nConstructing JAX arrays from Python collections:\n>>> jnp.array([1, 2, 3])  # list of ints -> 1D array\nArray([1, 2, 3], dtype=int32)\n>>> jnp.array([(1, 2, 3), (4, 5, 6)])  # list of tuples of ints -> 2D array\nArray([[1, 2, 3],\n[4, 5, 6]], dtype=int32)\n>>> jnp.array(range(5))\nArray([0, 1, 2, 3, 4], dtype=int32)\nConstructing JAX arrays from NumPy arrays:\n>>> jnp.array(np.linspace(0, 2, 5))\nArray([0. , 0.5, 1. , 1.5, 2. ], dtype=float32)\nConstructing a JAX array via the Python buffer interface, using Python's\nbuilt-in :mod:`array` module.\n>>> from array import array\n>>> pybuffer = array('i', [2, 3, 5, 7])\n>>> jnp.array(pybuffer)\nArray([2, 3, 5, 7], dtype=int32)"
      }
    },
    {
      "name": "array_equal",
      "signature": "array_equal(a1: 'ArrayLike', a2: 'ArrayLike', equal_nan: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "Check if two arrays are element-wise equal.\nJAX implementation of :func:`numpy.array_equal`.\nArgs:\na1: first input array to compare.\na2: second input array to compare.\nequal_nan: Boolean. If ``True``, NaNs in ``a1`` will be considered\nequal to NaNs in ``a2``. Default is ``False``.",
        "parameters": {},
        "returns": "Boolean scalar array indicating whether the input arrays are element-wise equal.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.allclose`\n- :func:`jax.numpy.array_equiv`",
        "notes": "",
        "examples": ">>> jnp.array_equal(jnp.array([1, 2, 3]), jnp.array([1, 2, 3]))\nArray(True, dtype=bool)\n>>> jnp.array_equal(jnp.array([1, 2, 3]), jnp.array([1, 2]))\nArray(False, dtype=bool)\n>>> jnp.array_equal(jnp.array([1, 2, 3]), jnp.array([1, 2, 4]))\nArray(False, dtype=bool)\n>>> jnp.array_equal(jnp.array([1, 2, float('nan')]),\n...                 jnp.array([1, 2, float('nan')]))\nArray(False, dtype=bool)\n>>> jnp.array_equal(jnp.array([1, 2, float('nan')]),\n...                 jnp.array([1, 2, float('nan')]), equal_nan=True)\nArray(True, dtype=bool)"
      }
    },
    {
      "name": "array_equiv",
      "signature": "array_equiv(a1: 'ArrayLike', a2: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "Check if two arrays are element-wise equal.\nJAX implementation of :func:`numpy.array_equiv`.\nThis function will return ``False`` if the input arrays cannot be broadcasted\nto the same shape.\nArgs:\na1: first input array to compare.\na2: second input array to compare.",
        "parameters": {},
        "returns": "Boolean scalar array indicating whether the input arrays are\nelement-wise equal after broadcasting.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.allclose`\n- :func:`jax.numpy.array_equal`",
        "notes": "",
        "examples": ">>> jnp.array_equiv(jnp.array([1, 2, 3]), jnp.array([1, 2, 3]))\nArray(True, dtype=bool)\n>>> jnp.array_equiv(jnp.array([1, 2, 3]), jnp.array([1, 2, 4]))\nArray(False, dtype=bool)\n>>> jnp.array_equiv(jnp.array([[1, 2, 3], [1, 2, 3]]),\n...                 jnp.array([1, 2, 3]))\nArray(True, dtype=bool)"
      }
    },
    {
      "name": "array_repr",
      "signature": "array_repr(arr, max_line_width=None, precision=None, suppress_small=None)",
      "documentation": {
        "description": "Return the string representation of an array.",
        "parameters": {
          "arr": {
            "type": "ndarray",
            "description": "Input array."
          },
          "max_line_width": {
            "type": "int, optional",
            "description": "Inserts newlines if text is longer than `max_line_width`.\nDefaults to ``numpy.get_printoptions()['linewidth']``."
          },
          "precision": {
            "type": "int, optional",
            "description": "Floating point precision.\nDefaults to ``numpy.get_printoptions()['precision']``."
          },
          "suppress_small": {
            "type": "bool, optional",
            "description": "Represent numbers \"very close\" to zero as zero; default is False.\nVery close is defined by precision: if the precision is 8, e.g.,\nnumbers smaller (in absolute value) than 5e-9 are represented as\nzero.\nDefaults to ``numpy.get_printoptions()['suppress']``."
          }
        },
        "returns": "-------\nstring : str\nThe string representation of an array.",
        "raises": "",
        "see_also": "--------\narray_str, array2string, set_printoptions",
        "notes": "",
        "examples": "--------\n>>> np.array_repr(np.array([1,2]))\n'array([1, 2])'\n>>> np.array_repr(np.ma.array([0.]))\n'MaskedArray([0.])'\n>>> np.array_repr(np.array([], np.int32))\n'array([], dtype=int32)'\n>>> x = np.array([1e-6, 4e-7, 2, 3])\n>>> np.array_repr(x, precision=6, suppress_small=True)\n'array([0.000001,  0.      ,  2.      ,  3.      ])'"
      }
    },
    {
      "name": "array_split",
      "signature": "array_split(ary: 'ArrayLike', indices_or_sections: 'int | Sequence[int] | ArrayLike', axis: 'int' = 0) -> 'list[Array]'",
      "documentation": {
        "description": "Split an array into sub-arrays.\nJAX implementation of :func:`numpy.array_split`.\nRefer to the documentation of :func:`jax.numpy.split` for details; ``array_split``\nis equivalent to ``split``, but allows integer ``indices_or_sections`` which does\nnot evenly divide the split axis.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> chunks = jnp.array_split(x, 4)\n>>> print(*chunks)\n[1 2 3] [4 5] [6 7] [8 9]\nSee also:\n- :func:`jax.numpy.split`: split an array along any axis.\n- :func:`jax.numpy.vsplit`: split vertically, i.e. along axis=0\n- :func:`jax.numpy.hsplit`: split horizontally, i.e. along axis=1\n- :func:`jax.numpy.dsplit`: split depth-wise, i.e. along axis=2"
      }
    },
    {
      "name": "array_str",
      "signature": "array_str(a, max_line_width=None, precision=None, suppress_small=None)",
      "documentation": {
        "description": "Return a string representation of the data in an array.\nThe data in the array is returned as a single string.  This function is\nsimilar to `array_repr`, the difference being that `array_repr` also\nreturns information on the kind of array and its data type.",
        "parameters": {
          "a": {
            "type": "ndarray",
            "description": "Input array."
          },
          "max_line_width": {
            "type": "int, optional",
            "description": "Inserts newlines if text is longer than `max_line_width`.\nDefaults to ``numpy.get_printoptions()['linewidth']``."
          },
          "precision": {
            "type": "int, optional",
            "description": "Floating point precision.\nDefaults to ``numpy.get_printoptions()['precision']``."
          },
          "suppress_small": {
            "type": "bool, optional",
            "description": "Represent numbers \"very close\" to zero as zero; default is False.\nVery close is defined by precision: if the precision is 8, e.g.,\nnumbers smaller (in absolute value) than 5e-9 are represented as\nzero.\nDefaults to ``numpy.get_printoptions()['suppress']``."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\narray2string, array_repr, set_printoptions",
        "notes": "",
        "examples": "--------\n>>> np.array_str(np.arange(3))\n'[0 1 2]'"
      }
    },
    {
      "name": "asarray",
      "signature": "asarray(a: 'Any', dtype: 'DTypeLike | None' = None, order: 'str | None' = None, *, copy: 'bool | None' = None, device: 'xc.Device | Sharding | None' = None) -> 'Array'",
      "documentation": {
        "description": "Convert an object to a JAX array.\nJAX implementation of :func:`numpy.asarray`.\nArgs:\na: an object that is convertible to an array. This includes JAX\narrays, NumPy arrays, Python scalars, Python collections like lists\nand tuples, objects with an ``__array__`` method, and objects\nsupporting the Python buffer protocol.\ndtype: optionally specify the dtype of the output array. If not\nspecified it will be inferred from the input.\norder: not implemented in JAX\ncopy: optional boolean specifying the copy mode. If True, then always\nreturn a copy. If False, then error if a copy is necessary. Default is\nNone, which will only copy when necessary.\ndevice: optional :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.",
        "parameters": {},
        "returns": "A JAX array constructed from the input.\nSee also:\n- :func:`jax.numpy.array`: like `asarray`, but defaults to `copy=True`.\n- :func:`jax.numpy.from_dlpack`: construct a JAX array from an object\nthat implements the dlpack interface.\n- :func:`jax.numpy.frombuffer`: construct a JAX array from an object\nthat implements the buffer interface.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Constructing JAX arrays from Python scalars:\n>>> jnp.asarray(True)\nArray(True, dtype=bool)\n>>> jnp.asarray(42)\nArray(42, dtype=int32, weak_type=True)\n>>> jnp.asarray(3.5)\nArray(3.5, dtype=float32, weak_type=True)\n>>> jnp.asarray(1 + 1j)\nArray(1.+1.j, dtype=complex64, weak_type=True)\nConstructing JAX arrays from Python collections:\n>>> jnp.asarray([1, 2, 3])  # list of ints -> 1D array\nArray([1, 2, 3], dtype=int32)\n>>> jnp.asarray([(1, 2, 3), (4, 5, 6)])  # list of tuples of ints -> 2D array\nArray([[1, 2, 3],\n[4, 5, 6]], dtype=int32)\n>>> jnp.asarray(range(5))\nArray([0, 1, 2, 3, 4], dtype=int32)\nConstructing JAX arrays from NumPy arrays:\n>>> jnp.asarray(np.linspace(0, 2, 5))\nArray([0. , 0.5, 1. , 1.5, 2. ], dtype=float32)\nConstructing a JAX array via the Python buffer interface, using Python's\nbuilt-in :mod:`array` module.\n>>> from array import array\n>>> pybuffer = array('i', [2, 3, 5, 7])\n>>> jnp.asarray(pybuffer)\nArray([2, 3, 5, 7], dtype=int32)"
      }
    },
    {
      "name": "asin",
      "signature": "asin(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.arcsin`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "asinh",
      "signature": "asinh(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.arcsinh`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "astype",
      "signature": "astype(x: 'ArrayLike', dtype: 'DTypeLike | None', /, *, copy: 'bool' = False, device: 'xc.Device | Sharding | None' = None) -> 'Array'",
      "documentation": {
        "description": "Convert an array to a specified dtype.\nJAX imlementation of :func:`numpy.astype`.\nThis is implemented via :func:`jax.lax.convert_element_type`, which may\nhave slightly different behavior than :func:`numpy.astype` in some cases.\nIn particular, the details of float-to-int and int-to-float casts are\nimplementation dependent.\nArgs:\nx: input array to convert\ndtype: output dtype\ncopy: if True, then always return a copy. If False (default) then only\nreturn a copy if necessary.\ndevice: optionally specify the device to which the output will be committed.",
        "parameters": {},
        "returns": "An array with the same shape as ``x``, containing values of the specified\ndtype.",
        "raises": "",
        "see_also": "- :func:`jax.lax.convert_element_type`: lower-level function for XLA-style\ndtype conversions.",
        "notes": "",
        "examples": ">>> x = jnp.array([0, 1, 2, 3])\n>>> x\nArray([0, 1, 2, 3], dtype=int32)\n>>> x.astype('float32')\nArray([0.0, 1.0, 2.0, 3.0], dtype=float32)\n>>> y = jnp.array([0.0, 0.5, 1.0])\n>>> y.astype(int)  # truncates fractional values\nArray([0, 0, 1], dtype=int32)"
      }
    },
    {
      "name": "atan",
      "signature": "atan(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.arctan`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "atan2",
      "signature": "atan2(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.arctan2`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "atanh",
      "signature": "atanh(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.arctanh`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "atleast_1d",
      "signature": "atleast_1d(*arys: 'ArrayLike') -> 'Array | list[Array]'",
      "documentation": {
        "description": "Convert inputs to arrays with at least 1 dimension.\nJAX implementation of :func:`numpy.atleast_1d`.\nArgs:\nzero or more arraylike arguments.",
        "parameters": {},
        "returns": "an array or list of arrays corresponding to the input values. Arrays\nof shape ``()`` are converted to shape ``(1,)``, and arrays with other\nshapes are returned unchanged.\nSee also:\n- :func:`jax.numpy.asarray`\n- :func:`jax.numpy.atleast_2d`\n- :func:`jax.numpy.atleast_3d`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar arguments are converted to 1D, length-1 arrays:\n>>> x = jnp.float32(1.0)\n>>> jnp.atleast_1d(x)\nArray([1.], dtype=float32)\nHigher dimensional inputs are returned unchanged:\n>>> y = jnp.arange(4)\n>>> jnp.atleast_1d(y)\nArray([0, 1, 2, 3], dtype=int32)\nMultiple arguments can be passed to the function at once, in which\ncase a list of results is returned:\n>>> jnp.atleast_1d(x, y)\n[Array([1.], dtype=float32), Array([0, 1, 2, 3], dtype=int32)]"
      }
    },
    {
      "name": "atleast_2d",
      "signature": "atleast_2d(*arys: 'ArrayLike') -> 'Array | list[Array]'",
      "documentation": {
        "description": "Convert inputs to arrays with at least 2 dimensions.\nJAX implementation of :func:`numpy.atleast_2d`.\nArgs:\nzero or more arraylike arguments.",
        "parameters": {},
        "returns": "an array or list of arrays corresponding to the input values. Arrays\nof shape ``()`` are converted to shape ``(1, 1)``, 1D arrays of shape\n``(N,)`` are converted to shape ``(1, N)``, and arrays of all other\nshapes are returned unchanged.\nSee also:\n- :func:`jax.numpy.asarray`\n- :func:`jax.numpy.atleast_1d`\n- :func:`jax.numpy.atleast_3d`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar arguments are converted to 2D, size-1 arrays:\n>>> x = jnp.float32(1.0)\n>>> jnp.atleast_2d(x)\nArray([[1.]], dtype=float32)\nOne-dimensional arguments have a unit dimension prepended to the shape:\n>>> y = jnp.arange(4)\n>>> jnp.atleast_2d(y)\nArray([[0, 1, 2, 3]], dtype=int32)\nHigher dimensional inputs are returned unchanged:\n>>> z = jnp.ones((2, 3))\n>>> jnp.atleast_2d(z)\nArray([[1., 1., 1.],\n[1., 1., 1.]], dtype=float32)\nMultiple arguments can be passed to the function at once, in which\ncase a list of results is returned:\n>>> jnp.atleast_2d(x, y)\n[Array([[1.]], dtype=float32), Array([[0, 1, 2, 3]], dtype=int32)]"
      }
    },
    {
      "name": "atleast_3d",
      "signature": "atleast_3d(*arys: 'ArrayLike') -> 'Array | list[Array]'",
      "documentation": {
        "description": "Convert inputs to arrays with at least 3 dimensions.\nJAX implementation of :func:`numpy.atleast_3d`.\nArgs:\nzero or more arraylike arguments.",
        "parameters": {},
        "returns": "an array or list of arrays corresponding to the input values. Arrays\nof shape ``()`` are converted to shape ``(1, 1, 1)``, 1D arrays of\nshape ``(N,)`` are converted to shape ``(1, N, 1)``, 2D arrays of\nshape ``(M, N)`` are converted to shape ``(M, N, 1)``, and arrays\nof all other shapes are returned unchanged.\nSee also:\n- :func:`jax.numpy.asarray`\n- :func:`jax.numpy.atleast_1d`\n- :func:`jax.numpy.atleast_2d`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar arguments are converted to 3D, size-1 arrays:\n>>> x = jnp.float32(1.0)\n>>> jnp.atleast_3d(x)\nArray([[[1.]]], dtype=float32)\n1D arrays have a unit dimension prepended and appended:\n>>> y = jnp.arange(4)\n>>> jnp.atleast_3d(y).shape\n(1, 4, 1)\n2D arrays have a unit dimension appended:\n>>> z = jnp.ones((2, 3))\n>>> jnp.atleast_3d(z).shape\n(2, 3, 1)\nMultiple arguments can be passed to the function at once, in which\ncase a list of results is returned:\n>>> x3, y3 = jnp.atleast_3d(x, y)\n>>> print(x3)\n[[[1.]]]\n>>> print(y3)\n[[[0]\n[1]\n[2]\n[3]]]"
      }
    },
    {
      "name": "average",
      "signature": "average(a: 'ArrayLike', axis: 'Axis' = None, weights: 'ArrayLike | None' = None, returned: 'bool' = False, keepdims: 'bool' = False) -> 'Array | tuple[Array, Array]'",
      "documentation": {
        "description": "Compute the weighed average.\nJAX Implementation of :func:`numpy.average`.\nArgs:\na: array to be averaged\naxis: an optional integer or sequence of integers specifying the axis along which\nthe mean to be computed. If not specified, mean is computed along all the axes.\nweights: an optional array of weights for a weighted average. Must be\nbroadcast-compatible with ``a``.\nreturned: If False (default) then return only the average. If True then return both\nthe average and the normalization factor (i.e. the sum of weights).\nkeepdims: If True, reduced axes are left in the result with size 1. If False (default)\nthen reduced axes are squeezed out.",
        "parameters": {},
        "returns": "An array ``average`` or tuple of arrays ``(average, normalization)`` if\n``returned`` is True.\nSee also:\n- :func:`jax.numpy.mean`: unweighted mean.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Simple average:\n>>> x = jnp.array([1, 2, 3, 2, 4])\n>>> jnp.average(x)\nArray(2.4, dtype=float32)\nWeighted average:\n>>> weights = jnp.array([2, 1, 3, 2, 2])\n>>> jnp.average(x, weights=weights)\nArray(2.5, dtype=float32)\nUse ``returned=True`` to optionally return the normalization, i.e. the\nsum of weights:\n>>> jnp.average(x, returned=True)\n(Array(2.4, dtype=float32), Array(5., dtype=float32))\n>>> jnp.average(x, weights=weights, returned=True)\n(Array(2.5, dtype=float32), Array(10., dtype=float32))\nWeighted average along a specified axis:\n>>> x = jnp.array([[8, 2, 7],\n...                [3, 6, 4]])\n>>> weights = jnp.array([1, 2, 3])\n>>> jnp.average(x, weights=weights, axis=1)\nArray([5.5, 4.5], dtype=float32)"
      }
    },
    {
      "name": "bartlett",
      "signature": "bartlett(M: int) -> jax.Array",
      "documentation": {
        "description": "Return a Bartlett window of size M.\nJAX implementation of :func:`numpy.bartlett`.\nArgs:\nM: The window size.",
        "parameters": {},
        "returns": "An array of size M containing the Bartlett window.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.bartlett(4))\n[0.   0.67 0.67 0.  ]\nSee also:\n- :func:`jax.numpy.blackman`: return a Blackman window of size M.\n- :func:`jax.numpy.hamming`: return a Hamming window of size M.\n- :func:`jax.numpy.hanning`: return a Hanning window of size M.\n- :func:`jax.numpy.kaiser`: return a Kaiser window of size M."
      }
    },
    {
      "name": "bincount",
      "signature": "bincount(x: 'ArrayLike', weights: 'ArrayLike | None' = None, minlength: 'int' = 0, *, length: 'int | None' = None) -> 'Array'",
      "documentation": {
        "description": "Count the number of occurrences of each value in an integer array.\nJAX implementation of :func:`numpy.bincount`.\nFor an array of positive integers ``x``, this function returns an array ``counts``\nof size ``x.max() + 1``, such that ``counts[i]`` contains the number of occurrences\nof the value ``i`` in ``x``.\nThe JAX version has a few differences from the NumPy version:\n- In NumPy, passing an array ``x`` with negative entries will result in an error.\nIn JAX, negative values are clipped to zero.\n- JAX adds an optional ``length`` parameter which can be used to statically specify\nthe length of the output array so that this function can be used with transformations\nlike :func:`jax.jit`. In this case, items larger than `length + 1` will be dropped.\nArgs:\nx : N-dimensional array of positive integers\nweights: optional array of weights associated with ``x``. If not specified, the\nweight for each entry will be ``1``.\nminlength: the minimum length of the output counts array.\nlength: the length of the output counts array. Must be specified statically for\n``bincount`` to be used with :func:`jax.jit` and other JAX transformations.",
        "parameters": {},
        "returns": "An array of counts or summed weights reflecting the number of occurrences of values\nin ``x``.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.histogram`\n- :func:`jax.numpy.digitize`\n- :func:`jax.numpy.unique_counts`",
        "notes": "",
        "examples": "Basic bincount:\n>>> x = jnp.array([1, 1, 2, 3, 3, 3])\n>>> jnp.bincount(x)\nArray([0, 2, 1, 3], dtype=int32)\nWeighted bincount:\n>>> weights = jnp.array([1, 2, 3, 4, 5, 6])\n>>> jnp.bincount(x, weights)\nArray([ 0,  3,  3, 15], dtype=int32)\nSpecifying a static ``length`` makes this jit-compatible:\n>>> jit_bincount = jax.jit(jnp.bincount, static_argnames=['length'])\n>>> jit_bincount(x, length=5)\nArray([0, 2, 1, 3, 0], dtype=int32)\nAny negative numbers are clipped to the first bin, and numbers beyond the\nspecified ``length`` are dropped:\n>>> x = jnp.array([-1, -1, 1, 3, 10])\n>>> jnp.bincount(x, length=5)\nArray([2, 1, 0, 1, 0], dtype=int32)"
      }
    },
    {
      "name": "bitwise_and",
      "signature": "bitwise_and(*args: 'ArrayLike', out: 'None' = None, where: 'None' = None) -> 'Any'",
      "documentation": {
        "description": "Compute the bitwise AND operation elementwise.\nJAX implementation of :obj:`numpy.bitwise_and`. This is a universal function,\nand supports the additional APIs described at :class:`jax.numpy.ufunc`.\nThis function provides the implementation of the ``&`` operator for\nJAX arrays.\nArgs:\nx, y: integer or boolean arrays. Must be broadcastable to a common shape.",
        "parameters": {},
        "returns": "Array containing the result of the element-wise bitwise AND.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Calling ``bitwise_and`` explicitly:\n>>> x = jnp.arange(4)\n>>> jnp.bitwise_and(x, 1)\nArray([0, 1, 0, 1], dtype=int32)\nCalling ``bitwise_and`` via the ``&`` operator:\n>>> x & 1\nArray([0, 1, 0, 1], dtype=int32)"
      }
    },
    {
      "name": "bitwise_count",
      "signature": "bitwise_count(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Counts the number of 1 bits in the binary representation of the absolute value\nof each element of ``x``.\nJAX implementation of :obj:`numpy.bitwise_count`.\nArgs:\nx: Input array, only accepts integer subtypes",
        "parameters": {},
        "returns": "An array-like object containing the binary 1 bit counts of the absolute value of\neach element in ``x``, with the same shape as ``x`` of dtype uint8.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([64, 32, 31, 20])\n>>> # 64 = 0b1000000, 32 = 0b100000, 31 = 0b11111, 20 = 0b10100\n>>> jnp.bitwise_count(x1)\nArray([1, 1, 5, 2], dtype=uint8)\n>>> x2 = jnp.array([-16, -7, 7])\n>>> # |-16| = 0b10000, |-7| = 0b111, 7 = 0b111\n>>> jnp.bitwise_count(x2)\nArray([1, 3, 3], dtype=uint8)\n>>> x3 = jnp.array([[2, -7],[-9, 7]])\n>>> # 2 = 0b10, |-7| = 0b111, |-9| = 0b1001, 7 = 0b111\n>>> jnp.bitwise_count(x3)\nArray([[1, 3],\n[2, 3]], dtype=uint8)"
      }
    },
    {
      "name": "bitwise_invert",
      "signature": "bitwise_invert(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.invert`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "bitwise_left_shift",
      "signature": "bitwise_left_shift(x: 'ArrayLike', y: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.left_shift`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "bitwise_not",
      "signature": "bitwise_not(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.invert`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "bitwise_or",
      "signature": "bitwise_or(*args: 'ArrayLike', out: 'None' = None, where: 'None' = None) -> 'Any'",
      "documentation": {
        "description": "Compute the bitwise OR operation elementwise.\nJAX implementation of :obj:`numpy.bitwise_or`. This is a universal function,\nand supports the additional APIs described at :class:`jax.numpy.ufunc`.\nThis function provides the implementation of the ``|`` operator for\nJAX arrays.\nArgs:\nx, y: integer or boolean arrays. Must be broadcastable to a common shape.",
        "parameters": {},
        "returns": "Array containing the result of the element-wise bitwise OR.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Calling ``bitwise_or`` explicitly:\n>>> x = jnp.arange(4)\n>>> jnp.bitwise_or(x, 1)\nArray([1, 1, 3, 3], dtype=int32)\nCalling ``bitwise_or`` via the ``|`` operator:\n>>> x | 1\nArray([1, 1, 3, 3], dtype=int32)"
      }
    },
    {
      "name": "bitwise_right_shift",
      "signature": "bitwise_right_shift(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.right_shift`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "bitwise_xor",
      "signature": "bitwise_xor(*args: 'ArrayLike', out: 'None' = None, where: 'None' = None) -> 'Any'",
      "documentation": {
        "description": "Compute the bitwise XOR operation elementwise.\nJAX implementation of :obj:`numpy.bitwise_xor`. This is a universal function,\nand supports the additional APIs described at :class:`jax.numpy.ufunc`.\nThis function provides the implementation of the ``^`` operator for\nJAX arrays.\nArgs:\nx, y: integer or boolean arrays. Must be broadcastable to a common shape.",
        "parameters": {},
        "returns": "Array containing the result of the element-wise bitwise XOR.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Calling ``bitwise_xor`` explicitly:\n>>> x = jnp.arange(4)\n>>> jnp.bitwise_xor(x, 1)\nArray([1, 0, 3, 2], dtype=int32)\nCalling ``bitwise_xor`` via the ``^`` operator:\n>>> x ^ 1\nArray([1, 0, 3, 2], dtype=int32)"
      }
    },
    {
      "name": "blackman",
      "signature": "blackman(M: int) -> jax.Array",
      "documentation": {
        "description": "Return a Blackman window of size M.\nJAX implementation of :func:`numpy.blackman`.\nArgs:\nM: The window size.",
        "parameters": {},
        "returns": "An array of size M containing the Blackman window.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.blackman(4))\n[-0.    0.63  0.63 -0.  ]\nSee also:\n- :func:`jax.numpy.bartlett`: return a Bartlett window of size M.\n- :func:`jax.numpy.hamming`: return a Hamming window of size M.\n- :func:`jax.numpy.hanning`: return a Hanning window of size M.\n- :func:`jax.numpy.kaiser`: return a Kaiser window of size M."
      }
    },
    {
      "name": "block",
      "signature": "block(arrays: 'ArrayLike | list[ArrayLike]') -> 'Array'",
      "documentation": {
        "description": "Create an array from a list of blocks.\nJAX implementation of :func:`numpy.block`.\nArgs:\narrays: an array, or nested list of arrays which will be concatenated\ntogether to form the final array.",
        "parameters": {},
        "returns": "a single array constructed from the inputs.\nSee also:\n- :func:`concatenate`, :func:`concat`: concatenate arrays along an existing axis.\n- :func:`stack`, :func:`vstack`, :func:`hstack`, :func:`dstack` concatenate\narrays along a new axis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "consider these blocks:\n>>> zeros = jnp.zeros((2, 2))\n>>> ones = jnp.ones((2, 2))\n>>> twos = jnp.full((2, 2), 2)\n>>> threes = jnp.full((2, 2), 3)\nPassing a single array to :func:`block` returns the array:\n>>> jnp.block(zeros)\nArray([[0., 0.],\n[0., 0.]], dtype=float32)\nPassing a simple list of arrays concatenates them along the last axis:\n>>> jnp.block([zeros, ones])\nArray([[0., 0., 1., 1.],\n[0., 0., 1., 1.]], dtype=float32)\nPassing a doubly-nested list of arrays concatenates the inner list along\nthe last axis, and the outer list along the second-to-last axis:\n>>> jnp.block([[zeros, ones],\n...            [twos, threes]])\nArray([[0., 0., 1., 1.],\n[0., 0., 1., 1.],\n[2., 2., 3., 3.],\n[2., 2., 3., 3.]], dtype=float32)\nNote that blocks need not align in all dimensions, though the size along the axis\nof concatenation must match. For example, this is valid because after the inner,\nhorizontal concatenation, the resulting blocks have a valid shape for the outer,\nvertical concatenation.\n>>> a = jnp.zeros((2, 1))\n>>> b = jnp.ones((2, 3))\n>>> c = jnp.full((1, 2), 2)\n>>> d = jnp.full((1, 2), 3)\n>>> jnp.block([[a, b], [c, d]])\nArray([[0., 1., 1., 1.],\n[0., 1., 1., 1.],\n[2., 2., 3., 3.]], dtype=float32)\nNote also that this logic generalizes to blocks in 3 or more dimensions.\nHere's a 3-dimensional block-wise array:\n>>> x = jnp.arange(6).reshape((1, 2, 3))\n>>> blocks = [[[x for i in range(3)] for j in range(4)] for k in range(5)]\n>>> jnp.block(blocks).shape\n(5, 8, 9)"
      }
    },
    {
      "name": "broadcast_arrays",
      "signature": "broadcast_arrays(*args: 'ArrayLike') -> 'list[Array]'",
      "documentation": {
        "description": "Broadcast arrays to a common shape.\nJAX implementation of :func:`numpy.broadcast_arrays`. JAX uses NumPy-style\nbroadcasting rules, which you can read more about at `NumPy broadcasting`_.\nArgs:\nargs: zero or more array-like objects to be broadcasted.",
        "parameters": {},
        "returns": "a list of arrays containing broadcasted copies of the inputs.\nSee also:\n- :func:`jax.numpy.broadcast_shapes`: broadcast input shapes to a common shape.\n- :func:`jax.numpy.broadcast_to`: broadcast an array to a specified shape.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.arange(3)\n>>> y = jnp.int32(1)\n>>> jnp.broadcast_arrays(x, y)\n[Array([0, 1, 2], dtype=int32), Array([1, 1, 1], dtype=int32)]\n>>> x = jnp.array([[1, 2, 3]])\n>>> y = jnp.array([[10],\n...                [20]])\n>>> x2, y2 = jnp.broadcast_arrays(x, y)\n>>> x2\nArray([[1, 2, 3],\n[1, 2, 3]], dtype=int32)\n>>> y2\nArray([[10, 10, 10],\n[20, 20, 20]], dtype=int32)\n.. _NumPy broadcasting: https://numpy.org/doc/stable/user/basics.broadcasting.html"
      }
    },
    {
      "name": "broadcast_shapes",
      "signature": "broadcast_shapes(*shapes)",
      "documentation": {
        "description": "Broadcast input shapes to a common output shape.\nJAX implementation of :func:`numpy.broadcast_shapes`. JAX uses NumPy-style\nbroadcasting rules, which you can read more about at `NumPy broadcasting`_.\nArgs:\nshapes: 0 or more shapes specified as sequences of integers",
        "parameters": {},
        "returns": "The broadcasted shape as a tuple of integers.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.broadcast_arrays`: broadcast arrays to a common shape.\n- :func:`jax.numpy.broadcast_to`: broadcast an array to a specified shape.",
        "notes": "",
        "examples": "Some compatible shapes:\n>>> jnp.broadcast_shapes((1,), (4,))\n(4,)\n>>> jnp.broadcast_shapes((3, 1), (4,))\n(3, 4)\n>>> jnp.broadcast_shapes((3, 1), (1, 4), (5, 1, 1))\n(5, 3, 4)\nIncompatible shapes:\n>>> jnp.broadcast_shapes((3, 1), (4, 1))  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nValueError: Incompatible shapes for broadcasting: shapes=[(3, 1), (4, 1)]\n.. _NumPy broadcasting: https://numpy.org/doc/stable/user/basics.broadcasting.html"
      }
    },
    {
      "name": "broadcast_to",
      "signature": "broadcast_to(array: 'ArrayLike', shape: 'DimSize | Shape') -> 'Array'",
      "documentation": {
        "description": "Broadcast an array to a specified shape.\nJAX implementation of :func:`numpy.broadcast_to`. JAX uses NumPy-style\nbroadcasting rules, which you can read more about at `NumPy broadcasting`_.\nArgs:\narray: array to be broadcast.\nshape: shape to which the array will be broadcast.",
        "parameters": {},
        "returns": "a copy of array broadcast to the specified shape.\nSee also:\n- :func:`jax.numpy.broadcast_arrays`: broadcast arrays to a common shape.\n- :func:`jax.numpy.broadcast_shapes`: broadcast input shapes to a common shape.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.int32(1)\n>>> jnp.broadcast_to(x, (1, 4))\nArray([[1, 1, 1, 1]], dtype=int32)\n>>> x = jnp.array([1, 2, 3])\n>>> jnp.broadcast_to(x, (2, 3))\nArray([[1, 2, 3],\n[1, 2, 3]], dtype=int32)\n>>> x = jnp.array([[2], [4]])\n>>> jnp.broadcast_to(x, (2, 4))\nArray([[2, 2, 2, 2],\n[4, 4, 4, 4]], dtype=int32)\n.. _NumPy broadcasting: https://numpy.org/doc/stable/user/basics.broadcasting.html"
      }
    },
    {
      "name": "can_cast",
      "signature": "can_cast(from_, to, casting='safe')",
      "documentation": {
        "description": "can_cast(from_, to, casting='safe')",
        "parameters": {
          "from_": {
            "type": "dtype, dtype specifier, scalar, or array",
            "description": "Data type, scalar, or array to cast from."
          },
          "to": {
            "type": "dtype or dtype specifier",
            "description": "Data type to cast to."
          },
          "casting": {
            "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
            "description": "Controls what kind of data casting may occur.\n* 'no' means the data types should not be cast at all.\n* 'equiv' means only byte-order changes are allowed.\n* 'safe' means only casts which can preserve values are allowed.\n* 'same_kind' means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n* 'unsafe' means any data conversions may be done."
          }
        },
        "returns": "casting rule.  If from is a scalar or array scalar, also returns\nTrue if the scalar value can be cast without overflow or truncation\nto an integer.\n-------\nout : bool\nTrue if cast can occur according to the casting rule.",
        "raises": "",
        "see_also": "",
        "notes": "-----\n.. versionchanged:: 1.17.0\nCasting between a simple data type and a structured one is possible only\nfor \"unsafe\" casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n.. versionchanged:: 1.9.0\nCasting from numeric to string types in 'safe' casting mode requires\nthat the string dtype length is long enough to store the maximum\ninteger/float value converted.\nSee also\n--------\ndtype, result_type",
        "examples": "--------\nBasic examples\n>>> np.can_cast(np.int32, np.int64)\nTrue\n>>> np.can_cast(np.float64, complex)\nTrue\n>>> np.can_cast(complex, float)\nFalse\n>>> np.can_cast('i8', 'f8')\nTrue\n>>> np.can_cast('i8', 'f4')\nFalse\n>>> np.can_cast('i4', 'S4')\nFalse\nCasting scalars\n>>> np.can_cast(100, 'i1')\nTrue\n>>> np.can_cast(150, 'i1')\nFalse\n>>> np.can_cast(150, 'u1')\nTrue\n>>> np.can_cast(3.5e100, np.float32)\nFalse\n>>> np.can_cast(1000.0, np.float32)\nTrue\nArray scalar checks the value, array does not\n>>> np.can_cast(np.array(1000.0), np.float32)\nTrue\n>>> np.can_cast(np.array([1000.0]), np.float32)\nFalse\nUsing the casting rules\n>>> np.can_cast('i8', 'i8', 'no')\nTrue\n>>> np.can_cast('<i8', '>i8', 'no')\nFalse\n>>> np.can_cast('<i8', '>i8', 'equiv')\nTrue\n>>> np.can_cast('<i4', '>i8', 'equiv')\nFalse\n>>> np.can_cast('<i4', '>i8', 'safe')\nTrue\n>>> np.can_cast('<i8', '>i4', 'safe')\nFalse\n>>> np.can_cast('<i8', '>i4', 'same_kind')\nTrue\n>>> np.can_cast('<i8', '>u4', 'same_kind')\nFalse\n>>> np.can_cast('<i8', '>u4', 'unsafe')\nTrue"
      }
    },
    {
      "name": "cbrt",
      "signature": "cbrt(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculates element-wise cube root of the input array.\nJAX implementation of :obj:`numpy.cbrt`.\nArgs:\nx: input array or scalar. ``complex`` dtypes are not supported.",
        "parameters": {},
        "returns": "An array containing the cube root of the elements of ``x``.\nSee also:\n- :func:`jax.numpy.sqrt`: Calculates the element-wise non-negative square root\nof the input.\n- :func:`jax.numpy.square`: Calculates the element-wise square of the input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[216, 125, 64],\n...                [-27, -8, -1]])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.cbrt(x)\nArray([[ 6.,  5.,  4.],\n[-3., -2., -1.]], dtype=float32)"
      }
    },
    {
      "name": "ceil",
      "signature": "ceil(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Round input to the nearest integer upwards.\nJAX implementation of :obj:`numpy.ceil`.\nArgs:\nx: input array or scalar. Must not have complex dtype.",
        "parameters": {},
        "returns": "An array with same shape and dtype as ``x`` containing the values rounded to\nthe nearest integer that is greater than or equal to the value itself.\nSee also:\n- :func:`jax.numpy.fix`: Rounds the input to the nearest interger towards zero.\n- :func:`jax.numpy.trunc`: Rounds the input to the nearest interger towards\nzero.\n- :func:`jax.numpy.floor`: Rounds the input down to the nearest integer.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> key = jax.random.key(1)\n>>> x = jax.random.uniform(key, (3, 3), minval=-5, maxval=5)\n>>> with jnp.printoptions(precision=2, suppress=True):\n...     print(x)\n[[-0.61  0.34 -0.54]\n[-0.62  3.97  0.59]\n[ 4.84  3.42 -1.14]]\n>>> jnp.ceil(x)\nArray([[-0.,  1., -0.],\n[-0.,  4.,  1.],\n[ 5.,  4., -1.]], dtype=float32)"
      }
    },
    {
      "name": "choose",
      "signature": "choose(a: 'ArrayLike', choices: 'Array | np.ndarray | Sequence[ArrayLike]', out: 'None' = None, mode: 'str' = 'raise') -> 'Array'",
      "documentation": {
        "description": "Construct an array by stacking slices of choice arrays.\nJAX implementation of :func:`numpy.choose`.\nThe semantics of this function can be confusing, but in the simplest case where\n``a`` is a one-dimensional array, ``choices`` is a two-dimensional array, and\nall entries of ``a`` are in-bounds (i.e. ``0 <= a_i < len(choices)``), then the\nfunction is equivalent to the following::\ndef choose(a, choices):\nreturn jnp.array([choices[a_i, i] for i, a_i in enumerate(a)])\nIn the more general case, ``a`` may have any number of dimensions and ``choices``\nmay be an arbitrary sequence of broadcast-compatible arrays. In this case, again\nfor in-bound indices, the logic is equivalent to::\ndef choose(a, choices):\na, *choices = jnp.broadcast_arrays(a, *choices)\nchoices = jnp.array(choices)\nreturn jnp.array([choices[a[idx], *idx] for idx in np.ndindex(a.shape)])\nThe only additional complexity comes from the ``mode`` argument, which controls\nthe behavior for out-of-bound indices in ``a`` as described below.\nArgs:\na: an N-dimensional array of integer indices.\nchoices: an array or sequence of arrays. All arrays in the sequence must be\nmutually broadcast compatible with ``a``.\nout: unused by JAX\nmode: specify the out-of-bounds indexing mode; one of ``'raise'`` (default),\n``'wrap'``, or ``'clip'``. Note that the default mode of ``'raise'`` is\nnot compatible with JAX transformations.",
        "parameters": {},
        "returns": "an array containing stacked slices from ``choices`` at the indices\nspecified by ``a``. The shape of the result is\n``broadcast_shapes(a.shape, *(c.shape for c in choices))``.\nSee also:\n- :func:`jax.lax.switch`: choose between N functions based on an index.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Here is the simplest case of a 1D index array with a 2D choice array,\nin which case this chooses the indexed value from each column:\n>>> choices = jnp.array([[ 1,  2,  3,  4],\n...                      [ 5,  6,  7,  8],\n...                      [ 9, 10, 11, 12]])\n>>> a = jnp.array([2, 0, 1, 0])\n>>> jnp.choose(a, choices)\nArray([9, 2, 7, 4], dtype=int32)\nThe ``mode`` argument specifies what to do with out-of-bound indices;\noptions are to either ``wrap`` or ``clip``:\n>>> a2 = jnp.array([2, 0, 1, 4])  # last index out-of-bound\n>>> jnp.choose(a2, choices, mode='clip')\nArray([ 9,  2,  7, 12], dtype=int32)\n>>> jnp.choose(a2, choices, mode='wrap')\nArray([9, 2, 7, 8], dtype=int32)\nIn the more general case, ``choices`` may be a sequence of array-like\nobjects with any broadcast-compatible shapes.\n>>> choice_1 = jnp.array([1, 2, 3, 4])\n>>> choice_2 = 99\n>>> choice_3 = jnp.array([[10],\n...                       [20],\n...                       [30]])\n>>> a = jnp.array([[0, 1, 2, 0],\n...                [1, 2, 0, 1],\n...                [2, 0, 1, 2]])\n>>> jnp.choose(a, [choice_1, choice_2, choice_3], mode='wrap')\nArray([[ 1, 99, 10,  4],\n[99, 20,  3, 99],\n[30,  2, 99, 30]], dtype=int32)"
      }
    },
    {
      "name": "clip",
      "signature": "clip(arr: 'ArrayLike | None' = None, /, min: 'ArrayLike | None' = None, max: 'ArrayLike | None' = None, *, a: 'ArrayLike | DeprecatedArg' = Deprecated, a_min: 'ArrayLike | None | DeprecatedArg' = Deprecated, a_max: 'ArrayLike | None | DeprecatedArg' = Deprecated) -> 'Array'",
      "documentation": {
        "description": "Clip array values to a specified range.\nJAX implementation of :func:`numpy.clip`.\nArgs:\narr: N-dimensional array to be clipped.\nmin: optional minimum value of the clipped range; if ``None`` (default) then\nresult will not be clipped to any minimum value. If specified, it should be\nbroadcast-compatible with ``arr`` and ``max``.\nmax: optional maximum value of the clipped range; if ``None`` (default) then\nresult will not be clipped to any maximum value. If specified, it should be\nbroadcast-compatible with ``arr`` and ``min``.\na: deprecated alias of the ``arr`` argument.  Will result in a\n:class:`DeprecationWarning` if used.\na_min: deprecated alias of the ``min`` argument. Will result in a\n:class:`DeprecationWarning` if used.\na_max: deprecated alias of the ``max`` argument. Will result in a\n:class:`DeprecationWarning` if used.",
        "parameters": {},
        "returns": "An array containing values from ``arr``, with values smaller than ``min`` set\nto ``min``, and values larger than ``max`` set to ``max``.\nSee also:\n- :func:`jax.numpy.minimum`: Compute the element-wise minimum value of two arrays.\n- :func:`jax.numpy.maximum`: Compute the element-wise maximum value of two arrays.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> arr = jnp.array([0, 1, 2, 3, 4, 5, 6, 7])\n>>> jnp.clip(arr, 2, 5)\nArray([2, 2, 2, 3, 4, 5, 5, 5], dtype=int32)"
      }
    },
    {
      "name": "column_stack",
      "signature": "column_stack(tup: 'np.ndarray | Array | Sequence[ArrayLike]') -> 'Array'",
      "documentation": {
        "description": "Stack arrays column-wise.\nJAX implementation of :func:`numpy.column_stack`.\nFor arrays of two or more dimensions, this is equivalent to\n:func:`jax.numpy.concatenate` with ``axis=1``.\nArgs:\ntup: a sequence of arrays to stack; each must have the same leading dimension.\nInput arrays will be promoted to at least rank 2. If a single array is given\nit will be treated equivalently to `tup = unstack(tup)`, but the implementation\nwill avoid explicit unstacking.\ndtype: optional dtype of the resulting array. If not specified, the dtype\nwill be determined via type promotion rules described in :ref:`type-promotion`.",
        "parameters": {},
        "returns": "the stacked result.\nSee also:\n- :func:`jax.numpy.stack`: stack along arbitrary axes\n- :func:`jax.numpy.concatenate`: concatenation along existing axes.\n- :func:`jax.numpy.vstack`: stack vertically, i.e. along axis 0.\n- :func:`jax.numpy.hstack`: stack horizontally, i.e. along axis 1.\n- :func:`jax.numpy.hstack`: stack depth=wise, i.e. along axis 2.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar values:\n>>> jnp.column_stack([1, 2, 3])\nArray([[1, 2, 3]], dtype=int32, weak_type=True)\n1D arrays:\n>>> x = jnp.arange(3)\n>>> y = jnp.ones(3)\n>>> jnp.column_stack([x, y])\nArray([[0., 1.],\n[1., 1.],\n[2., 1.]], dtype=float32)\n2D arrays:\n>>> x = x.reshape(3, 1)\n>>> y = y.reshape(3, 1)\n>>> jnp.column_stack([x, y])\nArray([[0., 1.],\n[1., 1.],\n[2., 1.]], dtype=float32)"
      }
    },
    {
      "name": "compress",
      "signature": "compress(condition: 'ArrayLike', a: 'ArrayLike', axis: 'int | None' = None, *, size: 'int | None' = None, fill_value: 'ArrayLike' = 0, out: 'None' = None) -> 'Array'",
      "documentation": {
        "description": "Compress an array along a given axis using a boolean condition.\nJAX implementation of :func:`numpy.compress`.\nArgs:\ncondition: 1-dimensional array of conditions. Will be converted to boolean.\na: N-dimensional array of values.\naxis: axis along which to compress. If None (default) then ``a`` will be\nflattened, and axis will be set to 0.\nsize: optional static size for output. Must be specified in order for ``compress``\nto be compatible with JAX transformations like :func:`~jax.jit` or :func:`~jax.vmap`.\nfill_value: if ``size`` is specified, fill padded entries with this value (default: 0).\nout: not implemented by JAX.",
        "parameters": {},
        "returns": "An array of dimension ``a.ndim``, compressed along the specified axis.\nSee also:\n- :func:`jax.numpy.extract`: 1D version of ``compress``.\n- :meth:`jax.Array.compress`: equivalent functionality as an array method.",
        "raises": "",
        "see_also": "",
        "notes": "This function does not require strict shape agreement between ``condition`` and ``a``.\nIf ``condition.size > a.shape[axis]``, then ``condition`` will be truncated, and if\n``a.shape[axis] > condition.size``, then ``a`` will be truncated.",
        "examples": "Compressing along the rows of a 2D array:\n>>> a = jnp.array([[1,  2,  3,  4],\n...                [5,  6,  7,  8],\n...                [9,  10, 11, 12]])\n>>> condition = jnp.array([True, False, True])\n>>> jnp.compress(condition, a, axis=0)\nArray([[ 1,  2,  3,  4],\n[ 9, 10, 11, 12]], dtype=int32)\nFor convenience, you can equivalently use the :meth:`~jax.Array.compress`\nmethod of JAX arrays:\n>>> a.compress(condition, axis=0)\nArray([[ 1,  2,  3,  4],\n[ 9, 10, 11, 12]], dtype=int32)\nNote that the condition need not match the shape of the specified axis;\nhere we compress the columns with the length-3 condition. Values beyond\nthe size of the condition are ignored:\n>>> jnp.compress(condition, a, axis=1)\nArray([[ 1,  3],\n[ 5,  7],\n[ 9, 11]], dtype=int32)\nThe optional ``size`` argument lets you specify a static output size so\nthat the output is statically-shaped, and so this function can be used\nwith transformations like :func:`~jax.jit` and :func:`~jax.vmap`:\n>>> f = lambda c, a: jnp.extract(c, a, size=len(a), fill_value=0)\n>>> mask = (a % 3 == 0)\n>>> jax.vmap(f)(mask, a)\nArray([[ 3,  0,  0,  0],\n[ 6,  0,  0,  0],\n[ 9, 12,  0,  0]], dtype=int32)"
      }
    },
    {
      "name": "concat",
      "signature": "concat(arrays: 'Sequence[ArrayLike]', /, *, axis: 'int | None' = 0) -> 'Array'",
      "documentation": {
        "description": "Join arrays along an existing axis.\nJAX implementation of :func:`array_api.concat`.\nArgs:\narrays: a sequence of arrays to concatenate; each must have the same shape\nexcept along the specified axis. If a single array is given it will be\ntreated equivalently to `arrays = unstack(arrays)`, but the implementation\nwill avoid explicit unstacking.\naxis: specify the axis along which to concatenate.",
        "parameters": {},
        "returns": "the concatenated result.\nSee also:\n- :func:`jax.lax.concatenate`: XLA concatenation API.\n- :func:`jax.numpy.concatenate`: NumPy version of this function.\n- :func:`jax.numpy.stack`: concatenate arrays along a new axis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "One-dimensional concatenation:\n>>> x = jnp.arange(3)\n>>> y = jnp.zeros(3, dtype=int)\n>>> jnp.concat([x, y])\nArray([0, 1, 2, 0, 0, 0], dtype=int32)\nTwo-dimensional concatenation:\n>>> x = jnp.ones((2, 3))\n>>> y = jnp.zeros((2, 1))\n>>> jnp.concat([x, y], axis=1)\nArray([[1., 1., 1., 0.],\n[1., 1., 1., 0.]], dtype=float32)"
      }
    },
    {
      "name": "concatenate",
      "signature": "concatenate(arrays: 'np.ndarray | Array | Sequence[ArrayLike]', axis: 'int | None' = 0, dtype: 'DTypeLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Join arrays along an existing axis.\nJAX implementation of :func:`numpy.concatenate`.\nArgs:\narrays: a sequence of arrays to concatenate; each must have the same shape\nexcept along the specified axis. If a single array is given it will be\ntreated equivalently to `arrays = unstack(arrays)`, but the implementation\nwill avoid explicit unstacking.\naxis: specify the axis along which to concatenate.\ndtype: optional dtype of the resulting array. If not specified, the dtype\nwill be determined via type promotion rules described in :ref:`type-promotion`.",
        "parameters": {},
        "returns": "the concatenated result.\nSee also:\n- :func:`jax.lax.concatenate`: XLA concatenation API.\n- :func:`jax.numpy.concat`: Array API version of this function.\n- :func:`jax.numpy.stack`: concatenate arrays along a new axis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "One-dimensional concatenation:\n>>> x = jnp.arange(3)\n>>> y = jnp.zeros(3, dtype=int)\n>>> jnp.concatenate([x, y])\nArray([0, 1, 2, 0, 0, 0], dtype=int32)\nTwo-dimensional concatenation:\n>>> x = jnp.ones((2, 3))\n>>> y = jnp.zeros((2, 1))\n>>> jnp.concatenate([x, y], axis=1)\nArray([[1., 1., 1., 0.],\n[1., 1., 1., 0.]], dtype=float32)"
      }
    },
    {
      "name": "conj",
      "signature": "conj(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.conjugate`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "conjugate",
      "signature": "conjugate(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return element-wise complex-conjugate of the input.\nJAX implementation of :obj:`numpy.conjugate`.\nArgs:\nx: inpuat array or scalar.",
        "parameters": {},
        "returns": "An array containing the complex-conjugate of ``x``.\nSee also:\n- :func:`jax.numpy.real`: Returns the element-wise real part of the complex\nargument.\n- :func:`jax.numpy.imag`: Returns the element-wise imaginary part of the\ncomplex argument.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.conjugate(3)\nArray(3, dtype=int32, weak_type=True)\n>>> x = jnp.array([2-1j, 3+5j, 7])\n>>> jnp.conjugate(x)\nArray([2.+1.j, 3.-5.j, 7.-0.j], dtype=complex64)"
      }
    },
    {
      "name": "convolve",
      "signature": "convolve(a: 'ArrayLike', v: 'ArrayLike', mode: 'str' = 'full', *, precision: 'PrecisionLike' = None, preferred_element_type: 'DTypeLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Convolution of two one dimensional arrays.\nJAX implementation of :func:`numpy.convolve`.\nConvolution of one dimensional arrays is defined as:\n.. math::\nc_k = \\sum_j a_{k - j} v_j\nArgs:\na: left-hand input to the convolution. Must have ``a.ndim == 1``.\nv: right-hand input to the convolution. Must have ``v.ndim == 1``.\nmode: controls the size of the output. Available operations are:\n* ``\"full\"``: (default) output the full convolution of the inputs.\n* ``\"same\"``: return a centered portion of the ``\"full\"`` output which\nis the same size as ``a``.\n* ``\"valid\"``: return the portion of the ``\"full\"`` output which do not\ndepend on padding at the array edges.\nprecision: Specify the precision of the computation. Refer to\n:class:`jax.lax.Precision` for a description of available values.\npreferred_element_type: A datatype, indicating to accumulate results to and\nreturn a result with that datatype. Default is ``None``, which means the\ndefault accumulation type for the input types.",
        "parameters": {},
        "returns": "Array containing the convolved result.",
        "raises": "",
        "see_also": "- :func:`jax.scipy.signal.convolve`: ND convolution\n- :func:`jax.numpy.correlate`: 1D correlation",
        "notes": "",
        "examples": "A few 1D convolution examples:\n>>> x = jnp.array([1, 2, 3, 2, 1])\n>>> y = jnp.array([4, 1, 2])\n``jax.numpy.convolve``, by default, returns full convolution using implicit\nzero-padding at the edges:\n>>> jnp.convolve(x, y)\nArray([ 4.,  9., 16., 15., 12.,  5.,  2.], dtype=float32)\nSpecifying ``mode = 'same'`` returns a centered convolution the same size\nas the first input:\n>>> jnp.convolve(x, y, mode='same')\nArray([ 9., 16., 15., 12.,  5.], dtype=float32)\nSpecifying ``mode = 'valid'`` returns only the portion where the two arrays\nfully overlap:\n>>> jnp.convolve(x, y, mode='valid')\nArray([16., 15., 12.], dtype=float32)\nFor complex-valued inputs:\n>>> x1 = jnp.array([3+1j, 2, 4-3j])\n>>> y1 = jnp.array([1, 2-3j, 4+5j])\n>>> jnp.convolve(x1, y1)\nArray([ 3. +1.j, 11. -7.j, 15.+10.j,  7. -8.j, 31. +8.j], dtype=complex64)"
      }
    },
    {
      "name": "copy",
      "signature": "copy(a: 'ArrayLike', order: 'str | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return a copy of the array.\nJAX implementation of :func:`numpy.copy`.\nArgs:\na: arraylike object to copy\norder: not implemented in JAX",
        "parameters": {},
        "returns": "a copy of the input array ``a``.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.array`: create an array with or without a copy.\n- :meth:`jax.Array.copy`: same function accessed as an array method.",
        "notes": "",
        "examples": "Since JAX arrays are immutable, in most cases explicit array copies\nare not necessary. One exception is when using a function with donated\narguments (see the ``donate_argnums`` argument to :func:`jax.jit`).\n>>> f = jax.jit(lambda x: 2 * x, donate_argnums=0)\n>>> x = jnp.arange(4)\n>>> y = f(x)\n>>> print(y)\n[0 2 4 6]\nBecause we marked ``x`` as being donated, the original array is no longer\navailable:\n>>> print(x)  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nRuntimeError: Array has been deleted with shape=int32[4].\nIn situations like this, an explicit copy will let you keep access to the\noriginal buffer:\n>>> x = jnp.arange(4)\n>>> y = f(x.copy())\n>>> print(y)\n[0 2 4 6]\n>>> print(x)\n[0 1 2 3]"
      }
    },
    {
      "name": "copysign",
      "signature": "copysign(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Copies the sign of each element in ``x2`` to the corresponding element in ``x1``.\nJAX implementation of :obj:`numpy.copysign`.\nArgs:\nx1: Input array\nx2: The array whose elements will be used to determine the sign, must be\nbroadcast-compatible with ``x1``",
        "parameters": {},
        "returns": "An array object containing the potentially changed elements of ``x1``, always promotes\nto inexact dtype, and has a shape of ``jnp.broadcast_shapes(x1.shape, x2.shape)``",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([5, 2, 0])\n>>> x2 = -1\n>>> jnp.copysign(x1, x2)\nArray([-5., -2., -0.], dtype=float32)\n>>> x1 = jnp.array([6, 8, 0])\n>>> x2 = 2\n>>> jnp.copysign(x1, x2)\nArray([6., 8., 0.], dtype=float32)\n>>> x1 = jnp.array([2, -3])\n>>> x2 = jnp.array([[1],[-4], [5]])\n>>> jnp.copysign(x1, x2)\nArray([[ 2.,  3.],\n[-2., -3.],\n[ 2.,  3.]], dtype=float32)"
      }
    },
    {
      "name": "corrcoef",
      "signature": "corrcoef(x: 'ArrayLike', y: 'ArrayLike | None' = None, rowvar: 'bool' = True) -> 'Array'",
      "documentation": {
        "description": "Compute the Pearson correlation coefficients.\nJAX implementation of :func:`numpy.corrcoef`.\nThis is a normalized version of the sample covariance computed by :func:`jax.numpy.cov`.\nFor a sample covariance :math:`C_{ij}`, the correlation coefficients are\n.. math::\nR_{ij} = \\frac{C_{ij}}{\\sqrt{C_{ii}C_{jj}}}\nthey are constructed such that the values satisfy :math:`-1 \\le R_{ij} \\le 1`.\nArgs:\nx: array of shape ``(M, N)`` (if ``rowvar`` is True), or ``(N, M)``\n(if ``rowvar`` is False) representing ``N`` observations of ``M`` variables.\n``x`` may also be one-dimensional, representing ``N`` observations of a\nsingle variable.\ny: optional set of additional observations, with the same form as ``m``. If\nspecified, then ``y`` is combined with ``m``, i.e. for the default\n``rowvar = True`` case, ``m`` becomes ``jnp.vstack([m, y])``.\nrowvar: if True (default) then each row of ``m`` represents a variable. If\nFalse, then each column represents a variable.",
        "parameters": {},
        "returns": "A covariance matrix of shape ``(M, M)``.\nSee also:\n- :func:`jax.numpy.cov`: compute the covariance matrix.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Consider these observations of two variables that correlate perfectly.\nThe correlation matrix in this case is a 2x2 matrix of ones:\n>>> x = jnp.array([[0, 1, 2],\n...                [0, 1, 2]])\n>>> jnp.corrcoef(x)\nArray([[1., 1.],\n[1., 1.]], dtype=float32)\nNow consider these observations of two variables that are perfectly\nanti-correlated. The correlation matrix in this case has ``-1`` in the\noff-diagonal:\n>>> x = jnp.array([[-1,  0,  1],\n...                [ 1,  0, -1]])\n>>> jnp.corrcoef(x)\nArray([[ 1., -1.],\n[-1.,  1.]], dtype=float32)\nEquivalently, these sequences can be specified as separate arguments,\nin which case they are stacked before continuing the computation.\n>>> x = jnp.array([-1, 0, 1])\n>>> y = jnp.array([1, 0, -1])\n>>> jnp.corrcoef(x, y)\nArray([[ 1., -1.],\n[-1.,  1.]], dtype=float32)\nThe entries of the correlation matrix are normalized such that they\nlie within the range -1 to +1, where +1 indicates perfect correlation\nand -1 indicates perfect anti-correlation. For example, here is the\ncorrelation of 100 points drawn from a 3-dimensional standard normal\ndistribution:\n>>> key = jax.random.key(0)\n>>> x = jax.random.normal(key, shape=(3, 100))\n>>> with jnp.printoptions(precision=2):\n...   print(jnp.corrcoef(x))\n[[1.   0.03 0.12]\n[0.03 1.   0.01]\n[0.12 0.01 1.  ]]"
      }
    },
    {
      "name": "correlate",
      "signature": "correlate(a: 'ArrayLike', v: 'ArrayLike', mode: 'str' = 'valid', *, precision: 'PrecisionLike' = None, preferred_element_type: 'DTypeLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Correlation of two one dimensional arrays.\nJAX implementation of :func:`numpy.correlate`.\nCorrelation of one dimensional arrays is defined as:\n.. math::\nc_k = \\sum_j a_{k + j} \\overline{v_j}\nwhere :math:`\\overline{v_j}` is the complex conjugate of :math:`v_j`.\nArgs:\na: left-hand input to the correlation. Must have ``a.ndim == 1``.\nv: right-hand input to the correlation. Must have ``v.ndim == 1``.\nmode: controls the size of the output. Available operations are:\n* ``\"full\"``: output the full correlation of the inputs.\n* ``\"same\"``: return a centered portion of the ``\"full\"`` output which\nis the same size as ``a``.\n* ``\"valid\"``: (default) return the portion of the ``\"full\"`` output which do not\ndepend on padding at the array edges.\nprecision: Specify the precision of the computation. Refer to\n:class:`jax.lax.Precision` for a description of available values.\npreferred_element_type: A datatype, indicating to accumulate results to and\nreturn a result with that datatype. Default is ``None``, which means the\ndefault accumulation type for the input types.",
        "parameters": {},
        "returns": "Array containing the cross-correlation result.",
        "raises": "",
        "see_also": "- :func:`jax.scipy.signal.correlate`: ND correlation\n- :func:`jax.numpy.convolve`: 1D convolution",
        "notes": "",
        "examples": ">>> x = jnp.array([1, 2, 3, 2, 1])\n>>> y = jnp.array([4, 5, 6])\nSince default ``mode = 'valid'``, ``jax.numpy.correlate`` returns only the\nportion of correlation where the two arrays fully overlap:\n>>> jnp.correlate(x, y)\nArray([32., 35., 28.], dtype=float32)\nSpecifying ``mode = 'full'`` returns full correlation using implicit\nzero-padding at the edges.\n>>> jnp.correlate(x, y, mode='full')\nArray([ 6., 17., 32., 35., 28., 13.,  4.], dtype=float32)\nSpecifying ``mode = 'same'`` returns a centered correlation the same size\nas the first input:\n>>> jnp.correlate(x, y, mode='same')\nArray([17., 32., 35., 28., 13.], dtype=float32)\nIf both the inputs arrays are real-valued and symmetric then the result will\nalso be symmetric and will be equal to the result of ``jax.numpy.convolve``.\n>>> x1 = jnp.array([1, 2, 3, 2, 1])\n>>> y1 = jnp.array([4, 5, 4])\n>>> jnp.correlate(x1, y1, mode='full')\nArray([ 4., 13., 26., 31., 26., 13.,  4.], dtype=float32)\n>>> jnp.convolve(x1, y1, mode='full')\nArray([ 4., 13., 26., 31., 26., 13.,  4.], dtype=float32)\nFor complex-valued inputs:\n>>> x2 = jnp.array([3+1j, 2, 2-3j])\n>>> y2 = jnp.array([4, 2-5j, 1])\n>>> jnp.correlate(x2, y2, mode='full')\nArray([ 3. +1.j,  3.+17.j, 18.+11.j, 27. +4.j,  8.-12.j], dtype=complex64)"
      }
    },
    {
      "name": "cos",
      "signature": "cos(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Compute a trigonometric cosine of each element of input.\nJAX implementation of :obj:`numpy.cos`.\nArgs:\nx: scalar or array. Angle in radians.",
        "parameters": {},
        "returns": "An array containing the cosine of each element in ``x``, promotes to inexact\ndtype.\nSee also:\n- :func:`jax.numpy.sin`: Computes a trigonometric sine of each element of input.\n- :func:`jax.numpy.tan`: Computes a trigonometric tangent of each element of\ninput.\n- :func:`jax.numpy.arccos` and :func:`jax.numpy.acos`: Computes the inverse of\ntrigonometric cosine of each element of input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> pi = jnp.pi\n>>> x = jnp.array([pi/4, pi/2, 3*pi/4, 5*pi/6])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   print(jnp.cos(x))\n[ 0.707 -0.    -0.707 -0.866]"
      }
    },
    {
      "name": "cosh",
      "signature": "cosh(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise hyperbolic cosine of input.\nJAX implementation of :obj:`numpy.cosh`.\nThe hyperbolic cosine is defined by:\n.. math::\ncosh(x) = \\frac{e^x + e^{-x}}{2}\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array containing the hyperbolic cosine of each element of ``x``, promoting\nto inexact dtype.\nNote:\n``jnp.cosh`` is equivalent to computing ``jnp.cos(1j * x)``.\nSee also:\n- :func:`jax.numpy.sinh`: Computes the element-wise hyperbolic sine of the input.\n- :func:`jax.numpy.tanh`: Computes the element-wise hyperbolic tangent of the\ninput.\n- :func:`jax.numpy.arccosh`:  Computes the element-wise inverse of hyperbolic\ncosine of the input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[3, -1, 0],\n...                [4, 7, -5]])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.cosh(x)\nArray([[ 10.068,   1.543,   1.   ],\n[ 27.308, 548.317,  74.21 ]], dtype=float32)\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.cos(1j * x)\nArray([[ 10.068+0.j,   1.543+0.j,   1.   +0.j],\n[ 27.308+0.j, 548.317+0.j,  74.21 +0.j]],      dtype=complex64, weak_type=True)\nFor complex-valued input:\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.cosh(5+1j)\nArray(40.096+62.44j, dtype=complex64, weak_type=True)\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.cos(1j * (5+1j))\nArray(40.096+62.44j, dtype=complex64, weak_type=True)"
      }
    },
    {
      "name": "count_nonzero",
      "signature": "count_nonzero(a: 'ArrayLike', axis: 'Axis' = None, keepdims: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "Return the number of nonzero elements along a given axis.\nJAX implementation of :func:`numpy.count_nonzero`.\nArgs:\na: input array.\naxis: optional, int or sequence of ints, default=None. Axis along which the\nnumber of nonzeros are counted. If None, counts within the flattened array.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.",
        "parameters": {},
        "returns": "An array with number of nonzeros elements along specified axis of the input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.count_nonzero`` counts the nonzero values along all axes.\n>>> x = jnp.array([[1, 0, 0, 0],\n...                [0, 0, 1, 0],\n...                [1, 1, 1, 0]])\n>>> jnp.count_nonzero(x)\nArray(5, dtype=int32)\nIf ``axis=1``, counts along axis 1.\n>>> jnp.count_nonzero(x, axis=1)\nArray([1, 1, 3], dtype=int32)\nTo preserve the dimensions of input, you can set ``keepdims=True``.\n>>> jnp.count_nonzero(x, axis=1, keepdims=True)\nArray([[1],\n[1],\n[3]], dtype=int32)"
      }
    },
    {
      "name": "cov",
      "signature": "cov(m: 'ArrayLike', y: 'ArrayLike | None' = None, rowvar: 'bool' = True, bias: 'bool' = False, ddof: 'int | None' = None, fweights: 'ArrayLike | None' = None, aweights: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Estimate the weighted sample covariance.\nJAX implementation of :func:`numpy.cov`.\nThe covariance :math:`C_{ij}` between variable *i* and variable *j* is defined\nas\n.. math::\ncov[X_i, X_j] = E[(X_i - E[X_i])(X_j - E[X_j])]\nGiven an array of *N* observations of the variables :math:`X_i` and :math:`X_j`,\nthis can be estimated via the sample covariance:\n.. math::\nC_{ij} = \\frac{1}{N - 1} \\sum_{n=1}^N (X_{in} - \\overline{X_i})(X_{jn} - \\overline{X_j})\nWhere :math:`\\overline{X_i} = \\frac{1}{N} \\sum_{k=1}^N X_{ik}` is the mean of the\nobservations.\nArgs:\nm: array of shape ``(M, N)`` (if ``rowvar`` is True), or ``(N, M)``\n(if ``rowvar`` is False) representing ``N`` observations of ``M`` variables.\n``m`` may also be one-dimensional, representing ``N`` observations of a\nsingle variable.\ny: optional set of additional observations, with the same form as ``m``. If\nspecified, then ``y`` is combined with ``m``, i.e. for the default\n``rowvar = True`` case, ``m`` becomes ``jnp.vstack([m, y])``.\nrowvar: if True (default) then each row of ``m`` represents a variable. If\nFalse, then each column represents a variable.\nbias: if False (default) then normalize the covariance by ``N - 1``. If True,\nthen normalize the covariance by ``N``\nddof: specify the degrees of freedom. Defaults to ``1`` if ``bias`` is False,\nor to ``0`` if ``bias`` is True.\nfweights: optional array of integer frequency weights of shape ``(N,)``. This\nis an absolute weight specifying the number of times each observation is\nincluded in the computation.\naweights: optional array of observation weights of shape ``(N,)``. This is\na relative weight specifying the \"importance\" of each observation. In the\n``ddof=0`` case, it is equivalent to assigning probabilities to each\nobservation.",
        "parameters": {},
        "returns": "A covariance matrix of shape ``(M, M)``, or a scalar with shape ``()`` if ``M = 1``.\nSee also:\n- :func:`jax.numpy.corrcoef`: compute the correlation coefficient, a normalized\nversion of the covariance matrix.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Consider these observations of two variables that correlate perfectly.\nThe covariance matrix in this case is a 2x2 matrix of ones:\n>>> x = jnp.array([[0, 1, 2],\n...                [0, 1, 2]])\n>>> jnp.cov(x)\nArray([[1., 1.],\n[1., 1.]], dtype=float32)\nNow consider these observations of two variables that are perfectly\nanti-correlated. The covariance matrix in this case has ``-1`` in the\noff-diagonal:\n>>> x = jnp.array([[-1,  0,  1],\n...                [ 1,  0, -1]])\n>>> jnp.cov(x)\nArray([[ 1., -1.],\n[-1.,  1.]], dtype=float32)\nEquivalently, these sequences can be specified as separate arguments,\nin which case they are stacked before continuing the computation.\n>>> x = jnp.array([-1, 0, 1])\n>>> y = jnp.array([1, 0, -1])\n>>> jnp.cov(x, y)\nArray([[ 1., -1.],\n[-1.,  1.]], dtype=float32)\nIn general, the entries of the covariance matrix may be any positive\nor negative real value. For example, here is the covariance of 100\npoints drawn from a 3-dimensional standard normal distribution:\n>>> key = jax.random.key(0)\n>>> x = jax.random.normal(key, shape=(3, 100))\n>>> with jnp.printoptions(precision=2):\n...   print(jnp.cov(x))\n[[0.9  0.03 0.1 ]\n[0.03 1.   0.01]\n[0.1  0.01 0.85]]"
      }
    },
    {
      "name": "cross",
      "signature": "cross(a, b, axisa: 'int' = -1, axisb: 'int' = -1, axisc: 'int' = -1, axis: 'int | None' = None)",
      "documentation": {
        "description": "Compute the (batched) cross product of two arrays.\nJAX implementation of :func:`numpy.cross`.\nThis computes the 2-dimensional or 3-dimensional cross product,\n.. math::\nc = a \\times b\nIn 3 dimensions, ``c`` is a length-3 array. In 2 dimensions, ``c`` is\na scalar.\nArgs:\na: N-dimensional array. ``a.shape[axisa]`` indicates the dimension of\nthe cross product, and must be 2 or 3.\nb: N-dimensional array. Must have ``b.shape[axisb] == a.shape[axisb]``,\nand other dimensions of ``a`` and ``b`` must be broadcast compatible.\naxisa: specicy the axis of ``a`` along which to compute the cross product.\naxisb: specicy the axis of ``b`` along which to compute the cross product.\naxisc: specicy the axis of ``c`` along which the cross product result\nwill be stored.\naxis: if specified, this overrides ``axisa``, ``axisb``, and ``axisc``\nwith a single value.",
        "parameters": {},
        "returns": "The array ``c`` containing the (batched) cross product of ``a`` and ``b``\nalong the specified axes.\nSee also:\n- :func:`jax.numpy.linalg.cross`: an array API compatible function for\ncomputing cross products over 3-vectors.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "A 2-dimensional cross product returns a scalar:\n>>> a = jnp.array([1, 2])\n>>> b = jnp.array([3, 4])\n>>> jnp.cross(a, b)\nArray(-2, dtype=int32)\nA 3-dimensional cross product returns a length-3 vector:\n>>> a = jnp.array([1, 2, 3])\n>>> b = jnp.array([4, 5, 6])\n>>> jnp.cross(a, b)\nArray([-3,  6, -3], dtype=int32)\nWith multi-dimensional inputs, the cross-product is computed along\nthe last axis by default. Here's a batched 3-dimensional cross\nproduct, operating on the rows of the inputs:\n>>> a = jnp.array([[1, 2, 3],\n...                [3, 4, 3]])\n>>> b = jnp.array([[2, 3, 2],\n...                [4, 5, 6]])\n>>> jnp.cross(a, b)\nArray([[-5,  4, -1],\n[ 9, -6, -1]], dtype=int32)\nSpecifying axis=0 makes this a batched 2-dimensional cross product,\noperating on the columns of the inputs:\n>>> jnp.cross(a, b, axis=0)\nArray([-2, -2, 12], dtype=int32)\nEquivalently, we can independently specify the axis of the inputs ``a``\nand ``b`` and the output ``c``:\n>>> jnp.cross(a, b, axisa=0, axisb=0, axisc=0)\nArray([-2, -2, 12], dtype=int32)"
      }
    },
    {
      "name": "cumprod",
      "signature": "cumprod(a: 'ArrayLike', axis: 'int | None' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None) -> 'Array'",
      "documentation": {
        "description": "Cumulative product of elements along an axis.\nJAX implementation of :func:`numpy.cumprod`.\nArgs:\na: N-dimensional array to be accumulated.\naxis: integer axis along which to accumulate. If None (default), then\narray will be flattened and accumulated along the flattened axis.\ndtype: optionally specify the dtype of the output. If not specified,\nthen the output dtype will match the input dtype.\nout: unused by JAX",
        "parameters": {},
        "returns": "An array containing the accumulated product along the given axis.\nSee also:\n- :meth:`jax.numpy.multiply.accumulate`: cumulative product via ufunc methods.\n- :func:`jax.numpy.nancumprod`: cumulative product ignoring NaN values.\n- :func:`jax.numpy.prod`: product along axis",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> jnp.cumprod(x)  # flattened cumulative product\nArray([  1,   2,   6,  24, 120, 720], dtype=int32)\n>>> jnp.cumprod(x, axis=1)  # cumulative product along axis 1\nArray([[  1,   2,   6],\n[  4,  20, 120]], dtype=int32)"
      }
    },
    {
      "name": "cumsum",
      "signature": "cumsum(a: 'ArrayLike', axis: 'int | None' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None) -> 'Array'",
      "documentation": {
        "description": "Cumulative sum of elements along an axis.\nJAX implementation of :func:`numpy.cumsum`.\nArgs:\na: N-dimensional array to be accumulated.\naxis: integer axis along which to accumulate. If None (default), then\narray will be flattened and accumulated along the flattened axis.\ndtype: optionally specify the dtype of the output. If not specified,\nthen the output dtype will match the input dtype.\nout: unused by JAX",
        "parameters": {},
        "returns": "An array containing the accumulated sum along the given axis.\nSee also:\n- :func:`jax.numpy.cumulative_sum`: cumulative sum via the array API standard.\n- :meth:`jax.numpy.add.accumulate`: cumulative sum via ufunc methods.\n- :func:`jax.numpy.nancumsum`: cumulative sum ignoring NaN values.\n- :func:`jax.numpy.sum`: sum along axis",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> jnp.cumsum(x)  # flattened cumulative sum\nArray([ 1,  3,  6, 10, 15, 21], dtype=int32)\n>>> jnp.cumsum(x, axis=1)  # cumulative sum along axis 1\nArray([[ 1,  3,  6],\n[ 4,  9, 15]], dtype=int32)"
      }
    },
    {
      "name": "cumulative_prod",
      "signature": "cumulative_prod(x: 'ArrayLike', /, *, axis: 'int | None' = None, dtype: 'DTypeLike | None' = None, include_initial: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "Cumulative product along the axis of an array.\nJAX implementation of :func:`numpy.cumulative_prod`.\nArgs:\nx: N-dimensional array\naxis: integer axis along which to accumulate. If ``x`` is one-dimensional,\nthis argument is optional and defaults to zero.\ndtype: optional dtype of the output.\ninclude_initial: if True, then include the initial value in the cumulative\nproduct. Default is False.",
        "parameters": {},
        "returns": "An array containing the accumulated values.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.cumprod`: alternative API for cumulative product.\n- :func:`jax.numpy.nancumprod`: cumulative product while ignoring NaN values.\n- :func:`jax.numpy.multiply.accumulate`: cumulative product via the ufunc API.",
        "notes": "",
        "examples": ">>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> jnp.cumulative_prod(x, axis=1)\nArray([[  1,   2,   6],\n[  4,  20, 120]], dtype=int32)\n>>> jnp.cumulative_prod(x, axis=1, include_initial=True)\nArray([[  1,   1,   2,   6],\n[  1,   4,  20, 120]], dtype=int32)"
      }
    },
    {
      "name": "cumulative_sum",
      "signature": "cumulative_sum(x: 'ArrayLike', /, *, axis: 'int | None' = None, dtype: 'DTypeLike | None' = None, include_initial: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "Cumulative sum along the axis of an array.\nJAX implementation of :func:`numpy.cumulative_sum`.\nArgs:\nx: N-dimensional array\naxis: integer axis along which to accumulate. If ``x`` is one-dimensional,\nthis argument is optional and defaults to zero.\ndtype: optional dtype of the output.\ninclude_initial: if True, then include the initial value in the cumulative\nsum. Default is False.",
        "parameters": {},
        "returns": "An array containing the accumulated values.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.cumsum`: alternative API for cumulative sum.\n- :func:`jax.numpy.nancumsum`: cumulative sum while ignoring NaN values.\n- :func:`jax.numpy.add.accumulate`: cumulative sum via the ufunc API.",
        "notes": "",
        "examples": ">>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> jnp.cumulative_sum(x, axis=1)\nArray([[ 1,  3,  6],\n[ 4,  9, 15]], dtype=int32)\n>>> jnp.cumulative_sum(x, axis=1, include_initial=True)\nArray([[ 0,  1,  3,  6],\n[ 0,  4,  9, 15]], dtype=int32)"
      }
    },
    {
      "name": "deg2rad",
      "signature": "deg2rad(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Convert angles from degrees to radians.\nJAX implementation of :obj:`numpy.deg2rad`.\nThe angle in degrees is converted to radians by:\n.. math::\ndeg2rad(x) = x * \\frac{pi}{180}\nArgs:\nx: scalar or array. Specifies the angle in degrees.",
        "parameters": {},
        "returns": "An array containing the angles in radians.\nSee also:\n- :func:`jax.numpy.rad2deg` and :func:`jax.numpy.degrees`: Converts the angles\nfrom radians to degrees.\n- :func:`jax.numpy.radians`: Alias of ``deg2rad``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([60, 90, 120, 180])\n>>> jnp.deg2rad(x)\nArray([1.0471976, 1.5707964, 2.0943952, 3.1415927], dtype=float32)\n>>> x * jnp.pi / 180\nArray([1.0471976, 1.5707964, 2.0943952, 3.1415927],      dtype=float32, weak_type=True)"
      }
    },
    {
      "name": "degrees",
      "signature": "degrees(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.rad2deg`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "delete",
      "signature": "delete(arr: 'ArrayLike', obj: 'ArrayLike | slice', axis: 'int | None' = None, *, assume_unique_indices: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "Delete entry or entries from an array.\nJAX implementation of :func:`numpy.delete`.\nArgs:\narr: array from which entries will be deleted.\nobj: index, indices, or slice to be deleted.\naxis: axis along which entries will be deleted.\nassume_unique_indices: In case of array-like integer (not boolean) indices,\nassume the indices are unique, and perform the deletion in a way that is\ncompatible with JIT and other JAX transformations.",
        "parameters": {},
        "returns": "Copy of ``arr`` with specified indices deleted.\nNote:\n``delete()`` usually requires the index specification to be static. If the\nindex is an integer array that is guaranteed to contain unique entries, you\nmay specify ``assume_unique_indices=True`` to perform the operation in a\nmanner that does not require static indices.\nSee also:\n- :func:`jax.numpy.insert`: insert entries into an array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Delete entries from a 1D array:\n>>> a = jnp.array([4, 5, 6, 7, 8, 9])\n>>> jnp.delete(a, 2)\nArray([4, 5, 7, 8, 9], dtype=int32)\n>>> jnp.delete(a, slice(1, 4))  # delete a[1:4]\nArray([4, 8, 9], dtype=int32)\n>>> jnp.delete(a, slice(None, None, 2))  # delete a[::2]\nArray([5, 7, 9], dtype=int32)\nDelete entries from a 2D array along a specified axis:\n>>> a2 = jnp.array([[4, 5, 6],\n...                 [7, 8, 9]])\n>>> jnp.delete(a2, 1, axis=1)\nArray([[4, 6],\n[7, 9]], dtype=int32)\nDelete multiple entries via a sequence of indices:\n>>> indices = jnp.array([0, 1, 3])\n>>> jnp.delete(a, indices)\nArray([6, 8, 9], dtype=int32)\nThis will fail under :func:`~jax.jit` and other transformations, because\nthe output shape cannot be known with the possibility of duplicate indices:\n>>> jax.jit(jnp.delete)(a, indices)  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nConcretizationTypeError: Abstract tracer value encountered where concrete value is expected: traced array with shape int32[3].\nIf you can ensure that the indices are unique, pass ``assume_unique_indices``\nto allow this to be executed under JIT:\n>>> jit_delete = jax.jit(jnp.delete, static_argnames=['assume_unique_indices'])\n>>> jit_delete(a, indices, assume_unique_indices=True)\nArray([6, 8, 9], dtype=int32)"
      }
    },
    {
      "name": "diag",
      "signature": "diag(v: 'ArrayLike', k: 'int' = 0) -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :func:`numpy.diag`.\nThe JAX version always returns a copy of the input, although if this is used\nwithin a JIT compilation, the compiler may avoid the copy.\nArgs:\nv: Input array. Can be a 1-D array to create a diagonal matrix or a\n2-D array to extract a diagonal.\nk: optional, default=0. Diagonal offset. Positive values place the diagonal\nabove the main diagonal, negative values place it below the main diagonal.\nIf `v` is a 2-D array, a 1-D array containing the diagonal elements.\nIf `v` is a 1-D array, a 2-D array with the input elements placed along the\nspecified diagonal.\nSee also:\n- :func:`jax.numpy.diagflat`\n- :func:`jax.numpy.diagonal`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Creating a diagonal matrix from a 1-D array:\n>>> jnp.diag(jnp.array([1, 2, 3]))\nArray([[1, 0, 0],\n[0, 2, 0],\n[0, 0, 3]], dtype=int32)\nSpecifying a diagonal offset:\n>>> jnp.diag(jnp.array([1, 2, 3]), k=1)\nArray([[0, 1, 0, 0],\n[0, 0, 2, 0],\n[0, 0, 0, 3],\n[0, 0, 0, 0]], dtype=int32)\nExtracting a diagonal from a 2-D array:\n>>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6],\n...                [7, 8, 9]])\n>>> jnp.diag(x)\nArray([1, 5, 9], dtype=int32)"
      }
    },
    {
      "name": "diag_indices",
      "signature": "diag_indices(n: 'int', ndim: 'int' = 2) -> 'tuple[Array, ...]'",
      "documentation": {
        "description": "Return indices for accessing the main diagonal of a multidimensional array.\nJAX implementation of :func:`numpy.diag_indices`.\nArgs:\nn: int. The size of each dimension of the square array.\nndim: optional, int, default=2. The number of dimensions of the array.",
        "parameters": {},
        "returns": "A tuple of arrays, each of length `n`, containing the indices to access\nthe main diagonal.\nSee also:\n- :func:`jax.numpy.diag_indices_from`\n- :func:`jax.numpy.diagonal`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.diag_indices(3)\n(Array([0, 1, 2], dtype=int32), Array([0, 1, 2], dtype=int32))\n>>> jnp.diag_indices(4, ndim=3)\n(Array([0, 1, 2, 3], dtype=int32),\nArray([0, 1, 2, 3], dtype=int32),\nArray([0, 1, 2, 3], dtype=int32))"
      }
    },
    {
      "name": "diag_indices_from",
      "signature": "diag_indices_from(arr: 'ArrayLike') -> 'tuple[Array, ...]'",
      "documentation": {
        "description": "Return indices for accessing the main diagonal of a given array.\nJAX implementation of :func:`numpy.diag_indices_from`.\nArgs:\narr: Input array. Must be at least 2-dimensional and have equal length along\nall dimensions.",
        "parameters": {},
        "returns": "A tuple of arrays containing the indices to access the main diagonal of\nthe input array.\nSee also:\n- :func:`jax.numpy.diag_indices`\n- :func:`jax.numpy.diagonal`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> arr = jnp.array([[1, 2, 3],\n...                  [4, 5, 6],\n...                  [7, 8, 9]])\n>>> jnp.diag_indices_from(arr)\n(Array([0, 1, 2], dtype=int32), Array([0, 1, 2], dtype=int32))\n>>> arr = jnp.array([[[1, 2], [3, 4]],\n...                  [[5, 6], [7, 8]]])\n>>> jnp.diag_indices_from(arr)\n(Array([0, 1], dtype=int32),\nArray([0, 1], dtype=int32),\nArray([0, 1], dtype=int32))"
      }
    },
    {
      "name": "diagflat",
      "signature": "diagflat(v: 'ArrayLike', k: 'int' = 0) -> 'Array'",
      "documentation": {
        "description": "Return a 2-D array with the flattened input array laid out on the diagonal.\nJAX implementation of :func:`numpy.diagflat`.\nThis differs from `np.diagflat` for some scalar values of `v`. JAX always returns\na two-dimensional array, whereas NumPy may return a scalar depending on the type\nof `v`.\nArgs:\nv: Input array. Can be N-dimensional but is flattened to 1D.\nk: optional, default=0. Diagonal offset. Positive values place the diagonal\nabove the main diagonal, negative values place it below the main diagonal.",
        "parameters": {},
        "returns": "A 2D array with the input elements placed along the diagonal with the\nspecified offset (k). The remaining entries are filled with zeros.\nSee also:\n- :func:`jax.numpy.diag`\n- :func:`jax.numpy.diagonal`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.diagflat(jnp.array([1, 2, 3]))\nArray([[1, 0, 0],\n[0, 2, 0],\n[0, 0, 3]], dtype=int32)\n>>> jnp.diagflat(jnp.array([1, 2, 3]), k=1)\nArray([[0, 1, 0, 0],\n[0, 0, 2, 0],\n[0, 0, 0, 3],\n[0, 0, 0, 0]], dtype=int32)\n>>> a = jnp.array([[1, 2],\n...                [3, 4]])\n>>> jnp.diagflat(a)\nArray([[1, 0, 0, 0],\n[0, 2, 0, 0],\n[0, 0, 3, 0],\n[0, 0, 0, 4]], dtype=int32)"
      }
    },
    {
      "name": "diagonal",
      "signature": "diagonal(a: 'ArrayLike', offset: 'int' = 0, axis1: 'int' = 0, axis2: 'int' = 1) -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :func:`numpy.diagonal`.\nThe JAX version always returns a copy of the input, although if this is used\nwithin a JIT compilation, the compiler may avoid the copy.\nArgs:\na: Input array. Must be at least 2-dimensional.\noffset: optional, default=0. Diagonal offset from the main diagonal.\nMust be a static integer value. Can be positive or negative.\naxis1: optional, default=0. The first axis along which to take the diagonal.\naxis2: optional, default=1. The second axis along which to take the diagonal.\nA 1D array for 2D input, and in general a N-1 dimensional array\nfor N-dimensional input.\nSee also:\n- :func:`jax.numpy.diag`\n- :func:`jax.numpy.diagflat`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6],\n...                [7, 8, 9]])\n>>> jnp.diagonal(x)\nArray([1, 5, 9], dtype=int32)\n>>> jnp.diagonal(x, offset=1)\nArray([2, 6], dtype=int32)\n>>> jnp.diagonal(x, offset=-1)\nArray([4, 8], dtype=int32)"
      }
    },
    {
      "name": "diff",
      "signature": "diff(a: 'ArrayLike', n: 'int' = 1, axis: 'int' = -1, prepend: 'ArrayLike | None' = None, append: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Calculate n-th order difference between array elements along a given axis.\nJAX implementation of :func:`numpy.diff`.\nThe first order difference is computed by ``a[i+1] - a[i]``, and the n-th order\ndifference is computed ``n`` times recursively.\nArgs:\na: input array. Must have ``a.ndim >= 1``.\nn: int, optional, default=1. Order of the difference. Specifies the number\nof times the difference is computed. If n=0, no difference is computed and\ninput is returned as is.\naxis: int, optional, default=-1. Specifies the axis along which the difference\nis computed. The difference is computed along ``axis -1`` by default.\nprepend: scalar or array, optional, default=None. Specifies the values to be\nprepended along ``axis`` before computing the difference.\nappend: scalar or array, optional, default=None. Specifies the values to be\nappended along ``axis`` before computing the difference.",
        "parameters": {},
        "returns": "An array containing the n-th order difference between the elements of ``a``.\nSee also:\n- :func:`jax.numpy.ediff1d`: Computes the differences between consecutive\nelements of an array.\n- :func:`jax.numpy.cumsum`: Computes the cumulative sum of the elements of\nthe array along a given axis.\n- :func:`jax.numpy.gradient`: Computes the gradient of an N-dimensional array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "``jnp.diff`` computes the first order difference along ``axis``, by default.\n>>> a = jnp.array([[1, 5, 2, 9],\n...                [3, 8, 7, 4]])\n>>> jnp.diff(a)\nArray([[ 4, -3,  7],\n[ 5, -1, -3]], dtype=int32)\nWhen ``n = 2``, second order difference is computed along ``axis``.\n>>> jnp.diff(a, n=2)\nArray([[-7, 10],\n[-6, -2]], dtype=int32)\nWhen ``prepend = 2``, it is prepended to ``a`` along ``axis`` before computing\nthe difference.\n>>> jnp.diff(a, prepend=2)\nArray([[-1,  4, -3,  7],\n[ 1,  5, -1, -3]], dtype=int32)\nWhen ``append = jnp.array([[3],[1]])``, it is appended to ``a`` along ``axis``\nbefore computing the difference.\n>>> jnp.diff(a, append=jnp.array([[3],[1]]))\nArray([[ 4, -3,  7, -6],\n[ 5, -1, -3, -3]], dtype=int32)"
      }
    },
    {
      "name": "digitize",
      "signature": "digitize(x: 'ArrayLike', bins: 'ArrayLike', right: 'bool' = False, *, method: 'str | None' = None) -> 'Array'",
      "documentation": {
        "description": "Convert an array to bin indices.\nJAX implementation of :func:`numpy.digitize`.\nArgs:\nx: array of values to digitize.\nbins: 1D array of bin edges. Must be monotonically increasing or decreasing.\nright: if true, the intervals include the right bin edges. If false (default)\nthe intervals include the left bin edges.\nmethod: optional method argument to be passed to :func:`~jax.numpy.searchsorted`.\nSee that function for available options.",
        "parameters": {},
        "returns": "An integer array of the same shape as ``x`` indicating the bin number that\nthe values are in.\nSee also:\n- :func:`jax.numpy.searchsorted`: find insertion indices for values in a\nsorted array.\n- :func:`jax.numpy.histogram`: compute frequency of array values within\nspecified bins.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([1.0, 2.0, 2.5, 1.5, 3.0, 3.5])\n>>> bins = jnp.array([1, 2, 3])\n>>> jnp.digitize(x, bins)\nArray([1, 2, 2, 1, 3, 3], dtype=int32)\n>>> jnp.digitize(x, bins, right=True)\nArray([0, 1, 2, 1, 2, 3], dtype=int32)\n``digitize`` supports reverse-ordered bins as well:\n>>> bins = jnp.array([3, 2, 1])\n>>> jnp.digitize(x, bins)\nArray([2, 1, 1, 2, 0, 0], dtype=int32)"
      }
    },
    {
      "name": "divide",
      "signature": "divide(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.true_divide`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "divmod",
      "signature": "divmod(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'tuple[Array, Array]'",
      "documentation": {
        "description": "Calculates the integer quotient and remainder of x1 by x2 element-wise\nJAX implementation of :obj:`numpy.divmod`.\nArgs:\nx1: Input array, the dividend\nx2: Input array, the divisor",
        "parameters": {},
        "returns": "A tuple of arrays ``(x1 // x2, x1 % x2)``.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.floor_divide`: floor division function\n- :func:`jax.numpy.remainder`: remainder function",
        "notes": "",
        "examples": ">>> x1 = jnp.array([10, 20, 30])\n>>> x2 = jnp.array([3, 4, 7])\n>>> jnp.divmod(x1, x2)\n(Array([3, 5, 4], dtype=int32), Array([1, 0, 2], dtype=int32))\n>>> x1 = jnp.array([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])\n>>> x2 = 3\n>>> jnp.divmod(x1, x2)\n(Array([-2, -2, -1, -1, -1,  0,  0,  0,  1,  1,  1], dtype=int32),\nArray([1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2], dtype=int32))\n>>> x1 = jnp.array([6, 6, 6], dtype=jnp.int32)\n>>> x2 = jnp.array([1.9, 2.5, 3.1], dtype=jnp.float32)\n>>> jnp.divmod(x1, x2)\n(Array([3., 2., 1.], dtype=float32),\nArray([0.30000007, 1.        , 2.9       ], dtype=float32))"
      }
    },
    {
      "name": "dot",
      "signature": "dot(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, precision: Union[NoneType, str, jax._src.lax.lax.Precision, tuple[str, str], tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision], jax._src.lax.lax.DotAlgorithm, jax._src.lax.lax.DotAlgorithmPreset] = None, preferred_element_type: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None) -> jax.Array",
      "documentation": {
        "description": "Compute the dot product of two arrays.\nJAX implementation of :func:`numpy.dot`.\nThis differs from :func:`jax.numpy.matmul` in two respects:\n- if either ``a`` or ``b`` is a scalar, the result of ``dot`` is equivalent to\n:func:`jax.numpy.multiply`, while the result of ``matmul`` is an error.\n- if ``a`` and ``b`` have more than 2 dimensions, the batch indices are\nstacked rather than broadcast.\nArgs:\na: first input array, of shape ``(..., N)``.\nb: second input array. Must have shape ``(N,)`` or ``(..., N, M)``.\nIn the multi-dimensional case, leading dimensions must be broadcast-compatible\nwith the leading dimensions of ``a``.\nprecision: either ``None`` (default), which means the default precision for\nthe backend, a :class:`~jax.lax.Precision` enum value (``Precision.DEFAULT``,\n``Precision.HIGH`` or ``Precision.HIGHEST``) or a tuple of two\nsuch values indicating precision of ``a`` and ``b``.\npreferred_element_type: either ``None`` (default), which means the default\naccumulation type for the input types, or a datatype, indicating to\naccumulate results to and return a result with that datatype.",
        "parameters": {},
        "returns": "array containing the dot product of the inputs, with batch dimensions of\n``a`` and ``b`` stacked rather than broadcast.\nSee also:\n- :func:`jax.numpy.matmul`: broadcasted batched matmul.\n- :func:`jax.lax.dot_general`: general batched matrix multiplication.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "For scalar inputs, ``dot`` computes the element-wise product:\n>>> x = jnp.array([1, 2, 3])\n>>> jnp.dot(x, 2)\nArray([2, 4, 6], dtype=int32)\nFor vector or matrix inputs, ``dot`` computes the vector or matrix product:\n>>> M = jnp.array([[2, 3, 4],\n...                [5, 6, 7],\n...                [8, 9, 0]])\n>>> jnp.dot(M, x)\nArray([20, 38, 26], dtype=int32)\n>>> jnp.dot(M, M)\nArray([[ 51,  60,  29],\n[ 96, 114,  62],\n[ 61,  78,  95]], dtype=int32)\nFor higher-dimensional matrix products, batch dimensions are stacked, whereas\nin :func:`~jax.numpy.matmul` they are broadcast. For example:\n>>> a = jnp.zeros((3, 2, 4))\n>>> b = jnp.zeros((3, 4, 1))\n>>> jnp.dot(a, b).shape\n(3, 2, 3, 1)\n>>> jnp.matmul(a, b).shape\n(3, 2, 1)"
      }
    },
    {
      "name": "dsplit",
      "signature": "dsplit(ary: 'ArrayLike', indices_or_sections: 'int | Sequence[int] | ArrayLike') -> 'list[Array]'",
      "documentation": {
        "description": "Split an array into sub-arrays depth-wise.\nJAX implementation of :func:`numpy.dsplit`.\nRefer to the documentation of :func:`jax.numpy.split` for details. ``dsplit`` is\nequivalent to ``split`` with ``axis=2``.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.arange(12).reshape(3, 1, 4)\n>>> print(x)\n[[[ 0  1  2  3]]\n<BLANKLINE>\n[[ 4  5  6  7]]\n<BLANKLINE>\n[[ 8  9 10 11]]]\n>>> x1, x2 = jnp.dsplit(x, 2)\n>>> print(x1)\n[[[0 1]]\n<BLANKLINE>\n[[4 5]]\n<BLANKLINE>\n[[8 9]]]\n>>> print(x2)\n[[[ 2  3]]\n<BLANKLINE>\n[[ 6  7]]\n<BLANKLINE>\n[[10 11]]]\nSee also:\n- :func:`jax.numpy.split`: split an array along any axis.\n- :func:`jax.numpy.vsplit`: split vertically, i.e. along axis=0\n- :func:`jax.numpy.hsplit`: split horizontally, i.e. along axis=1\n- :func:`jax.numpy.array_split`: like ``split``, but allows ``indices_or_sections``\nto be an integer that does not evenly divide the size of the array."
      }
    },
    {
      "name": "dstack",
      "signature": "dstack(tup: 'np.ndarray | Array | Sequence[ArrayLike]', dtype: 'DTypeLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Stack arrays depth-wise.\nJAX implementation of :func:`numpy.dstack`.\nFor arrays of three or more dimensions, this is equivalent to\n:func:`jax.numpy.concatenate` with ``axis=2``.\nArgs:\ntup: a sequence of arrays to stack; each must have the same shape along all\nbut the third axis. Input arrays will be promoted to at least rank 3. If a\nsingle array is given it will be treated equivalently to `tup = unstack(tup)`,\nbut the implementation will avoid explicit unstacking.\ndtype: optional dtype of the resulting array. If not specified, the dtype\nwill be determined via type promotion rules described in :ref:`type-promotion`.",
        "parameters": {},
        "returns": "the stacked result.\nSee also:\n- :func:`jax.numpy.stack`: stack along arbitrary axes\n- :func:`jax.numpy.concatenate`: concatenation along existing axes.\n- :func:`jax.numpy.vstack`: stack vertically, i.e. along axis 0.\n- :func:`jax.numpy.hstack`: stack horizontally, i.e. along axis 1.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar values:\n>>> jnp.dstack([1, 2, 3])\nArray([[[1, 2, 3]]], dtype=int32, weak_type=True)\n1D arrays:\n>>> x = jnp.arange(3)\n>>> y = jnp.ones(3)\n>>> jnp.dstack([x, y])\nArray([[[0., 1.],\n[1., 1.],\n[2., 1.]]], dtype=float32)\n2D arrays:\n>>> x = x.reshape(1, 3)\n>>> y = y.reshape(1, 3)\n>>> jnp.dstack([x, y])\nArray([[[0., 1.],\n[1., 1.],\n[2., 1.]]], dtype=float32)"
      }
    },
    {
      "name": "ediff1d",
      "signature": "ediff1d(ary: 'ArrayLike', to_end: 'ArrayLike | None' = None, to_begin: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Compute the differences of the elements of the flattened array.\nJAX implementation of :func:`numpy.ediff1d`.\nArgs:\nary: input array or scalar.\nto_end: scalar or array, optional, default=None. Specifies the numbers to\nappend to the resulting array.\nto_begin: scalar or array, optional, default=None. Specifies the numbers to\nprepend to the resulting array.",
        "parameters": {},
        "returns": "An array containing the differences between the elements of the input array.\nNote:\nUnlike NumPy's implementation of ediff1d, :py:func:`jax.numpy.ediff1d` will\nnot issue an error if casting ``to_end`` or ``to_begin`` to the type of\n``ary`` loses precision.\nSee also:\n- :func:`jax.numpy.diff`: Computes the n-th order difference between elements\nof the array along a given axis.\n- :func:`jax.numpy.cumsum`: Computes the cumulative sum of the elements of\nthe array along a given axis.\n- :func:`jax.numpy.gradient`: Computes the gradient of an N-dimensional array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> a = jnp.array([2, 3, 5, 9, 1, 4])\n>>> jnp.ediff1d(a)\nArray([ 1,  2,  4, -8,  3], dtype=int32)\n>>> jnp.ediff1d(a, to_begin=-10)\nArray([-10,   1,   2,   4,  -8,   3], dtype=int32)\n>>> jnp.ediff1d(a, to_end=jnp.array([20, 30]))\nArray([ 1,  2,  4, -8,  3, 20, 30], dtype=int32)\n>>> jnp.ediff1d(a, to_begin=-10, to_end=jnp.array([20, 30]))\nArray([-10,   1,   2,   4,  -8,   3,  20,  30], dtype=int32)\nFor array with ``ndim > 1``, the differences are computed after flattening\nthe input array.\n>>> a1 = jnp.array([[2, -1, 4, 7],\n...                 [3, 5, -6, 9]])\n>>> jnp.ediff1d(a1)\nArray([ -3,   5,   3,  -4,   2, -11,  15], dtype=int32)\n>>> a2 = jnp.array([2, -1, 4, 7, 3, 5, -6, 9])\n>>> jnp.ediff1d(a2)\nArray([ -3,   5,   3,  -4,   2, -11,  15], dtype=int32)"
      }
    },
    {
      "name": "einsum",
      "signature": "einsum(subscripts, /, *operands, out: None = None, optimize: str | bool | list[tuple[int, ...]] = 'auto', precision: Union[NoneType, str, jax._src.lax.lax.Precision, tuple[str, str], tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision], jax._src.lax.lax.DotAlgorithm, jax._src.lax.lax.DotAlgorithmPreset] = None, preferred_element_type: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None, _dot_general: Callable[..., jax.Array] = <function dot_general at 0x7b2214472520>, out_sharding=None) -> jax.Array",
      "documentation": {
        "description": "Einstein summation\nJAX implementation of :func:`numpy.einsum`.\n``einsum`` is a powerful and generic API for computing various reductions,\ninner products, outer products, axis reorderings, and combinations thereof\nacross one or more input arrays. It has a somewhat complicated overloaded API;\nthe arguments below reflect the most common calling convention. The Examples\nsection below demonstrates some of the alternative calling conventions.\nArgs:\nsubscripts: string containing axes names separated by commas.\n*operands: sequence of one or more arrays corresponding to the subscripts.\noptimize: specify how to optimize the order of computation. In JAX this defaults\nto ``\"auto\"`` which produces optimized expressions via the opt_einsum_\npackage. Other options are ``True`` (same as ``\"optimal\"``), ``False``\n(unoptimized), or any string supported by ``opt_einsum``, which\nincludes ``\"optimal\"``, ``\"greedy\"``, ``\"eager\"``, and others. It may also\nbe a pre-computed path (see :func:`~jax.numpy.einsum_path`).\nprecision: either ``None`` (default), which means the default precision for\nthe backend, a :class:`~jax.lax.Precision` enum value (``Precision.DEFAULT``,\n``Precision.HIGH`` or ``Precision.HIGHEST``).\npreferred_element_type: either ``None`` (default), which means the default\naccumulation type for the input types, or a datatype, indicating to\naccumulate results to and return a result with that datatype.\nout: unsupported by JAX\n_dot_general: optionally override the ``dot_general`` callable used by ``einsum``.\nThis parameter is experimental, and may be removed without warning at any time.",
        "parameters": {},
        "returns": "array containing the result of the einstein summation.\nSee also:\n:func:`jax.numpy.einsum_path`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "The mechanics of ``einsum`` are perhaps best demonstrated by example. Here we\nshow how to use ``einsum`` to compute a number of quantities from one or more\narrays. For more discussion and examples of ``einsum``, see the documentation\nof :func:`numpy.einsum`.\n>>> M = jnp.arange(16).reshape(4, 4)\n>>> x = jnp.arange(4)\n>>> y = jnp.array([5, 4, 3, 2])\n**Vector product**\n>>> jnp.einsum('i,i', x, y)\nArray(16, dtype=int32)\n>>> jnp.vecdot(x, y)\nArray(16, dtype=int32)\nHere are some alternative ``einsum`` calling conventions to compute the same\nresult:\n>>> jnp.einsum('i,i->', x, y)  # explicit form\nArray(16, dtype=int32)\n>>> jnp.einsum(x, (0,), y, (0,))  # implicit form via indices\nArray(16, dtype=int32)\n>>> jnp.einsum(x, (0,), y, (0,), ())  # explicit form via indices\nArray(16, dtype=int32)\n**Matrix product**\n>>> jnp.einsum('ij,j->i', M, x)  # explicit form\nArray([14, 38, 62, 86], dtype=int32)\n>>> jnp.matmul(M, x)\nArray([14, 38, 62, 86], dtype=int32)\nHere are some alternative ``einsum`` calling conventions to compute the same\nresult:\n>>> jnp.einsum('ij,j', M, x) # implicit form\nArray([14, 38, 62, 86], dtype=int32)\n>>> jnp.einsum(M, (0, 1), x, (1,), (0,)) # explicit form via indices\nArray([14, 38, 62, 86], dtype=int32)\n>>> jnp.einsum(M, (0, 1), x, (1,))  # implicit form via indices\nArray([14, 38, 62, 86], dtype=int32)\n**Outer product**\n>>> jnp.einsum(\"i,j->ij\", x, y)\nArray([[ 0,  0,  0,  0],\n[ 5,  4,  3,  2],\n[10,  8,  6,  4],\n[15, 12,  9,  6]], dtype=int32)\n>>> jnp.outer(x, y)\nArray([[ 0,  0,  0,  0],\n[ 5,  4,  3,  2],\n[10,  8,  6,  4],\n[15, 12,  9,  6]], dtype=int32)\nSome other ways of computing outer products:\n>>> jnp.einsum(\"i,j\", x, y)  # implicit form\nArray([[ 0,  0,  0,  0],\n[ 5,  4,  3,  2],\n[10,  8,  6,  4],\n[15, 12,  9,  6]], dtype=int32)\n>>> jnp.einsum(x, (0,), y, (1,), (0, 1))  # explicit form via indices\nArray([[ 0,  0,  0,  0],\n[ 5,  4,  3,  2],\n[10,  8,  6,  4],\n[15, 12,  9,  6]], dtype=int32)\n>>> jnp.einsum(x, (0,), y, (1,))  # implicit form via indices\nArray([[ 0,  0,  0,  0],\n[ 5,  4,  3,  2],\n[10,  8,  6,  4],\n[15, 12,  9,  6]], dtype=int32)\n**1D array sum**\n>>> jnp.einsum(\"i->\", x)  # requires explicit form\nArray(6, dtype=int32)\n>>> jnp.einsum(x, (0,), ())  # explicit form via indices\nArray(6, dtype=int32)\n>>> jnp.sum(x)\nArray(6, dtype=int32)\n**Sum along an axis**\n>>> jnp.einsum(\"...j->...\", M)  # requires explicit form\nArray([ 6, 22, 38, 54], dtype=int32)\n>>> jnp.einsum(M, (..., 0), (...,))  # explicit form via indices\nArray([ 6, 22, 38, 54], dtype=int32)\n>>> M.sum(-1)\nArray([ 6, 22, 38, 54], dtype=int32)\n**Matrix transpose**\n>>> y = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> jnp.einsum(\"ij->ji\", y)  # explicit form\nArray([[1, 4],\n[2, 5],\n[3, 6]], dtype=int32)\n>>> jnp.einsum(\"ji\", y)  # implicit form\nArray([[1, 4],\n[2, 5],\n[3, 6]], dtype=int32)\n>>> jnp.einsum(y, (1, 0))  # implicit form via indices\nArray([[1, 4],\n[2, 5],\n[3, 6]], dtype=int32)\n>>> jnp.einsum(y, (0, 1), (1, 0))  # explicit form via indices\nArray([[1, 4],\n[2, 5],\n[3, 6]], dtype=int32)\n>>> jnp.transpose(y)\nArray([[1, 4],\n[2, 5],\n[3, 6]], dtype=int32)\n**Matrix diagonal**\n>>> jnp.einsum(\"ii->i\", M)\nArray([ 0,  5, 10, 15], dtype=int32)\n>>> jnp.diagonal(M)\nArray([ 0,  5, 10, 15], dtype=int32)\n**Matrix trace**\n>>> jnp.einsum(\"ii\", M)\nArray(30, dtype=int32)\n>>> jnp.trace(M)\nArray(30, dtype=int32)\n**Tensor products**\n>>> x = jnp.arange(30).reshape(2, 3, 5)\n>>> y = jnp.arange(60).reshape(3, 4, 5)\n>>> jnp.einsum('ijk,jlk->il', x, y)  # explicit form\nArray([[ 3340,  3865,  4390,  4915],\n[ 8290,  9940, 11590, 13240]], dtype=int32)\n>>> jnp.tensordot(x, y, axes=[(1, 2), (0, 2)])\nArray([[ 3340,  3865,  4390,  4915],\n[ 8290,  9940, 11590, 13240]], dtype=int32)\n>>> jnp.einsum('ijk,jlk', x, y)  # implicit form\nArray([[ 3340,  3865,  4390,  4915],\n[ 8290,  9940, 11590, 13240]], dtype=int32)\n>>> jnp.einsum(x, (0, 1, 2), y, (1, 3, 2), (0, 3))  # explicit form via indices\nArray([[ 3340,  3865,  4390,  4915],\n[ 8290,  9940, 11590, 13240]], dtype=int32)\n>>> jnp.einsum(x, (0, 1, 2), y, (1, 3, 2))  # implicit form via indices\nArray([[ 3340,  3865,  4390,  4915],\n[ 8290,  9940, 11590, 13240]], dtype=int32)\n**Chained dot products**\n>>> w = jnp.arange(5, 9).reshape(2, 2)\n>>> x = jnp.arange(6).reshape(2, 3)\n>>> y = jnp.arange(-2, 4).reshape(3, 2)\n>>> z = jnp.array([[2, 4, 6], [3, 5, 7]])\n>>> jnp.einsum('ij,jk,kl,lm->im', w, x, y, z)\nArray([[ 481,  831, 1181],\n[ 651, 1125, 1599]], dtype=int32)\n>>> jnp.einsum(w, (0, 1), x, (1, 2), y, (2, 3), z, (3, 4))  # implicit, via indices\nArray([[ 481,  831, 1181],\n[ 651, 1125, 1599]], dtype=int32)\n>>> w @ x @ y @ z  # direct chain of matmuls\nArray([[ 481,  831, 1181],\n[ 651, 1125, 1599]], dtype=int32)\n>>> jnp.linalg.multi_dot([w, x, y, z])\nArray([[ 481,  831, 1181],\n[ 651, 1125, 1599]], dtype=int32)\n.. _opt_einsum: https://github.com/dgasmith/opt_einsum"
      }
    },
    {
      "name": "einsum_path",
      "signature": "einsum_path(subscripts, /, *operands, optimize: bool | str | list[tuple[int, ...]] = 'auto') -> tuple[list[tuple[int, ...]], typing.Any]",
      "documentation": {
        "description": "Evaluates the optimal contraction path without evaluating the einsum.\nJAX implementation of :func:`numpy.einsum_path`. This function calls into\nthe opt_einsum_ package, and makes use of its optimization routines.\nArgs:\nsubscripts: string containing axes names separated by commas.\n*operands: sequence of one or more arrays corresponding to the subscripts.\noptimize: specify how to optimize the order of computation. In JAX this defaults\nto ``\"auto\"``. Other options are ``True`` (same as ``\"optimize\"``), ``False``\n(unoptimized), or any string supported by ``opt_einsum``, which\nincludes ``\"optimize\"``,, ``\"greedy\"``, ``\"eager\"``, and others.",
        "parameters": {},
        "returns": "A tuple containing the path that may be passed to :func:`~jax.numpy.einsum`, and a\nprintable object representing this optimal path.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> key1, key2, key3 = jax.random.split(jax.random.key(0), 3)\n>>> x = jax.random.randint(key1, minval=-5, maxval=5, shape=(2, 3))\n>>> y = jax.random.randint(key2, minval=-5, maxval=5, shape=(3, 100))\n>>> z = jax.random.randint(key3, minval=-5, maxval=5, shape=(100, 5))\n>>> path, path_info = jnp.einsum_path(\"ij,jk,kl\", x, y, z, optimize=\"optimal\")\n>>> print(path)\n[(1, 2), (0, 1)]\n>>> print(path_info)\nComplete contraction:  ij,jk,kl->il\nNaive scaling:  4\nOptimized scaling:  3\nNaive FLOP count:  9.000e+3\nOptimized FLOP count:  3.060e+3\nTheoretical speedup:  2.941e+0\nLargest intermediate:  1.500e+1 elements\n--------------------------------------------------------------------------------\nscaling        BLAS                current                             remaining\n--------------------------------------------------------------------------------\n3           GEMM              kl,jk->lj                             ij,lj->il\n3           GEMM              lj,ij->il                                il->il\nUse the computed path in :func:`~jax.numpy.einsum`:\n>>> jnp.einsum(\"ij,jk,kl\", x, y, z, optimize=path)\nArray([[-754,  324, -142,   82,   50],\n[ 408,  -50,   87,  -29,    7]], dtype=int32)\n.. _opt_einsum: https://github.com/dgasmith/opt_einsum"
      }
    },
    {
      "name": "empty",
      "signature": "empty(shape: Any, dtype: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None, *, device: jaxlib.xla_extension.Device | jaxlib.xla_extension.Sharding | None = None) -> jax.Array",
      "documentation": {
        "description": "Create an empty array.\nJAX implementation of :func:`numpy.empty`. Because XLA cannot create an\nun-initialized array, :func:`jax.numpy.empty` will always return an array\nfull of zeros.\nArgs:\nshape: int or sequence of ints specifying the shape of the created array.\ndtype: optional dtype for the created array; defaults to floating point.\ndevice: (optional) :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.",
        "parameters": {},
        "returns": "Array of the specified shape and dtype, on the specified device if specified.\nSee also:\n- :func:`jax.numpy.empty_like`\n- :func:`jax.numpy.zeros`\n- :func:`jax.numpy.ones`\n- :func:`jax.numpy.full`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.empty(4)\nArray([0., 0., 0., 0.], dtype=float32)\n>>> jnp.empty((2, 3), dtype=bool)\nArray([[False, False, False],\n[False, False, False]], dtype=bool)"
      }
    },
    {
      "name": "empty_like",
      "signature": "empty_like(prototype: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, jax._src.typing.DuckTypedArray], dtype: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None, shape: Any = None, *, device: jaxlib.xla_extension.Device | jaxlib.xla_extension.Sharding | None = None) -> jax.Array",
      "documentation": {
        "description": "Create an empty array with the same shape and dtype as an array.\nJAX implementation of :func:`numpy.empty_like`. Because XLA cannot create\nan un-initialized array, :func:`jax.numpy.empty` will always return an\narray full of zeros.\nArgs:\na: Array-like object with ``shape`` and ``dtype`` attributes.\nshape: optionally override the shape of the created array.\ndtype: optionally override the dtype of the created array.\ndevice: (optional) :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.",
        "parameters": {},
        "returns": "Array of the specified shape and dtype, on the specified device if specified.\nSee also:\n- :func:`jax.numpy.empty`\n- :func:`jax.numpy.zeros_like`\n- :func:`jax.numpy.ones_like`\n- :func:`jax.numpy.full_like`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.arange(4)\n>>> jnp.empty_like(x)\nArray([0, 0, 0, 0], dtype=int32)\n>>> jnp.empty_like(x, dtype=bool)\nArray([False, False, False, False], dtype=bool)\n>>> jnp.empty_like(x, shape=(2, 3))\nArray([[0, 0, 0],\n[0, 0, 0]], dtype=int32)"
      }
    },
    {
      "name": "equal",
      "signature": "equal(x: 'ArrayLike', y: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :obj:`numpy.equal`. This function provides the implementation\nof the ``==`` operator for JAX arrays.\nArgs:\nx: input array or scalar.\ny: input array or scalar. ``x`` and ``y`` should either have same shape or be\nbroadcast compatible.\nA boolean array containing ``True`` where the elements of ``x == y`` and\n``False`` otherwise.\nSee also:\n- :func:`jax.numpy.not_equal`: Returns element-wise truth value of ``x != y``.\n- :func:`jax.numpy.greater_equal`: Returns element-wise truth value of\n``x >= y``.\n- :func:`jax.numpy.less_equal`: Returns element-wise truth value of ``x <= y``.\n- :func:`jax.numpy.greater`: Returns element-wise truth value of ``x > y``.\n- :func:`jax.numpy.less`: Returns element-wise truth value of ``x < y``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.equal(0., -0.)\nArray(True, dtype=bool, weak_type=True)\n>>> jnp.equal(1, 1.)\nArray(True, dtype=bool, weak_type=True)\n>>> jnp.equal(5, jnp.array(5))\nArray(True, dtype=bool, weak_type=True)\n>>> jnp.equal(2, -2)\nArray(False, dtype=bool, weak_type=True)\n>>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6],\n...                [7, 8, 9]])\n>>> y = jnp.array([1, 5, 9])\n>>> jnp.equal(x, y)\nArray([[ True, False, False],\n[False,  True, False],\n[False, False,  True]], dtype=bool)\n>>> x == y\nArray([[ True, False, False],\n[False,  True, False],\n[False, False,  True]], dtype=bool)"
      }
    },
    {
      "name": "exp",
      "signature": "exp(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise exponential of the input.\nJAX implementation of :obj:`numpy.exp`.\nArgs:\nx: input array or scalar",
        "parameters": {},
        "returns": "An array containing the exponential of each element in ``x``, promotes to\ninexact dtype.\nSee also:\n- :func:`jax.numpy.log`: Calculates element-wise logarithm of the input.\n- :func:`jax.numpy.expm1`: Calculates :math:`e^x-1` of each element of the\ninput.\n- :func:`jax.numpy.exp2`: Calculates base-2 exponential of each element of\nthe input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "``jnp.exp`` follows the properties of exponential such as :math:`e^{(a+b)}\n= e^a * e^b`.\n>>> x1 = jnp.array([2, 4, 3, 1])\n>>> x2 = jnp.array([1, 3, 2, 3])\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.exp(x1+x2))\n[  20.09 1096.63  148.41   54.6 ]\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.exp(x1)*jnp.exp(x2))\n[  20.09 1096.63  148.41   54.6 ]\nThis property holds for complex input also:\n>>> jnp.allclose(jnp.exp(3-4j), jnp.exp(3)*jnp.exp(-4j))\nArray(True, dtype=bool)"
      }
    },
    {
      "name": "exp2",
      "signature": "exp2(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise base-2 exponential of input.\nJAX implementation of :obj:`numpy.exp2`.\nArgs:\nx: input array or scalar",
        "parameters": {},
        "returns": "An array containing the base-2 exponential of each element in ``x``, promotes\nto inexact dtype.\nSee also:\n- :func:`jax.numpy.log2`: Calculates base-2 logarithm of each element of input.\n- :func:`jax.numpy.exp`: Calculates exponential of each element of the input.\n- :func:`jax.numpy.expm1`: Calculates :math:`e^x-1` of each element of the\ninput.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "``jnp.exp2`` follows the properties of the exponential such as :math:`2^{a+b}\n= 2^a * 2^b`.\n>>> x1 = jnp.array([2, -4, 3, -1])\n>>> x2 = jnp.array([-1, 3, -2, 3])\n>>> jnp.exp2(x1+x2)\nArray([2. , 0.5, 2. , 4. ], dtype=float32)\n>>> jnp.exp2(x1)*jnp.exp2(x2)\nArray([2. , 0.5, 2. , 4. ], dtype=float32)"
      }
    },
    {
      "name": "expand_dims",
      "signature": "expand_dims(a: 'ArrayLike', axis: 'int | Sequence[int]') -> 'Array'",
      "documentation": {
        "description": "Insert dimensions of length 1 into array\nJAX implementation of :func:`numpy.expand_dims`, implemented via\n:func:`jax.lax.expand_dims`.\nArgs:\na: input array\naxis: integer or sequence of integers specifying positions of axes to add.",
        "parameters": {},
        "returns": "Copy of ``a`` with added dimensions.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.squeeze`: inverse of this operation, i.e. remove length-1 dimensions.\n- :func:`jax.lax.expand_dims`: XLA version of this functionality.",
        "notes": "Unlike :func:`numpy.expand_dims`, :func:`jax.numpy.expand_dims` will return a copy\nrather than a view of the input array. However, under JIT, the compiler will optimize\naway such copies when possible, so this doesn't have performance impacts in practice.",
        "examples": ">>> x = jnp.array([1, 2, 3])\n>>> x.shape\n(3,)\nExpand the leading dimension:\n>>> jnp.expand_dims(x, 0)\nArray([[1, 2, 3]], dtype=int32)\n>>> _.shape\n(1, 3)\nExpand the trailing dimension:\n>>> jnp.expand_dims(x, 1)\nArray([[1],\n[2],\n[3]], dtype=int32)\n>>> _.shape\n(3, 1)\nExpand multiple dimensions:\n>>> jnp.expand_dims(x, (0, 1, 3))\nArray([[[[1],\n[2],\n[3]]]], dtype=int32)\n>>> _.shape\n(1, 1, 3, 1)\nDimensions can also be expanded more succinctly by indexing with ``None``:\n>>> x[None]  # equivalent to jnp.expand_dims(x, 0)\nArray([[1, 2, 3]], dtype=int32)\n>>> x[:, None]  # equivalent to jnp.expand_dims(x, 1)\nArray([[1],\n[2],\n[3]], dtype=int32)\n>>> x[None, None, :, None]  # equivalent to jnp.expand_dims(x, (0, 1, 3))\nArray([[[[1],\n[2],\n[3]]]], dtype=int32)"
      }
    },
    {
      "name": "expm1",
      "signature": "expm1(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate ``exp(x)-1`` of each element of the input.\nJAX implementation of :obj:`numpy.expm1`.\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array containing ``exp(x)-1`` of each element in ``x``, promotes to inexact\ndtype.\nNote:\n``jnp.expm1`` has much higher precision than the naive computation of\n``exp(x)-1`` for small values of ``x``.\nSee also:\n- :func:`jax.numpy.log1p`: Calculates element-wise logarithm of one plus input.\n- :func:`jax.numpy.exp`: Calculates element-wise exponential of the input.\n- :func:`jax.numpy.exp2`: Calculates base-2 exponential of each element of\nthe input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([2, -4, 3, -1])\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.expm1(x))\n[ 6.39 -0.98 19.09 -0.63]\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.exp(x)-1)\n[ 6.39 -0.98 19.09 -0.63]\nFor values very close to 0, ``jnp.expm1(x)`` is much more accurate than\n``jnp.exp(x)-1``:\n>>> x1 = jnp.array([1e-4, 1e-6, 2e-10])\n>>> jnp.expm1(x1)\nArray([1.0000500e-04, 1.0000005e-06, 2.0000000e-10], dtype=float32)\n>>> jnp.exp(x1)-1\nArray([1.00016594e-04, 9.53674316e-07, 0.00000000e+00], dtype=float32)"
      }
    },
    {
      "name": "extract",
      "signature": "extract(condition: 'ArrayLike', arr: 'ArrayLike', *, size: 'int | None' = None, fill_value: 'ArrayLike' = 0) -> 'Array'",
      "documentation": {
        "description": "Return the elements of an array that satisfy a condition.\nJAX implementation of :func:`numpy.extract`.\nArgs:\ncondition: array of conditions. Will be converted to boolean and flattened to 1D.\narr: array of values to extract. Will be flattened to 1D.\nsize: optional static size for output. Must be specified in order for ``extract``\nto be compatible with JAX transformations like :func:`~jax.jit` or :func:`~jax.vmap`.\nfill_value: if ``size`` is specified, fill padded entries with this value (default: 0).",
        "parameters": {},
        "returns": "1D array of extracted entries . If ``size`` is specified, the result will have shape\n``(size,)`` and be right-padded with ``fill_value``. If ``size`` is not specified,\nthe output shape will depend on the number of True entries in ``condition``.",
        "raises": "",
        "see_also": "",
        "notes": "This function does not require strict shape agreement between ``condition`` and ``arr``.\nIf ``condition.size > arr.size``, then ``condition`` will be truncated, and if\n``arr.size > condition.size``, then ``arr`` will be truncated.\nSee also:\n:func:`jax.numpy.compress`: multi-dimensional version of ``extract``.",
        "examples": "Extract values from a 1D array:\n>>> x = jnp.array([1, 2, 3, 4, 5, 6])\n>>> mask = (x % 2 == 0)\n>>> jnp.extract(mask, x)\nArray([2, 4, 6], dtype=int32)\nIn the simplest case, this is equivalent to boolean indexing:\n>>> x[mask]\nArray([2, 4, 6], dtype=int32)\nFor use with JAX transformations, you can pass the ``size`` argument to\nspecify a static shape for the output, along with an optional ``fill_value``\nthat defaults to zero:\n>>> jnp.extract(mask, x, size=len(x), fill_value=0)\nArray([2, 4, 6, 0, 0, 0], dtype=int32)\nNotice that unlike with boolean indexing, ``extract`` does not require strict\nagreement between the sizes of the array and condition, and will effectively\ntruncate both to the minimum size:\n>>> short_mask = jnp.array([False, True])\n>>> jnp.extract(short_mask, x)\nArray([2], dtype=int32)\n>>> long_mask = jnp.array([True, False, True, False, False, False, False, False])\n>>> jnp.extract(long_mask, x)\nArray([1, 3], dtype=int32)"
      }
    },
    {
      "name": "eye",
      "signature": "eye(N: 'DimSize', M: 'DimSize | None' = None, k: 'int | ArrayLike' = 0, dtype: 'DTypeLike | None' = None, *, device: 'xc.Device | Sharding | None' = None) -> 'Array'",
      "documentation": {
        "description": "Create a square or rectangular identity matrix\nJAX implementation of :func:`numpy.eye`.\nArgs:\nN: integer specifying the first dimension of the array.\nM: optional integer specifying the second dimension of the array;\ndefaults to the same value as ``N``.\nk: optional integer specifying the offset of the diagonal. Use positive\nvalues for upper diagonals, and negative values for lower diagonals.\nDefault is zero.\ndtype: optional dtype; defaults to floating point.\ndevice: optional :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.",
        "parameters": {},
        "returns": "Identity array of shape ``(N, M)``, or ``(N, N)`` if ``M`` is not specified.\nSee also:\n:func:`jax.numpy.identity`: Simpler API for generating square identity matrices.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "A simple 3x3 identity matrix:\n>>> jnp.eye(3)\nArray([[1., 0., 0.],\n[0., 1., 0.],\n[0., 0., 1.]], dtype=float32)\nInteger identity matrices with offset diagonals:\n>>> jnp.eye(3, k=1, dtype=int)\nArray([[0, 1, 0],\n[0, 0, 1],\n[0, 0, 0]], dtype=int32)\n>>> jnp.eye(3, k=-1, dtype=int)\nArray([[0, 0, 0],\n[1, 0, 0],\n[0, 1, 0]], dtype=int32)\nNon-square identity matrix:\n>>> jnp.eye(3, 5, k=1)\nArray([[0., 1., 0., 0., 0.],\n[0., 0., 1., 0., 0.],\n[0., 0., 0., 1., 0.]], dtype=float32)"
      }
    },
    {
      "name": "fabs",
      "signature": "fabs(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Compute the element-wise absolute values of the real-valued input.\nJAX implementation of :obj:`numpy.fabs`.\nArgs:\nx: input array or scalar. Must not have a complex dtype.",
        "parameters": {},
        "returns": "An array with same shape as ``x`` and dtype float, containing the element-wise\nabsolute values.\nSee also:\n- :func:`jax.numpy.absolute`: Computes the absolute values of the input including\ncomplex dtypes.\n- :func:`jax.numpy.abs`: Computes the absolute values of the input including\ncomplex dtypes.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "For integer inputs:\n>>> x = jnp.array([-5, -9, 1, 10, 15])\n>>> jnp.fabs(x)\nArray([ 5.,  9.,  1., 10., 15.], dtype=float32)\nFor float type inputs:\n>>> x1 = jnp.array([-1.342, 5.649, 3.927])\n>>> jnp.fabs(x1)\nArray([1.342, 5.649, 3.927], dtype=float32)\nFor boolean inputs:\n>>> x2 = jnp.array([True, False])\n>>> jnp.fabs(x2)\nArray([1., 0.], dtype=float32)"
      }
    },
    {
      "name": "fill_diagonal",
      "signature": "fill_diagonal(a: 'ArrayLike', val: 'ArrayLike', wrap: 'bool' = False, *, inplace: 'bool' = True) -> 'Array'",
      "documentation": {
        "description": "Return a copy of the array with the diagonal overwritten.\nJAX implementation of :func:`numpy.fill_diagonal`.\nThe semantics of :func:`numpy.fill_diagonal` are to modify arrays in-place, which\nis not possible for JAX's immutable arrays. The JAX version returns a modified\ncopy of the input, and adds the ``inplace`` parameter which must be set to\n`False`` by the user as a reminder of this API difference.\nArgs:\na: input array. Must have ``a.ndim >= 2``. If ``a.ndim >= 3``, then all\ndimensions must be the same size.\nval: scalar or array with which to fill the diagonal. If an array, it will\nbe flattened and repeated to fill the diagonal entries.\ninplace: must be set to False to indicate that the input is not modified\nin-place, but rather a modified copy is returned.",
        "parameters": {},
        "returns": "A copy of ``a`` with the diagonal set to ``val``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.zeros((3, 3), dtype=int)\n>>> jnp.fill_diagonal(x, jnp.array([1, 2, 3]), inplace=False)\nArray([[1, 0, 0],\n[0, 2, 0],\n[0, 0, 3]], dtype=int32)\nUnlike :func:`numpy.fill_diagonal`, the input ``x`` is not modified.\nIf the diagonal value has too many entries, it will be truncated\n>>> jnp.fill_diagonal(x, jnp.arange(100, 200), inplace=False)\nArray([[100,   0,   0],\n[  0, 101,   0],\n[  0,   0, 102]], dtype=int32)\nIf the diagonal has too few entries, it will be repeated:\n>>> x = jnp.zeros((4, 4), dtype=int)\n>>> jnp.fill_diagonal(x, jnp.array([3, 4]), inplace=False)\nArray([[3, 0, 0, 0],\n[0, 4, 0, 0],\n[0, 0, 3, 0],\n[0, 0, 0, 4]], dtype=int32)\nFor non-square arrays, the diagonal of the leading square slice is filled:\n>>> x = jnp.zeros((3, 5), dtype=int)\n>>> jnp.fill_diagonal(x, 1, inplace=False)\nArray([[1, 0, 0, 0, 0],\n[0, 1, 0, 0, 0],\n[0, 0, 1, 0, 0]], dtype=int32)\nAnd for square N-dimensional arrays, the N-dimensional diagonal is filled:\n>>> y = jnp.zeros((2, 2, 2))\n>>> jnp.fill_diagonal(y, 1, inplace=False)\nArray([[[1., 0.],\n[0., 0.]],\n<BLANKLINE>\n[[0., 0.],\n[0., 1.]]], dtype=float32)"
      }
    },
    {
      "name": "fix",
      "signature": "fix(x: 'ArrayLike', out: 'None' = None) -> 'Array'",
      "documentation": {
        "description": "Round input to the nearest integer towards zero.\nJAX implementation of :func:`numpy.fix`.\nArgs:\nx: input array.\nout: unused by JAX.",
        "parameters": {},
        "returns": "An array with same shape and dtype as ``x`` containing the rounded values.\nSee also:\n- :func:`jax.numpy.trunc`: Rounds the input to nearest integer towards zero.\n- :func:`jax.numpy.ceil`: Rounds the input up to the nearest integer.\n- :func:`jax.numpy.floor`: Rounds the input down to the nearest integer.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> key = jax.random.key(0)\n>>> x = jax.random.uniform(key, (3, 3), minval=-5, maxval=5)\n>>> with jnp.printoptions(precision=2, suppress=True):\n...     print(x)\n[[ 4.48  4.79 -1.68]\n[-0.31  0.7  -3.34]\n[-1.9   1.89  2.47]]\n>>> jnp.fix(x)\nArray([[ 4.,  4., -1.],\n[-0.,  0., -3.],\n[-1.,  1.,  2.]], dtype=float32)"
      }
    },
    {
      "name": "flatnonzero",
      "signature": "flatnonzero(a: 'ArrayLike', *, size: 'int | None' = None, fill_value: 'None | ArrayLike | tuple[ArrayLike, ...]' = None) -> 'Array'",
      "documentation": {
        "description": "Return indices of nonzero elements in a flattened array\nJAX implementation of :func:`numpy.flatnonzero`.\n``jnp.flatnonzero(x)`` is equivalent to ``nonzero(ravel(a))[0]``. For a full\ndiscussion of the parameters to this function, refer to :func:`jax.numpy.nonzero`.\nArgs:\na: N-dimensional array.\nsize: optional static integer specifying the number of nonzero entries to\nreturn. See :func:`jax.numpy.nonzero` for more discussion of this parameter.\nfill_value: optional padding value when ``size`` is specified. Defaults to 0.\nSee :func:`jax.numpy.nonzero` for more discussion of this parameter.",
        "parameters": {},
        "returns": "Array containing the indices of each nonzero value in the flattened array.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.nonzero`\n- :func:`jax.numpy.where`",
        "notes": "",
        "examples": ">>> x = jnp.array([[0, 5, 0],\n...                [6, 0, 8]])\n>>> jnp.flatnonzero(x)\nArray([1, 3, 5], dtype=int32)\nThis is equivalent to calling :func:`~jax.numpy.nonzero` on the flattened\narray, and extracting the first entry in the resulting tuple:\n>>> jnp.nonzero(x.ravel())[0]\nArray([1, 3, 5], dtype=int32)\nThe returned indices can be used to extract nonzero entries from the\nflattened array:\n>>> indices = jnp.flatnonzero(x)\n>>> x.ravel()[indices]\nArray([5, 6, 8], dtype=int32)"
      }
    },
    {
      "name": "flip",
      "signature": "flip(m: 'ArrayLike', axis: 'int | Sequence[int] | None' = None) -> 'Array'",
      "documentation": {
        "description": "Reverse the order of elements of an array along the given axis.\nJAX implementation of :func:`numpy.flip`.\nArgs:\nm: Array.\naxis: integer or sequence of integers. Specifies along which axis or axes\nshould the array elements be reversed. Default is ``None``, which flips\nalong all axes.",
        "parameters": {},
        "returns": "An array with the elements in reverse order along ``axis``.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.fliplr`: reverse the order along axis 1 (left/right)\n- :func:`jax.numpy.flipud`: reverse the order along axis 0 (up/down)",
        "notes": "",
        "examples": ">>> x1 = jnp.array([[1, 2],\n...                 [3, 4]])\n>>> jnp.flip(x1)\nArray([[4, 3],\n[2, 1]], dtype=int32)\nIf ``axis`` is specified with an integer, then ``jax.numpy.flip`` reverses\nthe array along that particular axis only.\n>>> jnp.flip(x1, axis=1)\nArray([[2, 1],\n[4, 3]], dtype=int32)\n>>> x2 = jnp.arange(1, 9).reshape(2, 2, 2)\n>>> x2\nArray([[[1, 2],\n[3, 4]],\n<BLANKLINE>\n[[5, 6],\n[7, 8]]], dtype=int32)\n>>> jnp.flip(x2)\nArray([[[8, 7],\n[6, 5]],\n<BLANKLINE>\n[[4, 3],\n[2, 1]]], dtype=int32)\nWhen ``axis`` is specified with a sequence of integers, then\n``jax.numpy.flip`` reverses the array along the specified axes.\n>>> jnp.flip(x2, axis=[1, 2])\nArray([[[4, 3],\n[2, 1]],\n<BLANKLINE>\n[[8, 7],\n[6, 5]]], dtype=int32)"
      }
    },
    {
      "name": "fliplr",
      "signature": "fliplr(m: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "Reverse the order of elements of an array along axis 1.\nJAX implementation of :func:`numpy.fliplr`.\nArgs:\nm: Array with at least two dimensions.",
        "parameters": {},
        "returns": "An array with the elements in reverse order along axis 1.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.flip`: reverse the order along the given axis\n- :func:`jax.numpy.flipud`: reverse the order along axis 0",
        "notes": "",
        "examples": ">>> x = jnp.array([[1, 2],\n...                [3, 4]])\n>>> jnp.fliplr(x)\nArray([[2, 1],\n[4, 3]], dtype=int32)"
      }
    },
    {
      "name": "flipud",
      "signature": "flipud(m: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "Reverse the order of elements of an array along axis 0.\nJAX implementation of :func:`numpy.flipud`.\nArgs:\nm: Array with at least one dimension.",
        "parameters": {},
        "returns": "An array with the elements in reverse order along axis 0.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.flip`: reverse the order along the given axis\n- :func:`jax.numpy.fliplr`: reverse the order along axis 1",
        "notes": "",
        "examples": ">>> x = jnp.array([[1, 2],\n...                [3, 4]])\n>>> jnp.flipud(x)\nArray([[3, 4],\n[1, 2]], dtype=int32)"
      }
    },
    {
      "name": "float_power",
      "signature": "float_power(x: 'ArrayLike', y: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise base ``x`` exponential of ``y``.\nJAX implementation of :obj:`numpy.float_power`.\nArgs:\nx: scalar or array. Specifies the bases.\ny: scalar or array. Specifies the exponents. ``x`` and ``y`` should either\nhave same shape or be broadcast compatible.",
        "parameters": {},
        "returns": "An array containing the base ``x`` exponentials of ``y``, promoting to the\ninexact dtype.\nSee also:\n- :func:`jax.numpy.exp`: Calculates element-wise exponential of the input.\n- :func:`jax.numpy.exp2`: Calculates base-2 exponential of each element of\nthe input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Inputs with same shape:\n>>> x = jnp.array([3, 1, -5])\n>>> y = jnp.array([2, 4, -1])\n>>> jnp.float_power(x, y)\nArray([ 9. ,  1. , -0.2], dtype=float32)\nInputs with broacast compatibility:\n>>> x1 = jnp.array([[2, -4, 1],\n...                 [-1, 2, 3]])\n>>> y1 = jnp.array([-2, 1, 4])\n>>> jnp.float_power(x1, y1)\nArray([[ 0.25, -4.  ,  1.  ],\n[ 1.  ,  2.  , 81.  ]], dtype=float32)\n``jnp.float_power`` produces ``nan`` for negative values raised to a non-integer\nvalues.\n>>> jnp.float_power(-3, 1.7)\nArray(nan, dtype=float32, weak_type=True)"
      }
    },
    {
      "name": "floor",
      "signature": "floor(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Round input to the nearest integer downwards.\nJAX implementation of :obj:`numpy.floor`.\nArgs:\nx: input array or scalar. Must not have complex dtype.",
        "parameters": {},
        "returns": "An array with same shape and dtype as ``x`` containing the values rounded to\nthe nearest integer that is less than or equal to the value itself.\nSee also:\n- :func:`jax.numpy.fix`: Rounds the input to the nearest interger towards zero.\n- :func:`jax.numpy.trunc`: Rounds the input to the nearest interger towards\nzero.\n- :func:`jax.numpy.ceil`: Rounds the input up to the nearest integer.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> key = jax.random.key(42)\n>>> x = jax.random.uniform(key, (3, 3), minval=-5, maxval=5)\n>>> with jnp.printoptions(precision=2, suppress=True):\n...     print(x)\n[[-0.11  1.8   1.16]\n[ 0.61 -0.49  0.86]\n[-4.25  2.75  1.99]]\n>>> jnp.floor(x)\nArray([[-1.,  1.,  1.],\n[ 0., -1.,  0.],\n[-5.,  2.,  1.]], dtype=float32)"
      }
    },
    {
      "name": "floor_divide",
      "signature": "floor_divide(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculates the floor division of x1 by x2 element-wise\nJAX implementation of :obj:`numpy.floor_divide`.\nArgs:\nx1: Input array, the dividend\nx2: Input array, the divisor",
        "parameters": {},
        "returns": "An array-like object containing each of the quotients rounded down\nto the nearest integer towards negative infinity. This is equivalent\nto ``x1 // x2`` in Python.\nNote:\n``x1 // x2`` is equivalent to ``jnp.floor_divide(x1, x2)`` for arrays ``x1``\nand ``x2``",
        "raises": "",
        "see_also": ":func:`jax.numpy.divide` and :func:`jax.numpy.true_divide` for floating point\ndivision.",
        "notes": "",
        "examples": ">>> x1 = jnp.array([10, 20, 30])\n>>> x2 = jnp.array([3, 4, 7])\n>>> jnp.floor_divide(x1, x2)\nArray([3, 5, 4], dtype=int32)\n>>> x1 = jnp.array([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])\n>>> x2 = 3\n>>> jnp.floor_divide(x1, x2)\nArray([-2, -2, -1, -1, -1,  0,  0,  0,  1,  1,  1], dtype=int32)\n>>> x1 = jnp.array([6, 6, 6], dtype=jnp.int32)\n>>> x2 = jnp.array([2.0, 2.5, 3.0], dtype=jnp.float32)\n>>> jnp.floor_divide(x1, x2)\nArray([3., 2., 2.], dtype=float32)"
      }
    },
    {
      "name": "fmax",
      "signature": "fmax(x1: 'ArrayLike', x2: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "Return element-wise maximum of the input arrays.\nJAX implementation of :func:`numpy.fmax`.\nArgs:\nx1: input array or scalar\nx2: input array or scalar. x1 and x1 must either have same shape or be\nbroadcast compatible.",
        "parameters": {},
        "returns": "An array containing the element-wise maximum of x1 and x2.\nNote:\nFor each pair of elements, ``jnp.fmax`` returns:\n- the larger of the two if both elements are finite numbers.\n- finite number if one element is ``nan``.\n- ``nan`` if both elements are ``nan``.\n- ``inf`` if one element is ``inf`` and the other is finite or ``nan``.\n- ``-inf`` if one element is ``-inf`` and the other is ``nan``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.fmax(3, 7)\nArray(7, dtype=int32, weak_type=True)\n>>> jnp.fmax(5, jnp.array([1, 7, 9, 4]))\nArray([5, 7, 9, 5], dtype=int32)\n>>> x1 = jnp.array([1, 3, 7, 8])\n>>> x2 = jnp.array([-1, 4, 6, 9])\n>>> jnp.fmax(x1, x2)\nArray([1, 4, 7, 9], dtype=int32)\n>>> x3 = jnp.array([[2, 3, 5, 10],\n...                 [11, 9, 7, 5]])\n>>> jnp.fmax(x1, x3)\nArray([[ 2,  3,  7, 10],\n[11,  9,  7,  8]], dtype=int32)\n>>> x4 = jnp.array([jnp.inf, 6, -jnp.inf, nan])\n>>> x5 = jnp.array([[3, 5, 7, nan],\n...                 [nan, 9, nan, -1]])\n>>> jnp.fmax(x4, x5)\nArray([[ inf,   6.,   7.,  nan],\n[ inf,   9., -inf,  -1.]], dtype=float32)"
      }
    },
    {
      "name": "fmin",
      "signature": "fmin(x1: 'ArrayLike', x2: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "Return element-wise minimum of the input arrays.\nJAX implemtentation of :func:`numpy.fmin`.\nArgs:\nx1: input array or scalar.\nx2: input array or scalar. x1 and x2 must either have same shape or be\nbroadcast compatible.",
        "parameters": {},
        "returns": "An array containing the element-wise minimum of x1 and x2.\nNote:\nFor each pair of elements, ``jnp.fmin`` returns:\n- the smaller of the two if both elements are finite numbers.\n- finite number if one element is ``nan``.\n- ``-inf`` if one element is ``-inf`` and the other is finite or ``nan``.\n- ``inf`` if one element is ``inf`` and the other is ``nan``.\n- ``nan`` if both elements are ``nan``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.fmin(2, 3)\nArray(2, dtype=int32, weak_type=True)\n>>> jnp.fmin(2, jnp.array([1, 4, 2, -1]))\nArray([ 1,  2,  2, -1], dtype=int32)\n>>> x1 = jnp.array([1, 3, 2])\n>>> x2 = jnp.array([2, 1, 4])\n>>> jnp.fmin(x1, x2)\nArray([1, 1, 2], dtype=int32)\n>>> x3 = jnp.array([1, 5, 3])\n>>> x4 = jnp.array([[2, 3, 1],\n...                 [5, 6, 7]])\n>>> jnp.fmin(x3, x4)\nArray([[1, 3, 1],\n[1, 5, 3]], dtype=int32)\n>>> nan = jnp.nan\n>>> x5 = jnp.array([jnp.inf, 5, nan])\n>>> x6 = jnp.array([[2, 3, nan],\n...                 [nan, 6, 7]])\n>>> jnp.fmin(x5, x6)\nArray([[ 2.,  3., nan],\n[inf,  5.,  7.]], dtype=float32)"
      }
    },
    {
      "name": "fmod",
      "signature": "fmod(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise floating-point modulo operation.\nJAX implementation of :obj:`numpy.fmod`.\nArgs:\nx1: scalar or array. Specifies the dividend.\nx2: scalar or array. Specifies the divisor. ``x1`` and ``x2`` should either\nhave same shape or be broadcast compatible.",
        "parameters": {},
        "returns": "An array containing the result of the element-wise floating-point modulo\noperation of ``x1`` and ``x2`` with same sign as the elements of ``x1``.\nNote:\nThe result of ``jnp.fmod`` is equivalent to ``x1 - x2 * jnp.fix(x1 / x2)``.\nSee also:\n- :func:`jax.numpy.mod` and :func:`jax.numpy.remainder`: Returns the element-wise\nremainder of the division.\n- :func:`jax.numpy.divmod`: Calculates the integer quotient and remainder of\n``x1`` by ``x2``, element-wise.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([[3, -1, 4],\n...                 [8, 5, -2]])\n>>> x2 = jnp.array([2, 3, -5])\n>>> jnp.fmod(x1, x2)\nArray([[ 1, -1,  4],\n[ 0,  2, -2]], dtype=int32)\n>>> x1 - x2 * jnp.fix(x1 / x2)\nArray([[ 1., -1.,  4.],\n[ 0.,  2., -2.]], dtype=float32)"
      }
    },
    {
      "name": "frexp",
      "signature": "frexp(x: 'ArrayLike', /) -> 'tuple[Array, Array]'",
      "documentation": {
        "description": "Split floating point values into mantissa and twos exponent.\nJAX implementation of :func:`numpy.frexp`.\nArgs:\nx: real-valued array",
        "parameters": {},
        "returns": "A tuple ``(mantissa, exponent)`` where ``mantissa`` is a floating point\nvalue between -1 and 1, and ``exponent`` is an integer such that\n``x == mantissa * 2 ** exponent``.\nSee also:\n- :func:`jax.numpy.ldexp`: compute the inverse of ``frexp``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Split values into mantissa and exponent:\n>>> x = jnp.array([1., 2., 3., 4., 5.])\n>>> m, e = jnp.frexp(x)\n>>> m\nArray([0.5  , 0.5  , 0.75 , 0.5  , 0.625], dtype=float32)\n>>> e\nArray([1, 2, 2, 3, 3], dtype=int32)\nReconstruct the original array:\n>>> m * 2 ** e\nArray([1., 2., 3., 4., 5.], dtype=float32)"
      }
    },
    {
      "name": "from_dlpack",
      "signature": "from_dlpack(x: 'Any', /, *, device: 'xc.Device | Sharding | None' = None, copy: 'bool | None' = None) -> 'Array'",
      "documentation": {
        "description": "Construct a JAX array via DLPack.\nJAX implementation of :func:`numpy.from_dlpack`.\nArgs:\nx: An object that implements the DLPack_ protocol via the ``__dlpack__``\nand ``__dlpack_device__`` methods, or a legacy DLPack tensor on either\nCPU or GPU.\ndevice: An optional :class:`~jax.Device` or :class:`~jax.sharding.Sharding`,\nrepresenting the single device onto which the returned array should be placed.\nIf given, then the result is committed to the device. If unspecified,\nthe resulting array will be unpacked onto the same device it originated from.\nSetting ``device`` to a device different from the source of ``external_array``\nwill require a copy, meaning ``copy`` must be set to either ``True`` or ``None``.\ncopy: An optional boolean, controlling whether or not a copy is performed.\nIf ``copy=True`` then a copy is always performed, even if unpacked onto the\nsame device. If ``copy=False`` then the copy is never performed and will raise\nan error if necessary. When ``copy=None`` (default) then a copy may be performed\nif needed for a device transfer.",
        "parameters": {},
        "returns": "A JAX array of the imput buffer.\nNote:\nWhile JAX arrays are always immutable, dlpack buffers cannot be marked as\nimmutable, and it is possible for processes external to JAX to mutate them\nin-place. If a JAX Array is constructed from a dlpack buffer without copying\nand the source buffer is later modified in-place, it may lead to undefined\nbehavior when using the associated JAX array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Passing data between NumPy and JAX via DLPack_:\n>>> import numpy as np\n>>> rng = np.random.default_rng(42)\n>>> x_numpy = rng.random(4, dtype='float32')\n>>> print(x_numpy)\n[0.08925092 0.773956   0.6545715  0.43887842]\n>>> hasattr(x_numpy, \"__dlpack__\")  # NumPy supports the DLPack interface\nTrue\n>>> import jax.numpy as jnp\n>>> x_jax = jnp.from_dlpack(x_numpy)\n>>> print(x_jax)\n[0.08925092 0.773956   0.6545715  0.43887842]\n>>> hasattr(x_jax, \"__dlpack__\")  # JAX supports the DLPack interface\nTrue\n>>> x_numpy_round_trip = np.from_dlpack(x_jax)\n>>> print(x_numpy_round_trip)\n[0.08925092 0.773956   0.6545715  0.43887842]\n.. _DLPack: https://dmlc.github.io/dlpack"
      }
    },
    {
      "name": "frombuffer",
      "signature": "frombuffer(buffer: 'bytes | Any', dtype: 'DTypeLike' = <class 'float'>, count: 'int' = -1, offset: 'int' = 0) -> 'Array'",
      "documentation": {
        "description": "Convert a buffer into a 1-D JAX array.\nJAX implementation of :func:`numpy.frombuffer`.\nArgs:\nbuffer: an object containing the data. It must be either a bytes object with\na length that is an integer multiple of the dtype element size, or\nit must be an object exporting the `Python buffer interface`_.\ndtype: optional. Desired data type for the array. Default is ``float64``.\nThis specifies the dtype used to parse the buffer, but note that after parsing,\n64-bit values will be cast to 32-bit JAX arrays if the ``jax_enable_x64``\nflag is set to ``False``.\ncount: optional integer specifying the number of items to read from the buffer.\nIf -1 (default), all items from the buffer are read.\noffset: optional integer specifying the number of bytes to skip at the beginning\nof the buffer. Default is 0.",
        "parameters": {},
        "returns": "A 1-D JAX array representing the interpreted data from the buffer.\nSee also:\n- :func:`jax.numpy.fromstring`: convert a string of text into 1-D JAX array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Using a bytes buffer:\n>>> buf = b\"\\x00\\x01\\x02\\x03\\x04\"\n>>> jnp.frombuffer(buf, dtype=jnp.uint8)\nArray([0, 1, 2, 3, 4], dtype=uint8)\n>>> jnp.frombuffer(buf, dtype=jnp.uint8, offset=1)\nArray([1, 2, 3, 4], dtype=uint8)\nConstructing a JAX array via the Python buffer interface, using Python's\nbuilt-in :mod:`array` module.\n>>> from array import array\n>>> pybuffer = array('i', [0, 1, 2, 3, 4])\n>>> jnp.frombuffer(pybuffer, dtype=jnp.int32)\nArray([0, 1, 2, 3, 4], dtype=int32)\n.. _Python buffer interface: https://docs.python.org/3/c-api/buffer.html"
      }
    },
    {
      "name": "fromfile",
      "signature": "fromfile(*args, **kwargs)",
      "documentation": {
        "description": "Unimplemented JAX wrapper for jnp.fromfile.\nThis function is left deliberately unimplemented because it may be non-pure and thus\nunsafe for use with JIT and other JAX transformations. Consider using\n``jnp.asarray(np.fromfile(...))`` instead, although care should be taken if ``np.fromfile``\nis used within jax transformations because of its potential side-effect of consuming the\nfile object; for more information see `Common Gotchas: Pure Functions\n<https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions>`_.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fromfunction",
      "signature": "fromfunction(function: 'Callable[..., Array]', shape: 'Any', *, dtype: 'DTypeLike' = <class 'float'>, **kwargs) -> 'Array'",
      "documentation": {
        "description": "Create an array from a function applied over indices.\nJAX implementation of :func:`numpy.fromfunction`. The JAX implementation\ndiffers in that it dispatches via :func:`jax.vmap`, and so unlike in NumPy\nthe function logically operates on scalar inputs, and need not explicitly\nhandle broadcasted inputs (See *Examples* below).\nArgs:\nfunction: a function that takes *N* dynamic scalars and outputs a scalar.\nshape: a length-*N* tuple of integers specifying the output shape.\ndtype: optionally specify the dtype of the inputs. Defaults to floating-point.\nkwargs: additional keyword arguments are passed statically to ``function``.",
        "parameters": {},
        "returns": "An array of shape ``shape`` if ``function`` returns a scalar, or in general\na pytree of arrays with leading dimensions ``shape``, as determined by the\noutput of ``function``.\nSee also:\n- :func:`jax.vmap`: the core transformation that the :func:`fromfunction`\nAPI is built on.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Generate a multiplication table of a given shape:\n>>> jnp.fromfunction(jnp.multiply, shape=(3, 6), dtype=int)\nArray([[ 0,  0,  0,  0,  0,  0],\n[ 0,  1,  2,  3,  4,  5],\n[ 0,  2,  4,  6,  8, 10]], dtype=int32)\nWhen ``function`` returns a non-scalar the output will have leading\ndimension of ``shape``:\n>>> def f(x):\n...   return (x + 1) * jnp.arange(3)\n>>> jnp.fromfunction(f, shape=(2,))\nArray([[0., 1., 2.],\n[0., 2., 4.]], dtype=float32)\n``function`` may return multiple results, in which case each is mapped\nindependently:\n>>> def f(x, y):\n...   return x + y, x * y\n>>> x_plus_y, x_times_y = jnp.fromfunction(f, shape=(3, 5))\n>>> print(x_plus_y)\n[[0. 1. 2. 3. 4.]\n[1. 2. 3. 4. 5.]\n[2. 3. 4. 5. 6.]]\n>>> print(x_times_y)\n[[0. 0. 0. 0. 0.]\n[0. 1. 2. 3. 4.]\n[0. 2. 4. 6. 8.]]\nThe JAX implementation differs slightly from NumPy's implementation. In\n:func:`numpy.fromfunction`, the function is expected to explicitly operate\nelement-wise on the full grid of input values:\n>>> def f(x, y):\n...   print(f\"{x.shape = }\\n{y.shape = }\")\n...   return x + y\n...\n>>> np.fromfunction(f, (2, 3))\nx.shape = (2, 3)\ny.shape = (2, 3)\narray([[0., 1., 2.],\n[1., 2., 3.]])\nIn :func:`jax.numpy.fromfunction`, the function is vectorized via\n:func:`jax.vmap`, and so is expected to operate on scalar values:\n>>> jnp.fromfunction(f, (2, 3))\nx.shape = ()\ny.shape = ()\nArray([[0., 1., 2.],\n[1., 2., 3.]], dtype=float32)"
      }
    },
    {
      "name": "fromiter",
      "signature": "fromiter(*args, **kwargs)",
      "documentation": {
        "description": "Unimplemented JAX wrapper for jnp.fromiter.\nThis function is left deliberately unimplemented because it may be non-pure and thus\nunsafe for use with JIT and other JAX transformations. Consider using\n``jnp.asarray(np.fromiter(...))`` instead, although care should be taken if ``np.fromiter``\nis used within jax transformations because of its potential side-effect of consuming the\niterable object; for more information see `Common Gotchas: Pure Functions\n<https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions>`_.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "frompyfunc",
      "signature": "frompyfunc(func: 'Callable[..., Any]', /, nin: 'int', nout: 'int', *, identity: 'Any' = None) -> 'ufunc'",
      "documentation": {
        "description": "Create a JAX ufunc from an arbitrary JAX-compatible scalar function.\nArgs:\nfunc : a callable that takes `nin` scalar arguments and returns `nout` outputs.\nnin: integer specifying the number of scalar inputs\nnout: integer specifying the number of scalar outputs\nidentity: (optional) a scalar specifying the identity of the operation, if any.",
        "parameters": {},
        "returns": "wrapped : jax.numpy.ufunc wrapper of func.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Here is an example of creating a ufunc similar to :obj:`jax.numpy.add`:\n>>> import operator\n>>> add = frompyfunc(operator.add, nin=2, nout=1, identity=0)\nNow all the standard :class:`jax.numpy.ufunc` methods are available:\n>>> x = jnp.arange(4)\n>>> add(x, 10)\nArray([10, 11, 12, 13], dtype=int32)\n>>> add.outer(x, x)\nArray([[0, 1, 2, 3],\n[1, 2, 3, 4],\n[2, 3, 4, 5],\n[3, 4, 5, 6]], dtype=int32)\n>>> add.reduce(x)\nArray(6, dtype=int32)\n>>> add.accumulate(x)\nArray([0, 1, 3, 6], dtype=int32)\n>>> add.at(x, 1, 10, inplace=False)\nArray([ 0, 11,  2,  3], dtype=int32)"
      }
    },
    {
      "name": "fromstring",
      "signature": "fromstring(string: 'str', dtype: 'DTypeLike' = <class 'float'>, count: 'int' = -1, *, sep: 'str') -> 'Array'",
      "documentation": {
        "description": "Convert a string of text into 1-D JAX array.\nJAX implementation of :func:`numpy.fromstring`.\nArgs:\nstring: input string containing the data.\ndtype: optional. Desired data type for the array. Default is ``float``.\ncount: optional integer specifying the number of items to read from the string.\nIf -1 (default), all items are read.\nsep: the string used to separate values in the input string.",
        "parameters": {},
        "returns": "A 1-D JAX array containing the parsed data from the input string.\nSee also:\n- :func:`jax.numpy.frombuffer`: construct a JAX array from an object\nthat implements the buffer interface.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.fromstring(\"1 2 3\", dtype=int, sep=\" \")\nArray([1, 2, 3], dtype=int32)\n>>> jnp.fromstring(\"0.1, 0.2, 0.3\", dtype=float, count=2, sep=\",\")\nArray([0.1, 0.2], dtype=float32)"
      }
    },
    {
      "name": "full",
      "signature": "full(shape: Any, fill_value: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dtype: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None, *, device: jaxlib.xla_extension.Device | jaxlib.xla_extension.Sharding | None = None) -> jax.Array",
      "documentation": {
        "description": "Create an array full of a specified value.\nJAX implementation of :func:`numpy.full`.\nArgs:\nshape: int or sequence of ints specifying the shape of the created array.\nfill_value: scalar or array with which to fill the created array.\ndtype: optional dtype for the created array; defaults to the dtype of the\nfill value.\ndevice: (optional) :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.",
        "parameters": {},
        "returns": "Array of the specified shape and dtype, on the specified device if specified.\nSee also:\n- :func:`jax.numpy.full_like`\n- :func:`jax.numpy.empty`\n- :func:`jax.numpy.zeros`\n- :func:`jax.numpy.ones`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.full(4, 2, dtype=float)\nArray([2., 2., 2., 2.], dtype=float32)\n>>> jnp.full((2, 3), 0, dtype=bool)\nArray([[False, False, False],\n[False, False, False]], dtype=bool)\n`fill_value` may also be an array that is broadcast to the specified shape:\n>>> jnp.full((2, 3), fill_value=jnp.arange(3))\nArray([[0, 1, 2],\n[0, 1, 2]], dtype=int32)"
      }
    },
    {
      "name": "full_like",
      "signature": "full_like(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, jax._src.typing.DuckTypedArray], fill_value: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dtype: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None, shape: Any = None, *, device: jaxlib.xla_extension.Device | jaxlib.xla_extension.Sharding | None = None) -> jax.Array",
      "documentation": {
        "description": "Create an array full of a specified value with the same shape and dtype as an array.\nJAX implementation of :func:`numpy.full_like`.\nArgs:\na: Array-like object with ``shape`` and ``dtype`` attributes.\nfill_value: scalar or array with which to fill the created array.\nshape: optionally override the shape of the created array.\ndtype: optionally override the dtype of the created array.\ndevice: (optional) :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.",
        "parameters": {},
        "returns": "Array of the specified shape and dtype, on the specified device if specified.\nSee also:\n- :func:`jax.numpy.full`\n- :func:`jax.numpy.empty_like`\n- :func:`jax.numpy.zeros_like`\n- :func:`jax.numpy.ones_like`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.arange(4.0)\n>>> jnp.full_like(x, 2)\nArray([2., 2., 2., 2.], dtype=float32)\n>>> jnp.full_like(x, 0, shape=(2, 3))\nArray([[0., 0., 0.],\n[0., 0., 0.]], dtype=float32)\n`fill_value` may also be an array that is broadcast to the specified shape:\n>>> x = jnp.arange(6).reshape(2, 3)\n>>> jnp.full_like(x, fill_value=jnp.array([[1], [2]]))\nArray([[1, 1, 1],\n[2, 2, 2]], dtype=int32)"
      }
    },
    {
      "name": "gcd",
      "signature": "gcd(x1: 'ArrayLike', x2: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "Compute the greatest common divisor of two arrays.\nJAX implementation of :func:`numpy.gcd`.\nArgs:\nx1: First input array. The elements must have integer dtype.\nx2: Second input array. The elements must have integer dtype.",
        "parameters": {},
        "returns": "An array containing the greatest common divisors of the corresponding\nelements from the absolute values of `x1` and `x2`.\nSee also:\n- :func:`jax.numpy.lcm`: compute the least common multiple of two arrays.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar inputs:\n>>> jnp.gcd(12, 18)\nArray(6, dtype=int32, weak_type=True)\nArray inputs:\n>>> x1 = jnp.array([12, 18, 24])\n>>> x2 = jnp.array([5, 10, 15])\n>>> jnp.gcd(x1, x2)\nArray([1, 2, 3], dtype=int32)\nBroadcasting:\n>>> x1 = jnp.array([12])\n>>> x2 = jnp.array([6, 9, 12])\n>>> jnp.gcd(x1, x2)\nArray([ 6,  3, 12], dtype=int32)"
      }
    },
    {
      "name": "geomspace",
      "signature": "geomspace(start: 'ArrayLike', stop: 'ArrayLike', num: 'int' = 50, endpoint: 'bool' = True, dtype: 'DTypeLike | None' = None, axis: 'int' = 0) -> 'Array'",
      "documentation": {
        "description": "Generate geometrically-spaced values.\nJAX implementation of :func:`numpy.geomspace`.\nArgs:\nstart: scalar or array. Specifies the starting values.\nstop: scalar or array. Specifies the stop values.\nnum: int, optional, default=50. Number of values to generate.\nendpoint: bool, optional, default=True. If True, then include the ``stop`` value\nin the result. If False, then exclude the ``stop`` value.\ndtype: optional. Specifies the dtype of the output.\naxis: int, optional, default=0. Axis along which to generate the geomspace.",
        "parameters": {},
        "returns": "An array containing the geometrically-spaced values.\nSee also:\n- :func:`jax.numpy.arange`: Generate ``N`` evenly-spaced values given a starting\npoint and a step value.\n- :func:`jax.numpy.linspace`: Generate evenly-spaced values.\n- :func:`jax.numpy.logspace`: Generate logarithmically-spaced values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "List 5 geometrically-spaced values between 1 and 16:\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.geomspace(1, 16, 5)\nArray([ 1.,  2.,  4.,  8., 16.], dtype=float32)\nList 4 geomtrically-spaced values between 1 and 16, with ``endpoint=False``:\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.geomspace(1, 16, 4, endpoint=False)\nArray([1., 2., 4., 8.], dtype=float32)\nMulti-dimensional geomspace:\n>>> start = jnp.array([1, 1000])\n>>> stop = jnp.array([27, 1])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.geomspace(start, stop, 4)\nArray([[   1., 1000.],\n[   3.,  100.],\n[   9.,   10.],\n[  27.,    1.]], dtype=float32)"
      }
    },
    {
      "name": "get_printoptions",
      "signature": "get_printoptions()",
      "documentation": {
        "description": "Alias of :func:`numpy.get_printoptions`.\nJAX arrays are printed via NumPy, so NumPy's `printoptions`\nconfigurations will apply to printed JAX arrays.\nSee the :func:`numpy.set_printoptions` documentation for details\non the available options and their meanings.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "gradient",
      "signature": "gradient(f: 'ArrayLike', *varargs: 'ArrayLike', axis: 'int | Sequence[int] | None' = None, edge_order: 'int | None' = None) -> 'Array | list[Array]'",
      "documentation": {
        "description": "Compute the numerical gradient of a sampled function.\nJAX implementation of :func:`numpy.gradient`.\nThe gradient in ``jnp.gradient`` is computed using second-order finite\ndifferences across the array of sampled function values. This should not\nbe confused with :func:`jax.grad`, which computes a precise gradient of\na callable function via :ref:`automatic differentiation <automatic-differentiation>`.\nArgs:\nf: *N*-dimensional array of function values.\nvarargs: optional list of scalars or arrays specifying spacing of\nfunction evaluations. Options are:\n- not specified: unit spacing in all dimensions.\n- a single scalar: constant spacing in all dimensions.\n- *N* values: specify different spacing in each dimension:\n- scalar values indicate constant spacing in that dimension.\n- array values must match the length of the corresponding dimension,\nand specify the coordinates at which ``f`` is evaluated.\nedge_order: not implemented in JAX\naxis: integer or tuple of integers specifying the axis along which\nto compute the gradient. If None (default) calculates the gradient\nalong all axes.",
        "parameters": {},
        "returns": "an array or tuple of arrays containing the numerical gradient along\neach specified axis.\nSee also:\n- :func:`jax.grad`: automatic differentiation of a function with a single output.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Comparing numerical and automatic differentiation of a simple function:\n>>> def f(x):\n...   return jnp.sin(x) * jnp.exp(-x / 4)\n...\n>>> def gradf_exact(x):\n...   # exact analytical gradient of f(x)\n...   return -f(x) / 4 + jnp.cos(x) * jnp.exp(-x / 4)\n...\n>>> x = jnp.linspace(0, 5, 10)\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(\"numerical gradient:\", jnp.gradient(f(x), x))\n...   print(\"automatic gradient:\", jax.vmap(jax.grad(f))(x))\n...   print(\"exact gradient:    \", gradf_exact(x))\n...\nnumerical gradient: [ 0.83  0.61  0.18 -0.2  -0.43 -0.49 -0.39 -0.21 -0.02  0.08]\nautomatic gradient: [ 1.    0.62  0.17 -0.23 -0.46 -0.51 -0.41 -0.21 -0.01  0.15]\nexact gradient:     [ 1.    0.62  0.17 -0.23 -0.46 -0.51 -0.41 -0.21 -0.01  0.15]\nNotice that, as expected, the numerical gradient has some approximation error\ncompared to the automatic gradient computed via :func:`jax.grad`."
      }
    },
    {
      "name": "greater",
      "signature": "greater(x: 'ArrayLike', y: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return element-wise truth value of ``x > y``.\nJAX implementation of :obj:`numpy.greater`.\nArgs:\nx: input array or scalar.\ny: input array or scalar. ``x`` and ``y`` must either have same shape or be\nbroadcast compatible.",
        "parameters": {},
        "returns": "An array containing boolean values. ``True`` if the elements of ``x > y``,\nand ``False`` otherwise.\nSee also:\n- :func:`jax.numpy.less`: Returns element-wise truth value of ``x < y``.\n- :func:`jax.numpy.greater_equal`: Returns element-wise truth value of\n``x >= y``.\n- :func:`jax.numpy.less_equal`: Returns element-wise truth value of ``x <= y``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar inputs:\n>>> jnp.greater(5, 2)\nArray(True, dtype=bool, weak_type=True)\nInputs with same shape:\n>>> x = jnp.array([5, 9, -2])\n>>> y = jnp.array([4, -1, 6])\n>>> jnp.greater(x, y)\nArray([ True,  True, False], dtype=bool)\nInputs with broadcast compatibility:\n>>> x1 = jnp.array([[5, -6, 7],\n...                 [-2, 5, 9]])\n>>> y1 = jnp.array([-4, 3, 10])\n>>> jnp.greater(x1, y1)\nArray([[ True, False, False],\n[ True,  True, False]], dtype=bool)"
      }
    },
    {
      "name": "greater_equal",
      "signature": "greater_equal(x: 'ArrayLike', y: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return element-wise truth value of ``x >= y``.\nJAX implementation of :obj:`numpy.greater_equal`.\nArgs:\nx: input array or scalar.\ny: input array or scalar. ``x`` and ``y`` must either have same shape or be\nbroadcast compatible.",
        "parameters": {},
        "returns": "An array containing boolean values. ``True`` if the elements of ``x >= y``,\nand ``False`` otherwise.\nSee also:\n- :func:`jax.numpy.less_equal`: Returns element-wise truth value of ``x <= y``.\n- :func:`jax.numpy.greater`: Returns element-wise truth value of ``x > y``.\n- :func:`jax.numpy.less`: Returns element-wise truth value of ``x < y``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar inputs:\n>>> jnp.greater_equal(4, 7)\nArray(False, dtype=bool, weak_type=True)\nInputs with same shape:\n>>> x = jnp.array([2, 5, -1])\n>>> y = jnp.array([-6, 4, 3])\n>>> jnp.greater_equal(x, y)\nArray([ True,  True, False], dtype=bool)\nInputs with broadcast compatibility:\n>>> x1 = jnp.array([[3, -1, 4],\n...                 [5, 9, -6]])\n>>> y1 = jnp.array([-1, 4, 2])\n>>> jnp.greater_equal(x1, y1)\nArray([[ True, False,  True],\n[ True,  True, False]], dtype=bool)"
      }
    },
    {
      "name": "hamming",
      "signature": "hamming(M: int) -> jax.Array",
      "documentation": {
        "description": "Return a Hamming window of size M.\nJAX implementation of :func:`numpy.hamming`.\nArgs:\nM: The window size.",
        "parameters": {},
        "returns": "An array of size M containing the Hamming window.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.hamming(4))\n[0.08 0.77 0.77 0.08]\nSee also:\n- :func:`jax.numpy.bartlett`: return a Bartlett window of size M.\n- :func:`jax.numpy.blackman`: return a Blackman window of size M.\n- :func:`jax.numpy.hanning`: return a Hanning window of size M.\n- :func:`jax.numpy.kaiser`: return a Kaiser window of size M."
      }
    },
    {
      "name": "hanning",
      "signature": "hanning(M: int) -> jax.Array",
      "documentation": {
        "description": "Return a Hanning window of size M.\nJAX implementation of :func:`numpy.hanning`.\nArgs:\nM: The window size.",
        "parameters": {},
        "returns": "An array of size M containing the Hanning window.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.hanning(4))\n[0.   0.75 0.75 0.  ]\nSee also:\n- :func:`jax.numpy.bartlett`: return a Bartlett window of size M.\n- :func:`jax.numpy.blackman`: return a Blackman window of size M.\n- :func:`jax.numpy.hamming`: return a Hamming window of size M.\n- :func:`jax.numpy.kaiser`: return a Kaiser window of size M."
      }
    },
    {
      "name": "heaviside",
      "signature": "heaviside(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Compute the heaviside step function.\nJAX implementation of :obj:`numpy.heaviside`.\nThe heaviside step function is defined by:\n.. math::\n\\mathrm{heaviside}(x1, x2) = \\begin{cases}\n0., & x < 0\\\\\nx2, & x = 0\\\\\n1., & x > 0.\n\\end{cases}\nArgs:\nx1: input array or scalar. ``complex`` dtype are not supported.\nx2: scalar or array. Specifies the return values when ``x1`` is ``0``. ``complex``\ndtype are not supported. ``x1`` and ``x2`` must either have same shape or\nbroadcast compatible.",
        "parameters": {},
        "returns": "An array containing the heaviside step function of ``x1``, promoting to\ninexact dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([[-2, 0, 3],\n...                 [5, -1, 0],\n...                 [0, 7, -3]])\n>>> x2 = jnp.array([2, 0.5, 1])\n>>> jnp.heaviside(x1, x2)\nArray([[0. , 0.5, 1. ],\n[1. , 0. , 1. ],\n[2. , 1. , 0. ]], dtype=float32)\n>>> jnp.heaviside(x1, 0.5)\nArray([[0. , 0.5, 1. ],\n[1. , 0. , 0.5],\n[0.5, 1. , 0. ]], dtype=float32)\n>>> jnp.heaviside(-3, x2)\nArray([0., 0., 0.], dtype=float32)"
      }
    },
    {
      "name": "histogram",
      "signature": "histogram(a: 'ArrayLike', bins: 'ArrayLike' = 10, range: 'Sequence[ArrayLike] | None' = None, weights: 'ArrayLike | None' = None, density: 'bool | None' = None) -> 'tuple[Array, Array]'",
      "documentation": {
        "description": "Compute a 1-dimensional histogram.\nJAX implementation of :func:`numpy.histogram`.\nArgs:\na: array of values to be binned. May be any size or dimension.\nbins: Specify the number of bins in the histogram (default: 10). ``bins``\nmay also be an array specifying the locations of the bin edges.\nrange: tuple of scalars. Specifies the range of the data. If not specified,\nthe range is inferred from the data.\nweights: An optional array specifying the weights of the data points.\nShould be broadcast-compatible with ``a``. If not specified, each\ndata point is weighted equally.\ndensity: If True, return the normalized histogram in units of counts\nper unit length. If False (default) return the (weighted) counts per bin.",
        "parameters": {},
        "returns": "A tuple of arrays ``(histogram, bin_edges)``, where ``histogram`` contains\nthe aggregated data, and ``bin_edges`` specifies the boundaries of the bins.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.bincount`: Count the number of occurrences of each value in an array.\n- :func:`jax.numpy.histogram2d`: Compute the histogram of a 2D array.\n- :func:`jax.numpy.histogramdd`: Compute the histogram of an N-dimensional array.\n- :func:`jax.numpy.histogram_bin_edges`: Compute the bin edges for a histogram.",
        "notes": "",
        "examples": ">>> a = jnp.array([1, 2, 3, 10, 11, 15, 19, 25])\n>>> counts, bin_edges = jnp.histogram(a, bins=8)\n>>> print(counts)\n[3. 0. 0. 2. 1. 0. 1. 1.]\n>>> print(bin_edges)\n[ 1.  4.  7. 10. 13. 16. 19. 22. 25.]\nSpecifying the bin range:\n>>> counts, bin_edges = jnp.histogram(a, range=(0, 25), bins=5)\n>>> print(counts)\n[3. 0. 2. 2. 1.]\n>>> print(bin_edges)\n[ 0.  5. 10. 15. 20. 25.]\nSpecifying the bin edges explicitly:\n>>> bin_edges = jnp.array([0, 10, 20, 30])\n>>> counts, _ = jnp.histogram(a, bins=bin_edges)\n>>> print(counts)\n[3. 4. 1.]\nUsing ``density=True`` returns a normalized histogram:\n>>> density, bin_edges = jnp.histogram(a, density=True)\n>>> dx = jnp.diff(bin_edges)\n>>> normed_sum = jnp.sum(density * dx)\n>>> jnp.allclose(normed_sum, 1.0)\nArray(True, dtype=bool)"
      }
    },
    {
      "name": "histogram2d",
      "signature": "histogram2d(x: 'ArrayLike', y: 'ArrayLike', bins: 'ArrayLike | list[ArrayLike]' = 10, range: 'Sequence[None | Array | Sequence[ArrayLike]] | None' = None, weights: 'ArrayLike | None' = None, density: 'bool | None' = None) -> 'tuple[Array, Array, Array]'",
      "documentation": {
        "description": "Compute a 2-dimensional histogram.\nJAX implementation of :func:`numpy.histogram2d`.\nArgs:\nx: one-dimensional array of x-values for points to be binned.\ny: one-dimensional array of y-values for points to be binned.\nbins: Specify the number of bins in the histogram (default: 10). ``bins``\nmay also be an array specifying the locations of the bin edges, or a pair\nof integers or pair of arrays specifying the number of bins in each\ndimension.\nrange: Pair of arrays or lists of the form ``[[xmin, xmax], [ymin, ymax]]``\nspecifying the range of the data in each dimension. If not specified, the\nrange is inferred from the data.\nweights: An optional array specifying the weights of the data points.\nShould be the same shape as ``x`` and ``y``. If not specified, each\ndata point is weighted equally.\ndensity: If True, return the normalized histogram in units of counts\nper unit area. If False (default) return the (weighted) counts per bin.",
        "parameters": {},
        "returns": "A tuple of arrays ``(histogram, x_edges, y_edges)``, where ``histogram``\ncontains the aggregated data, and ``x_edges`` and ``y_edges`` specify the\nboundaries of the bins.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.histogram`: Compute the histogram of a 1D array.\n- :func:`jax.numpy.histogramdd`: Compute the histogram of an N-dimensional array.\n- :func:`jax.numpy.histogram_bin_edges`: Compute the bin edges for a histogram.",
        "notes": "",
        "examples": ">>> x = jnp.array([1, 2, 3, 10, 11, 15, 19, 25])\n>>> y = jnp.array([2, 5, 6, 8, 13, 16, 17, 18])\n>>> counts, x_edges, y_edges = jnp.histogram2d(x, y, bins=8)\n>>> counts.shape\n(8, 8)\n>>> x_edges\nArray([ 1.,  4.,  7., 10., 13., 16., 19., 22., 25.], dtype=float32)\n>>> y_edges\nArray([ 2.,  4.,  6.,  8., 10., 12., 14., 16., 18.], dtype=float32)\nSpecifying the bin range:\n>>> counts, x_edges, y_edges = jnp.histogram2d(x, y, range=[(0, 25), (0, 25)], bins=5)\n>>> counts.shape\n(5, 5)\n>>> x_edges\nArray([ 0.,  5., 10., 15., 20., 25.], dtype=float32)\n>>> y_edges\nArray([ 0.,  5., 10., 15., 20., 25.], dtype=float32)\nSpecifying the bin edges explicitly:\n>>> x_edges = jnp.array([0, 10, 20, 30])\n>>> y_edges = jnp.array([0, 10, 20, 30])\n>>> counts, _, _ = jnp.histogram2d(x, y, bins=[x_edges, y_edges])\n>>> counts\nArray([[3, 0, 0],\n[1, 3, 0],\n[0, 1, 0]], dtype=int32)\nUsing ``density=True`` returns a normalized histogram:\n>>> density, x_edges, y_edges = jnp.histogram2d(x, y, density=True)\n>>> dx = jnp.diff(x_edges)\n>>> dy = jnp.diff(y_edges)\n>>> normed_sum = jnp.sum(density * dx[:, None] * dy[None, :])\n>>> jnp.allclose(normed_sum, 1.0)\nArray(True, dtype=bool)"
      }
    },
    {
      "name": "histogram_bin_edges",
      "signature": "histogram_bin_edges(a: 'ArrayLike', bins: 'ArrayLike' = 10, range: 'None | Array | Sequence[ArrayLike]' = None, weights: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Compute the bin edges for a histogram.\nJAX implementation of :func:`numpy.histogram_bin_edges`.\nArgs:\na: array of values to be binned\nbins: Specify the number of bins in the histogram (default: 10).\nrange: tuple of scalars. Specifies the range of the data. If not specified,\nthe range is inferred from the data.\nweights: unused by JAX.",
        "parameters": {},
        "returns": "An array of bin edges for the histogram.\nSee also:\n- :func:`jax.numpy.histogram`: compute a 1D histogram.\n- :func:`jax.numpy.histogram2d`: compute a 2D histogram.\n- :func:`jax.numpy.histogramdd`: compute an N-dimensional histogram.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> a = jnp.array([2, 5, 3, 6, 4, 1])\n>>> jnp.histogram_bin_edges(a, bins=5)\nArray([1., 2., 3., 4., 5., 6.], dtype=float32)\n>>> jnp.histogram_bin_edges(a, bins=5, range=(-10, 10))  # doctest: +SKIP\nArray([-10.,  -6.,  -2.,   2.,   6.,  10.], dtype=float32)"
      }
    },
    {
      "name": "histogramdd",
      "signature": "histogramdd(sample: 'ArrayLike', bins: 'ArrayLike | list[ArrayLike]' = 10, range: 'Sequence[None | Array | Sequence[ArrayLike]] | None' = None, weights: 'ArrayLike | None' = None, density: 'bool | None' = None) -> 'tuple[Array, list[Array]]'",
      "documentation": {
        "description": "Compute an N-dimensional histogram.\nJAX implementation of :func:`numpy.histogramdd`.\nArgs:\nsample: input array of shape ``(N, D)`` representing ``N`` points in\n``D`` dimensions.\nbins: Specify the number of bins in each dimension of the histogram.\n(default: 10). May also be a length-D sequence of integers or arrays\nof bin edges.\nrange: Length-D sequence of pairs specifying the range for each dimension.\nIf not specified, the range is inferred from the data.\nweights: An optional shape ``(N,)`` array specifying the weights of the\ndata points.\nShould be the same shape as ``sample``. If not specified, each\ndata point is weighted equally.\ndensity: If True, return the normalized histogram in units of counts\nper unit volume. If False (default) return the (weighted) counts per bin.",
        "parameters": {},
        "returns": "A tuple of arrays ``(histogram, bin_edges)``, where ``histogram`` contains\nthe aggregated data, and ``bin_edges`` specifies the boundaries of the bins.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.histogram`: Compute the histogram of a 1D array.\n- :func:`jax.numpy.histogram2d`: Compute the histogram of a 2D array.\n- :func:`jax.numpy.histogram_bin_edges`: Compute the bin edges for a histogram.",
        "notes": "",
        "examples": "A histogram over 100 points in three dimensions\n>>> key = jax.random.key(42)\n>>> a = jax.random.normal(key, (100, 3))\n>>> counts, bin_edges = jnp.histogramdd(a, bins=6,\n...                                     range=[(-3, 3), (-3, 3), (-3, 3)])\n>>> counts.shape\n(6, 6, 6)\n>>> bin_edges  # doctest: +SKIP\n[Array([-3., -2., -1.,  0.,  1.,  2.,  3.], dtype=float32),\nArray([-3., -2., -1.,  0.,  1.,  2.,  3.], dtype=float32),\nArray([-3., -2., -1.,  0.,  1.,  2.,  3.], dtype=float32)]\nUsing ``density=True`` returns a normalized histogram:\n>>> density, bin_edges = jnp.histogramdd(a, density=True)\n>>> bin_widths = map(jnp.diff, bin_edges)\n>>> dx, dy, dz = jnp.meshgrid(*bin_widths, indexing='ij')\n>>> normed = jnp.sum(density * dx * dy * dz)\n>>> jnp.allclose(normed, 1.0)\nArray(True, dtype=bool)"
      }
    },
    {
      "name": "hsplit",
      "signature": "hsplit(ary: 'ArrayLike', indices_or_sections: 'int | Sequence[int] | ArrayLike') -> 'list[Array]'",
      "documentation": {
        "description": "Split an array into sub-arrays horizontally.\nJAX implementation of :func:`numpy.hsplit`.\nRefer to the documentation of :func:`jax.numpy.split` for details. ``hsplit`` is\nequivalent to ``split`` with ``axis=1``, or ``axis=0`` for one-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "1D array:\n>>> x = jnp.array([1, 2, 3, 4, 5, 6])\n>>> x1, x2 = jnp.hsplit(x, 2)\n>>> print(x1, x2)\n[1 2 3] [4 5 6]\n2D array:\n>>> x = jnp.array([[1, 2, 3, 4],\n...                [5, 6, 7, 8]])\n>>> x1, x2 = jnp.hsplit(x, 2)\n>>> print(x1)\n[[1 2]\n[5 6]]\n>>> print(x2)\n[[3 4]\n[7 8]]\nSee also:\n- :func:`jax.numpy.split`: split an array along any axis.\n- :func:`jax.numpy.vsplit`: split vertically, i.e. along axis=0\n- :func:`jax.numpy.dsplit`: split depth-wise, i.e. along axis=2\n- :func:`jax.numpy.array_split`: like ``split``, but allows ``indices_or_sections``\nto be an integer that does not evenly divide the size of the array."
      }
    },
    {
      "name": "hstack",
      "signature": "hstack(tup: 'np.ndarray | Array | Sequence[ArrayLike]', dtype: 'DTypeLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Horizontally stack arrays.\nJAX implementation of :func:`numpy.hstack`.\nFor arrays of one or more dimensions, this is equivalent to\n:func:`jax.numpy.concatenate` with ``axis=1``.\nArgs:\ntup: a sequence of arrays to stack; each must have the same shape along all\nbut the second axis. Input arrays will be promoted to at least rank 1.\nIf a single array is given it will be treated equivalently to\n`tup = unstack(tup)`, but the implementation will avoid explicit unstacking.\ndtype: optional dtype of the resulting array. If not specified, the dtype\nwill be determined via type promotion rules described in :ref:`type-promotion`.",
        "parameters": {},
        "returns": "the stacked result.\nSee also:\n- :func:`jax.numpy.stack`: stack along arbitrary axes\n- :func:`jax.numpy.concatenate`: concatenation along existing axes.\n- :func:`jax.numpy.vstack`: stack vertically, i.e. along axis 0.\n- :func:`jax.numpy.dstack`: stack depth-wise, i.e. along axis 2.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar values:\n>>> jnp.hstack([1, 2, 3])\nArray([1, 2, 3], dtype=int32, weak_type=True)\n1D arrays:\n>>> x = jnp.arange(3)\n>>> y = jnp.ones(3)\n>>> jnp.hstack([x, y])\nArray([0., 1., 2., 1., 1., 1.], dtype=float32)\n2D arrays:\n>>> x = x.reshape(3, 1)\n>>> y = y.reshape(3, 1)\n>>> jnp.hstack([x, y])\nArray([[0., 1.],\n[1., 1.],\n[2., 1.]], dtype=float32)"
      }
    },
    {
      "name": "hypot",
      "signature": "hypot(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return element-wise hypotenuse for the given legs of a right angle triangle.\nJAX implementation of :obj:`numpy.hypot`.\nArgs:\nx1: scalar or array. Specifies one of the legs of right angle triangle.\n``complex`` dtype are not supported.\nx2: scalar or array. Specifies the other leg of right angle triangle.\n``complex`` dtype are not supported. ``x1`` and ``x2`` must either have\nsame shape or be broadcast compatible.",
        "parameters": {},
        "returns": "An array containing the hypotenuse for the given given legs ``x1`` and ``x2``\nof a right angle triangle, promoting to inexact dtype.\nNote:\n``jnp.hypot`` is a more numerically stable way of computing\n``jnp.sqrt(x1 ** 2 + x2 **2)``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.hypot(3, 4)\nArray(5., dtype=float32, weak_type=True)\n>>> x1 = jnp.array([[3, -2, 5],\n...                 [9, 1, -4]])\n>>> x2 = jnp.array([-5, 6, 8])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.hypot(x1, x2)\nArray([[ 5.831,  6.325,  9.434],\n[10.296,  6.083,  8.944]], dtype=float32)"
      }
    },
    {
      "name": "i0",
      "signature": "i0(x: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "Calculate modified Bessel function of first kind, zeroth order.\nJAX implementation of :func:`numpy.i0`.\nModified Bessel function of first kind, zeroth order is defined by:\n.. math::\n\\mathrm{i0}(x) = I_0(x) = \\sum_{k=0}^{\\infty} \\frac{(x^2/4)^k}{(k!)^2}\nArgs:\nx: scalar or array. Specifies the argument of Bessel function. Complex inputs\nare not supported.",
        "parameters": {},
        "returns": "An array containing the corresponding values of the modified Bessel function\nof ``x``.\nSee also:\n- :func:`jax.scipy.special.i0`: Calculates the modified Bessel function of\nzeroth order.\n- :func:`jax.scipy.special.i1`: Calculates the modified Bessel function of\nfirst order.\n- :func:`jax.scipy.special.i0e`: Calculates the exponentially scaled modified\nBessel function of zeroth order.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([-2, -1, 0, 1, 2])\n>>> jnp.i0(x)\nArray([2.2795851, 1.266066 , 1.0000001, 1.266066 , 2.2795851], dtype=float32)"
      }
    },
    {
      "name": "identity",
      "signature": "identity(n: 'DimSize', dtype: 'DTypeLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Create a square identity matrix\nJAX implementation of :func:`numpy.identity`.\nArgs:\nn: integer specifying the size of each array dimension.\ndtype: optional dtype; defaults to floating point.",
        "parameters": {},
        "returns": "Identity array of shape ``(n, n)``.\nSee also:\n:func:`jax.numpy.eye`: non-square and/or offset identity matrices.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "A simple 3x3 identity matrix:\n>>> jnp.identity(3)\nArray([[1., 0., 0.],\n[0., 1., 0.],\n[0., 0., 1.]], dtype=float32)\nA 2x2 integer identity matrix:\n>>> jnp.identity(2, dtype=int)\nArray([[1, 0],\n[0, 1]], dtype=int32)"
      }
    },
    {
      "name": "imag",
      "signature": "imag(val: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return element-wise imaginary of part of the complex argument.\nJAX implementation of :obj:`numpy.imag`.\nArgs:\nval: input array or scalar.",
        "parameters": {},
        "returns": "An array containing the imaginary part of the elements of ``val``.\nSee also:\n- :func:`jax.numpy.conjugate` and :func:`jax.numpy.conj`: Returns the element-wise\ncomplex-conjugate of the input.\n- :func:`jax.numpy.real`: Returns the element-wise real part of the complex\nargument.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.imag(4)\nArray(0, dtype=int32, weak_type=True)\n>>> jnp.imag(5j)\nArray(5., dtype=float32, weak_type=True)\n>>> x = jnp.array([2+3j, 5-1j, -3])\n>>> jnp.imag(x)\nArray([ 3., -1.,  0.], dtype=float32)"
      }
    },
    {
      "name": "indices",
      "signature": "indices(dimensions: 'Sequence[int]', dtype: 'DTypeLike | None' = None, sparse: 'bool' = False) -> 'Array | tuple[Array, ...]'",
      "documentation": {
        "description": "Generate arrays of grid indices.\nJAX implementation of :func:`numpy.indices`.\nArgs:\ndimensions: the shape of the grid.\ndtype: the dtype of the indices (defaults to integer).\nsparse: if True, then return sparse indices. Default is False, which\nreturns dense indices.",
        "parameters": {},
        "returns": "An array of shape ``(len(dimensions), *dimensions)`` If ``sparse`` is False,\nor a sequence of arrays of the same length as ``dimensions`` if ``sparse`` is True.\nSee also:\n- :func:`jax.numpy.meshgrid`: generate a grid from arbitrary input arrays.\n- :obj:`jax.numpy.mgrid`: generate dense indices using a slicing syntax.\n- :obj:`jax.numpy.ogrid`: generate sparse indices using a slicing syntax.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.indices((2, 3))\nArray([[[0, 0, 0],\n[1, 1, 1]],\n<BLANKLINE>\n[[0, 1, 2],\n[0, 1, 2]]], dtype=int32)\n>>> jnp.indices((2, 3), sparse=True)\n(Array([[0],\n[1]], dtype=int32), Array([[0, 1, 2]], dtype=int32))"
      }
    },
    {
      "name": "inner",
      "signature": "inner(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, precision: Union[NoneType, str, jax._src.lax.lax.Precision, tuple[str, str], tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision], jax._src.lax.lax.DotAlgorithm, jax._src.lax.lax.DotAlgorithmPreset] = None, preferred_element_type: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None) -> jax.Array",
      "documentation": {
        "description": "Compute the inner product of two arrays.\nJAX implementation of :func:`numpy.inner`.\nUnlike :func:`jax.numpy.matmul` or :func:`jax.numpy.dot`, this always performs\na contraction along the last dimension of each input.\nArgs:\na: array of shape ``(..., N)``\nb: array of shape ``(..., N)``\nprecision: either ``None`` (default), which means the default precision for\nthe backend, a :class:`~jax.lax.Precision` enum value (``Precision.DEFAULT``,\n``Precision.HIGH`` or ``Precision.HIGHEST``) or a tuple of two\nsuch values indicating precision of ``a`` and ``b``.\npreferred_element_type: either ``None`` (default), which means the default\naccumulation type for the input types, or a datatype, indicating to\naccumulate results to and return a result with that datatype.",
        "parameters": {},
        "returns": "array of shape ``(*a.shape[:-1], *b.shape[:-1])`` containing the batched vector\nproduct of the inputs.\nSee also:\n- :func:`jax.numpy.vecdot`: conjugate multiplication along a specified axis.\n- :func:`jax.numpy.tensordot`: general tensor multiplication.\n- :func:`jax.numpy.matmul`: general batched matrix & vector multiplication.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "For 1D inputs, this implements standard (non-conjugate) vector multiplication:\n>>> a = jnp.array([1j, 3j, 4j])\n>>> b = jnp.array([4., 2., 5.])\n>>> jnp.inner(a, b)\nArray(0.+30.j, dtype=complex64)\nFor multi-dimensional inputs, batch dimensions are stacked rather than broadcast:\n>>> a = jnp.ones((2, 3))\n>>> b = jnp.ones((5, 3))\n>>> jnp.inner(a, b).shape\n(2, 5)"
      }
    },
    {
      "name": "insert",
      "signature": "insert(arr: 'ArrayLike', obj: 'ArrayLike | slice', values: 'ArrayLike', axis: 'int | None' = None) -> 'Array'",
      "documentation": {
        "description": "Insert entries into an array at specified indices.\nJAX implementation of :func:`numpy.insert`.\nArgs:\narr: array object into which values will be inserted.\nobj: slice or array of indices specifying insertion locations.\nvalues: array of values to be inserted.\naxis: specify the insertion axis in the case of multi-dimensional\narrays. If unspecified, ``arr`` will be flattened.",
        "parameters": {},
        "returns": "A copy of ``arr`` with values inserted at the specified locations.\nSee also:\n- :func:`jax.numpy.delete`: delete entries from an array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Inserting a single value:\n>>> x = jnp.arange(5)\n>>> jnp.insert(x, 2, 99)\nArray([ 0,  1, 99,  2,  3,  4], dtype=int32)\nInserting multiple identical values using a slice:\n>>> jnp.insert(x, slice(None, None, 2), -1)\nArray([-1,  0,  1, -1,  2,  3, -1,  4], dtype=int32)\nInserting multiple values using an index:\n>>> indices = jnp.array([4, 2, 5])\n>>> values = jnp.array([10, 11, 12])\n>>> jnp.insert(x, indices, values)\nArray([ 0,  1, 11,  2,  3, 10,  4, 12], dtype=int32)\nInserting columns into a 2D array:\n>>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> indices = jnp.array([1, 3])\n>>> values = jnp.array([[10, 11],\n...                     [12, 13]])\n>>> jnp.insert(x, indices, values, axis=1)\nArray([[ 1, 10,  2,  3, 11],\n[ 4, 12,  5,  6, 13]], dtype=int32)"
      }
    },
    {
      "name": "interp",
      "signature": "interp(x: 'ArrayLike', xp: 'ArrayLike', fp: 'ArrayLike', left: 'ArrayLike | str | None' = None, right: 'ArrayLike | str | None' = None, period: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "One-dimensional linear interpolation.\nJAX implementation of :func:`numpy.interp`.\nArgs:\nx: N-dimensional array of x coordinates at which to evaluate the interpolation.\nxp: one-dimensional sorted array of points to be interpolated.\nfp: array of shape ``xp.shape`` containing the function values associated with ``xp``.\nleft: specify how to handle points ``x < xp[0]``. Default is to return ``fp[0]``.\nIf ``left`` is a scalar value, it will return this value. if ``left`` is the string\n``\"extrapolate\"``, then the value will be determined by linear extrapolation.\n``left`` is ignored if ``period`` is specified.\nright: specify how to handle points ``x > xp[-1]``. Default is to return ``fp[-1]``.\nIf ``right`` is a scalar value, it will return this value. if ``right`` is the string\n``\"extrapolate\"``, then the value will be determined by linear extrapolation.\n``right`` is ignored if ``period`` is specified.\nperiod: optionally specify the period for the *x* coordinates, for e.g. interpolation\nin angular space.",
        "parameters": {},
        "returns": "an array of shape ``x.shape`` containing the interpolated function at values ``x``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> xp = jnp.arange(10)\n>>> fp = 2 * xp\n>>> x = jnp.array([0.5, 2.0, 3.5])\n>>> interp(x, xp, fp)\nArray([1., 4., 7.], dtype=float32)\nUnless otherwise specified, extrapolation will be constant:\n>>> x = jnp.array([-10., 10.])\n>>> interp(x, xp, fp)\nArray([ 0., 18.], dtype=float32)\nUse ``\"extrapolate\"`` mode for linear extrapolation:\n>>> interp(x, xp, fp, left='extrapolate', right='extrapolate')\nArray([-20.,  20.], dtype=float32)\nFor periodic interpolation, specify the ``period``:\n>>> xp = jnp.array([0, jnp.pi / 2, jnp.pi, 3 * jnp.pi / 2])\n>>> fp = jnp.sin(xp)\n>>> x = 2 * jnp.pi  # note: not in input array\n>>> jnp.interp(x, xp, fp, period=2 * jnp.pi)\nArray(0., dtype=float32)"
      }
    },
    {
      "name": "intersect1d",
      "signature": "intersect1d(ar1: 'ArrayLike', ar2: 'ArrayLike', assume_unique: 'bool' = False, return_indices: 'bool' = False, *, size: 'int | None' = None, fill_value: 'ArrayLike | None' = None) -> 'Array | tuple[Array, Array, Array]'",
      "documentation": {
        "description": "Compute the set intersection of two 1D arrays.\nJAX implementation of :func:`numpy.intersect1d`.\nBecause the size of the output of ``intersect1d`` is data-dependent, the function\nis not typically compatible with :func:`~jax.jit` and other JAX transformations.\nThe JAX version adds the optional ``size`` argument which must be specified\nstatically for ``jnp.intersect1d`` to be used in such contexts.\nArgs:\nar1: first array of values to intersect.\nar2: second array of values to intersect.\nassume_unique: if True, assume the input arrays contain unique values. This allows\na more efficient implementation, but if ``assume_unique`` is True and the input\narrays contain duplicates, the behavior is undefined. default: False.\nreturn_indices: If True, return arrays of indices specifying where the intersected\nvalues first appear in the input arrays.\nsize: if specified, return only the first ``size`` sorted elements. If there are fewer\nelements than ``size`` indicates, the return value will be padded with ``fill_value``,\nand returned indices will be padded with an out-of-bound index.\nfill_value: when ``size`` is specified and there are fewer than the indicated number of\nelements, fill the remaining entries ``fill_value``. Defaults to the smallest value\nin the intersection.",
        "parameters": {},
        "returns": "An array ``intersection``, or if ``return_indices=True``, a tuple of arrays\n``(intersection, ar1_indices, ar2_indices)``. Returned values are\n- ``intersection``:\nA 1D array containing each value that appears in both ``ar1`` and ``ar2``.\n- ``ar1_indices``:\n*(returned if return_indices=True)* an array of shape ``intersection.shape`` containing\nthe indices in flattened ``ar1`` of values in ``intersection``. For 1D inputs,\n``intersection`` is equivalent to ``ar1[ar1_indices]``.\n- ``ar2_indices``:\n*(returned if return_indices=True)* an array of shape ``intersection.shape`` containing\nthe indices in flattened ``ar2`` of values in ``intersection``. For 1D inputs,\n``intersection`` is equivalent to ``ar2[ar2_indices]``.\nSee also:\n- :func:`jax.numpy.union1d`: the set union of two 1D arrays.\n- :func:`jax.numpy.setxor1d`: the set XOR of two 1D arrays.\n- :func:`jax.numpy.setdiff1d`: the set difference of two 1D arrays.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> ar1 = jnp.array([1, 2, 3, 4])\n>>> ar2 = jnp.array([3, 4, 5, 6])\n>>> jnp.intersect1d(ar1, ar2)\nArray([3, 4], dtype=int32)\nComputing intersection with indices:\n>>> intersection, ar1_indices, ar2_indices = jnp.intersect1d(ar1, ar2, return_indices=True)\n>>> intersection\nArray([3, 4], dtype=int32)\n``ar1_indices`` gives the indices of the intersected values within ``ar1``:\n>>> ar1_indices\nArray([2, 3], dtype=int32)\n>>> jnp.all(intersection == ar1[ar1_indices])\nArray(True, dtype=bool)\n``ar2_indices`` gives the indices of the intersected values within ``ar2``:\n>>> ar2_indices\nArray([0, 1], dtype=int32)\n>>> jnp.all(intersection == ar2[ar2_indices])\nArray(True, dtype=bool)"
      }
    },
    {
      "name": "invert",
      "signature": "invert(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Compute the bitwise inversion of an input.\nJAX implementation of :func:`numpy.invert`. This function provides the\nimplementation of the ``~`` operator for JAX arrays.\nArgs:\nx: input array, must be boolean or integer typed.",
        "parameters": {},
        "returns": "An array of the same shape and dtype as ```x``, with the bits inverted.\nSee also:\n- :func:`jax.numpy.bitwise_invert`: Array API alias of this function.\n- :func:`jax.numpy.logical_not`: Invert after casting input to boolean.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.arange(5, dtype='uint8')\n>>> print(x)\n[0 1 2 3 4]\n>>> print(jnp.invert(x))\n[255 254 253 252 251]\nThis function implements the unary ``~`` operator for JAX arrays:\n>>> print(~x)\n[255 254 253 252 251]\n:func:`invert` operates bitwise on the input, and so the meaning of its\noutput may be more clear by showing the bitwise representation:\n>>> with jnp.printoptions(formatter={'int': lambda x: format(x, '#010b')}):\n...   print(f\"{x  = }\")\n...   print(f\"{~x = }\")\nx  = Array([0b00000000, 0b00000001, 0b00000010, 0b00000011, 0b00000100], dtype=uint8)\n~x = Array([0b11111111, 0b11111110, 0b11111101, 0b11111100, 0b11111011], dtype=uint8)\nFor boolean inputs, :func:`invert` is equivalent to :func:`logical_not`:\n>>> x = jnp.array([True, False, True, True, False])\n>>> jnp.invert(x)\nArray([False,  True, False, False,  True], dtype=bool)"
      }
    },
    {
      "name": "isclose",
      "signature": "isclose(a: 'ArrayLike', b: 'ArrayLike', rtol: 'ArrayLike' = 1e-05, atol: 'ArrayLike' = 1e-08, equal_nan: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "Check if the elements of two arrays are approximately equal within a tolerance.\nJAX implementation of :func:`numpy.allclose`.\nEssentially this function evaluates the following condition:\n.. math::\n|a - b| \\le \\mathtt{atol} + \\mathtt{rtol} * |b|\n``jnp.inf`` in ``a`` will be considered equal to ``jnp.inf`` in ``b``.\nArgs:\na: first input array to compare.\nb: second input array to compare.\nrtol: relative tolerance used for approximate equality. Default = 1e-05.\natol: absolute tolerance used for approximate equality. Default = 1e-08.\nequal_nan: Boolean. If ``True``, NaNs in ``a`` will be considered\nequal to NaNs in ``b``. Default is ``False``.",
        "parameters": {},
        "returns": "A new array containing boolean values indicating whether the input arrays\nare element-wise approximately equal within the specified tolerances.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.allclose`\n- :func:`jax.numpy.equal`",
        "notes": "",
        "examples": ">>> jnp.isclose(jnp.array([1e6, 2e6, jnp.inf]), jnp.array([1e6, 2e7, jnp.inf]))\nArray([ True, False,  True], dtype=bool)\n>>> jnp.isclose(jnp.array([1e6, 2e6, 3e6]),\n...              jnp.array([1.00008e6, 2.00008e7, 3.00008e8]), rtol=1e3)\nArray([ True,  True,  True], dtype=bool)\n>>> jnp.isclose(jnp.array([1e6, 2e6, 3e6]),\n...              jnp.array([1.00001e6, 2.00002e6, 3.00009e6]), atol=1e3)\nArray([ True,  True,  True], dtype=bool)\n>>> jnp.isclose(jnp.array([jnp.nan, 1, 2]),\n...              jnp.array([jnp.nan, 1, 2]), equal_nan=True)\nArray([ True,  True,  True], dtype=bool)"
      }
    },
    {
      "name": "iscomplex",
      "signature": "iscomplex(x: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "Return boolean array showing where the input is complex.\nJAX implementation of :func:`numpy.iscomplex`.\nArgs:\nx: Input array to check.",
        "parameters": {},
        "returns": "A new array containing boolean values indicating complex elements.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.iscomplexobj`\n- :func:`jax.numpy.isrealobj`",
        "notes": "",
        "examples": ">>> jnp.iscomplex(jnp.array([True, 0, 1, 2j, 1+2j]))\nArray([False, False, False, True, True], dtype=bool)"
      }
    },
    {
      "name": "iscomplexobj",
      "signature": "iscomplexobj(x: 'Any') -> 'bool'",
      "documentation": {
        "description": "Check if the input is a complex number or an array containing complex elements.\nJAX implementation of :func:`numpy.iscomplexobj`.\nThe function evaluates based on input type rather than value.\nInputs with zero imaginary parts are still considered complex.\nArgs:\nx: input object to check.",
        "parameters": {},
        "returns": "True if ``x`` is a complex number or an array containing at least one complex element,\nFalse otherwise.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.isrealobj`\n- :func:`jax.numpy.iscomplex`",
        "notes": "",
        "examples": ">>> jnp.iscomplexobj(True)\nFalse\n>>> jnp.iscomplexobj(0)\nFalse\n>>> jnp.iscomplexobj(jnp.array([1, 2]))\nFalse\n>>> jnp.iscomplexobj(1+2j)\nTrue\n>>> jnp.iscomplexobj(jnp.array([0, 1+2j]))\nTrue"
      }
    },
    {
      "name": "isdtype",
      "signature": "isdtype(dtype: 'DTypeLike', kind: 'str | DTypeLike | tuple[str | DTypeLike, ...]') -> 'bool'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "Args:\ndtype : the input dtype\nkind : the data type kind.\nIf ``kind`` is dtype-like, return ``dtype = kind``.\nIf ``kind`` is a string, then return True if the dtype is in the specified category:\n- ``'bool'``: ``{bool}``\n- ``'signed integer'``: ``{int4, int8, int16, int32, int64}``\n- ``'unsigned integer'``: ``{uint4, uint8, uint16, uint32, uint64}``\n- ``'integral'``: shorthand for ``('signed integer', 'unsigned integer')``\n- ``'real floating'``: ``{float8_*, float16, bfloat16, float32, float64}``\n- ``'complex floating'``: ``{complex64, complex128}``\n- ``'numeric'``: shorthand for ``('integral', 'real floating', 'complex floating')``\nIf ``kind`` is a tuple, then return True if dtype matches any entry of the tuple.\nTrue or False",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "isfinite",
      "signature": "isfinite(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return a boolean array indicating whether each element of input is finite.\nJAX implementation of :obj:`numpy.isfinite`.\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "A boolean array of same shape as ``x`` containing ``True`` where ``x`` is\nnot ``inf``, ``-inf``, or ``NaN``, and ``False`` otherwise.\nSee also:\n- :func:`jax.numpy.isinf`: Returns a boolean array indicating whether each\nelement of input is either positive or negative infinity.\n- :func:`jax.numpy.isposinf`: Returns a boolean array indicating whether each\nelement of input is positive infinity.\n- :func:`jax.numpy.isneginf`: Returns a boolean array indicating whether each\nelement of input is negative infinity.\n- :func:`jax.numpy.isnan`: Returns a boolean array indicating whether each\nelement of input is not a number (``NaN``).",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([-1, 3, jnp.inf, jnp.nan])\n>>> jnp.isfinite(x)\nArray([ True,  True, False, False], dtype=bool)\n>>> jnp.isfinite(3-4j)\nArray(True, dtype=bool, weak_type=True)"
      }
    },
    {
      "name": "isin",
      "signature": "isin(element: 'ArrayLike', test_elements: 'ArrayLike', assume_unique: 'bool' = False, invert: 'bool' = False, *, method='auto') -> 'Array'",
      "documentation": {
        "description": "Determine whether elements in ``element`` appear in ``test_elements``.\nJAX implementation of :func:`numpy.isin`.\nArgs:\nelement: input array of elements for which membership will be checked.\ntest_elements: N-dimensional array of test values to check for the presence of\neach element.\ninvert: If True, return ``~isin(element, test_elements)``. Default is False.\nassume_unique: if true, input arrays are assumed to be unique, which can\nlead to more efficient computation. If the input arrays are not unique\nand assume_unique is set to True, the results are undefined.\nmethod: string specifying the method used to compute the result. Supported\noptions are 'compare_all', 'binary_search', 'sort', and 'auto' (default).",
        "parameters": {},
        "returns": "A boolean array of shape ``element.shape`` that specifies whether each element\nappears in ``test_elements``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> elements = jnp.array([1, 2, 3, 4])\n>>> test_elements = jnp.array([[1, 5, 6, 3, 7, 1]])\n>>> jnp.isin(elements, test_elements)\nArray([ True, False,  True, False], dtype=bool)"
      }
    },
    {
      "name": "isinf",
      "signature": "isinf(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return a boolean array indicating whether each element of input is infinite.\nJAX implementation of :obj:`numpy.isinf`.\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "A boolean array of same shape as ``x`` containing ``True`` where ``x`` is\n``inf`` or ``-inf``, and ``False`` otherwise.\nSee also:\n- :func:`jax.numpy.isposinf`: Returns a boolean array indicating whether each\nelement of input is positive infinity.\n- :func:`jax.numpy.isneginf`: Returns a boolean array indicating whether each\nelement of input is negative infinity.\n- :func:`jax.numpy.isfinite`: Returns a boolean array indicating whether each\nelement of input is finite.\n- :func:`jax.numpy.isnan`: Returns a boolean array indicating whether each\nelement of input is not a number (``NaN``).",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.isinf(jnp.inf)\nArray(True, dtype=bool)\n>>> x = jnp.array([2+3j, -jnp.inf, 6, jnp.inf, jnp.nan])\n>>> jnp.isinf(x)\nArray([False,  True, False,  True, False], dtype=bool)"
      }
    },
    {
      "name": "isnan",
      "signature": "isnan(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :obj:`numpy.isnan`.\nArgs:\nx: input array or scalar.\nA boolean array of same shape as ``x`` containing ``True`` where ``x`` is\nnot a number (i.e. ``NaN``) and ``False`` otherwise.\nSee also:\n- :func:`jax.numpy.isfinite`: Returns a boolean array indicating whether each\nelement of input is finite.\n- :func:`jax.numpy.isinf`: Returns a boolean array indicating whether each\nelement of input is either positive or negative infinity.\n- :func:`jax.numpy.isposinf`: Returns a boolean array indicating whether each\nelement of input is positive infinity.\n- :func:`jax.numpy.isneginf`: Returns a boolean array indicating whether each\nelement of input is negative infinity.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.isnan(6)\nArray(False, dtype=bool, weak_type=True)\n>>> x = jnp.array([2, 1+4j, jnp.inf, jnp.nan])\n>>> jnp.isnan(x)\nArray([False, False, False,  True], dtype=bool)"
      }
    },
    {
      "name": "isneginf",
      "signature": "isneginf(x, /, out=None)",
      "documentation": {
        "description": "Return boolean array indicating whether each element of input is negative infinite.\nJAX implementation of :obj:`numpy.isneginf`.\nArgs:\nx: input array or scalar. ``complex`` dtype are not supported.",
        "parameters": {},
        "returns": "A boolean array of same shape as ``x`` containing ``True`` where ``x`` is\n``-inf``, and ``False`` otherwise.\nSee also:\n- :func:`jax.numpy.isinf`: Returns a boolean array indicating whether each\nelement of input is either positive or negative infinity.\n- :func:`jax.numpy.isposinf`: Returns a boolean array indicating whether each\nelement of input is positive infinity.\n- :func:`jax.numpy.isfinite`: Returns a boolean array indicating whether each\nelement of input is finite.\n- :func:`jax.numpy.isnan`: Returns a boolean array indicating whether each\nelement of input is not a number (``NaN``).",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.isneginf(jnp.inf)\nArray(False, dtype=bool)\n>>> x = jnp.array([-jnp.inf, 5, jnp.inf, jnp.nan, 1])\n>>> jnp.isneginf(x)\nArray([ True, False, False, False, False], dtype=bool)"
      }
    },
    {
      "name": "isposinf",
      "signature": "isposinf(x, /, out=None)",
      "documentation": {
        "description": "Return boolean array indicating whether each element of input is positive infinite.\nJAX implementation of :obj:`numpy.isposinf`.\nArgs:\nx: input array or scalar. ``complex`` dtype are not supported.",
        "parameters": {},
        "returns": "A boolean array of same shape as ``x`` containing ``True`` where ``x`` is\n``inf``, and ``False`` otherwise.\nSee also:\n- :func:`jax.numpy.isinf`: Returns a boolean array indicating whether each\nelement of input is either positive or negative infinity.\n- :func:`jax.numpy.isneginf`: Returns a boolean array indicating whether each\nelement of input is negative infinity.\n- :func:`jax.numpy.isfinite`: Returns a boolean array indicating whether each\nelement of input is finite.\n- :func:`jax.numpy.isnan`: Returns a boolean array indicating whether each\nelement of input is not a number (``NaN``).",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.isposinf(5)\nArray(False, dtype=bool)\n>>> x = jnp.array([-jnp.inf, 5, jnp.inf, jnp.nan, 1])\n>>> jnp.isposinf(x)\nArray([False, False,  True, False, False], dtype=bool)"
      }
    },
    {
      "name": "isreal",
      "signature": "isreal(x: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "Return boolean array showing where the input is real.\nJAX implementation of :func:`numpy.isreal`.\nArgs:\nx: input array to check.",
        "parameters": {},
        "returns": "A new array containing boolean values indicating real elements.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.iscomplex`\n- :func:`jax.numpy.isrealobj`",
        "notes": "",
        "examples": ">>> jnp.isreal(jnp.array([False, 0j, 1, 2.1, 1+2j]))\nArray([ True,  True,  True,  True, False], dtype=bool)"
      }
    },
    {
      "name": "isrealobj",
      "signature": "isrealobj(x: 'Any') -> 'bool'",
      "documentation": {
        "description": "Check if the input is not a complex number or an array containing complex elements.\nJAX implementation of :func:`numpy.isrealobj`.\nThe function evaluates based on input type rather than value.\nInputs with zero imaginary parts are still considered complex.\nArgs:\nx: input object to check.",
        "parameters": {},
        "returns": "False if ``x`` is a complex number or an array containing at least one complex element,\nTrue otherwise.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.iscomplexobj`\n- :func:`jax.numpy.isreal`",
        "notes": "",
        "examples": ">>> jnp.isrealobj(0)\nTrue\n>>> jnp.isrealobj(1.2)\nTrue\n>>> jnp.isrealobj(jnp.array([1, 2]))\nTrue\n>>> jnp.isrealobj(1+2j)\nFalse\n>>> jnp.isrealobj(jnp.array([0, 1+2j]))\nFalse"
      }
    },
    {
      "name": "isscalar",
      "signature": "isscalar(element: 'Any') -> 'bool'",
      "documentation": {
        "description": "Return True if the input is a scalar.\nJAX implementation of :func:`numpy.isscalar`. JAX's implementation differs\nfrom NumPy's in that it considers zero-dimensional arrays to be scalars; see\nthe *Note* below for more details.\nArgs:\nelement: input object to check; any type is valid input.",
        "parameters": {},
        "returns": "True if ``element`` is a scalar value or an array-like object with zero\ndimensions, False otherwise.\nNote:\nJAX and NumPy differ in their representation of scalar values. NumPy has\nspecial scalar objects (e.g. ``np.int32(0)``) which are distinct from\nzero-dimensional arrays (e.g. ``np.array(0)``), and :func:`numpy.isscalar`\nreturns ``True`` for the former and ``False`` for the latter.\nJAX does not define special scalar objects, but rather represents scalars as\nzero-dimensional arrays. As such, :func:`jax.numpy.isscalar` returns ``True``\nfor both scalar objects (e.g. ``0.0`` or ``np.float32(0.0)``) and array-like\nobjects with zero dimensions (e.g. ``jnp.array(0.0)``, ``np.array(0.0)``).\nOne reason for the different conventions in ``isscalar`` is to maintain\nJIT-invariance: i.e. the property that the result of a function should not\nchange when it is JIT-compiled. Because scalar inputs are cast to\nzero-dimensional JAX arrays at JIT boundaries, the semantics of\n:func:`numpy.isscalar` are such that the result changes under JIT:\n>>> np.isscalar(1.0)\nTrue\n>>> jax.jit(np.isscalar)(1.0)\nArray(False, dtype=bool)\nBy treating zero-dimensional arrays as scalars, :func:`jax.numpy.isscalar`\navoids this issue:\n>>> jnp.isscalar(1.0)\nTrue\n>>> jax.jit(jnp.isscalar)(1.0)\nArray(True, dtype=bool)",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "In JAX, both scalars and zero-dimensional array-like objects are considered\nscalars:\n>>> jnp.isscalar(1.0)\nTrue\n>>> jnp.isscalar(1 + 1j)\nTrue\n>>> jnp.isscalar(jnp.array(1))  # zero-dimensional JAX array\nTrue\n>>> jnp.isscalar(jnp.int32(1))  # JAX scalar constructor\nTrue\n>>> jnp.isscalar(np.array(1.0))  # zero-dimensional NumPy array\nTrue\n>>> jnp.isscalar(np.int32(1))  # NumPy scalar type\nTrue\nArrays with one or more dimension are not considered scalars:\n>>> jnp.isscalar(jnp.array([1]))\nFalse\n>>> jnp.isscalar(np.array([1]))\nFalse\nCompare this to :func:`numpy.isscalar`, which returns ``True`` for\nscalar-typed objects, and ``False`` for *all* arrays, even those with\nzero dimensions:\n>>> np.isscalar(np.int32(1))  # scalar object\nTrue\n>>> np.isscalar(np.array(1))  # zero-dimensional array\nFalse\nIn JAX, as in NumPy, objects which are not array-like are not considered\nscalars:\n>>> jnp.isscalar(None)\nFalse\n>>> jnp.isscalar([1])\nFalse\n>>> jnp.isscalar(tuple())\nFalse\n>>> jnp.isscalar(slice(10))\nFalse"
      }
    },
    {
      "name": "issubdtype",
      "signature": "issubdtype(arg1: 'DTypeLike', arg2: 'DTypeLike') -> 'bool'",
      "documentation": {
        "description": "Return True if arg1 is equal or lower than arg2 in the type hierarchy.\nJAX implementation of :func:`numpy.issubdtype`.\nThe main difference in JAX's implementation is that it properly handles\ndtype extensions such as :code:`bfloat16`.\nArgs:\narg1: dtype-like object. In typical usage, this will be a dtype specifier,\nsuch as ``\"float32\"`` (i.e. a string), ``np.dtype('int32')`` (i.e. an\ninstance of :class:`numpy.dtype`), ``jnp.complex64`` (i.e. a JAX scalar\nconstructor), or ``np.uint8`` (i.e. a NumPy scalar type).\narg2: dtype-like object. In typical usage, this will be a generic scalar\ntype, such as ``jnp.integer``, ``jnp.floating``, or ``jnp.complexfloating``.",
        "parameters": {},
        "returns": "True if arg1 represents a dtype that is equal or lower in the type\nhierarchy than arg2.\nSee also:\n- :func:`jax.numpy.isdtype`: similar function aligning with the array API standard.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.issubdtype('uint32', jnp.unsignedinteger)\nTrue\n>>> jnp.issubdtype(np.int32, jnp.integer)\nTrue\n>>> jnp.issubdtype(jnp.bfloat16, jnp.floating)\nTrue\n>>> jnp.issubdtype(np.dtype('complex64'), jnp.complexfloating)\nTrue\n>>> jnp.issubdtype('complex64', jnp.integer)\nFalse\nBe aware that while this is very similar to :func:`numpy.issubdtype`, the\nresults of these differ in the case of JAX's custom floating point types:\n>>> np.issubdtype('bfloat16', np.floating)\nFalse\n>>> jnp.issubdtype('bfloat16', jnp.floating)\nTrue"
      }
    },
    {
      "name": "iterable",
      "signature": "iterable(y)",
      "documentation": {
        "description": "Check whether or not an object can be iterated over.",
        "parameters": {
          "y": {
            "type": "object",
            "description": "Input object."
          }
        },
        "returns": "-------\nb : bool\nReturn ``True`` if the object has an iterator method or is a\nsequence and ``False`` otherwise.",
        "raises": "",
        "see_also": "",
        "notes": "-----\nIn most cases, the results of ``np.iterable(obj)`` are consistent with\n``isinstance(obj, collections.abc.Iterable)``. One notable exception is\nthe treatment of 0-dimensional arrays::\n>>> from collections.abc import Iterable\n>>> a = np.array(1.0)  # 0-dimensional numpy array\n>>> isinstance(a, Iterable)\nTrue\n>>> np.iterable(a)\nFalse",
        "examples": "--------\n>>> np.iterable([1, 2, 3])\nTrue\n>>> np.iterable(2)\nFalse"
      }
    },
    {
      "name": "ix_",
      "signature": "ix_(*args: 'ArrayLike') -> 'tuple[Array, ...]'",
      "documentation": {
        "description": "Return a multi-dimensional grid (open mesh) from N one-dimensional sequences.\nJAX implementation of :func:`numpy.ix_`.\nArgs:\n*args: N one-dimensional arrays",
        "parameters": {},
        "returns": "Tuple of Jax arrays forming an open mesh, each with N dimensions.",
        "raises": "",
        "see_also": "- :obj:`jax.numpy.ogrid`\n- :obj:`jax.numpy.mgrid`\n- :func:`jax.numpy.meshgrid`",
        "notes": "",
        "examples": ">>> rows = jnp.array([0, 2])\n>>> cols = jnp.array([1, 3])\n>>> open_mesh = jnp.ix_(rows, cols)\n>>> open_mesh\n(Array([[0],\n[2]], dtype=int32), Array([[1, 3]], dtype=int32))\n>>> [grid.shape for grid in open_mesh]\n[(2, 1), (1, 2)]\n>>> x = jnp.array([[10, 20, 30, 40],\n...                [50, 60, 70, 80],\n...                [90, 100, 110, 120],\n...                [130, 140, 150, 160]])\n>>> x[open_mesh]\nArray([[ 20,  40],\n[100, 120]], dtype=int32)"
      }
    },
    {
      "name": "kaiser",
      "signature": "kaiser(M: int, beta: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
      "documentation": {
        "description": "Return a Kaiser window of size M.\nJAX implementation of :func:`numpy.kaiser`.\nArgs:\nM: The window size.\nbeta: The Kaiser window parameter.",
        "parameters": {},
        "returns": "An array of size M containing the Kaiser window.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.kaiser(4, 1.5))\n[0.61 0.95 0.95 0.61]\nSee also:\n- :func:`jax.numpy.bartlett`: return a Bartlett window of size M.\n- :func:`jax.numpy.blackman`: return a Blackman window of size M.\n- :func:`jax.numpy.hamming`: return a Hamming window of size M.\n- :func:`jax.numpy.hanning`: return a Hanning window of size M."
      }
    },
    {
      "name": "kron",
      "signature": "kron(a: 'ArrayLike', b: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "Compute the Kronecker product of two input arrays.\nJAX implementation of :func:`numpy.kron`.\nThe Kronecker product is an operation on two matrices of arbitrary size that\nproduces a block matrix. Each element of the first matrix ``a`` is multiplied by\nthe entire second matrix ``b``. If ``a`` has shape (m, n) and ``b``\nhas shape (p, q), the resulting matrix will have shape (m * p, n * q).\nArgs:\na: first input array with any shape.\nb: second input array with any shape.",
        "parameters": {},
        "returns": "A new array representing the Kronecker product of the inputs  ``a`` and ``b``.\nThe shape of the output is the element-wise product of the input shapes.\nSee also:\n- :func:`jax.numpy.outer`: compute the outer product of two arrays.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> a = jnp.array([[1, 2],\n...                [3, 4]])\n>>> b = jnp.array([[5, 6],\n...                [7, 8]])\n>>> jnp.kron(a, b)\nArray([[ 5,  6, 10, 12],\n[ 7,  8, 14, 16],\n[15, 18, 20, 24],\n[21, 24, 28, 32]], dtype=int32)"
      }
    },
    {
      "name": "lcm",
      "signature": "lcm(x1: 'ArrayLike', x2: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "Compute the least common multiple of two arrays.\nJAX implementation of :func:`numpy.lcm`.\nArgs:\nx1: First input array. The elements must have integer dtype.\nx2: Second input array. The elements must have integer dtype.",
        "parameters": {},
        "returns": "An array containing the least common multiple of the corresponding\nelements from the absolute values of `x1` and `x2`.\nSee also:\n- :func:`jax.numpy.gcd`: compute the greatest common divisor of two arrays.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar inputs:\n>>> jnp.lcm(12, 18)\nArray(36, dtype=int32, weak_type=True)\nArray inputs:\n>>> x1 = jnp.array([12, 18, 24])\n>>> x2 = jnp.array([5, 10, 15])\n>>> jnp.lcm(x1, x2)\nArray([ 60,  90, 120], dtype=int32)\nBroadcasting:\n>>> x1 = jnp.array([12])\n>>> x2 = jnp.array([6, 9, 12])\n>>> jnp.lcm(x1, x2)\nArray([12, 36, 12], dtype=int32)"
      }
    },
    {
      "name": "ldexp",
      "signature": "ldexp(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Compute x1 * 2 ** x2\nJAX implementation of :func:`numpy.ldexp`.\nNote that XLA does not provide an ``ldexp`` operation, so this\nis implemneted in JAX via a standard multiplication and\nexponentiation.\nArgs:\nx1: real-valued input array.\nx2: integer input array. Must be broadcast-compatible with ``x1``.",
        "parameters": {},
        "returns": "``x1 * 2 ** x2`` computed element-wise.\nSee also:\n- :func:`jax.numpy.frexp`: decompose values into mantissa and exponent.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.arange(5.0)\n>>> x2 = 10\n>>> jnp.ldexp(x1, x2)\nArray([   0., 1024., 2048., 3072., 4096.], dtype=float32)\n``ldexp`` can be used to reconstruct the input to ``frexp``:\n>>> x = jnp.array([2., 3., 5., 11.])\n>>> m, e = jnp.frexp(x)\n>>> m\nArray([0.5   , 0.75  , 0.625 , 0.6875], dtype=float32)\n>>> e\nArray([2, 2, 3, 4], dtype=int32)\n>>> jnp.ldexp(m, e)\nArray([ 2.,  3.,  5., 11.], dtype=float32)"
      }
    },
    {
      "name": "left_shift",
      "signature": "left_shift(x: 'ArrayLike', y: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Shift bits of ``x`` to left by the amount specified in ``y``, element-wise.\nJAX implementation of :obj:`numpy.left_shift`.\nArgs:\nx: Input array, must be integer-typed.\ny: The amount of bits to shift each element in ``x`` to the left, only accepts\ninteger subtypes. ``x`` and ``y`` must either have same shape or be broadcast\ncompatible.",
        "parameters": {},
        "returns": "An array containing the left shifted elements of ``x`` by the amount specified\nin ``y``, with the same shape as the broadcasted shape of ``x`` and ``y``.\nNote:\nLeft shifting ``x`` by ``y`` is equivalent to ``x * (2**y)`` within the\nbounds of the dtypes involved.\nSee also:\n- :func:`jax.numpy.right_shift`: and :func:`jax.numpy.bitwise_right_shift`:\nShifts the bits of ``x1`` to right by the amount specified in ``x2``,\nelement-wise.\n- :func:`jax.numpy.bitwise_left_shift`: Alias of :func:`jax.left_shift`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> def print_binary(x):\n...   return [bin(int(val)) for val in x]\n>>> x1 = jnp.arange(5)\n>>> x1\nArray([0, 1, 2, 3, 4], dtype=int32)\n>>> print_binary(x1)\n['0b0', '0b1', '0b10', '0b11', '0b100']\n>>> x2 = 1\n>>> result = jnp.left_shift(x1, x2)\n>>> result\nArray([0, 2, 4, 6, 8], dtype=int32)\n>>> print_binary(result)\n['0b0', '0b10', '0b100', '0b110', '0b1000']\n>>> x3 = 4\n>>> print_binary([x3])\n['0b100']\n>>> x4 = jnp.array([1, 2, 3, 4])\n>>> result1 = jnp.left_shift(x3, x4)\n>>> result1\nArray([ 8, 16, 32, 64], dtype=int32)\n>>> print_binary(result1)\n['0b1000', '0b10000', '0b100000', '0b1000000']"
      }
    },
    {
      "name": "less",
      "signature": "less(x: 'ArrayLike', y: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return element-wise truth value of ``x < y``.\nJAX implementation of :obj:`numpy.less`.\nArgs:\nx: input array or scalar.\ny: input array or scalar. ``x`` and ``y`` must either have same shape or be\nbroadcast compatible.",
        "parameters": {},
        "returns": "An array containing boolean values. ``True`` if the elements of ``x < y``,\nand ``False`` otherwise.\nSee also:\n- :func:`jax.numpy.greater`: Returns element-wise truth value of ``x > y``.\n- :func:`jax.numpy.greater_equal`: Returns element-wise truth value of\n``x >= y``.\n- :func:`jax.numpy.less_equal`: Returns element-wise truth value of ``x <= y``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar inputs:\n>>> jnp.less(3, 7)\nArray(True, dtype=bool, weak_type=True)\nInputs with same shape:\n>>> x = jnp.array([5, 9, -3])\n>>> y = jnp.array([1, 6, 4])\n>>> jnp.less(x, y)\nArray([False, False,  True], dtype=bool)\nInputs with broadcast compatibility:\n>>> x1 = jnp.array([[2, -4, 6, -8],\n...                 [-1, 5, -3, 7]])\n>>> y1 = jnp.array([0, 3, -5, 9])\n>>> jnp.less(x1, y1)\nArray([[False,  True, False,  True],\n[ True, False, False,  True]], dtype=bool)"
      }
    },
    {
      "name": "less_equal",
      "signature": "less_equal(x: 'ArrayLike', y: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return element-wise truth value of ``x <= y``.\nJAX implementation of :obj:`numpy.less_equal`.\nArgs:\nx: input array or scalar.\ny: input array or scalar. ``x`` and ``y`` must have either same shape or be\nbroadcast compatible.",
        "parameters": {},
        "returns": "An array containing the boolean values. ``True`` if the elements of ``x <= y``,\nand ``False`` otherwise.\nSee also:\n- :func:`jax.numpy.greater_equal`: Returns element-wise truth value of\n``x >= y``.\n- :func:`jax.numpy.greater`: Returns element-wise truth value of ``x > y``.\n- :func:`jax.numpy.less`: Returns element-wise truth value of ``x < y``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar inputs:\n>>> jnp.less_equal(6, -2)\nArray(False, dtype=bool, weak_type=True)\nInputs with same shape:\n>>> x = jnp.array([-4, 1, 7])\n>>> y = jnp.array([2, -3, 8])\n>>> jnp.less_equal(x, y)\nArray([ True, False,  True], dtype=bool)\nInputs with broadcast compatibility:\n>>> x1 = jnp.array([2, -5, 9])\n>>> y1 = jnp.array([[1, -6, 5],\n...                 [-2, 4, -6]])\n>>> jnp.less_equal(x1, y1)\nArray([[False, False, False],\n[False,  True, False]], dtype=bool)"
      }
    },
    {
      "name": "lexsort",
      "signature": "lexsort(keys: Union[jax.Array, numpy.ndarray, Sequence[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]]], axis: int = -1) -> jax.Array",
      "documentation": {
        "description": "Sort a sequence of keys in lexicographic order.\nJAX implementation of :func:`numpy.lexsort`.\nArgs:\nkeys: a sequence of arrays to sort; all arrays must have the same shape.\nThe last key in the sequence is used as the primary key.\naxis: the axis along which to sort (default: -1).",
        "parameters": {},
        "returns": "An array of integers of shape ``keys[0].shape`` giving the indices of the\nentries in lexicographically-sorted order.\nSee also:\n- :func:`jax.numpy.argsort`: sort a single entry by index.\n- :func:`jax.lax.sort`: direct XLA sorting API.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ":func:`lexsort` with a single key is equivalent to :func:`argsort`:\n>>> key1 = jnp.array([4, 2, 3, 2, 5])\n>>> jnp.lexsort([key1])\nArray([1, 3, 2, 0, 4], dtype=int32)\n>>> jnp.argsort(key1)\nArray([1, 3, 2, 0, 4], dtype=int32)\nWith multiple keys, :func:`lexsort` uses the last key as the primary key:\n>>> key2 = jnp.array([2, 1, 1, 2, 2])\n>>> jnp.lexsort([key1, key2])\nArray([1, 2, 3, 0, 4], dtype=int32)\nThe meaning of the indices become more clear when printing the sorted keys:\n>>> indices = jnp.lexsort([key1, key2])\n>>> print(f\"{key1[indices]}\\n{key2[indices]}\")\n[2 3 2 4 5]\n[1 1 2 2 2]\nNotice that the elements of ``key2`` appear in order, and within the sequences\nof duplicated values the corresponding elements of ```key1`` appear in order.\nFor multi-dimensional inputs, :func:`lexsort` defaults to sorting along the\nlast axis:\n>>> key1 = jnp.array([[2, 4, 2, 3],\n...                   [3, 1, 2, 2]])\n>>> key2 = jnp.array([[1, 2, 1, 3],\n...                   [2, 1, 2, 1]])\n>>> jnp.lexsort([key1, key2])\nArray([[0, 2, 1, 3],\n[1, 3, 2, 0]], dtype=int32)\nA different sort axis can be chosen using the ``axis`` keyword; here we sort\nalong the leading axis:\n>>> jnp.lexsort([key1, key2], axis=0)\nArray([[0, 1, 0, 1],\n[1, 0, 1, 0]], dtype=int32)"
      }
    },
    {
      "name": "linspace",
      "signature": "linspace(start: 'ArrayLike', stop: 'ArrayLike', num: 'int' = 50, endpoint: 'bool' = True, retstep: 'bool' = False, dtype: 'DTypeLike | None' = None, axis: 'int' = 0, *, device: 'xc.Device | Sharding | None' = None) -> 'Array | tuple[Array, Array]'",
      "documentation": {
        "description": "Return evenly-spaced numbers within an interval.\nJAX implementation of :func:`numpy.linspace`.\nArgs:\nstart: scalar or array of starting values.\nstop: scalar or array of stop values.\nnum: number of values to generate. Default: 50.\nendpoint: if True (default) then include the ``stop`` value in the result.\nIf False, then exclude the ``stop`` value.\nretstep: If True, then return a ``(result, step)`` tuple, where ``step`` is the\ninterval between adjacent values in ``result``.\naxis: integer axis along which to generate the linspace. Defaults to zero.\ndevice: optional :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.",
        "parameters": {},
        "returns": "An array ``values``, or a tuple ``(values, step)`` if ``retstep`` is True, where:\n- ``values`` is an array of evenly-spaced values from ``start`` to ``stop``\n- ``step`` is the interval between adjacent values.\nSee also:\n- :func:`jax.numpy.arange`: Generate ``N`` evenly-spaced values given a starting\npoint and a step\n- :func:`jax.numpy.logspace`: Generate logarithmically-spaced values.\n- :func:`jax.numpy.geomspace`: Generate geometrically-spaced values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "List of 5 values between 0 and 10:\n>>> jnp.linspace(0, 10, 5)\nArray([ 0. ,  2.5,  5. ,  7.5, 10. ], dtype=float32)\nList of 8 values between 0 and 10, excluding the endpoint:\n>>> jnp.linspace(0, 10, 8, endpoint=False)\nArray([0.  , 1.25, 2.5 , 3.75, 5.  , 6.25, 7.5 , 8.75], dtype=float32)\nList of values and the step size between them\n>>> vals, step = jnp.linspace(0, 10, 9, retstep=True)\n>>> vals\nArray([ 0.  ,  1.25,  2.5 ,  3.75,  5.  ,  6.25,  7.5 ,  8.75, 10.  ],      dtype=float32)\n>>> step\nArray(1.25, dtype=float32)\nMulti-dimensional linspace:\n>>> start = jnp.array([0, 5])\n>>> stop = jnp.array([5, 10])\n>>> jnp.linspace(start, stop, 5)\nArray([[ 0.  ,  5.  ],\n[ 1.25,  6.25],\n[ 2.5 ,  7.5 ],\n[ 3.75,  8.75],\n[ 5.  , 10.  ]], dtype=float32)"
      }
    },
    {
      "name": "load",
      "signature": "load(file: 'IO[bytes] | str | os.PathLike[Any]', *args: 'Any', **kwargs: 'Any') -> 'Array'",
      "documentation": {
        "description": "Load JAX arrays from npy files.\nJAX wrapper of :func:`numpy.load`.\nThis function is a simple wrapper of :func:`numpy.load`, but in the case of\n``.npy`` files created with :func:`numpy.save` or :func:`jax.numpy.save`,\nthe output will be returned as a :class:`jax.Array`, and ``bfloat16`` data\ntypes will be restored. For ``.npz`` files, results will be returned as\nnormal NumPy arrays.\nThis function requires concrete array inputs, and is not compatible with\ntransformations like :func:`jax.jit` or :func:`jax.vmap`.\nArgs:\nfile: string, bytes, or path-like object containing the array data.\nargs, kwargs: for additional arguments, see :func:`numpy.load`",
        "parameters": {},
        "returns": "the array stored in the file.\nSee also:\n- :func:`jax.numpy.save`: save an array to a file.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import io\n>>> f = io.BytesIO()  # use an in-memory file-like object.\n>>> x = jnp.array([2, 4, 6, 8], dtype='bfloat16')\n>>> jnp.save(f, x)\n>>> f.seek(0)\n0\n>>> jnp.load(f)\nArray([2, 4, 6, 8], dtype=bfloat16)"
      }
    },
    {
      "name": "log",
      "signature": "log(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise natural logarithm of the input.\nJAX implementation of :obj:`numpy.log`.\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array containing the logarithm of each element in ``x``, promotes to inexact\ndtype.\nSee also:\n- :func:`jax.numpy.exp`: Calculates element-wise exponential of the input.\n- :func:`jax.numpy.log2`: Calculates base-2 logarithm of each element of input.\n- :func:`jax.numpy.log1p`: Calculates element-wise logarithm of one plus input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "``jnp.log`` and ``jnp.exp`` are inverse functions of each other. Applying\n``jnp.log`` on the result of ``jnp.exp(x)`` yields the original input ``x``.\n>>> x = jnp.array([2, 3, 4, 5])\n>>> jnp.log(jnp.exp(x))\nArray([2., 3., 4., 5.], dtype=float32)\nUsing ``jnp.log`` we can demonstrate well-known properties of logarithms, such\nas :math:`log(a*b) = log(a)+log(b)`.\n>>> x1 = jnp.array([2, 1, 3, 1])\n>>> x2 = jnp.array([1, 3, 2, 4])\n>>> jnp.allclose(jnp.log(x1*x2), jnp.log(x1)+jnp.log(x2))\nArray(True, dtype=bool)"
      }
    },
    {
      "name": "log10",
      "signature": "log10(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculates the base-10 logarithm of x element-wise\nJAX implementation of :obj:`numpy.log10`.\nArgs:\nx: Input array",
        "parameters": {},
        "returns": "An array containing the base-10 logarithm of each element in ``x``, promotes\nto inexact dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([0.01, 0.1, 1, 10, 100, 1000])\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.log10(x1))\n[-2. -1.  0.  1.  2.  3.]"
      }
    },
    {
      "name": "log1p",
      "signature": "log1p(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculates element-wise logarithm of one plus input, ``log(x+1)``.\nJAX implementation of :obj:`numpy.log1p`.\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array containing the logarithm of one plus of each element in ``x``,\npromotes to inexact dtype.\nNote:\n``jnp.log1p`` is more accurate than when using the naive computation of\n``log(x+1)`` for small values of ``x``.\nSee also:\n- :func:`jax.numpy.expm1`: Calculates :math:`e^x-1` of each element of the\ninput.\n- :func:`jax.numpy.log2`: Calculates base-2 logarithm of each element of input.\n- :func:`jax.numpy.log`: Calculates element-wise logarithm of the input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([2, 5, 9, 4])\n>>> jnp.allclose(jnp.log1p(x), jnp.log(x+1))\nArray(True, dtype=bool)\nFor values very close to 0, ``jnp.log1p(x)`` is more accurate than\n``jnp.log(x+1)``:\n>>> x1 = jnp.array([1e-4, 1e-6, 2e-10])\n>>> jnp.expm1(jnp.log1p(x1))  # doctest: +SKIP\nArray([1.00000005e-04, 9.99999997e-07, 2.00000003e-10], dtype=float32)\n>>> jnp.expm1(jnp.log(x1+1))  # doctest: +SKIP\nArray([1.000166e-04, 9.536743e-07, 0.000000e+00], dtype=float32)"
      }
    },
    {
      "name": "log2",
      "signature": "log2(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculates the base-2 logarithm of ``x`` element-wise.\nJAX implementation of :obj:`numpy.log2`.\nArgs:\nx: Input array",
        "parameters": {},
        "returns": "An array containing the base-2 logarithm of each element in ``x``, promotes\nto inexact dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([0.25, 0.5, 1, 2, 4, 8])\n>>> jnp.log2(x1)\nArray([-2., -1.,  0.,  1.,  2.,  3.], dtype=float32)"
      }
    },
    {
      "name": "logaddexp",
      "signature": "logaddexp(*args: 'ArrayLike', out: 'None' = None, where: 'None' = None) -> 'Any'",
      "documentation": {
        "description": "Compute ``log(exp(x1) + exp(x2))`` avoiding overflow.\nJAX implementation of :obj:`numpy.logaddexp`\nArgs:\nx1: input array\nx2: input array",
        "parameters": {},
        "returns": "array containing the result.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([1, 2, 3])\n>>> x2 = jnp.array([4, 5, 6])\n>>> result1 = jnp.logaddexp(x1, x2)\n>>> result2 = jnp.log(jnp.exp(x1) + jnp.exp(x2))\n>>> print(jnp.allclose(result1, result2))\nTrue"
      }
    },
    {
      "name": "logaddexp2",
      "signature": "logaddexp2(*args: 'ArrayLike', out: 'None' = None, where: 'None' = None) -> 'Any'",
      "documentation": {
        "description": "Logarithm of the sum of exponentials of inputs in base-2 avoiding overflow.\nJAX implementation of :obj:`numpy.logaddexp2`.\nArgs:\nx1: input array or scalar.\nx2: input array or scalar. ``x1`` and ``x2`` should either have same shape or\nbe broadcast compatible.",
        "parameters": {},
        "returns": "An array containing the result, :math:`log_2(2^{x1}+2^{x2})`, element-wise.\nSee also:\n- :func:`jax.numpy.logaddexp`: Computes ``log(exp(x1) + exp(x2))``, element-wise.\n- :func:`jax.numpy.log2`: Calculates the base-2 logarithm of ``x`` element-wise.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([[3, -1, 4],\n...                 [8, 5, -2]])\n>>> x2 = jnp.array([2, 3, -5])\n>>> result1 = jnp.logaddexp2(x1, x2)\n>>> result2 = jnp.log2(jnp.exp2(x1) + jnp.exp2(x2))\n>>> jnp.allclose(result1, result2)\nArray(True, dtype=bool)"
      }
    },
    {
      "name": "logical_and",
      "signature": "logical_and(*args: 'ArrayLike', out: 'None' = None, where: 'None' = None) -> 'Any'",
      "documentation": {
        "description": "Compute the logical AND operation elementwise.\nJAX implementation of :obj:`numpy.logical_and`. This is a universal function,\nand supports the additional APIs described at :class:`jax.numpy.ufunc`.\nArgs:\nx, y: input arrays. Must be broadcastable to a common shape.",
        "parameters": {},
        "returns": "Array containing the result of the element-wise logical AND.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.arange(4)\n>>> jnp.logical_and(x, 1)\nArray([False,  True,  True,  True], dtype=bool)"
      }
    },
    {
      "name": "logical_not",
      "signature": "logical_not(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Compute NOT bool(x) element-wise.\nJAX implementation of :func:`numpy.logical_not`.\nArgs:\nx: input array of any dtype.",
        "parameters": {},
        "returns": "A boolean array that computes NOT bool(x) element-wise\nSee also:\n- :func:`jax.numpy.invert` or :func:`jax.numpy.bitwise_invert`: bitwise NOT operation",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Compute NOT x element-wise on a boolean array:\n>>> x = jnp.array([True, False, True])\n>>> jnp.logical_not(x)\nArray([False,  True, False], dtype=bool)\nFor boolean input, this is equivalent to :func:`~jax.numpy.invert`, which implements\nthe unary ``~`` operator:\n>>> ~x\nArray([False,  True, False], dtype=bool)\nFor non-boolean input, the input of :func:`logical_not` is implicitly cast to boolean:\n>>> x = jnp.array([-1, 0, 1])\n>>> jnp.logical_not(x)\nArray([False,  True, False], dtype=bool)"
      }
    },
    {
      "name": "logical_or",
      "signature": "logical_or(*args: 'ArrayLike', out: 'None' = None, where: 'None' = None) -> 'Any'",
      "documentation": {
        "description": "Compute the logical OR operation elementwise.\nJAX implementation of :obj:`numpy.logical_or`. This is a universal function,\nand supports the additional APIs described at :class:`jax.numpy.ufunc`.\nArgs:\nx, y: input arrays. Must be broadcastable to a common shape.",
        "parameters": {},
        "returns": "Array containing the result of the element-wise logical OR.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.arange(4)\n>>> jnp.logical_or(x, 1)\nArray([ True,  True,  True,  True], dtype=bool)"
      }
    },
    {
      "name": "logical_xor",
      "signature": "logical_xor(*args: 'ArrayLike', out: 'None' = None, where: 'None' = None) -> 'Any'",
      "documentation": {
        "description": "Compute the logical XOR operation elementwise.\nJAX implementation of :obj:`numpy.logical_xor`. This is a universal function,\nand supports the additional APIs described at :class:`jax.numpy.ufunc`.\nArgs:\nx, y: input arrays. Must be broadcastable to a common shape.",
        "parameters": {},
        "returns": "Array containing the result of the element-wise logical XOR.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.arange(4)\n>>> jnp.logical_xor(x, 1)\nArray([ True, False, False, False], dtype=bool)"
      }
    },
    {
      "name": "logspace",
      "signature": "logspace(start: 'ArrayLike', stop: 'ArrayLike', num: 'int' = 50, endpoint: 'bool' = True, base: 'ArrayLike' = 10.0, dtype: 'DTypeLike | None' = None, axis: 'int' = 0) -> 'Array'",
      "documentation": {
        "description": "Generate logarithmically-spaced values.\nJAX implementation of :func:`numpy.logspace`.\nArgs:\nstart: scalar or array. Used to specify the start value. The start value is\n``base ** start``.\nstop: scalar or array. Used to specify the stop value. The end value is\n``base ** stop``.\nnum: int, optional, default=50. Number of values to generate.\nendpoint: bool, optional, default=True. If True, then include the ``stop`` value\nin the result. If False, then exclude the ``stop`` value.\nbase: scalar or array, optional, default=10. Specifies the base of the logarithm.\ndtype: optional. Specifies the dtype of the output.\naxis: int, optional, default=0. Axis along which to generate the logspace.",
        "parameters": {},
        "returns": "An array of logarithm.\nSee also:\n- :func:`jax.numpy.arange`: Generate ``N`` evenly-spaced values given a starting\npoint and a step value.\n- :func:`jax.numpy.linspace`: Generate evenly-spaced values.\n- :func:`jax.numpy.geomspace`: Generate geometrically-spaced values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "List 5 logarithmically spaced values between 1 (``10 ** 0``) and 100\n(``10 ** 2``):\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.logspace(0, 2, 5)\nArray([  1.   ,   3.162,  10.   ,  31.623, 100.   ], dtype=float32)\nList 5 logarithmically-spaced values between 1(``10 ** 0``) and 100\n(``10 ** 2``), excluding endpoint:\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.logspace(0, 2, 5, endpoint=False)\nArray([ 1.   ,  2.512,  6.31 , 15.849, 39.811], dtype=float32)\nList 7 logarithmically-spaced values between 1 (``2 ** 0``) and 4 (``2 ** 2``)\nwith base 2:\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.logspace(0, 2, 7, base=2)\nArray([1.   , 1.26 , 1.587, 2.   , 2.52 , 3.175, 4.   ], dtype=float32)\nMulti-dimensional logspace:\n>>> start = jnp.array([0, 5])\n>>> stop = jnp.array([5, 0])\n>>> base = jnp.array([2, 3])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.logspace(start, stop, 5, base=base)\nArray([[  1.   , 243.   ],\n[  2.378,  61.547],\n[  5.657,  15.588],\n[ 13.454,   3.948],\n[ 32.   ,   1.   ]], dtype=float32)"
      }
    },
    {
      "name": "mask_indices",
      "signature": "mask_indices(n: 'int', mask_func: 'Callable[[ArrayLike, int], Array]', k: 'int' = 0, *, size: 'int | None' = None) -> 'tuple[Array, Array]'",
      "documentation": {
        "description": "Return indices of a mask of an (n, n) array.\nArgs:\nn: static integer array dimension.\nmask_func: a function that takes a shape ``(n, n)`` array and\nan optional offset ``k``, and returns a shape ``(n, n)`` mask.",
        "parameters": {},
        "returns": "a tuple of indices where ``mask_func`` is nonzero.\nSee also:\n- :func:`jax.numpy.triu_indices`: compute ``mask_indices`` for :func:`~jax.numpy.triu`.\n- :func:`jax.numpy.tril_indices`: compute ``mask_indices`` for :func:`~jax.numpy.tril`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ":func:`~jax.numpy.triu` and :func:`~jax.numpy.tril`.\nk: a scalar value passed to ``mask_func``.\nsize: optional argument specifying the static size of the output arrays.\nThis is passed to :func:`~jax.numpy.nonzero` when generating the indices\nfrom the mask.\nCalling ``mask_indices`` on built-in masking functions:\n>>> jnp.mask_indices(3, jnp.triu)\n(Array([0, 0, 0, 1, 1, 2], dtype=int32), Array([0, 1, 2, 1, 2, 2], dtype=int32))\n>>> jnp.mask_indices(3, jnp.tril)\n(Array([0, 1, 1, 2, 2, 2], dtype=int32), Array([0, 0, 1, 0, 1, 2], dtype=int32))\nCalling ``mask_indices`` on a custom masking function:\n>>> def mask_func(x, k=0):\n...   i = jnp.arange(x.shape[0])[:, None]\n...   j = jnp.arange(x.shape[1])\n...   return (i + 1) % (j + 1 + k) == 0\n>>> mask_func(jnp.ones((3, 3)))\nArray([[ True, False, False],\n[ True,  True, False],\n[ True, False,  True]], dtype=bool)\n>>> jnp.mask_indices(3, mask_func)\n(Array([0, 1, 1, 2, 2], dtype=int32), Array([0, 0, 1, 0, 2], dtype=int32))"
      }
    },
    {
      "name": "matmul",
      "signature": "matmul(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, precision: Union[NoneType, str, jax._src.lax.lax.Precision, tuple[str, str], tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision], jax._src.lax.lax.DotAlgorithm, jax._src.lax.lax.DotAlgorithmPreset] = None, preferred_element_type: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None) -> jax.Array",
      "documentation": {
        "description": "Perform a matrix multiplication.\nJAX implementation of :func:`numpy.matmul`.\nArgs:\na: first input array, of shape ``(N,)`` or ``(..., K, N)``.\nb: second input array. Must have shape ``(N,)`` or ``(..., N, M)``.\nIn the multi-dimensional case, leading dimensions must be broadcast-compatible\nwith the leading dimensions of ``a``.\nprecision: either ``None`` (default), which means the default precision for\nthe backend, a :class:`~jax.lax.Precision` enum value (``Precision.DEFAULT``,\n``Precision.HIGH`` or ``Precision.HIGHEST``) or a tuple of two\nsuch values indicating precision of ``a`` and ``b``.\npreferred_element_type: either ``None`` (default), which means the default\naccumulation type for the input types, or a datatype, indicating to\naccumulate results to and return a result with that datatype.",
        "parameters": {},
        "returns": "array containing the matrix product of the inputs. Shape is ``a.shape[:-1]``\nif ``b.ndim == 1``, otherwise the shape is ``(..., K, M)``, where leading\ndimensions of ``a`` and ``b`` are broadcast together.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.linalg.vecdot`: batched vector product.\n- :func:`jax.numpy.linalg.tensordot`: batched tensor product.\n- :func:`jax.lax.dot_general`: general N-dimensional batched dot product.",
        "notes": "",
        "examples": "Vector dot products:\n>>> a = jnp.array([1, 2, 3])\n>>> b = jnp.array([4, 5, 6])\n>>> jnp.matmul(a, b)\nArray(32, dtype=int32)\nMatrix dot product:\n>>> a = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> b = jnp.array([[1, 2],\n...                [3, 4],\n...                [5, 6]])\n>>> jnp.matmul(a, b)\nArray([[22, 28],\n[49, 64]], dtype=int32)\nFor convenience, in all cases you can do the same computation using\nthe ``@`` operator:\n>>> a @ b\nArray([[22, 28],\n[49, 64]], dtype=int32)"
      }
    },
    {
      "name": "matrix_transpose",
      "signature": "matrix_transpose(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Transpose the last two dimensions of an array.\nJAX implementation of :func:`numpy.matrix_transpose`, implemented in terms of\n:func:`jax.lax.transpose`.\nArgs:\nx: input array, Must have ``x.ndim >= 2``",
        "parameters": {},
        "returns": "matrix-transposed copy of the array.",
        "raises": "",
        "see_also": "- :attr:`jax.Array.mT`: same operation accessed via an :func:`~jax.Array` property.\n- :func:`jax.numpy.transpose`: general multi-axis transpose\nNote:\nUnlike :func:`numpy.matrix_transpose`, :func:`jax.numpy.matrix_transpose` will return a\ncopy rather than a view of the input array. However, under JIT, the compiler will\noptimize-away such copies when possible, so this doesn't have performance impacts in practice.",
        "notes": "",
        "examples": "Here is a 2x2x2 matrix representing a batched 2x2 matrix:\n>>> x = jnp.array([[[1, 2],\n...                 [3, 4]],\n...                [[5, 6],\n...                 [7, 8]]])\n>>> jnp.matrix_transpose(x)\nArray([[[1, 3],\n[2, 4]],\n<BLANKLINE>\n[[5, 7],\n[6, 8]]], dtype=int32)\nFor convenience, you can perform the same transpose via the :attr:`~jax.Array.mT`\nproperty of :class:`jax.Array`:\n>>> x.mT\nArray([[[1, 3],\n[2, 4]],\n<BLANKLINE>\n[[5, 7],\n[6, 8]]], dtype=int32)"
      }
    },
    {
      "name": "matvec",
      "signature": "matvec(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
      "documentation": {
        "description": "Batched matrix-vector product.\nJAX implementation of :func:`numpy.matvec`.\nArgs:\nx1: array of shape ``(..., M, N)``\nx2: array of shape ``(..., N)``. Leading dimensions must be broadcast-compatible\nwith leading dimensions of ``x1``.",
        "parameters": {},
        "returns": "An array of shape ``(..., M)`` containing the batched matrix-vector product.\nSee also:\n- :func:`jax.numpy.linalg.vecdot`: batched vector product.\n- :func:`jax.numpy.vecmat`: vector-matrix product.\n- :func:`jax.numpy.matmul`: general matrix multiplication.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Simple matrix-vector product:\n>>> x1 = jnp.array([[1, 2, 3],\n...                 [4, 5, 6]])\n>>> x2 = jnp.array([7, 8, 9])\n>>> jnp.matvec(x1, x2)\nArray([ 50, 122], dtype=int32)\nBatched matrix-vector product:\n>>> x2 = jnp.array([[7, 8, 9],\n...                 [5, 6, 7]])\n>>> jnp.matvec(x1, x2)\nArray([[ 50, 122],\n[ 38,  92]], dtype=int32)"
      }
    },
    {
      "name": "max",
      "signature": "max(a: 'ArrayLike', axis: 'Axis' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return the maximum of the array elements along a given axis.\nJAX implementation of :func:`numpy.max`.\nArgs:\na: Input array.\naxis: int or array, default=None. Axis along which the maximum to be computed.\nIf None, the maximum is computed along all the axes.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\ninitial: int or array, default=None. Initial value for the maximum.\nwhere: int or array of boolean dtype, default=None. The elements to be used\nin the maximum. Array should be broadcast compatible to the input.\n``initial`` must be specified when ``where`` is used.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array of maximum values along the given axis.\nSee also:\n- :func:`jax.numpy.min`: Compute the minimum of array elements along a given\naxis.\n- :func:`jax.numpy.sum`: Compute the sum of array elements along a given axis.\n- :func:`jax.numpy.prod`: Compute the product of array elements along a given\naxis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.max`` computes the maximum of elements along all the axes.\n>>> x = jnp.array([[9, 3, 4, 5],\n...                [5, 2, 7, 4],\n...                [8, 1, 3, 6]])\n>>> jnp.max(x)\nArray(9, dtype=int32)\nIf ``axis=1``, the maximum will be computed along axis 1.\n>>> jnp.max(x, axis=1)\nArray([9, 7, 8], dtype=int32)\nIf ``keepdims=True``, ``ndim`` of the output will be same of that of the input.\n>>> jnp.max(x, axis=1, keepdims=True)\nArray([[9],\n[7],\n[8]], dtype=int32)\nTo include only specific elements in computing the maximum, you can use\n``where``. It can either have same dimension as input\n>>> where=jnp.array([[0, 0, 1, 0],\n...                  [0, 0, 1, 1],\n...                  [1, 1, 1, 0]], dtype=bool)\n>>> jnp.max(x, axis=1, keepdims=True, initial=0, where=where)\nArray([[4],\n[7],\n[8]], dtype=int32)\nor must be broadcast compatible with input.\n>>> where = jnp.array([[False],\n...                    [False],\n...                    [False]])\n>>> jnp.max(x, axis=0, keepdims=True, initial=0, where=where)\nArray([[0, 0, 0, 0]], dtype=int32)"
      }
    },
    {
      "name": "maximum",
      "signature": "maximum(x: 'ArrayLike', y: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return element-wise maximum of the input arrays.\nJAX implementation of :obj:`numpy.maximum`.\nArgs:\nx: input array or scalar.\ny: input array or scalar. Both ``x`` and ``y`` should either have same shape\nor be broadcast compatible.",
        "parameters": {},
        "returns": "An array containing the element-wise maximum of ``x`` and ``y``.\nNote:\nFor each pair of elements, ``jnp.maximum`` returns:\n- larger of the two if both elements are finite numbers.\n- ``nan`` if one element is ``nan``.\nSee also:\n- :func:`jax.numpy.minimum`: Returns element-wise minimum of the input\narrays.\n- :func:`jax.numpy.fmax`: Returns element-wise maximum of the input arrays,\nignoring NaNs.\n- :func:`jax.numpy.amax`: Retruns the maximum of array elements along a given\naxis.\n- :func:`jax.numpy.nanmax`: Returns the maximum of the array elements along\na given axis, ignoring NaNs.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Inputs with ``x.shape == y.shape``:\n>>> x = jnp.array([1, -5, 3, 2])\n>>> y = jnp.array([-2, 4, 7, -6])\n>>> jnp.maximum(x, y)\nArray([1, 4, 7, 2], dtype=int32)\nInputs with broadcast compatibility:\n>>> x1 = jnp.array([[-2, 5, 7, 4],\n...                 [1, -6, 3, 8]])\n>>> y1 = jnp.array([-5, 3, 6, 9])\n>>> jnp.maximum(x1, y1)\nArray([[-2,  5,  7,  9],\n[ 1,  3,  6,  9]], dtype=int32)\nInputs having ``nan``:\n>>> nan = jnp.nan\n>>> x2 = jnp.array([nan, -3, 9])\n>>> y2 = jnp.array([[4, -2, nan],\n...                 [-3, -5, 10]])\n>>> jnp.maximum(x2, y2)\nArray([[nan, -2., nan],\n[nan, -3., 10.]], dtype=float32)"
      }
    },
    {
      "name": "mean",
      "signature": "mean(a: 'ArrayLike', axis: 'Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, keepdims: 'bool' = False, *, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return the mean of array elements along a given axis.\nJAX implementation of :func:`numpy.mean`.\nArgs:\na: input array.\naxis: optional, int or sequence of ints, default=None. Axis along which the\nmean to be computed. If None, mean is computed along all the axes.\ndtype: The type of the output array. If None (default) then the output dtype\nwill be match the input dtype for floating point inputs, or be set to float32\nor float64 for non-floating-point inputs.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\nwhere: optional, boolean array, default=None. The elements to be used in the\nmean. Array should be broadcast compatible to the input.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array of the mean along the given axis.",
        "raises": "",
        "see_also": "",
        "notes": "For inputs of type `float16` or `bfloat16`, the reductions will be performed at\nfloat32 precision.\nSee also:\n- :func:`jax.numpy.average`: Compute the weighted average of array elements\n- :func:`jax.numpy.sum`: Compute the sum of array elements.",
        "examples": "By default, the mean is computed along all the axes.\n>>> x = jnp.array([[1, 3, 4, 2],\n...                [5, 2, 6, 3],\n...                [8, 1, 2, 9]])\n>>> jnp.mean(x)\nArray(3.8333335, dtype=float32)\nIf ``axis=1``, the mean is computed along axis 1.\n>>> jnp.mean(x, axis=1)\nArray([2.5, 4. , 5. ], dtype=float32)\nIf ``keepdims=True``, ``ndim`` of the output is equal to that of the input.\n>>> jnp.mean(x, axis=1, keepdims=True)\nArray([[2.5],\n[4. ],\n[5. ]], dtype=float32)\nTo use only specific elements of ``x`` to compute the mean, you can use\n``where``.\n>>> where = jnp.array([[1, 0, 1, 0],\n...                    [0, 1, 0, 1],\n...                    [1, 1, 0, 1]], dtype=bool)\n>>> jnp.mean(x, axis=1, keepdims=True, where=where)\nArray([[2.5],\n[2.5],\n[6. ]], dtype=float32)"
      }
    },
    {
      "name": "median",
      "signature": "median(a: 'ArrayLike', axis: 'int | tuple[int, ...] | None' = None, out: 'None' = None, overwrite_input: 'bool' = False, keepdims: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "Return the median of array elements along a given axis.\nJAX implementation of :func:`numpy.median`.\nArgs:\na: input array.\naxis: optional, int or sequence of ints, default=None. Axis along which the\nmedian to be computed. If None, median is computed for the flattened array.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\nout: Unused by JAX.\noverwrite_input: Unused by JAX.",
        "parameters": {},
        "returns": "An array of the median along the given axis.\nSee also:\n- :func:`jax.numpy.mean`: Compute the mean of array elements over a given axis.\n- :func:`jax.numpy.max`: Compute the maximum of array elements over given axis.\n- :func:`jax.numpy.min`: Compute the minimum of array elements over given axis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, the median is computed for the flattened array.\n>>> x = jnp.array([[2, 4, 7, 1],\n...                [3, 5, 9, 2],\n...                [6, 1, 8, 3]])\n>>> jnp.median(x)\nArray(3.5, dtype=float32)\nIf ``axis=1``, the median is computed along axis 1.\n>>> jnp.median(x, axis=1)\nArray([3. , 4. , 4.5], dtype=float32)\nIf ``keepdims=True``, ``ndim`` of the output is equal to that of the input.\n>>> jnp.median(x, axis=1, keepdims=True)\nArray([[3. ],\n[4. ],\n[4.5]], dtype=float32)"
      }
    },
    {
      "name": "meshgrid",
      "signature": "meshgrid(*xi: 'ArrayLike', copy: 'bool' = True, sparse: 'bool' = False, indexing: 'str' = 'xy') -> 'list[Array]'",
      "documentation": {
        "description": "Construct N-dimensional grid arrays from N 1-dimensional vectors.\nJAX implementation of :func:`numpy.meshgrid`.\nArgs:\nxi: N arrays to convert to a grid.\ncopy: whether to copy the input arrays. JAX supports only ``copy=True``,\nthough under JIT compilation the compiler may opt to avoid copies.\nsparse: if False (default), then each returned arrays will be of shape\n``[len(x1), len(x2), ..., len(xN)]``. If False, then returned arrays\nwill be of shape ``[1, 1, ..., len(xi), ..., 1, 1]``.\nindexing: options are ``'xy'`` for cartesian indexing (default) or ``'ij'``\nfor matrix indexing.",
        "parameters": {},
        "returns": "A length-N list of grid arrays.\nSee also:\n- :func:`jax.numpy.indices`: generate a grid of indices.\n- :obj:`jax.numpy.mgrid`: create a meshgrid using indexing syntax.\n- :obj:`jax.numpy.ogrid`: create an open meshgrid using indexing syntax.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "For the following examples, we'll use these 1D arrays as inputs:\n>>> x = jnp.array([1, 2])\n>>> y = jnp.array([10, 20, 30])\n2D cartesian mesh grid:\n>>> x_grid, y_grid = jnp.meshgrid(x, y)\n>>> print(x_grid)\n[[1 2]\n[1 2]\n[1 2]]\n>>> print(y_grid)\n[[10 10]\n[20 20]\n[30 30]]\n2D sparse cartesian mesh grid:\n>>> x_grid, y_grid = jnp.meshgrid(x, y, sparse=True)\n>>> print(x_grid)\n[[1 2]]\n>>> print(y_grid)\n[[10]\n[20]\n[30]]\n2D matrix-index mesh grid:\n>>> x_grid, y_grid = jnp.meshgrid(x, y, indexing='ij')\n>>> print(x_grid)\n[[1 1 1]\n[2 2 2]]\n>>> print(y_grid)\n[[10 20 30]\n[10 20 30]]"
      }
    },
    {
      "name": "min",
      "signature": "min(a: 'ArrayLike', axis: 'Axis' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return the minimum of array elements along a given axis.\nJAX implementation of :func:`numpy.min`.\nArgs:\na: Input array.\naxis: int or array, default=None. Axis along which the minimum to be computed.\nIf None, the minimum is computed along all the axes.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\ninitial: int or array, Default=None. Initial value for the minimum.\nwhere: int or array, default=None. The elements to be used in the minimum.\nArray should be broadcast compatible to the input. ``initial`` must be\nspecified when ``where`` is used.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array of minimum values along the given axis.\nSee also:\n- :func:`jax.numpy.max`: Compute the maximum of array elements along a given\naxis.\n- :func:`jax.numpy.sum`: Compute the sum of array elements along a given axis.\n- :func:`jax.numpy.prod`: Compute the product of array elements along a given\naxis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, the minimum is computed along all the axes.\n>>> x = jnp.array([[2, 5, 1, 6],\n...                [3, -7, -2, 4],\n...                [8, -4, 1, -3]])\n>>> jnp.min(x)\nArray(-7, dtype=int32)\nIf ``axis=1``, the minimum is computed along axis 1.\n>>> jnp.min(x, axis=1)\nArray([ 1, -7, -4], dtype=int32)\nIf ``keepdims=True``, ``ndim`` of the output will be same of that of the input.\n>>> jnp.min(x, axis=1, keepdims=True)\nArray([[ 1],\n[-7],\n[-4]], dtype=int32)\nTo include only specific elements in computing the minimum, you can use\n``where``. ``where`` can either have same dimension as input.\n>>> where=jnp.array([[1, 0, 1, 0],\n...                  [0, 0, 1, 1],\n...                  [1, 1, 1, 0]], dtype=bool)\n>>> jnp.min(x, axis=1, keepdims=True, initial=0, where=where)\nArray([[ 0],\n[-2],\n[-4]], dtype=int32)\nor must be broadcast compatible with input.\n>>> where = jnp.array([[False],\n...                    [False],\n...                    [False]])\n>>> jnp.min(x, axis=0, keepdims=True, initial=0, where=where)\nArray([[0, 0, 0, 0]], dtype=int32)"
      }
    },
    {
      "name": "minimum",
      "signature": "minimum(x: 'ArrayLike', y: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return element-wise minimum of the input arrays.\nJAX implementation of :obj:`numpy.minimum`.\nArgs:\nx: input array or scalar.\ny: input array or scalar. Both ``x`` and ``y`` should either have same shape\nor be broadcast compatible.",
        "parameters": {},
        "returns": "An array containing the element-wise minimum of ``x`` and ``y``.\nNote:\nFor each pair of elements, ``jnp.minimum`` returns:\n- smaller of the two if both elements are finite numbers.\n- ``nan`` if one element is ``nan``.\nSee also:\n- :func:`jax.numpy.maximum`: Returns element-wise maximum of the input arrays.\n- :func:`jax.numpy.fmin`: Returns element-wise minimum of the input arrays,\nignoring NaNs.\n- :func:`jax.numpy.amin`: Returns the minimum of array elements along a given\naxis.\n- :func:`jax.numpy.nanmin`: Returns the minimum of the array elements along\na given axis, ignoring NaNs.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Inputs with ``x.shape == y.shape``:\n>>> x = jnp.array([2, 3, 5, 1])\n>>> y = jnp.array([-3, 6, -4, 7])\n>>> jnp.minimum(x, y)\nArray([-3,  3, -4,  1], dtype=int32)\nInputs having broadcast compatibility:\n>>> x1 = jnp.array([[1, 5, 2],\n...                 [-3, 4, 7]])\n>>> y1 = jnp.array([-2, 3, 6])\n>>> jnp.minimum(x1, y1)\nArray([[-2,  3,  2],\n[-3,  3,  6]], dtype=int32)\nInputs with ``nan``:\n>>> nan = jnp.nan\n>>> x2 = jnp.array([[2.5, nan, -2],\n...                 [nan, 5, 6],\n...                 [-4, 3, 7]])\n>>> y2 = jnp.array([1, nan, 5])\n>>> jnp.minimum(x2, y2)\nArray([[ 1., nan, -2.],\n[nan, nan,  5.],\n[-4., nan,  5.]], dtype=float32)"
      }
    },
    {
      "name": "mod",
      "signature": "mod(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.remainder`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "modf",
      "signature": "modf(x: 'ArrayLike', /, out=None) -> 'tuple[Array, Array]'",
      "documentation": {
        "description": "Return element-wise fractional and integral parts of the input array.\nJAX implementation of :obj:`numpy.modf`.\nArgs:\nx: input array or scalar.\nout: Not used by JAX.",
        "parameters": {},
        "returns": "An array containing the fractional and integral parts of the elements of ``x``,\npromoting dtypes inexact.\nSee also:\n- :func:`jax.numpy.divmod`: Calculates the integer quotient and remainder of\n``x1`` by ``x2`` element-wise.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.modf(4.8)\n(Array(0.8000002, dtype=float32, weak_type=True), Array(4., dtype=float32, weak_type=True))\n>>> x = jnp.array([-3.4, -5.7, 0.6, 1.5, 2.3])\n>>> jnp.modf(x)\n(Array([-0.4000001 , -0.6999998 ,  0.6       ,  0.5       ,  0.29999995],      dtype=float32), Array([-3., -5.,  0.,  1.,  2.], dtype=float32))"
      }
    },
    {
      "name": "moveaxis",
      "signature": "moveaxis(a: 'ArrayLike', source: 'int | Sequence[int]', destination: 'int | Sequence[int]') -> 'Array'",
      "documentation": {
        "description": "Move an array axis to a new position\nJAX implementation of :func:`numpy.moveaxis`, implemented in terms of\n:func:`jax.lax.transpose`.\nArgs:\na: input array\nsource: index or indices of the axes to move.\ndestination: index or indices of the axes destinations",
        "parameters": {},
        "returns": "Copy of ``a`` with axes moved from ``source`` to ``destination``.",
        "raises": "",
        "see_also": "",
        "notes": "Unlike :func:`numpy.moveaxis`, :func:`jax.numpy.moveaxis` will return a copy rather\nthan a view of the input array. However, under JIT, the compiler will optimize away\nsuch copies when possible, so this doesn't have performance impacts in practice.\nSee also:\n- :func:`jax.numpy.swapaxes`: swap two axes.\n- :func:`jax.numpy.rollaxis`: older API for moving an axis.\n- :func:`jax.numpy.transpose`: general axes permutation.",
        "examples": ">>> a = jnp.ones((2, 3, 4, 5))\nMove axis ``1`` to the end of the array:\n>>> jnp.moveaxis(a, 1, -1).shape\n(2, 4, 5, 3)\nMove the last axis to position 1:\n>>> jnp.moveaxis(a, -1, 1).shape\n(2, 5, 3, 4)\nMove multiple axes:\n>>> jnp.moveaxis(a, (0, 1), (-1, -2)).shape\n(4, 5, 3, 2)\nThis can also be accomplished via :func:`~jax.numpy.transpose`:\n>>> a.transpose(2, 3, 1, 0).shape\n(4, 5, 3, 2)"
      }
    },
    {
      "name": "multiply",
      "signature": "multiply(*args: 'ArrayLike', out: 'None' = None, where: 'None' = None) -> 'Any'",
      "documentation": {
        "description": "Multiply two arrays element-wise.\nJAX implementation of :obj:`numpy.multiply`. This is a universal function,\nand supports the additional APIs described at :class:`jax.numpy.ufunc`.\nThis function provides the implementation of the ``*`` operator for\nJAX arrays.\nArgs:\nx, y: arrays to multiply. Must be broadcastable to a common shape.",
        "parameters": {},
        "returns": "Array containing the result of the element-wise multiplication.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Calling ``multiply`` explicitly:\n>>> x = jnp.arange(4)\n>>> jnp.multiply(x, 10)\nArray([ 0, 10, 20, 30], dtype=int32)\nCalling ``multiply`` via the ``*`` operator:\n>>> x * 10\nArray([ 0, 10, 20, 30], dtype=int32)"
      }
    },
    {
      "name": "nan_to_num",
      "signature": "nan_to_num(x: 'ArrayLike', copy: 'bool' = True, nan: 'ArrayLike' = 0.0, posinf: 'ArrayLike | None' = None, neginf: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Replace NaN and infinite entries in an array.\nJAX implementation of :func:`numpy.nan_to_num`.\nArgs:\nx: array of values to be replaced. If it does not have an inexact\ndtype it will be returned unmodified.\ncopy: unused by JAX\nnan: value to substitute for NaN entries. Defaults to 0.0.\nposinf: value to substitute for positive infinite entries.\nDefaults to the maximum representable value.\nneginf: value to substitute for positive infinite entries.\nDefaults to the minimum representable value.",
        "parameters": {},
        "returns": "A copy of ``x`` with the requested substitutions.\nSee also:\n- :func:`jax.numpy.isnan`: return True where the array contains NaN\n- :func:`jax.numpy.isposinf`: return True where the array contains +inf\n- :func:`jax.numpy.isneginf`: return True where the array contains -inf",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([0, jnp.nan, 1, jnp.inf, 2, -jnp.inf])\nDefault substitution values:\n>>> jnp.nan_to_num(x)\nArray([ 0.0000000e+00,  0.0000000e+00,  1.0000000e+00,  3.4028235e+38,\n2.0000000e+00, -3.4028235e+38], dtype=float32)\nOverriding substitutions for ``-inf`` and ``+inf``:\n>>> jnp.nan_to_num(x, posinf=999, neginf=-999)\nArray([   0.,    0.,    1.,  999.,    2., -999.], dtype=float32)\nIf you only wish to substitute for NaN values while leaving ``inf`` values\nuntouched, using :func:`~jax.numpy.where` with :func:`jax.numpy.isnan` is\na better option:\n>>> jnp.where(jnp.isnan(x), 0, x)\nArray([  0.,   0.,   1.,  inf,   2., -inf], dtype=float32)"
      }
    },
    {
      "name": "nanargmax",
      "signature": "nanargmax(a: 'ArrayLike', axis: 'int | None' = None, out: 'None' = None, keepdims: 'bool | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return the index of the maximum value of an array, ignoring NaNs.\nJAX implementation of :func:`numpy.nanargmax`.\nArgs:\na: input array\naxis: optional integer specifying the axis along which to find the maximum\nvalue. If ``axis`` is not specified, ``a`` will be flattened.\nout: unused by JAX\nkeepdims: if True, then return an array with the same number of dimensions\nas ``a``.",
        "parameters": {},
        "returns": "an array containing the index of the maximum value along the specified axis.\nNote:\nIn the case of an axis with all-NaN values, the returned index will be -1.\nThis differs from the behavior of :func:`numpy.nanargmax`, which raises an error.\nSee also:\n- :func:`jax.numpy.argmax`: return the index of the maximum value.\n- :func:`jax.numpy.nanargmin`: compute ``argmin`` while ignoring NaN values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([1, 3, 5, 4, jnp.nan])\nUsing a standard :func:`~jax.numpy.argmax` leads to potentially unexpected results:\n>>> jnp.argmax(x)\nArray(4, dtype=int32)\nUsing ``nanargmax`` returns the index of the maximum non-NaN value.\n>>> jnp.nanargmax(x)\nArray(2, dtype=int32)\n>>> x = jnp.array([[1, 3, jnp.nan],\n...                [5, 4, jnp.nan]])\n>>> jnp.nanargmax(x, axis=1)\nArray([1, 0], dtype=int32)\n>>> jnp.nanargmax(x, axis=1, keepdims=True)\nArray([[1],\n[0]], dtype=int32)"
      }
    },
    {
      "name": "nanargmin",
      "signature": "nanargmin(a: 'ArrayLike', axis: 'int | None' = None, out: 'None' = None, keepdims: 'bool | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return the index of the minimum value of an array, ignoring NaNs.\nJAX implementation of :func:`numpy.nanargmin`.\nArgs:\na: input array\naxis: optional integer specifying the axis along which to find the maximum\nvalue. If ``axis`` is not specified, ``a`` will be flattened.\nout: unused by JAX\nkeepdims: if True, then return an array with the same number of dimensions\nas ``a``.",
        "parameters": {},
        "returns": "an array containing the index of the minimum value along the specified axis.\nNote:\nIn the case of an axis with all-NaN values, the returned index will be -1.\nThis differs from the behavior of :func:`numpy.nanargmin`, which raises an error.\nSee also:\n- :func:`jax.numpy.argmin`: return the index of the minimum value.\n- :func:`jax.numpy.nanargmax`: compute ``argmax`` while ignoring NaN values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([jnp.nan, 3, 5, 4, 2])\n>>> jnp.nanargmin(x)\nArray(4, dtype=int32)\n>>> x = jnp.array([[1, 3, jnp.nan],\n...                [5, 4, jnp.nan]])\n>>> jnp.nanargmin(x, axis=1)\nArray([0, 1], dtype=int32)\n>>> jnp.nanargmin(x, axis=1, keepdims=True)\nArray([[0],\n[1]], dtype=int32)"
      }
    },
    {
      "name": "nancumprod",
      "signature": "nancumprod(a: 'ArrayLike', axis: 'int | None' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None) -> 'Array'",
      "documentation": {
        "description": "Cumulative product of elements along an axis, ignoring NaN values.\nJAX implementation of :func:`numpy.nancumprod`.\nArgs:\na: N-dimensional array to be accumulated.\naxis: integer axis along which to accumulate. If None (default), then\narray will be flattened and accumulated along the flattened axis.\ndtype: optionally specify the dtype of the output. If not specified,\nthen the output dtype will match the input dtype.\nout: unused by JAX",
        "parameters": {},
        "returns": "An array containing the accumulated product along the given axis.\nSee also:\n- :func:`jax.numpy.cumprod`: cumulative product without ignoring NaN values.\n- :meth:`jax.numpy.multiply.accumulate`: cumulative product via ufunc methods.\n- :func:`jax.numpy.prod`: product along axis",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[1., 2., jnp.nan],\n...                [4., jnp.nan, 6.]])\nThe standard cumulative product will propagate NaN values:\n>>> jnp.cumprod(x)\nArray([ 1.,  2., nan, nan, nan, nan], dtype=float32)\n:func:`~jax.numpy.nancumprod` will ignore NaN values, effectively replacing\nthem with ones:\n>>> jnp.nancumprod(x)\nArray([ 1.,  2.,  2.,  8.,  8., 48.], dtype=float32)\nCumulative product along axis 1:\n>>> jnp.nancumprod(x, axis=1)\nArray([[ 1.,  2.,  2.],\n[ 4.,  4., 24.]], dtype=float32)"
      }
    },
    {
      "name": "nancumsum",
      "signature": "nancumsum(a: 'ArrayLike', axis: 'int | None' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None) -> 'Array'",
      "documentation": {
        "description": "Cumulative sum of elements along an axis, ignoring NaN values.\nJAX implementation of :func:`numpy.nancumsum`.\nArgs:\na: N-dimensional array to be accumulated.\naxis: integer axis along which to accumulate. If None (default), then\narray will be flattened and accumulated along the flattened axis.\ndtype: optionally specify the dtype of the output. If not specified,\nthen the output dtype will match the input dtype.\nout: unused by JAX",
        "parameters": {},
        "returns": "An array containing the accumulated sum along the given axis.\nSee also:\n- :func:`jax.numpy.cumsum`: cumulative sum without ignoring NaN values.\n- :func:`jax.numpy.cumulative_sum`: cumulative sum via the array API standard.\n- :meth:`jax.numpy.add.accumulate`: cumulative sum via ufunc methods.\n- :func:`jax.numpy.sum`: sum along axis",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[1., 2., jnp.nan],\n...                [4., jnp.nan, 6.]])\nThe standard cumulative sum will propagate NaN values:\n>>> jnp.cumsum(x)\nArray([ 1.,  3., nan, nan, nan, nan], dtype=float32)\n:func:`~jax.numpy.nancumsum` will ignore NaN values, effectively replacing\nthem with zeros:\n>>> jnp.nancumsum(x)\nArray([ 1.,  3.,  3.,  7.,  7., 13.], dtype=float32)\nCumulative sum along axis 1:\n>>> jnp.nancumsum(x, axis=1)\nArray([[ 1.,  3.,  3.],\n[ 4.,  4., 10.]], dtype=float32)"
      }
    },
    {
      "name": "nanmax",
      "signature": "nanmax(a: 'ArrayLike', axis: 'Axis' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return the maximum of the array elements along a given axis, ignoring NaNs.\nJAX implementation of :func:`numpy.nanmax`.\nArgs:\na: Input array.\naxis: int or sequence of ints, default=None. Axis along which the maximum is\ncomputed. If None, the maximum is computed along the flattened array.\nkeepdims: bool, default=False. If True, reduced axes are left in the result\nwith size 1.\ninitial: int or array, default=None. Initial value for the maximum.\nwhere: array of boolean dtype, default=None. The elements to be used in the\nmaximum. Array should be broadcast compatible to the input. ``initial``\nmust be specified when ``where`` is used.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array of maximum values along the given axis, ignoring NaNs. If all values\nare NaNs along the given axis, returns ``nan``.\nSee also:\n- :func:`jax.numpy.nanmin`: Compute the minimum of array elements along a\ngiven axis, ignoring NaNs.\n- :func:`jax.numpy.nansum`: Compute the sum of array elements along a given\naxis, ignoring NaNs.\n- :func:`jax.numpy.nanprod`: Compute the product of array elements along a\ngiven axis, ignoring NaNs.\n- :func:`jax.numpy.nanmean`: Compute the mean of array elements along a given\naxis, ignoring NaNs.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.nanmax`` computes the maximum of elements along the flattened\narray.\n>>> nan = jnp.nan\n>>> x = jnp.array([[8, nan, 4, 6],\n...                [nan, -2, nan, -4],\n...                [-2, 1, 7, nan]])\n>>> jnp.nanmax(x)\nArray(8., dtype=float32)\nIf ``axis=1``, the maximum will be computed along axis 1.\n>>> jnp.nanmax(x, axis=1)\nArray([ 8., -2.,  7.], dtype=float32)\nIf ``keepdims=True``, ``ndim`` of the output will be same of that of the input.\n>>> jnp.nanmax(x, axis=1, keepdims=True)\nArray([[ 8.],\n[-2.],\n[ 7.]], dtype=float32)\nTo include only specific elements in computing the maximum, you can use\n``where``. It can either have same dimension as input\n>>> where=jnp.array([[0, 0, 1, 0],\n...                  [0, 0, 1, 1],\n...                  [1, 1, 1, 0]], dtype=bool)\n>>> jnp.nanmax(x, axis=1, keepdims=True, initial=0, where=where)\nArray([[4.],\n[0.],\n[7.]], dtype=float32)\nor must be broadcast compatible with input.\n>>> where = jnp.array([[True],\n...                    [False],\n...                    [False]])\n>>> jnp.nanmax(x, axis=0, keepdims=True, initial=0, where=where)\nArray([[8., 0., 4., 6.]], dtype=float32)"
      }
    },
    {
      "name": "nanmean",
      "signature": "nanmean(a: 'ArrayLike', axis: 'Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, keepdims: 'bool' = False, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return the mean of the array elements along a given axis, ignoring NaNs.\nJAX implementation of :func:`numpy.nanmean`.\nArgs:\na: Input array.\naxis: int or sequence of ints, default=None. Axis along which the mean is\ncomputed. If None, the mean is computed along the flattened array.\ndtype: The type of the output array. Default=None.\nkeepdims: bool, default=False. If True, reduced axes are left in the result\nwith size 1.\nwhere: array of boolean dtype, default=None. The elements to be used in\ncomputing mean. Array should be broadcast compatible to the input.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array containing the mean of array elements along the given axis, ignoring\nNaNs. If all elements along the given axis are NaNs, returns ``nan``.\nSee also:\n- :func:`jax.numpy.nanmin`: Compute the minimum of array elements along a\ngiven axis, ignoring NaNs.\n- :func:`jax.numpy.nanmax`: Compute the maximum of array elements along a\ngiven axis, ignoring NaNs.\n- :func:`jax.numpy.nansum`: Compute the sum of array elements along a given\naxis, ignoring NaNs.\n- :func:`jax.numpy.nanprod`: Compute the product of array elements along a\ngiven axis, ignoring NaNs.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.nanmean`` computes the mean of elements along the flattened\narray.\n>>> nan = jnp.nan\n>>> x = jnp.array([[2, nan, 4, 3],\n...                [nan, -2, nan, 9],\n...                [4, -7, 6, nan]])\n>>> jnp.nanmean(x)\nArray(2.375, dtype=float32)\nIf ``axis=1``, mean will be computed along axis 1.\n>>> jnp.nanmean(x, axis=1)\nArray([3. , 3.5, 1. ], dtype=float32)\nIf ``keepdims=True``, ``ndim`` of the output will be same of that of the input.\n>>> jnp.nanmean(x, axis=1, keepdims=True)\nArray([[3. ],\n[3.5],\n[1. ]], dtype=float32)\n``where`` can be used to include only specific elements in computing the mean.\n>>> where = jnp.array([[1, 0, 1, 0],\n...                    [0, 0, 1, 1],\n...                    [1, 1, 0, 1]], dtype=bool)\n>>> jnp.nanmean(x, axis=1, keepdims=True, where=where)\nArray([[ 3. ],\n[ 9. ],\n[-1.5]], dtype=float32)\nIf ``where`` is ``False`` at all elements, ``jnp.nanmean`` returns ``nan``\nalong the given axis.\n>>> where = jnp.array([[False],\n...                    [False],\n...                    [False]])\n>>> jnp.nanmean(x, axis=0, keepdims=True, where=where)\nArray([[nan, nan, nan, nan]], dtype=float32)"
      }
    },
    {
      "name": "nanmedian",
      "signature": "nanmedian(a: 'ArrayLike', axis: 'int | tuple[int, ...] | None' = None, out: 'None' = None, overwrite_input: 'bool' = False, keepdims: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "Return the median of array elements along a given axis, ignoring NaNs.\nJAX implementation of :func:`numpy.nanmedian`.\nArgs:\na: input array.\naxis: optional, int or sequence of ints, default=None. Axis along which the\nmedian to be computed. If None, median is computed for the flattened array.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\nout: Unused by JAX.\noverwrite_input: Unused by JAX.",
        "parameters": {},
        "returns": "An array containing the median along the given axis, ignoring NaNs. If all\nelements along the given axis are NaNs, returns ``nan``.\nSee also:\n- :func:`jax.numpy.nanmean`: Compute the mean of array elements over a given\naxis, ignoring NaNs.\n- :func:`jax.numpy.nanmax`: Compute the maximum of array elements over given\naxis, ignoring NaNs.\n- :func:`jax.numpy.nanmin`: Compute the minimum of array elements over given\naxis, ignoring NaNs.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, the median is computed for the flattened array.\n>>> nan = jnp.nan\n>>> x = jnp.array([[2, nan, 7, nan],\n...                [nan, 5, 9, 2],\n...                [6, 1, nan, 3]])\n>>> jnp.nanmedian(x)\nArray(4., dtype=float32)\nIf ``axis=1``, the median is computed along axis 1.\n>>> jnp.nanmedian(x, axis=1)\nArray([4.5, 5. , 3. ], dtype=float32)\nIf ``keepdims=True``, ``ndim`` of the output is equal to that of the input.\n>>> jnp.nanmedian(x, axis=1, keepdims=True)\nArray([[4.5],\n[5. ],\n[3. ]], dtype=float32)"
      }
    },
    {
      "name": "nanmin",
      "signature": "nanmin(a: 'ArrayLike', axis: 'Axis' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return the minimum of the array elements along a given axis, ignoring NaNs.\nJAX implementation of :func:`numpy.nanmin`.\nArgs:\na: Input array.\naxis: int or sequence of ints, default=None. Axis along which the minimum is\ncomputed. If None, the minimum is computed along the flattened array.\nkeepdims: bool, default=False. If True, reduced axes are left in the result\nwith size 1.\ninitial: int or array, default=None. Initial value for the minimum.\nwhere: array of boolean dtype, default=None. The elements to be used in the\nminimum. Array should be broadcast compatible to the input. ``initial``\nmust be specified when ``where`` is used.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array of minimum values along the given axis, ignoring NaNs. If all values\nare NaNs along the given axis, returns ``nan``.\nSee also:\n- :func:`jax.numpy.nanmax`: Compute the maximum of array elements along a\ngiven axis, ignoring NaNs.\n- :func:`jax.numpy.nansum`: Compute the sum of array elements along a given\naxis, ignoring NaNs.\n- :func:`jax.numpy.nanprod`: Compute the product of array elements along a\ngiven axis, ignoring NaNs.\n- :func:`jax.numpy.nanmean`: Compute the mean of array elements along a given\naxis, ignoring NaNs.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.nanmin`` computes the minimum of elements along the flattened\narray.\n>>> nan = jnp.nan\n>>> x = jnp.array([[1, nan, 4, 5],\n...                [nan, -2, nan, -4],\n...                [2, 1, 3, nan]])\n>>> jnp.nanmin(x)\nArray(-4., dtype=float32)\nIf ``axis=1``, the maximum will be computed along axis 1.\n>>> jnp.nanmin(x, axis=1)\nArray([ 1., -4.,  1.], dtype=float32)\nIf ``keepdims=True``, ``ndim`` of the output will be same of that of the input.\n>>> jnp.nanmin(x, axis=1, keepdims=True)\nArray([[ 1.],\n[-4.],\n[ 1.]], dtype=float32)\nTo include only specific elements in computing the maximum, you can use\n``where``. It can either have same dimension as input\n>>> where=jnp.array([[0, 0, 1, 0],\n...                  [0, 0, 1, 1],\n...                  [1, 1, 1, 0]], dtype=bool)\n>>> jnp.nanmin(x, axis=1, keepdims=True, initial=0, where=where)\nArray([[ 0.],\n[-4.],\n[ 0.]], dtype=float32)\nor must be broadcast compatible with input.\n>>> where = jnp.array([[False],\n...                    [True],\n...                    [False]])\n>>> jnp.nanmin(x, axis=0, keepdims=True, initial=0, where=where)\nArray([[ 0., -2.,  0., -4.]], dtype=float32)"
      }
    },
    {
      "name": "nanpercentile",
      "signature": "nanpercentile(a: 'ArrayLike', q: 'ArrayLike', axis: 'int | tuple[int, ...] | None' = None, out: 'None' = None, overwrite_input: 'bool' = False, method: 'str' = 'linear', keepdims: 'bool' = False, *, interpolation: 'str | DeprecatedArg' = Deprecated) -> 'Array'",
      "documentation": {
        "description": "Compute the percentile of the data along the specified axis, ignoring NaN values.\nJAX implementation of :func:`numpy.nanpercentile`.\nArgs:\na: N-dimensional array input.\nq: scalar or 1-dimensional array specifying the desired quantiles. ``q``\nshould contain integer or floating point values between ``0`` and ``100``.\naxis: optional axis or tuple of axes along which to compute the quantile\nout: not implemented by JAX; will error if not None\noverwrite_input: not implemented by JAX; will error if not False\nmethod: specify the interpolation method to use. Options are one of\n``[\"linear\", \"lower\", \"higher\", \"midpoint\", \"nearest\"]``.\ndefault is ``linear``.\nkeepdims: if True, then the returned array will have the same number of\ndimensions as the input. Default is False.\ninterpolation: deprecated alias of the ``method`` argument. Will result\nin a :class:`DeprecationWarning` if used.",
        "parameters": {},
        "returns": "An array containing the specified percentiles along the specified axes.\nSee also:\n- :func:`jax.numpy.nanquantile`: compute the nan-aware quantile (0.0-1.0)\n- :func:`jax.numpy.percentile`: compute the percentile without special\nhandling of NaNs.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Computing the median and quartiles of a 1D array:\n>>> x = jnp.array([0, 1, 2, jnp.nan, 3, 4, 5, 6])\n>>> q = jnp.array([25, 50, 75])\nBecause of the NaN value, :func:`jax.numpy.percentile` returns all NaNs,\nwhile :func:`~jax.numpy.nanpercentile` ignores them:\n>>> jnp.percentile(x, q)\nArray([nan, nan, nan], dtype=float32)\n>>> jnp.nanpercentile(x, q)\nArray([1.5, 3. , 4.5], dtype=float32)"
      }
    },
    {
      "name": "nanprod",
      "signature": "nanprod(a: 'ArrayLike', axis: 'Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return the product of the array elements along a given axis, ignoring NaNs.\nJAX implementation of :func:`numpy.nanprod`.\nArgs:\na: Input array.\naxis: int or sequence of ints, default=None. Axis along which the product is\ncomputed. If None, the product is computed along the flattened array.\ndtype: The type of the output array. Default=None.\nkeepdims: bool, default=False. If True, reduced axes are left in the result\nwith size 1.\ninitial: int or array, default=None. Initial value for the product.\nwhere: array of boolean dtype, default=None. The elements to be used in the\nproduct. Array should be broadcast compatible to the input.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array containing the product of array elements along the given axis,\nignoring NaNs. If all elements along the given axis are NaNs, returns 1.\nSee also:\n- :func:`jax.numpy.nanmin`: Compute the minimum of array elements along a\ngiven axis, ignoring NaNs.\n- :func:`jax.numpy.nanmax`: Compute the maximum of array elements along a\ngiven axis, ignoring NaNs.\n- :func:`jax.numpy.nansum`: Compute the sum of array elements along a given\naxis, ignoring NaNs.\n- :func:`jax.numpy.nanmean`: Compute the mean of array elements along a given\naxis, ignoring NaNs.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.nanprod`` computes the product of elements along the flattened\narray.\n>>> nan = jnp.nan\n>>> x = jnp.array([[nan, 3, 4, nan],\n...                [5, nan, 1, 3],\n...                [2, 1, nan, 1]])\n>>> jnp.nanprod(x)\nArray(360., dtype=float32)\nIf ``axis=1``, the product will be computed along axis 1.\n>>> jnp.nanprod(x, axis=1)\nArray([12., 15.,  2.], dtype=float32)\nIf ``keepdims=True``, ``ndim`` of the output will be same of that of the input.\n>>> jnp.nanprod(x, axis=1, keepdims=True)\nArray([[12.],\n[15.],\n[ 2.]], dtype=float32)\nTo include only specific elements in computing the maximum, you can use ``where``.\n>>> where=jnp.array([[1, 0, 1, 0],\n...                  [0, 0, 1, 1],\n...                  [1, 1, 1, 0]], dtype=bool)\n>>> jnp.nanprod(x, axis=1, keepdims=True, where=where)\nArray([[4.],\n[3.],\n[2.]], dtype=float32)\nIf ``where`` is ``False`` at all elements, ``jnp.nanprod`` returns 1 along\nthe given axis.\n>>> where = jnp.array([[False],\n...                    [False],\n...                    [False]])\n>>> jnp.nanprod(x, axis=0, keepdims=True, where=where)\nArray([[1., 1., 1., 1.]], dtype=float32)"
      }
    },
    {
      "name": "nanquantile",
      "signature": "nanquantile(a: 'ArrayLike', q: 'ArrayLike', axis: 'int | tuple[int, ...] | None' = None, out: 'None' = None, overwrite_input: 'bool' = False, method: 'str' = 'linear', keepdims: 'bool' = False, *, interpolation: 'DeprecatedArg | str' = Deprecated) -> 'Array'",
      "documentation": {
        "description": "Compute the quantile of the data along the specified axis, ignoring NaNs.\nJAX implementation of :func:`numpy.nanquantile`.\nArgs:\na: N-dimensional array input.\nq: scalar or 1-dimensional array specifying the desired quantiles. ``q``\nshould contain floating-point values between ``0.0`` and ``1.0``.\naxis: optional axis or tuple of axes along which to compute the quantile\nout: not implemented by JAX; will error if not None\noverwrite_input: not implemented by JAX; will error if not False\nmethod: specify the interpolation method to use. Options are one of\n``[\"linear\", \"lower\", \"higher\", \"midpoint\", \"nearest\"]``.\ndefault is ``linear``.\nkeepdims: if True, then the returned array will have the same number of\ndimensions as the input. Default is False.\ninterpolation: deprecated alias of the ``method`` argument. Will result\nin a :class:`DeprecationWarning` if used.",
        "parameters": {},
        "returns": "An array containing the specified quantiles along the specified axes.\nSee also:\n- :func:`jax.numpy.quantile`: compute the quantile without ignoring nans\n- :func:`jax.numpy.nanpercentile`: compute the percentile (0-100)",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Computing the median and quartiles of a 1D array:\n>>> x = jnp.array([0, 1, 2, jnp.nan, 3, 4, 5, 6])\n>>> q = jnp.array([0.25, 0.5, 0.75])\nBecause of the NaN value, :func:`jax.numpy.quantile` returns all NaNs,\nwhile :func:`~jax.numpy.nanquantile` ignores them:\n>>> jnp.quantile(x, q)\nArray([nan, nan, nan], dtype=float32)\n>>> jnp.nanquantile(x, q)\nArray([1.5, 3. , 4.5], dtype=float32)"
      }
    },
    {
      "name": "nanstd",
      "signature": "nanstd(a: 'ArrayLike', axis: 'Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, ddof: 'int' = 0, keepdims: 'bool' = False, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Compute the standard deviation along a given axis, ignoring NaNs.\nJAX implementation of :func:`numpy.nanstd`.\nArgs:\na: input array.\naxis: optional, int or sequence of ints, default=None. Axis along which the\nstandard deviation is computed. If None, standard deviaiton is computed\nalong flattened array.\ndtype: The type of the output array. Default=None.\nddof: int, default=0. Degrees of freedom. The divisor in the standard deviation\ncomputation is ``N-ddof``, ``N`` is number of elements along given axis.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\nwhere: optional, boolean array, default=None. The elements to be used in the\nstandard deviation. Array should be broadcast compatible to the input.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array containing the standard deviation of array elements along the given\naxis. If all elements along the given axis are NaNs, returns ``nan``.\nSee also:\n- :func:`jax.numpy.nanmean`: Compute the mean of array elements over a given\naxis, ignoring NaNs.\n- :func:`jax.numpy.nanvar`: Compute the variance along the given axis, ignoring\nNaNs values.\n- :func:`jax.numpy.std`: Computed the standard deviation along the given axis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.nanstd`` computes the standard deviation along flattened array.\n>>> nan = jnp.nan\n>>> x = jnp.array([[3, nan, 4, 5],\n...                [nan, 2, nan, 7],\n...                [2, 1, 6, nan]])\n>>> jnp.nanstd(x)\nArray(1.9843135, dtype=float32)\nIf ``axis=0``, computes standard deviation along axis 0.\n>>> jnp.nanstd(x, axis=0)\nArray([0.5, 0.5, 1. , 1. ], dtype=float32)\nTo preserve the dimensions of input, you can set ``keepdims=True``.\n>>> jnp.nanstd(x, axis=0, keepdims=True)\nArray([[0.5, 0.5, 1. , 1. ]], dtype=float32)\nIf ``ddof=1``:\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.nanstd(x, axis=0, keepdims=True, ddof=1))\n[[0.71 0.71 1.41 1.41]]\nTo include specific elements of the array to compute standard deviation, you\ncan use ``where``.\n>>> where=jnp.array([[1, 0, 1, 0],\n...                  [0, 1, 0, 1],\n...                  [1, 1, 0, 1]], dtype=bool)\n>>> jnp.nanstd(x, axis=0, keepdims=True, where=where)\nArray([[0.5, 0.5, 0. , 0. ]], dtype=float32)"
      }
    },
    {
      "name": "nansum",
      "signature": "nansum(a: 'ArrayLike', axis: 'Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return the sum of the array elements along a given axis, ignoring NaNs.\nJAX implementation of :func:`numpy.nansum`.\nArgs:\na: Input array.\naxis: int or sequence of ints, default=None. Axis along which the sum is\ncomputed. If None, the sum is computed along the flattened array.\ndtype: The type of the output array. Default=None.\nkeepdims: bool, default=False. If True, reduced axes are left in the result\nwith size 1.\ninitial: int or array, default=None. Initial value for the sum.\nwhere: array of boolean dtype, default=None. The elements to be used in the\nsum. Array should be broadcast compatible to the input.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array containing the sum of array elements along the given axis, ignoring\nNaNs. If all elements along the given axis are NaNs, returns 0.\nSee also:\n- :func:`jax.numpy.nanmin`: Compute the minimum of array elements along a\ngiven axis, ignoring NaNs.\n- :func:`jax.numpy.nanmax`: Compute the maximum of array elements along a\ngiven axis, ignoring NaNs.\n- :func:`jax.numpy.nanprod`: Compute the product of array elements along a\ngiven axis, ignoring NaNs.\n- :func:`jax.numpy.nanmean`: Compute the mean of array elements along a given\naxis, ignoring NaNs.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.nansum`` computes the sum of elements along the flattened\narray.\n>>> nan = jnp.nan\n>>> x = jnp.array([[3, nan, 4, 5],\n...                [nan, -2, nan, 7],\n...                [2, 1, 6, nan]])\n>>> jnp.nansum(x)\nArray(26., dtype=float32)\nIf ``axis=1``, the sum will be computed along axis 1.\n>>> jnp.nansum(x, axis=1)\nArray([12.,  5.,  9.], dtype=float32)\nIf ``keepdims=True``, ``ndim`` of the output will be same of that of the input.\n>>> jnp.nansum(x, axis=1, keepdims=True)\nArray([[12.],\n[ 5.],\n[ 9.]], dtype=float32)\nTo include only specific elements in computing the sum, you can use ``where``.\n>>> where=jnp.array([[1, 0, 1, 0],\n...                  [0, 0, 1, 1],\n...                  [1, 1, 1, 0]], dtype=bool)\n>>> jnp.nansum(x, axis=1, keepdims=True, where=where)\nArray([[7.],\n[7.],\n[9.]], dtype=float32)\nIf ``where`` is ``False`` at all elements, ``jnp.nansum`` returns 0 along\nthe given axis.\n>>> where = jnp.array([[False],\n...                    [False],\n...                    [False]])\n>>> jnp.nansum(x, axis=0, keepdims=True, where=where)\nArray([[0., 0., 0., 0.]], dtype=float32)"
      }
    },
    {
      "name": "nanvar",
      "signature": "nanvar(a: 'ArrayLike', axis: 'Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, ddof: 'int' = 0, keepdims: 'bool' = False, where: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Compute the variance of array elements along a given axis, ignoring NaNs.\nJAX implementation of :func:`numpy.nanvar`.\nArgs:\na: input array.\naxis: optional, int or sequence of ints, default=None. Axis along which the\nvariance is computed. If None, variance is computed along flattened array.\ndtype: The type of the output array. Default=None.\nddof: int, default=0. Degrees of freedom. The divisor in the variance computation\nis ``N-ddof``, ``N`` is number of elements along given axis.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\nwhere: optional, boolean array, default=None. The elements to be used in the\nvariance. Array should be broadcast compatible to the input.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array containing the variance of array elements along specified axis. If\nall elements along the given axis are NaNs, returns ``nan``.\nSee also:\n- :func:`jax.numpy.nanmean`: Compute the mean of array elements over a given\naxis, ignoring NaNs.\n- :func:`jax.numpy.nanstd`: Computed the standard deviation of a given axis,\nignoring NaNs.\n- :func:`jax.numpy.var`: Compute the variance of array elements along a given\naxis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.nanvar`` computes the variance along all axes.\n>>> nan = jnp.nan\n>>> x = jnp.array([[1, nan, 4, 3],\n...                [nan, 2, nan, 9],\n...                [4, 8, 6, nan]])\n>>> jnp.nanvar(x)\nArray(6.984375, dtype=float32)\nIf ``axis=1``, variance is computed along axis 1.\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.nanvar(x, axis=1))\n[ 1.56 12.25  2.67]\nTo preserve the dimensions of input, you can set ``keepdims=True``.\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.nanvar(x, axis=1, keepdims=True))\n[[ 1.56]\n[12.25]\n[ 2.67]]\nIf ``ddof=1``:\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.nanvar(x, axis=1, keepdims=True, ddof=1))\n[[ 2.33]\n[24.5 ]\n[ 4.  ]]\nTo include specific elements of the array to compute variance, you can use\n``where``.\n>>> where = jnp.array([[1, 0, 1, 0],\n...                    [0, 1, 1, 0],\n...                    [1, 1, 0, 1]], dtype=bool)\n>>> jnp.nanvar(x, axis=1, keepdims=True, where=where)\nArray([[2.25],\n[0.  ],\n[4.  ]], dtype=float32)"
      }
    },
    {
      "name": "ndim",
      "signature": "ndim(a: 'ArrayLike') -> 'int'",
      "documentation": {
        "description": "Return the number of dimensions of an array.\nJAX implementation of :func:`numpy.ndim`. Unlike ``np.ndim``, this function\nraises a :class:`TypeError` if the input is a collection such as a list or\ntuple.\nArgs:\na: array-like object.",
        "parameters": {},
        "returns": "An integer specifying the number of dimensions of ``a``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Number of dimensions for arrays:\n>>> x = jnp.arange(10)\n>>> jnp.ndim(x)\n1\n>>> y = jnp.ones((2, 3))\n>>> jnp.ndim(y)\n2\nThis also works for scalars:\n>>> jnp.ndim(3.14)\n0\nFor arrays, this can also be accessed via the :attr:`jax.Array.ndim` property:\n>>> x.ndim\n1"
      }
    },
    {
      "name": "negative",
      "signature": "negative(*args: 'ArrayLike', out: 'None' = None, where: 'None' = None) -> 'Any'",
      "documentation": {
        "description": "Return element-wise negative values of the input.\nJAX implementation of :obj:`numpy.negative`.\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array with same shape and dtype as ``x`` containing ``-x``.\nSee also:\n- :func:`jax.numpy.positive`: Returns element-wise positive values of the input.\n- :func:`jax.numpy.sign`: Returns element-wise indication of sign of the input.\nNote:\n``jnp.negative``, when applied over ``unsigned integer``, produces the result\nof their two's complement negation, which typically results in unexpected\nlarge positive values due to integer underflow.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "For real-valued inputs:\n>>> x = jnp.array([0., -3., 7])\n>>> jnp.negative(x)\nArray([-0.,  3., -7.], dtype=float32)\nFor complex inputs:\n>>> x1 = jnp.array([1-2j, -3+4j, 5-6j])\n>>> jnp.negative(x1)\nArray([-1.+2.j,  3.-4.j, -5.+6.j], dtype=complex64)\nFor unit32:\n>>> x2 = jnp.array([5, 0, -7]).astype(jnp.uint32)\n>>> x2\nArray([         5,          0, 4294967289], dtype=uint32)\n>>> jnp.negative(x2)\nArray([4294967291,          0,          7], dtype=uint32)"
      }
    },
    {
      "name": "nextafter",
      "signature": "nextafter(x: 'ArrayLike', y: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return element-wise next floating point value after ``x`` towards ``y``.\nJAX implementation of :obj:`numpy.nextafter`.\nArgs:\nx: scalar or array. Specifies the value after which the next number is found.\ny: scalar or array. Specifies the direction towards which the next number is\nfound. ``x`` and ``y`` should either have same shape or be broadcast\ncompatible.",
        "parameters": {},
        "returns": "An array containing the next representable number of ``x`` in the direction\nof ``y``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.nextafter(2, 1)  # doctest: +SKIP\nArray(1.9999999, dtype=float32, weak_type=True)\n>>> x = jnp.array([3, -2, 1])\n>>> y = jnp.array([2, -1, 2])\n>>> jnp.nextafter(x, y)  # doctest: +SKIP\nArray([ 2.9999998, -1.9999999,  1.0000001], dtype=float32)"
      }
    },
    {
      "name": "nonzero",
      "signature": "nonzero(a: 'ArrayLike', *, size: 'int | None' = None, fill_value: 'None | ArrayLike | tuple[ArrayLike, ...]' = None) -> 'tuple[Array, ...]'",
      "documentation": {
        "description": "Return indices of nonzero elements of an array.\nJAX implementation of :func:`numpy.nonzero`.\nBecause the size of the output of ``nonzero`` is data-dependent, the function\nis not compatible with JIT and other transformations. The JAX version adds\nthe optional ``size`` argument which must be specified statically for\n``jnp.nonzero`` to be used within JAX's transformations.\nArgs:\na: N-dimensional array.\nsize: optional static integer specifying the number of nonzero entries to\nreturn. If there are more nonzero elements than the specified ``size``,\nthen indices will be truncated at the end. If there are fewer nonzero\nelements than the specified size, then indices will be padded with\n``fill_value``, which defaults to zero.\nfill_value: optional padding value when ``size`` is specified. Defaults to 0.",
        "parameters": {},
        "returns": "Tuple of JAX Arrays of length ``a.ndim``, containing the indices of each\nnonzero value.\nSee also:\n- :func:`jax.numpy.flatnonzero`\n- :func:`jax.numpy.where`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "One-dimensional array returns a length-1 tuple of indices:\n>>> x = jnp.array([0, 5, 0, 6, 0, 7])\n>>> jnp.nonzero(x)\n(Array([1, 3, 5], dtype=int32),)\nTwo-dimensional array returns a length-2 tuple of indices:\n>>> x = jnp.array([[0, 5, 0],\n...                [6, 0, 7]])\n>>> jnp.nonzero(x)\n(Array([0, 1, 1], dtype=int32), Array([1, 0, 2], dtype=int32))\nIn either case, the resulting tuple of indices can be used directly to extract\nthe nonzero values:\n>>> indices = jnp.nonzero(x)\n>>> x[indices]\nArray([5, 6, 7], dtype=int32)\nThe output of ``nonzero`` has a dynamic shape, because the number of returned\nindices depends on the contents of the input array. As such, it is incompatible\nwith JIT and other JAX transformations:\n>>> x = jnp.array([0, 5, 0, 6, 0, 7])\n>>> jax.jit(jnp.nonzero)(x)  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nConcretizationTypeError: Abstract tracer value encountered where concrete value is expected: traced array with shape int32[].\nThe size argument of jnp.nonzero must be statically specified to use jnp.nonzero within JAX transformations.\nThis can be addressed by passing a static ``size`` parameter to specify the\ndesired output shape:\n>>> nonzero_jit = jax.jit(jnp.nonzero, static_argnames='size')\n>>> nonzero_jit(x, size=3)\n(Array([1, 3, 5], dtype=int32),)\nIf ``size`` does not match the true size, the result will be either truncated or padded:\n>>> nonzero_jit(x, size=2)  # size < 3: indices are truncated\n(Array([1, 3], dtype=int32),)\n>>> nonzero_jit(x, size=5)  # size > 3: indices are padded with zeros.\n(Array([1, 3, 5, 0, 0], dtype=int32),)\nYou can specify a custom fill value for the padding using the ``fill_value`` argument:\n>>> nonzero_jit(x, size=5, fill_value=len(x))\n(Array([1, 3, 5, 6, 6], dtype=int32),)"
      }
    },
    {
      "name": "not_equal",
      "signature": "not_equal(x: 'ArrayLike', y: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :obj:`numpy.not_equal`. This function provides the\nimplementation of the ``!=`` operator for JAX arrays.\nArgs:\nx: input array or scalar.\ny: input array or scalar. ``x`` and ``y`` should either have same shape or be\nbroadcast compatible.\nA boolean array containing ``True`` where the elements of ``x != y`` and\n``False`` otherwise.\nSee also:\n- :func:`jax.numpy.equal`: Returns element-wise truth value of ``x == y``.\n- :func:`jax.numpy.greater_equal`: Returns element-wise truth value of\n``x >= y``.\n- :func:`jax.numpy.less_equal`: Returns element-wise truth value of ``x <= y``.\n- :func:`jax.numpy.greater`: Returns element-wise truth value of ``x > y``.\n- :func:`jax.numpy.less`: Returns element-wise truth value of ``x < y``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.not_equal(0., -0.)\nArray(False, dtype=bool, weak_type=True)\n>>> jnp.not_equal(-2, 2)\nArray(True, dtype=bool, weak_type=True)\n>>> jnp.not_equal(1, 1.)\nArray(False, dtype=bool, weak_type=True)\n>>> jnp.not_equal(5, jnp.array(5))\nArray(False, dtype=bool, weak_type=True)\n>>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6],\n...                [7, 8, 9]])\n>>> y = jnp.array([1, 5, 9])\n>>> jnp.not_equal(x, y)\nArray([[False,  True,  True],\n[ True, False,  True],\n[ True,  True, False]], dtype=bool)\n>>> x != y\nArray([[False,  True,  True],\n[ True, False,  True],\n[ True,  True, False]], dtype=bool)"
      }
    },
    {
      "name": "ones",
      "signature": "ones(shape: Any, dtype: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None, *, device: jaxlib.xla_extension.Device | jaxlib.xla_extension.Sharding | None = None) -> jax.Array",
      "documentation": {
        "description": "Create an array full of ones.\nJAX implementation of :func:`numpy.ones`.\nArgs:\nshape: int or sequence of ints specifying the shape of the created array.\ndtype: optional dtype for the created array; defaults to floating point.\ndevice: (optional) :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.",
        "parameters": {},
        "returns": "Array of the specified shape and dtype, on the specified device if specified.\nSee also:\n- :func:`jax.numpy.ones_like`\n- :func:`jax.numpy.empty`\n- :func:`jax.numpy.zeros`\n- :func:`jax.numpy.full`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.ones(4)\nArray([1., 1., 1., 1.], dtype=float32)\n>>> jnp.ones((2, 3), dtype=bool)\nArray([[ True,  True,  True],\n[ True,  True,  True]], dtype=bool)"
      }
    },
    {
      "name": "ones_like",
      "signature": "ones_like(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, jax._src.typing.DuckTypedArray], dtype: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None, shape: Any = None, *, device: jaxlib.xla_extension.Device | jaxlib.xla_extension.Sharding | None = None) -> jax.Array",
      "documentation": {
        "description": "Create an array of ones with the same shape and dtype as an array.\nJAX implementation of :func:`numpy.ones_like`.\nArgs:\na: Array-like object with ``shape`` and ``dtype`` attributes.\nshape: optionally override the shape of the created array.\ndtype: optionally override the dtype of the created array.\ndevice: (optional) :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.",
        "parameters": {},
        "returns": "Array of the specified shape and dtype, on the specified device if specified.\nSee also:\n- :func:`jax.numpy.empty`\n- :func:`jax.numpy.zeros_like`\n- :func:`jax.numpy.ones_like`\n- :func:`jax.numpy.full_like`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.arange(4)\n>>> jnp.ones_like(x)\nArray([1, 1, 1, 1], dtype=int32)\n>>> jnp.ones_like(x, dtype=bool)\nArray([ True,  True,  True,  True], dtype=bool)\n>>> jnp.ones_like(x, shape=(2, 3))\nArray([[1, 1, 1],\n[1, 1, 1]], dtype=int32)"
      }
    },
    {
      "name": "outer",
      "signature": "outer(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], out: None = None) -> jax.Array",
      "documentation": {
        "description": "Compute the outer product of two arrays.\nJAX implementation of :func:`numpy.outer`.\nArgs:\na: first input array, if not 1D it will be flattened.\nb: second input array, if not 1D it will be flattened.\nout: unsupported by JAX.",
        "parameters": {},
        "returns": "The outer product of the inputs ``a`` and ``b``. Returned array\nwill be of shape ``(a.size, b.size)``.\nSee also:\n- :func:`jax.numpy.inner`: compute the inner product of two arrays.\n- :func:`jax.numpy.einsum`: Einstein summation.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> a = jnp.array([1, 2, 3])\n>>> b = jnp.array([4, 5, 6])\n>>> jnp.outer(a, b)\nArray([[ 4,  5,  6],\n[ 8, 10, 12],\n[12, 15, 18]], dtype=int32)"
      }
    },
    {
      "name": "packbits",
      "signature": "packbits(a: 'ArrayLike', axis: 'int | None' = None, bitorder: 'str' = 'big') -> 'Array'",
      "documentation": {
        "description": "Pack array of bits into a uint8 array.\nJAX implementation of :func:`numpy.packbits`\nArgs:\na: N-dimensional array of bits to pack.\naxis: optional axis along which to pack bits. If not specified, ``a`` will\nbe flattened.\nbitorder: ``\"big\"`` (default) or ``\"little\"``: specify whether the bit order\nis big-endian or little-endian.",
        "parameters": {},
        "returns": "A uint8 array of packed values.\nSee also:\n- :func:`jax.numpy.unpackbits`: inverse of ``packbits``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Packing bits in one dimension:\n>>> bits = jnp.array([0, 0, 0, 0, 0, 1, 1, 1])\n>>> jnp.packbits(bits)\nArray([7], dtype=uint8)\n>>> 0b00000111  # equivalent bit-wise representation:\n7\nOptionally specifying little-endian convention:\n>>> jnp.packbits(bits, bitorder=\"little\")\nArray([224], dtype=uint8)\n>>> 0b11100000  # equivalent bit-wise representation\n224\nIf the number of bits is not a multiple of 8, it will be right-padded\nwith zeros:\n>>> jnp.packbits(jnp.array([1, 0, 1]))\nArray([160], dtype=uint8)\n>>> jnp.packbits(jnp.array([1, 0, 1, 0, 0, 0, 0, 0]))\nArray([160], dtype=uint8)\nFor a multi-dimensional input, bits may be packed along a specified axis:\n>>> a = jnp.array([[1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0],\n...                [0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1]])\n>>> vals = jnp.packbits(a, axis=1)\n>>> vals\nArray([[212, 150],\n[ 69, 207]], dtype=uint8)\nThe inverse of ``packbits`` is provided by :func:`~jax.numpy.unpackbits`:\n>>> jnp.unpackbits(vals, axis=1)\nArray([[1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0],\n[0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1]], dtype=uint8)"
      }
    },
    {
      "name": "pad",
      "signature": "pad(array: 'ArrayLike', pad_width: 'PadValueLike[int | Array | np.ndarray]', mode: 'str | Callable[..., Any]' = 'constant', **kwargs) -> 'Array'",
      "documentation": {
        "description": "Add padding to an array.\nJAX implementation of :func:`numpy.pad`.\nArgs:\narray: array to pad.\npad_width: specify the pad width for each dimension of an array. Padding widths\nmay be separately specified for *before* and *after* the array. Options are:\n- ``int`` or ``(int,)``: pad each array dimension with the same number of values\nboth before and after.\n- ``(before, after)``: pad each array with ``before`` elements before, and ``after``\nelements after\n- ``((before_1, after_1), (before_2, after_2), ... (before_N, after_N))``: specify\ndistinct ``before`` and ``after`` values for each array dimension.\nmode: a string or callable. Supported pad modes are:\n- ``'constant'`` (default): pad with a constant value, which defaults to zero.\n- ``'empty'``: pad with empty values (i.e. zero)\n- ``'edge'``: pad with the edge values of the array.\n- ``'wrap'``: pad by wrapping the array.\n- ``'linear_ramp'``: pad with a linear ramp to specified ``end_values``.\n- ``'maximum'``: pad with the maximum value.\n- ``'mean'``: pad with the mean value.\n- ``'median'``: pad with the median value.\n- ``'minimum'``: pad with the minimum value.\n- ``'reflect'``: pad by reflection.\n- ``'symmetric'``: pad by symmetric reflection.\n- ``<callable>``: a callable function. See Notes below.\nconstant_values: referenced for ``mode = 'constant'``. Specify the constant value\nto pad with.\nstat_length: referenced for ``mode in ['maximum', 'mean', 'median', 'minimum']``.\nAn integer or tuple specifying the number of edge values to use when calculating\nthe statistic.\nend_values: referenced for ``mode = 'linear_ramp'``. Specify the end values to\nramp the padding values to.\nreflect_type: referenced for ``mode in ['reflect', 'symmetric']``. Specify whether\nto use even or odd reflection.",
        "parameters": {},
        "returns": "A padded copy of ``array``.",
        "raises": "",
        "see_also": "",
        "notes": "When ``mode`` is callable, it should have the following signature::\ndef pad_func(row: Array, pad_width: tuple[int, int],\niaxis: int, kwargs: dict) -> Array:\n...\nHere ``row`` is a 1D slice of the padded array along axis ``iaxis``, with the pad\nvalues filled with zeros. ``pad_width`` is a tuple specifying the ``(before, after)``\npadding sizes, and ``kwargs`` are any additional keyword arguments passed to the\n:func:`jax.numpy.pad` function.\nNote that while in NumPy, the function should modify ``row`` in-place, in JAX the\nfunction should return the modified ``row``. In JAX, the custom padding function\nwill be mapped across the padded axis using the :func:`jax.vmap` transformation.\nSee also:\n- :func:`jax.numpy.resize`: resize an array\n- :func:`jax.numpy.tile`: create a larger array by tiling a smaller array.\n- :func:`jax.numpy.repeat`: create a larger array by repeating values of a smaller array.",
        "examples": "Pad a 1-dimensional array with zeros:\n>>> x = jnp.array([10, 20, 30, 40])\n>>> jnp.pad(x, 2)\nArray([ 0,  0, 10, 20, 30, 40,  0,  0], dtype=int32)\n>>> jnp.pad(x, (2, 4))\nArray([ 0,  0, 10, 20, 30, 40,  0,  0,  0,  0], dtype=int32)\nPad a 1-dimensional array with specified values:\n>>> jnp.pad(x, 2, constant_values=99)\nArray([99, 99, 10, 20, 30, 40, 99, 99], dtype=int32)\nPad a 1-dimensional array with the mean array value:\n>>> jnp.pad(x, 2, mode='mean')\nArray([25, 25, 10, 20, 30, 40, 25, 25], dtype=int32)\nPad a 1-dimensional array with reflected values:\n>>> jnp.pad(x, 2, mode='reflect')\nArray([30, 20, 10, 20, 30, 40, 30, 20], dtype=int32)\nPad a 2-dimensional array with different paddings in each dimension:\n>>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> jnp.pad(x, ((1, 2), (3, 0)))\nArray([[0, 0, 0, 0, 0, 0],\n[0, 0, 0, 1, 2, 3],\n[0, 0, 0, 4, 5, 6],\n[0, 0, 0, 0, 0, 0],\n[0, 0, 0, 0, 0, 0]], dtype=int32)\nPad a 1-dimensional array with a custom padding function:\n>>> def custom_pad(row, pad_width, iaxis, kwargs):\n...   # row represents a 1D slice of the zero-padded array.\n...   before, after = pad_width\n...   before_value = kwargs.get('before_value', 0)\n...   after_value = kwargs.get('after_value', 0)\n...   row = row.at[:before].set(before_value)\n...   return row.at[len(row) - after:].set(after_value)\n>>> x = jnp.array([2, 3, 4])\n>>> jnp.pad(x, 2, custom_pad, before_value=-10, after_value=10)\nArray([-10, -10,   2,   3,   4,  10,  10], dtype=int32)"
      }
    },
    {
      "name": "partition",
      "signature": "partition(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], kth: int, axis: int = -1) -> jax.Array",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :func:`numpy.partition`. The JAX version differs from\nNumPy in the treatment of NaN entries: NaNs which have the negative bit set\nare sorted to the beginning of the array.\nArgs:\na: array to be partitioned.\nkth: static integer index about which to partition the array.\naxis: static integer axis along which to partition the array; default is -1.\nA copy of ``a`` partitioned at the ``kth`` value along ``axis``. The entries\nbefore ``kth`` are values smaller than ``take(a, kth, axis)``, and entries\nafter ``kth`` are indices of values larger than ``take(a, kth, axis)``\nNote:\nThe JAX version requires the ``kth`` argument to be a static integer rather than\na general array. This is implemented via two calls to :func:`jax.lax.top_k`. If\nyou're only accessing the top or bottom k values of the output, it may be more\nefficient to call :func:`jax.lax.top_k` directly.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.sort`: full sort\n- :func:`jax.numpy.argpartition`: indirect partial sort\n- :func:`jax.lax.top_k`: directly find the top k entries\n- :func:`jax.lax.approx_max_k`: compute the approximate top k entries\n- :func:`jax.lax.approx_min_k`: compute the approximate bottom k entries",
        "notes": "",
        "examples": ">>> x = jnp.array([6, 8, 4, 3, 1, 9, 7, 5, 2, 3])\n>>> kth = 4\n>>> x_partitioned = jnp.partition(x, kth)\n>>> x_partitioned\nArray([1, 2, 3, 3, 4, 9, 8, 7, 6, 5], dtype=int32)\nThe result is a partially-sorted copy of the input. All values before ``kth``\nare of smaller than the pivot value, and all values after ``kth`` are larger\nthan the pivot value:\n>>> smallest_values = x_partitioned[:kth]\n>>> pivot_value = x_partitioned[kth]\n>>> largest_values = x_partitioned[kth + 1:]\n>>> print(smallest_values, pivot_value, largest_values)\n[1 2 3 3] 4 [9 8 7 6 5]\nNotice that among ``smallest_values`` and ``largest_values``, the returned\norder is arbitrary and implementation-dependent."
      }
    },
    {
      "name": "percentile",
      "signature": "percentile(a: 'ArrayLike', q: 'ArrayLike', axis: 'int | tuple[int, ...] | None' = None, out: 'None' = None, overwrite_input: 'bool' = False, method: 'str' = 'linear', keepdims: 'bool' = False, *, interpolation: 'str | DeprecatedArg' = Deprecated) -> 'Array'",
      "documentation": {
        "description": "Compute the percentile of the data along the specified axis.\nJAX implementation of :func:`numpy.percentile`.\nArgs:\na: N-dimensional array input.\nq: scalar or 1-dimensional array specifying the desired quantiles. ``q``\nshould contain integer or floating point values between ``0`` and ``100``.\naxis: optional axis or tuple of axes along which to compute the quantile\nout: not implemented by JAX; will error if not None\noverwrite_input: not implemented by JAX; will error if not False\nmethod: specify the interpolation method to use. Options are one of\n``[\"linear\", \"lower\", \"higher\", \"midpoint\", \"nearest\"]``.\ndefault is ``linear``.\nkeepdims: if True, then the returned array will have the same number of\ndimensions as the input. Default is False.\ninterpolation: deprecated alias of the ``method`` argument. Will result\nin a :class:`DeprecationWarning` if used.",
        "parameters": {},
        "returns": "An array containing the specified percentiles along the specified axes.\nSee also:\n- :func:`jax.numpy.quantile`: compute the quantile (0.0-1.0)\n- :func:`jax.numpy.nanpercentile`: compute the percentile while ignoring NaNs",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Computing the median and quartiles of a 1D array:\n>>> x = jnp.array([0, 1, 2, 3, 4, 5, 6])\n>>> q = jnp.array([25, 50, 75])\n>>> jnp.percentile(x, q)\nArray([1.5, 3. , 4.5], dtype=float32)\nComputing the same percentiles with nearest rather than linear interpolation:\n>>> jnp.percentile(x, q, method='nearest')\nArray([1., 3., 4.], dtype=float32)"
      }
    },
    {
      "name": "permute_dims",
      "signature": "permute_dims(a: 'ArrayLike', /, axes: 'tuple[int, ...]') -> 'Array'",
      "documentation": {
        "description": "Permute the axes/dimensions of an array.\nJAX implementation of :func:`array_api.permute_dims`.\nArgs:\na: input array\naxes: tuple of integers in range ``[0, a.ndim)`` specifying the\naxes permutation.",
        "parameters": {},
        "returns": "a copy of ``a`` with axes permuted.\nSee also:\n- :func:`jax.numpy.transpose`\n- :func:`jax.numpy.matrix_transpose`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> a = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> jnp.permute_dims(a, (1, 0))\nArray([[1, 4],\n[2, 5],\n[3, 6]], dtype=int32)"
      }
    },
    {
      "name": "piecewise",
      "signature": "piecewise(x: 'ArrayLike', condlist: 'Array | Sequence[ArrayLike]', funclist: 'list[ArrayLike | Callable[..., Array]]', *args, **kw) -> 'Array'",
      "documentation": {
        "description": "Evaluate a function defined piecewise across the domain.\nJAX implementation of :func:`numpy.piecewise`, in terms of :func:`jax.lax.switch`.\nNote:\nUnlike :func:`numpy.piecewise`, :func:`jax.numpy.piecewise` requires functions\nin ``funclist`` to be traceable by JAX, as it is implemented via\n:func:`jax.lax.switch`.\nArgs:\nx: array of input values.\ncondlist: boolean array or sequence of boolean arrays corresponding to the\nfunctions in ``funclist``. If a sequence of arrays, the length of each\narray must match the length of ``x``\nfunclist: list of arrays or functions; must either be the same length as\n``condlist``, or have length ``len(condlist) + 1``, in which case the\nlast entry is the default applied when none of the conditions are True.\nAlternatively, entries of ``funclist`` may be numerical values, in which\ncase they indicate a constant function.\nargs, kwargs: additional arguments are passed to each function in\n``funclist``.",
        "parameters": {},
        "returns": "An array which is the result of evaluating the functions on ``x`` at\nthe specified conditions.\nSee also:\n- :func:`jax.lax.switch`: choose between *N* functions based on an index.\n- :func:`jax.lax.cond`: choose between two functions based on a boolean condition.\n- :func:`jax.numpy.where`: choose between two results based on a boolean mask.\n- :func:`jax.lax.select`: choose between two results based on a boolean mask.\n- :func:`jax.lax.select_n`: choose between *N* results based on a boolean mask.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Here's an example of a function which is zero for negative values, and linear\nfor positive values:\n>>> x = jnp.array([-4, -3, -2, -1, 0, 1, 2, 3, 4])\n>>> condlist = [x < 0, x >= 0]\n>>> funclist = [lambda x: 0 * x, lambda x: x]\n>>> jnp.piecewise(x, condlist, funclist)\nArray([0, 0, 0, 0, 0, 1, 2, 3, 4], dtype=int32)\n``funclist`` can also contain a simple scalar value for constant functions:\n>>> condlist = [x < 0, x >= 0]\n>>> funclist = [0, lambda x: x]\n>>> jnp.piecewise(x, condlist, funclist)\nArray([0, 0, 0, 0, 0, 1, 2, 3, 4], dtype=int32)\nYou can specify a default value by appending an extra condition to ``funclist``:\n>>> condlist = [x < -1, x > 1]\n>>> funclist = [lambda x: 1 + x, lambda x: x - 1, 0]\n>>> jnp.piecewise(x, condlist, funclist)\nArray([-3, -2,  -1,  0,  0,  0,  1,  2, 3], dtype=int32)\n``condlist`` may also be a simple array of scalar conditions, in which case\nthe associated function applies to the whole range\n>>> condlist = jnp.array([False, True, False])\n>>> funclist = [lambda x: x * 0, lambda x: x * 10, lambda x: x * 100]\n>>> jnp.piecewise(x, condlist, funclist)\nArray([-40, -30, -20, -10,   0,  10,  20,  30,  40], dtype=int32)"
      }
    },
    {
      "name": "place",
      "signature": "place(arr: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], mask: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], vals: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, inplace: bool = True) -> jax.Array",
      "documentation": {
        "description": "Update array elements based on a mask.\nJAX implementation of :func:`numpy.place`.\nThe semantics of :func:`numpy.place` are to modify arrays in-place, which\nis not possible for JAX's immutable arrays. The JAX version returns a modified\ncopy of the input, and adds the ``inplace`` parameter which must be set to\n`False`` by the user as a reminder of this API difference.\nArgs:\narr: array into which values will be placed.\nmask: boolean mask with the same size as ``arr``.\nvals: values to be inserted into ``arr`` at the locations indicated\nby mask. If too many values are supplied, they will be truncated.\nIf not enough values are supplied, they will be repeated.\ninplace: must be set to False to indicate that the input is not modified\nin-place, but rather a modified copy is returned.",
        "parameters": {},
        "returns": "A copy of ``arr`` with masked values set to entries from `vals`.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.put`: put elements into an array at numerical indices.\n- :func:`jax.numpy.ndarray.at`: array updates using NumPy-style indexing",
        "notes": "",
        "examples": ">>> x = jnp.zeros((3, 5), dtype=int)\n>>> mask = (jnp.arange(x.size) % 3 == 0).reshape(x.shape)\n>>> mask\nArray([[ True, False, False,  True, False],\n[False,  True, False, False,  True],\n[False, False,  True, False, False]], dtype=bool)\nPlacing a scalar value:\n>>> jnp.place(x, mask, 1, inplace=False)\nArray([[1, 0, 0, 1, 0],\n[0, 1, 0, 0, 1],\n[0, 0, 1, 0, 0]], dtype=int32)\nIn this case, ``jnp.place`` is similar to the masked array update syntax:\n>>> x.at[mask].set(1)\nArray([[1, 0, 0, 1, 0],\n[0, 1, 0, 0, 1],\n[0, 0, 1, 0, 0]], dtype=int32)\n``place`` differs when placing values from an array. The array is repeated\nto fill the masked entries:\n>>> vals = jnp.array([1, 3, 5])\n>>> jnp.place(x, mask, vals, inplace=False)\nArray([[1, 0, 0, 3, 0],\n[0, 5, 0, 0, 1],\n[0, 0, 3, 0, 0]], dtype=int32)"
      }
    },
    {
      "name": "poly",
      "signature": "poly(seq_of_zeros: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :func:`numpy.poly`.\nArgs:\nseq_of_zeros: A scalar or an array of roots of the polynomial of shape ``(M,)``\nor ``(M, M)``.\nAn array containing the coefficients of the polynomial. The dtype of the\noutput is always promoted to inexact.\nNote:\n:func:`jax.numpy.poly` differs from :func:`numpy.poly`:\n- When the input is a scalar, ``np.poly`` raises a ``TypeError``, whereas\n``jnp.poly`` treats scalars the same as length-1 arrays.\n- For complex-valued or square-shaped inputs, ``jnp.poly`` always returns\ncomplex coefficients, whereas ``np.poly`` may return real or complex\ndepending on their values.\nSee also:\n- :func:`jax.numpy.polyfit`: Least squares polynomial fit.\n- :func:`jax.numpy.polyval`: Evaluate a polynomial at specific values.\n- :func:`jax.numpy.roots`: Computes the roots of a polynomial for given\ncoefficients.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar inputs:\n>>> jnp.poly(1)\nArray([ 1., -1.], dtype=float32)\nInput array with integer values:\n>>> x = jnp.array([1, 2, 3])\n>>> jnp.poly(x)\nArray([ 1., -6., 11., -6.], dtype=float32)\nInput array with complex conjugates:\n>>> x = jnp.array([2, 1+2j, 1-2j])\n>>> jnp.poly(x)\nArray([  1.+0.j,  -4.+0.j,   9.+0.j, -10.+0.j], dtype=complex64)\nInput array as square matrix with real valued inputs:\n>>> x = jnp.array([[2, 1, 5],\n...                [3, 4, 7],\n...                [1, 3, 5]])\n>>> jnp.round(jnp.poly(x))\nArray([  1.+0.j, -11.-0.j,   9.+0.j, -15.+0.j], dtype=complex64)"
      }
    },
    {
      "name": "polyadd",
      "signature": "polyadd(a1: 'ArrayLike', a2: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :func:`numpy.polyadd`.\nArgs:\na1: Array of polynomial coefficients.\na2: Array of polynomial coefficients.\nAn array containing the coefficients of the sum of input polynomials.\nNote:\n:func:`jax.numpy.polyadd` only accepts arrays as input unlike\n:func:`numpy.polyadd` which accepts scalar inputs as well.\nSee also:\n- :func:`jax.numpy.polysub`: Computes the difference of two polynomials.\n- :func:`jax.numpy.polymul`: Computes the product of two polynomials.\n- :func:`jax.numpy.polydiv`: Computes the quotient and remainder of polynomial\ndivision.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([2, 3])\n>>> x2 = jnp.array([5, 4, 1])\n>>> jnp.polyadd(x1, x2)\nArray([5, 6, 4], dtype=int32)\n>>> x3 = jnp.array([[2, 3, 1]])\n>>> x4 = jnp.array([[5, 7, 3],\n...                 [8, 2, 6]])\n>>> jnp.polyadd(x3, x4)\nArray([[ 5,  7,  3],\n[10,  5,  7]], dtype=int32)\n>>> x5 = jnp.array([1, 3, 5])\n>>> x6 = jnp.array([[5, 7, 9],\n...                 [8, 6, 4]])\n>>> jnp.polyadd(x5, x6)  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nValueError: Cannot broadcast to shape with fewer dimensions: arr_shape=(2, 3) shape=(2,)\n>>> x7 = jnp.array([2])\n>>> jnp.polyadd(x6, x7)\nArray([[ 5,  7,  9],\n[10,  8,  6]], dtype=int32)"
      }
    },
    {
      "name": "polyder",
      "signature": "polyder(p: 'ArrayLike', m: 'int' = 1) -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :func:`numpy.polyder`.\nArgs:\np: Array of polynomials coefficients.\nm: Order of differentiation (positive integer). Default is 1. It must be\nspecified statically.\nAn array of polynomial coefficients representing the derivative.\nNote:\n:func:`jax.numpy.polyder` differs from :func:`numpy.polyder` when an integer\narray is given. NumPy returns the result with dtype ``int`` whereas JAX\nreturns the result with dtype ``float``.\nSee also:\n- :func:`jax.numpy.polyint`: Computes the integral of polynomial.\n- :func:`jax.numpy.polyval`: Evaluates a polynomial at specific values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "The first order derivative of the polynomial :math:`2 x^3 - 5 x^2 + 3 x - 1`\nis :math:`6 x^2 - 10 x +3`:\n>>> p = jnp.array([2, -5, 3, -1])\n>>> jnp.polyder(p)\nArray([  6., -10.,   3.], dtype=float32)\nand its second order derivative is :math:`12 x - 10`:\n>>> jnp.polyder(p, m=2)\nArray([ 12., -10.], dtype=float32)"
      }
    },
    {
      "name": "polydiv",
      "signature": "polydiv(u: 'ArrayLike', v: 'ArrayLike', *, trim_leading_zeros: 'bool' = False) -> 'tuple[Array, Array]'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :func:`numpy.polydiv`.\nArgs:\nu: Array of dividend polynomial coefficients.\nv: Array of divisor polynomial coefficients.\ntrim_leading_zeros: Default is ``False``. If ``True`` removes the leading\nzeros in the return value to match the result of numpy. But prevents the\nfunction from being able to be used in compiled code. Due to differences\nin accumulation of floating point arithmetic errors, the cutoff for values\nto be considered zero may lead to inconsistent results between NumPy and\nJAX, and even between different JAX backends. The result may lead to\ninconsistent output shapes when ``trim_leading_zeros=True``.\nA tuple of quotient and remainder arrays. The dtype of the output is always\npromoted to inexact.\nNote:\n:func:`jax.numpy.polydiv` only accepts arrays as input unlike\n:func:`numpy.polydiv` which accepts scalar inputs as well.\nSee also:\n- :func:`jax.numpy.polyadd`: Computes the sum of two polynomials.\n- :func:`jax.numpy.polysub`: Computes the difference of two polynomials.\n- :func:`jax.numpy.polymul`: Computes the product of two polynomials.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([5, 7, 9])\n>>> x2 = jnp.array([4, 1])\n>>> np.polydiv(x1, x2)\n(array([1.25  , 1.4375]), array([7.5625]))\n>>> jnp.polydiv(x1, x2)\n(Array([1.25  , 1.4375], dtype=float32), Array([0.    , 0.    , 7.5625], dtype=float32))\nIf ``trim_leading_zeros=True``, the result matches with ``np.polydiv``'s.\n>>> jnp.polydiv(x1, x2, trim_leading_zeros=True)\n(Array([1.25  , 1.4375], dtype=float32), Array([7.5625], dtype=float32))"
      }
    },
    {
      "name": "polyfit",
      "signature": "polyfit(x: 'ArrayLike', y: 'ArrayLike', deg: 'int', rcond: 'float | None' = None, full: 'bool' = False, w: 'ArrayLike | None' = None, cov: 'bool' = False) -> 'Array | tuple[Array, ...]'",
      "documentation": {
        "description": "Least squares polynomial fit to data.\nJax implementation of :func:`numpy.polyfit`.\nGiven a set of data points ``(x, y)`` and degree of polynomial ``deg``, the\nfunction finds a polynomial equation of the form:\n.. math::\ny = p(x) = p[0] x^{deg} + p[1] x^{deg - 1} + ... + p[deg]\nArgs:\nx: Array of data points of shape ``(M,)``.\ny: Array of data points of shape ``(M,)`` or ``(M, K)``.\ndeg: Degree of the polynomials. It must be specified statically.\nrcond: Relative condition number of the fit. Default value is ``len(x) * eps``.\nIt must be specified statically.\nfull: Switch that controls the return value. Default is ``False`` which\nrestricts the return value to the array of polynomail coefficients ``p``.\nIf ``True``, the function returns a tuple ``(p, resids, rank, s, rcond)``.\nIt must be specified statically.\nw: Array of weights of shape ``(M,)``. If None, all data points are considered\nto have equal weight. If not None, the weight :math:`w_i` is applied to the\nunsquared residual of :math:`y_i - \\widehat{y}_i` at :math:`x_i`, where\n:math:`\\widehat{y}_i` is the fitted value of :math:`y_i`. Default is None.\ncov: Boolean or string. If ``True``, returns the covariance matrix scaled\nby ``resids/(M-deg-1)`` along with ploynomial coefficients. If\n``cov='unscaled'``, returns the unscaaled version of covariance matrix.\nDefault is ``False``. ``cov`` is ignored if ``full=True``. It must be\nspecified statically.",
        "parameters": {},
        "returns": "- An array polynomial coefficients ``p`` if ``full=False`` and ``cov=False``.\n- A tuple of arrays ``(p, resids, rank, s, rcond)`` if ``full=True``. Where\n- ``p`` is an array of shape ``(M,)`` or ``(M, K)`` containing the polynomial\ncoefficients.\n- ``resids`` is the sum of squared residual of shape () or (K,).\n- ``rank`` is the rank of the matrix ``x``.\n- ``s`` is the singular values of the matrix ``x``.\n- ``rcond`` as the array.\n- A tuple of arrays ``(p, C)`` if ``full=False`` and ``cov=True``. Where\n- ``p`` is an array of shape ``(M,)`` or ``(M, K)`` containing the polynomial\ncoefficients.\n- ``C`` is the covariance matrix of polynomial coefficients of shape\n``(deg + 1, deg + 1)`` or ``(deg + 1, deg + 1, 1)``.\nNote:\nUnlike :func:`numpy.polyfit` implementation of polyfit, :func:`jax.numpy.polyfit`\nwill not warn on rank reduction, which indicates an ill conditioned matrix.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.poly`: Finds the polynomial coefficients of the given\nsequence of roots.\n- :func:`jax.numpy.polyval`: Evaluate a polynomial at specific values.\n- :func:`jax.numpy.roots`: Computes the roots of a polynomial for given\ncoefficients.",
        "notes": "",
        "examples": ">>> x = jnp.array([3., 6., 9., 4.])\n>>> y = jnp.array([[0, 1, 2],\n...                [2, 5, 7],\n...                [8, 4, 9],\n...                [1, 6, 3]])\n>>> p = jnp.polyfit(x, y, 2)\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(p)\n[[ 0.2  -0.35 -0.14]\n[-1.17  4.47  2.96]\n[ 1.95 -8.21 -5.93]]\nIf ``full=True``, returns a tuple of arrays as follows:\n>>> p, resids, rank, s, rcond = jnp.polyfit(x, y, 2, full=True)\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(\"Polynomial Coefficients:\", \"\\n\", p, \"\\n\",\n...         \"Residuals:\", resids, \"\\n\",\n...         \"Rank:\", rank, \"\\n\",\n...         \"s:\", s, \"\\n\",\n...         \"rcond:\", rcond)\nPolynomial Coefficients:\n[[ 0.2  -0.35 -0.14]\n[-1.17  4.47  2.96]\n[ 1.95 -8.21 -5.93]]\nResiduals: [0.37 5.94 0.61]\nRank: 3\ns: [1.67 0.47 0.04]\nrcond: 4.7683716e-07\nIf ``cov=True`` and ``full=False``, returns a tuple of arrays having\npolynomial coefficients and covariance matrix.\n>>> p, C = jnp.polyfit(x, y, 2, cov=True)\n>>> p.shape, C.shape\n((3, 3), (3, 3, 1))"
      }
    },
    {
      "name": "polyint",
      "signature": "polyint(p: 'ArrayLike', m: 'int' = 1, k: 'int | ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :func:`numpy.polyint`.\nArgs:\np: An array of polynomial coefficients.\nm: Order of integration. Default is 1. It must be specified statically.\nk: Scalar or array of ``m`` integration constant (s).\nAn array of coefficients of integrated polynomial.\nSee also:\n- :func:`jax.numpy.polyder`: Computes the coefficients of the derivative of\na polynomial.\n- :func:`jax.numpy.polyval`: Evaluates a polynomial at specific values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "The first order integration of the polynomial :math:`12 x^2 + 12 x + 6` is\n:math:`4 x^3 + 6 x^2 + 6 x`.\n>>> p = jnp.array([12, 12, 6])\n>>> jnp.polyint(p)\nArray([4., 6., 6., 0.], dtype=float32)\nSince the constant ``k`` is not provided, the result included ``0`` at the end.\nIf the constant ``k`` is provided:\n>>> jnp.polyint(p, k=4)\nArray([4., 6., 6., 4.], dtype=float32)\nand the second order integration is :math:`x^4 + 2 x^3 + 3 x`:\n>>> jnp.polyint(p, m=2)\nArray([1., 2., 3., 0., 0.], dtype=float32)\nWhen ``m>=2``, the constants ``k`` should be provided as an array having\n``m`` elements. The second order integration of the polynomial\n:math:`12 x^2 + 12 x + 6` with the constants ``k=[4, 5]`` is\n:math:`x^4 + 2 x^3 + 3 x^2 + 4 x + 5`:\n>>> jnp.polyint(p, m=2, k=jnp.array([4, 5]))\nArray([1., 2., 3., 4., 5.], dtype=float32)"
      }
    },
    {
      "name": "polymul",
      "signature": "polymul(a1: 'ArrayLike', a2: 'ArrayLike', *, trim_leading_zeros: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :func:`numpy.polymul`.\nArgs:\na1: 1D array of polynomial coefficients.\na2: 1D array of polynomial coefficients.\ntrim_leading_zeros: Default is ``False``. If ``True`` removes the leading\nzeros in the return value to match the result of numpy. But prevents the\nfunction from being able to be used in compiled code. Due to differences\nin accumulation of floating point arithmetic errors, the cutoff for values\nto be considered zero may lead to inconsistent results between NumPy and\nJAX, and even between different JAX backends. The result may lead to\ninconsistent output shapes when ``trim_leading_zeros=True``.\nAn array of the coefficients of the product of the two polynomials. The dtype\nof the output is always promoted to inexact.\nNote:\n:func:`jax.numpy.polymul` only accepts arrays as input unlike\n:func:`numpy.polymul` which accepts scalar inputs as well.\nSee also:\n- :func:`jax.numpy.polyadd`: Computes the sum of two polynomials.\n- :func:`jax.numpy.polysub`: Computes the difference of two polynomials.\n- :func:`jax.numpy.polydiv`: Computes the quotient and remainder of polynomial\ndivision.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = np.array([2, 1, 0])\n>>> x2 = np.array([0, 5, 0, 3])\n>>> np.polymul(x1, x2)\narray([10,  5,  6,  3,  0])\n>>> jnp.polymul(x1, x2)\nArray([ 0., 10.,  5.,  6.,  3.,  0.], dtype=float32)\nIf ``trim_leading_zeros=True``, the result matches with ``np.polymul``'s.\n>>> jnp.polymul(x1, x2, trim_leading_zeros=True)\nArray([10.,  5.,  6.,  3.,  0.], dtype=float32)\nFor input arrays of dtype ``complex``:\n>>> x3 = np.array([2., 1+2j, 1-2j])\n>>> x4 = np.array([0, 5, 0, 3])\n>>> np.polymul(x3, x4)\narray([10. +0.j,  5.+10.j, 11.-10.j,  3. +6.j,  3. -6.j])\n>>> jnp.polymul(x3, x4)\nArray([ 0. +0.j, 10. +0.j,  5.+10.j, 11.-10.j,  3. +6.j,  3. -6.j],      dtype=complex64)\n>>> jnp.polymul(x3, x4, trim_leading_zeros=True)\nArray([10. +0.j,  5.+10.j, 11.-10.j,  3. +6.j,  3. -6.j], dtype=complex64)"
      }
    },
    {
      "name": "polysub",
      "signature": "polysub(a1: 'ArrayLike', a2: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :func:`numpy.polysub`.\nArgs:\na1: Array of minuend polynomial coefficients.\na2: Array of subtrahend polynomial coefficients.\nAn array containing the coefficients of the difference of two polynomials.\nNote:\n:func:`jax.numpy.polysub` only accepts arrays as input unlike\n:func:`numpy.polysub` which accepts scalar inputs as well.\nSee also:\n- :func:`jax.numpy.polyadd`: Computes the sum of two polynomials.\n- :func:`jax.numpy.polymul`: Computes the product of two polynomials.\n- :func:`jax.numpy.polydiv`: Computes the quotient and remainder of polynomial\ndivision.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([2, 3])\n>>> x2 = jnp.array([5, 4, 1])\n>>> jnp.polysub(x1, x2)\nArray([-5, -2,  2], dtype=int32)\n>>> x3 = jnp.array([[2, 3, 1]])\n>>> x4 = jnp.array([[5, 7, 3],\n...                 [8, 2, 6]])\n>>> jnp.polysub(x3, x4)\nArray([[-5, -7, -3],\n[-6,  1, -5]], dtype=int32)\n>>> x5 = jnp.array([1, 3, 5])\n>>> x6 = jnp.array([[5, 7, 9],\n...                 [8, 6, 4]])\n>>> jnp.polysub(x5, x6)  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nValueError: Cannot broadcast to shape with fewer dimensions: arr_shape=(2, 3) shape=(2,)\n>>> x7 = jnp.array([2])\n>>> jnp.polysub(x6, x7)\nArray([[5, 7, 9],\n[6, 4, 2]], dtype=int32)"
      }
    },
    {
      "name": "polyval",
      "signature": "polyval(p: 'ArrayLike', x: 'ArrayLike', *, unroll: 'int' = 16) -> 'Array'",
      "documentation": {
        "description": "Evaluates the polynomial at specific values.\nJAX implementations of :func:`numpy.polyval`.\nFor the 1D-polynomial coefficients ``p`` of length ``M``, the function returns\nthe value:\n.. math::\np_0 x^{M - 1} + p_1 x^{M - 2} + ... + p_{M - 1}\nArgs:\np: An array of polynomial coefficients of shape ``(M,)``.\nx: A number or an array of numbers.\nunroll: A number used to control the number of unrolled steps with\n``lax.scan``. It must be specified statically.",
        "parameters": {},
        "returns": "An array of same shape as ``x``.\nNote:\nThe ``unroll`` parameter is JAX specific. It does not affect correctness but\ncan have a major impact on performance for evaluating high-order polynomials.\nThe parameter controls the number of unrolled steps with ``lax.scan`` inside\nthe ``jnp.polyval`` implementation. Consider setting ``unroll=128`` (or even\nhigher) to improve runtime performance on accelerators, at the cost of\nincreased compilation time.\nSee also:\n- :func:`jax.numpy.polyfit`: Least squares polynomial fit.\n- :func:`jax.numpy.poly`: Finds the coefficients of a polynomial with given\nroots.\n- :func:`jax.numpy.roots`: Computes the roots of a polynomial for given\ncoefficients.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> p = jnp.array([2, 5, 1])\n>>> jnp.polyval(p, 3)\nArray(34., dtype=float32)\nIf ``x`` is a 2D array, ``polyval`` returns 2D-array with same shape as\nthat of ``x``:\n>>> x = jnp.array([[2, 1, 5],\n...                [3, 4, 7],\n...                [1, 3, 5]])\n>>> jnp.polyval(p, x)\nArray([[ 19.,   8.,  76.],\n[ 34.,  53., 134.],\n[  8.,  34.,  76.]], dtype=float32)"
      }
    },
    {
      "name": "positive",
      "signature": "positive(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return element-wise positive values of the input.\nJAX implementation of :obj:`numpy.positive`.\nArgs:\nx: input array or scalar",
        "parameters": {},
        "returns": "An array of same shape and dtype as ``x`` containing ``+x``.\nNote:\n``jnp.positive`` is equivalent to ``x.copy()`` and is defined only for the\ntypes that support arithmetic operations.\nSee also:\n- :func:`jax.numpy.negative`: Returns element-wise negative values of the input.\n- :func:`jax.numpy.sign`: Returns element-wise indication of sign of the input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "For real-valued inputs:\n>>> x = jnp.array([-5, 4, 7., -9.5])\n>>> jnp.positive(x)\nArray([-5. ,  4. ,  7. , -9.5], dtype=float32)\n>>> x.copy()\nArray([-5. ,  4. ,  7. , -9.5], dtype=float32)\nFor complex inputs:\n>>> x1 = jnp.array([1-2j, -3+4j, 5-6j])\n>>> jnp.positive(x1)\nArray([ 1.-2.j, -3.+4.j,  5.-6.j], dtype=complex64)\n>>> x1.copy()\nArray([ 1.-2.j, -3.+4.j,  5.-6.j], dtype=complex64)\nFor uint32:\n>>> x2 = jnp.array([6, 0, -4]).astype(jnp.uint32)\n>>> x2\nArray([         6,          0, 4294967292], dtype=uint32)\n>>> jnp.positive(x2)\nArray([         6,          0, 4294967292], dtype=uint32)"
      }
    },
    {
      "name": "pow",
      "signature": "pow(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.power`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "power",
      "signature": "power(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise base ``x1`` exponential of ``x2``.\nJAX implementation of :obj:`numpy.power`.\nArgs:\nx1: scalar or array. Specifies the bases.\nx2: scalar or array. Specifies the exponent. ``x1`` and ``x2`` should either\nhave same shape or be broadcast compatible.",
        "parameters": {},
        "returns": "An array containing the base ``x1`` exponentials of ``x2`` with same dtype\nas input.\nNote:\n- When ``x2`` is a concrete integer scalar, ``jnp.power`` lowers to\n:func:`jax.lax.integer_pow`.\n- When ``x2`` is a traced scalar or an array, ``jnp.power`` lowers to\n:func:`jax.lax.pow`.\n- ``jnp.power`` raises a ``TypeError`` for integer type raised to negative\ninteger power.\n- ``jnp.power`` returns ``nan`` for negative value raised to the power of\nnon-integer values.\nSee also:\n- :func:`jax.lax.pow`: Computes element-wise power, :math:`x^y`.\n- :func:`jax.lax.integer_pow`: Computes element-wise power :math:`x^y`, where\n:math:`y` is a fixed integer.\n- :func:`jax.numpy.float_power`: Computes the first array raised to the power\nof second array, element-wise, by promoting to the inexact dtype.\n- :func:`jax.numpy.pow`: Computes the first array raised to the power of second\narray, element-wise.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Inputs with scalar integers:\n>>> jnp.power(4, 3)\nArray(64, dtype=int32, weak_type=True)\nInputs with same shape:\n>>> x1 = jnp.array([2, 4, 5])\n>>> x2 = jnp.array([3, 0.5, 2])\n>>> jnp.power(x1, x2)\nArray([ 8.,  2., 25.], dtype=float32)\nInputs with broadcast compatibility:\n>>> x3 = jnp.array([-2, 3, 1])\n>>> x4 = jnp.array([[4, 1, 6],\n...                 [1.3, 3, 5]])\n>>> jnp.power(x3, x4)\nArray([[16.,  3.,  1.],\n[nan, 27.,  1.]], dtype=float32)"
      }
    },
    {
      "name": "printoptions",
      "signature": "printoptions(*args, **kwargs)",
      "documentation": {
        "description": "Alias of :func:`numpy.printoptions`.\nJAX arrays are printed via NumPy, so NumPy's `printoptions`\nconfigurations will apply to printed JAX arrays.\nSee the :func:`numpy.set_printoptions` documentation for details\non the available options and their meanings.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "prod",
      "signature": "prod(a: 'ArrayLike', axis: 'Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None, promote_integers: 'bool' = True) -> 'Array'",
      "documentation": {
        "description": "Return product of the array elements over a given axis.\nJAX implementation of :func:`numpy.prod`.\nArgs:\na: Input array.\naxis: int or array, default=None. Axis along which the product to be computed.\nIf None, the product is computed along all the axes.\ndtype: The type of the output array. Default=None.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\ninitial: int or array, Default=None. Initial value for the product.\nwhere: int or array, default=None. The elements to be used in the product.\nArray should be broadcast compatible to the input.\npromote_integers : bool, default=True. If True, then integer inputs will be\npromoted to the widest available integer dtype, following numpy's behavior.\nIf False, the result will have the same dtype as the input.\n``promote_integers`` is ignored if ``dtype`` is specified.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array of the product along the given axis.\nSee also:\n- :func:`jax.numpy.sum`: Compute the sum of array elements over a given axis.\n- :func:`jax.numpy.max`: Compute the maximum of array elements over given axis.\n- :func:`jax.numpy.min`: Compute the minimum of array elements over given axis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.prod`` computes along all the axes.\n>>> x = jnp.array([[1, 3, 4, 2],\n...                [5, 2, 1, 3],\n...                [2, 1, 3, 1]])\n>>> jnp.prod(x)\nArray(4320, dtype=int32)\nIf ``axis=1``, product is computed along axis 1.\n>>> jnp.prod(x, axis=1)\nArray([24, 30,  6], dtype=int32)\nIf ``keepdims=True``, ``ndim`` of the output is equal to that of the input.\n>>> jnp.prod(x, axis=1, keepdims=True)\nArray([[24],\n[30],\n[ 6]], dtype=int32)\nTo include only specific elements in the sum, you can use a``where``.\n>>> where=jnp.array([[1, 0, 1, 0],\n...                  [0, 0, 1, 1],\n...                  [1, 1, 1, 0]], dtype=bool)\n>>> jnp.prod(x, axis=1, keepdims=True, where=where)\nArray([[4],\n[3],\n[6]], dtype=int32)\n>>> where = jnp.array([[False],\n...                    [False],\n...                    [False]])\n>>> jnp.prod(x, axis=1, keepdims=True, where=where)\nArray([[1],\n[1],\n[1]], dtype=int32)"
      }
    },
    {
      "name": "promote_types",
      "signature": "promote_types(a: 'DTypeLike', b: 'DTypeLike') -> 'DType'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :func:`numpy.promote_types`. For details of JAX's\ntype promotion semantics, see :ref:`type-promotion`.\nArgs:\na: a :class:`numpy.dtype` or a dtype specifier.\nb: a :class:`numpy.dtype` or a dtype specifier.\nA :class:`numpy.dtype` object.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Type specifiers may be strings, dtypes, or scalar types, and the return\nvalue is always a dtype:\n>>> jnp.promote_types('int32', 'float32')  # strings\ndtype('float32')\n>>> jnp.promote_types(jnp.dtype('int32'), jnp.dtype('float32'))  # dtypes\ndtype('float32')\n>>> jnp.promote_types(jnp.int32, jnp.float32)  # scalar types\ndtype('float32')\nBuilt-in scalar types (:type:`int`, :type:`float`, or :type:`complex`) are\ntreated as weakly-typed and will not change the bit width of a strongly-typed\ncounterpart (see discussion in :ref:`type-promotion`):\n>>> jnp.promote_types('uint8', int)\ndtype('uint8')\n>>> jnp.promote_types('float16', float)\ndtype('float16')\nThis differs from the NumPy version of this function, which treats built-in scalar\ntypes as equivalent to 64-bit types:\n>>> import numpy\n>>> numpy.promote_types('uint8', int)\ndtype('int64')\n>>> numpy.promote_types('float16', float)\ndtype('float64')"
      }
    },
    {
      "name": "ptp",
      "signature": "ptp(a: 'ArrayLike', axis: 'Axis' = None, out: 'None' = None, keepdims: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "Return the peak-to-peak range along a given axis.\nJAX implementation of :func:`numpy.ptp`.\nArgs:\na: input array.\naxis: optional, int or sequence of ints, default=None. Axis along which the\nrange is computed. If None, the range is computed on the flattened array.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array with the range of elements along specified axis of input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.ptp`` computes the range along all axes.\n>>> x = jnp.array([[1, 3, 5, 2],\n...                [4, 6, 8, 1],\n...                [7, 9, 3, 4]])\n>>> jnp.ptp(x)\nArray(8, dtype=int32)\nIf ``axis=1``, computes the range along axis 1.\n>>> jnp.ptp(x, axis=1)\nArray([4, 7, 6], dtype=int32)\nTo preserve the dimensions of input, you can set ``keepdims=True``.\n>>> jnp.ptp(x, axis=1, keepdims=True)\nArray([[4],\n[7],\n[6]], dtype=int32)"
      }
    },
    {
      "name": "put",
      "signature": "put(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], ind: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], v: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], mode: str | None = None, *, inplace: bool = True) -> jax.Array",
      "documentation": {
        "description": "Put elements into an array at given indices.\nJAX implementation of :func:`numpy.put`.\nThe semantics of :func:`numpy.put` are to modify arrays in-place, which\nis not possible for JAX's immutable arrays. The JAX version returns a modified\ncopy of the input, and adds the ``inplace`` parameter which must be set to\n`False`` by the user as a reminder of this API difference.\nArgs:\na: array into which values will be placed.\nind: array of indices over the flattened array at which to put values.\nv: array of values to put into the array.\nmode: string specifying how to handle out-of-bound indices. Supported values:\n- ``\"clip\"`` (default): clip out-of-bound indices to the final index.\n- ``\"wrap\"``: wrap out-of-bound indices to the beginning of the array.\ninplace: must be set to False to indicate that the input is not modified\nin-place, but rather a modified copy is returned.",
        "parameters": {},
        "returns": "A copy of ``a`` with specified entries updated.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.place`: place elements into an array via boolean mask.\n- :func:`jax.numpy.ndarray.at`: array updates using NumPy-style indexing.\n- :func:`jax.numpy.take`: extract values from an array at given indices.",
        "notes": "",
        "examples": ">>> x = jnp.zeros(5, dtype=int)\n>>> indices = jnp.array([0, 2, 4])\n>>> values = jnp.array([10, 20, 30])\n>>> jnp.put(x, indices, values, inplace=False)\nArray([10,  0, 20,  0, 30], dtype=int32)\nThis is equivalent to the following :attr:`jax.numpy.ndarray.at` indexing syntax:\n>>> x.at[indices].set(values)\nArray([10,  0, 20,  0, 30], dtype=int32)\nThere are two modes for handling out-of-bound indices. By default they are\nclipped:\n>>> indices = jnp.array([0, 2, 6])\n>>> jnp.put(x, indices, values, inplace=False, mode='clip')\nArray([10,  0, 20,  0, 30], dtype=int32)\nAlternatively, they can be wrapped to the beginning of the array:\n>>> jnp.put(x, indices, values, inplace=False, mode='wrap')\nArray([10,  30, 20,  0, 0], dtype=int32)\nFor N-dimensional inputs, the indices refer to the flattened array:\n>>> x = jnp.zeros((3, 5), dtype=int)\n>>> indices = jnp.array([0, 7, 14])\n>>> jnp.put(x, indices, values, inplace=False)\nArray([[10,  0,  0,  0,  0],\n[ 0,  0, 20,  0,  0],\n[ 0,  0,  0,  0, 30]], dtype=int32)"
      }
    },
    {
      "name": "put_along_axis",
      "signature": "put_along_axis(arr: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], indices: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], values: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: int | None, inplace: bool = True, *, mode: str | None = None) -> jax.Array",
      "documentation": {
        "description": "Put values into the destination array by matching 1d index and data slices.\nJAX implementation of :func:`numpy.put_along_axis`.\nThe semantics of :func:`numpy.put_along_axis` are to modify arrays in-place, which\nis not possible for JAX's immutable arrays. The JAX version returns a modified\ncopy of the input, and adds the ``inplace`` parameter which must be set to\n`False`` by the user as a reminder of this API difference.\nArgs:\narr: array into which values will be put.\nindices: array of indices at which to put values.\nvalues: array of values to put into the array.\naxis: the axis along which to put values. If not specified, the array will\nbe flattened before indexing is applied.\ninplace: must be set to False to indicate that the input is not modified\nin-place, but rather a modified copy is returned.\nmode: Out-of-bounds indexing mode. For more discussion of ``mode`` options,\nsee :attr:`jax.numpy.ndarray.at`.",
        "parameters": {},
        "returns": "A copy of ``a`` with specified entries updated.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.put`: put elements into an array at given indices.\n- :func:`jax.numpy.place`: place elements into an array via boolean mask.\n- :func:`jax.numpy.ndarray.at`: array updates using NumPy-style indexing.\n- :func:`jax.numpy.take`: extract values from an array at given indices.\n- :func:`jax.numpy.take_along_axis`: extract values from an array along an axis.",
        "notes": "",
        "examples": ">>> from jax import numpy as jnp\n>>> a = jnp.array([[10, 30, 20], [60, 40, 50]])\n>>> i = jnp.argmax(a, axis=1, keepdims=True)\n>>> print(i)\n[[1]\n[0]]\n>>> b = jnp.put_along_axis(a, i, 99, axis=1, inplace=False)\n>>> print(b)\n[[10 99 20]\n[99 40 50]]"
      }
    },
    {
      "name": "quantile",
      "signature": "quantile(a: 'ArrayLike', q: 'ArrayLike', axis: 'int | tuple[int, ...] | None' = None, out: 'None' = None, overwrite_input: 'bool' = False, method: 'str' = 'linear', keepdims: 'bool' = False, *, interpolation: 'DeprecatedArg | str' = Deprecated) -> 'Array'",
      "documentation": {
        "description": "Compute the quantile of the data along the specified axis.\nJAX implementation of :func:`numpy.quantile`.\nArgs:\na: N-dimensional array input.\nq: scalar or 1-dimensional array specifying the desired quantiles. ``q``\nshould contain floating-point values between ``0.0`` and ``1.0``.\naxis: optional axis or tuple of axes along which to compute the quantile\nout: not implemented by JAX; will error if not None\noverwrite_input: not implemented by JAX; will error if not False\nmethod: specify the interpolation method to use. Options are one of\n``[\"linear\", \"lower\", \"higher\", \"midpoint\", \"nearest\"]``.\ndefault is ``linear``.\nkeepdims: if True, then the returned array will have the same number of\ndimensions as the input. Default is False.\ninterpolation: deprecated alias of the ``method`` argument. Will result\nin a :class:`DeprecationWarning` if used.",
        "parameters": {},
        "returns": "An array containing the specified quantiles along the specified axes.\nSee also:\n- :func:`jax.numpy.nanquantile`: compute the quantile while ignoring NaNs\n- :func:`jax.numpy.percentile`: compute the percentile (0-100)",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Computing the median and quartiles of an array, with linear interpolation:\n>>> x = jnp.arange(10)\n>>> q = jnp.array([0.25, 0.5, 0.75])\n>>> jnp.quantile(x, q)\nArray([2.25, 4.5 , 6.75], dtype=float32)\nComputing the quartiles using nearest-value interpolation:\n>>> jnp.quantile(x, q, method='nearest')\nArray([2., 4., 7.], dtype=float32)"
      }
    },
    {
      "name": "rad2deg",
      "signature": "rad2deg(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Convert angles from radians to degrees.\nJAX implementation of :obj:`numpy.rad2deg`.\nThe angle in radians is converted to degrees by:\n.. math::\nrad2deg(x) = x * \\frac{180}{pi}\nArgs:\nx: scalar or array. Specifies the angle in radians.",
        "parameters": {},
        "returns": "An array containing the angles in degrees.\nSee also:\n- :func:`jax.numpy.deg2rad` and :func:`jax.numpy.radians`: Converts the angles\nfrom degrees to radians.\n- :func:`jax.numpy.degrees`: Alias of ``rad2deg``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> pi = jnp.pi\n>>> x = jnp.array([pi/4, pi/2, 2*pi/3])\n>>> jnp.rad2deg(x)\nArray([ 45.     ,  90.     , 120.00001], dtype=float32)\n>>> x * 180 / pi\nArray([ 45.,  90., 120.], dtype=float32)"
      }
    },
    {
      "name": "radians",
      "signature": "radians(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Alias of :func:`jax.numpy.deg2rad`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ravel",
      "signature": "ravel(a: 'ArrayLike', order: 'str' = 'C') -> 'Array'",
      "documentation": {
        "description": "Flatten array into a 1-dimensional shape.\nJAX implementation of :func:`numpy.ravel`, implemented in terms of\n:func:`jax.lax.reshape`.\n``ravel(arr, order=order)`` is equivalent to ``reshape(arr, -1, order=order)``.\nArgs:\na: array to be flattened.\norder: ``'F'`` or ``'C'``, specifies whether the reshape should apply column-major\n(fortran-style, ``\"F\"``) or row-major (C-style, ``\"C\"``) order; default is ``\"C\"``.\nJAX does not support `order=\"A\"` or `order=\"K\"`.",
        "parameters": {},
        "returns": "flattened copy of input array.",
        "raises": "",
        "see_also": "- :meth:`jax.Array.ravel`: equivalent functionality via an array method.\n- :func:`jax.numpy.reshape`: general array reshape.",
        "notes": "Unlike :func:`numpy.ravel`, :func:`jax.numpy.ravel` will return a copy rather\nthan a view of the input array. However, under JIT, the compiler will optimize-away\nsuch copies when possible, so this doesn't have performance impacts in practice.",
        "examples": ">>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\nBy default, ravel in C-style, row-major order\n>>> jnp.ravel(x)\nArray([1, 2, 3, 4, 5, 6], dtype=int32)\nOptionally ravel in Fortran-style, column-major:\n>>> jnp.ravel(x, order='F')\nArray([1, 4, 2, 5, 3, 6], dtype=int32)\nFor convenience, the same functionality is available via the :meth:`jax.Array.ravel`\nmethod:\n>>> x.ravel()\nArray([1, 2, 3, 4, 5, 6], dtype=int32)"
      }
    },
    {
      "name": "ravel_multi_index",
      "signature": "ravel_multi_index(multi_index: 'Sequence[ArrayLike]', dims: 'Sequence[int]', mode: 'str' = 'raise', order: 'str' = 'C') -> 'Array'",
      "documentation": {
        "description": "Convert multi-dimensional indices into flat indices.\nJAX implementation of :func:`numpy.ravel_multi_index`\nArgs:\nmulti_index: sequence of integer arrays containing indices in each dimension.\ndims: sequence of integer sizes; must have ``len(dims) == len(multi_index)``\nmode: how to handle out-of bound indices. Options are\n- ``\"raise\"`` (default): raise a ValueError. This mode is incompatible\nwith :func:`~jax.jit` or other JAX transformations.\n- ``\"clip\"``: clip out-of-bound indices to valid range.\n- ``\"wrap\"``: wrap out-of-bound indices to valid range.\norder: ``\"C\"`` (default) or ``\"F\"``, specify whether to assume C-style\nrow-major order or Fortran-style column-major order.",
        "parameters": {},
        "returns": "array of flattened indices\nSee also:\n:func:`jax.numpy.unravel_index`: inverse of this function.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Define a 2-dimensional array and a sequence of indices of even values:\n>>> x = jnp.array([[2., 3., 4.],\n...                [5., 6., 7.]])\n>>> indices = jnp.where(x % 2 == 0)\n>>> indices\n(Array([0, 0, 1], dtype=int32), Array([0, 2, 1], dtype=int32))\n>>> x[indices]\nArray([2., 4., 6.], dtype=float32)\nCompute the flattened indices:\n>>> indices_flat = jnp.ravel_multi_index(indices, x.shape)\n>>> indices_flat\nArray([0, 2, 4], dtype=int32)\nThese flattened indices can be used to extract the same values from the\nflattened ``x`` array:\n>>> x_flat = x.ravel()\n>>> x_flat\nArray([2., 3., 4., 5., 6., 7.], dtype=float32)\n>>> x_flat[indices_flat]\nArray([2., 4., 6.], dtype=float32)\nThe original indices can be recovered with :func:`~jax.numpy.unravel_index`:\n>>> jnp.unravel_index(indices_flat, x.shape)\n(Array([0, 0, 1], dtype=int32), Array([0, 2, 1], dtype=int32))"
      }
    },
    {
      "name": "real",
      "signature": "real(val: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return element-wise real part of the complex argument.\nJAX implementation of :obj:`numpy.real`.\nArgs:\nval: input array or scalar.",
        "parameters": {},
        "returns": "An array containing the real part of the elements of ``val``.\nSee also:\n- :func:`jax.numpy.conjugate` and :func:`jax.numpy.conj`: Returns the element-wise\ncomplex-conjugate of the input.\n- :func:`jax.numpy.imag`: Returns the element-wise imaginary part of the\ncomplex argument.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.real(5)\nArray(5, dtype=int32, weak_type=True)\n>>> jnp.real(2j)\nArray(0., dtype=float32, weak_type=True)\n>>> x = jnp.array([3-2j, 4+7j, -2j])\n>>> jnp.real(x)\nArray([ 3.,  4., -0.], dtype=float32)"
      }
    },
    {
      "name": "reciprocal",
      "signature": "reciprocal(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise reciprocal of the input.\nJAX implementation of :obj:`numpy.reciprocal`.\nThe reciprocal is calculated by ``1/x``.\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array of same shape as ``x`` containing the reciprocal of each element of\n``x``.\nNote:\nFor integer inputs, ``np.reciprocal`` returns rounded integer output, while\n``jnp.reciprocal`` promotes integer inputs to floating point.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.reciprocal(2)\nArray(0.5, dtype=float32, weak_type=True)\n>>> jnp.reciprocal(0.)\nArray(inf, dtype=float32, weak_type=True)\n>>> x = jnp.array([1, 5., 4.])\n>>> jnp.reciprocal(x)\nArray([1.  , 0.2 , 0.25], dtype=float32)"
      }
    },
    {
      "name": "remainder",
      "signature": "remainder(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementation of :obj:`numpy.remainder`.\nArgs:\nx1: scalar or array. Specifies the dividend.\nx2: scalar or array. Specifies the divisor. ``x1`` and ``x2`` should either\nhave same shape or be broadcast compatible.\nAn array containing the remainder of element-wise division of ``x1`` by\n``x2`` with same sign as the elements of ``x2``.\nNote:\nThe result of ``jnp.remainder`` is equivalent to ``x1 - x2 * jnp.floor(x1 / x2)``.\nSee also:\n- :func:`jax.numpy.mod`: Returns the element-wise remainder of the division.\n- :func:`jax.numpy.fmod`: Calculates the element-wise floating-point modulo\noperation.\n- :func:`jax.numpy.divmod`: Calculates the integer quotient and remainder of\n``x1`` by ``x2``, element-wise.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([[3, -1, 4],\n...                 [8, 5, -2]])\n>>> x2 = jnp.array([2, 3, -5])\n>>> jnp.remainder(x1, x2)\nArray([[ 1,  2, -1],\n[ 0,  2, -2]], dtype=int32)\n>>> x1 - x2 * jnp.floor(x1 / x2)\nArray([[ 1.,  2., -1.],\n[ 0.,  2., -2.]], dtype=float32)"
      }
    },
    {
      "name": "repeat",
      "signature": "repeat(a: 'ArrayLike', repeats: 'ArrayLike', axis: 'int | None' = None, *, total_repeat_length: 'int | None' = None) -> 'Array'",
      "documentation": {
        "description": "Construct an array from repeated elements.\nJAX implementation of :func:`numpy.repeat`.\nArgs:\na: N-dimensional array\nrepeats: 1D integer array specifying the number of repeats. Must match the\nlength of the repeated axis.\naxis: integer specifying the axis of ``a`` along which to construct the\nrepeated array. If None (default) then ``a`` is first flattened.\ntotal_repeat_length: this must be specified statically for ``jnp.repeat``\nto be compatible with :func:`~jax.jit` and other JAX transformations.\nIf ``sum(repeats)`` is larger than the specified ``total_repeat_length``,\nthe remaining values will be discarded. If ``sum(repeats)`` is smaller\nthan ``total_repeat_length``, the final value will be repeated.",
        "parameters": {},
        "returns": "an array constructed from repeated values of ``a``.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.tile`: repeat a full array rather than individual values.",
        "notes": "",
        "examples": "Repeat each value twice along the last axis:\n>>> a = jnp.array([[1, 2],\n...                [3, 4]])\n>>> jnp.repeat(a, 2, axis=-1)\nArray([[1, 1, 2, 2],\n[3, 3, 4, 4]], dtype=int32)\nIf ``axis`` is not specified, the input array will be flattened:\n>>> jnp.repeat(a, 2)\nArray([1, 1, 2, 2, 3, 3, 4, 4], dtype=int32)\nPass an array to ``repeats`` to repeat each value a different number of times:\n>>> repeats = jnp.array([2, 3])\n>>> jnp.repeat(a, repeats, axis=1)\nArray([[1, 1, 2, 2, 2],\n[3, 3, 4, 4, 4]], dtype=int32)\nIn order to use ``repeat`` within ``jit`` and other JAX transformations, the\nsize of the output must be specified statically using ``total_repeat_length``:\n>>> jit_repeat = jax.jit(jnp.repeat, static_argnames=['axis', 'total_repeat_length'])\n>>> jit_repeat(a, repeats, axis=1, total_repeat_length=5)\nArray([[1, 1, 2, 2, 2],\n[3, 3, 4, 4, 4]], dtype=int32)\nIf `total_repeat_length` is smaller than ``sum(repeats)``, the result will be truncated:\n>>> jit_repeat(a, repeats, axis=1, total_repeat_length=4)\nArray([[1, 1, 2, 2],\n[3, 3, 4, 4]], dtype=int32)\nIf it is larger, then the additional entries will be filled with the final value:\n>>> jit_repeat(a, repeats, axis=1, total_repeat_length=7)\nArray([[1, 1, 2, 2, 2, 2, 2],\n[3, 3, 4, 4, 4, 4, 4]], dtype=int32)"
      }
    },
    {
      "name": "reshape",
      "signature": "reshape(a: 'ArrayLike', shape: 'DimSize | Shape | None' = None, order: 'str' = 'C', *, newshape: 'DimSize | Shape | DeprecatedArg' = Deprecated, copy: 'bool | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return a reshaped copy of an array.\nJAX implementation of :func:`numpy.reshape`, implemented in terms of\n:func:`jax.lax.reshape`.\nArgs:\na: input array to reshape\nshape: integer or sequence of integers giving the new shape, which must match the\nsize of the input array. If any single dimension is given size ``-1``, it will be\nreplaced with a value such that the output has the correct size.\norder: ``'F'`` or ``'C'``, specifies whether the reshape should apply column-major\n(fortran-style, ``\"F\"``) or row-major (C-style, ``\"C\"``) order; default is ``\"C\"``.\nJAX does not support ``order=\"A\"``.\ncopy: unused by JAX; JAX always returns a copy, though under JIT the compiler\nmay optimize such copies away.\nnewshape: deprecated alias of the ``shape`` argument. Will result in a\n:class:`DeprecationWarning` if used.",
        "parameters": {},
        "returns": "reshaped copy of input array with the specified shape.",
        "raises": "",
        "see_also": "- :meth:`jax.Array.reshape`: equivalent functionality via an array method.\n- :func:`jax.numpy.ravel`: flatten an array into a 1D shape.\n- :func:`jax.numpy.squeeze`: remove one or more length-1 axes from an array's shape.",
        "notes": "Unlike :func:`numpy.reshape`, :func:`jax.numpy.reshape` will return a copy rather\nthan a view of the input array. However, under JIT, the compiler will optimize-away\nsuch copies when possible, so this doesn't have performance impacts in practice.",
        "examples": ">>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> jnp.reshape(x, 6)\nArray([1, 2, 3, 4, 5, 6], dtype=int32)\n>>> jnp.reshape(x, (3, 2))\nArray([[1, 2],\n[3, 4],\n[5, 6]], dtype=int32)\nYou can use ``-1`` to automatically compute a shape that is consistent with\nthe input size:\n>>> jnp.reshape(x, -1)  # -1 is inferred to be 6\nArray([1, 2, 3, 4, 5, 6], dtype=int32)\n>>> jnp.reshape(x, (-1, 2))  # -1 is inferred to be 3\nArray([[1, 2],\n[3, 4],\n[5, 6]], dtype=int32)\nThe default ordering of axes in the reshape is C-style row-major ordering.\nTo use Fortran-style column-major ordering, specify ``order='F'``:\n>>> jnp.reshape(x, 6, order='F')\nArray([1, 4, 2, 5, 3, 6], dtype=int32)\n>>> jnp.reshape(x, (3, 2), order='F')\nArray([[1, 5],\n[4, 3],\n[2, 6]], dtype=int32)\nFor convenience, this functionality is also available via the\n:meth:`jax.Array.reshape` method:\n>>> x.reshape(3, 2)\nArray([[1, 2],\n[3, 4],\n[5, 6]], dtype=int32)"
      }
    },
    {
      "name": "resize",
      "signature": "resize(a: 'ArrayLike', new_shape: 'Shape') -> 'Array'",
      "documentation": {
        "description": "Return a new array with specified shape.\nJAX implementation of :func:`numpy.resize`.\nArgs:\na: input array or scalar.\nnew_shape: int or tuple of ints. Specifies the shape of the resized array.",
        "parameters": {},
        "returns": "A resized array with specified shape. The elements of ``a`` are repeated in\nthe resized array, if the resized array is larger than the original aray.\nSee also:\n- :func:`jax.numpy.reshape`: Returns a reshaped copy of an array.\n- :func:`jax.numpy.repeat`: Constructs an array from repeated elements.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> jnp.resize(x, (3, 3))\nArray([[1, 2, 3],\n[4, 5, 6],\n[7, 8, 9]], dtype=int32)\n>>> jnp.resize(x, (3, 4))\nArray([[1, 2, 3, 4],\n[5, 6, 7, 8],\n[9, 1, 2, 3]], dtype=int32)\n>>> jnp.resize(4, (3, 2))\nArray([[4, 4],\n[4, 4],\n[4, 4]], dtype=int32, weak_type=True)"
      }
    },
    {
      "name": "result_type",
      "signature": "result_type(*args: 'Any') -> 'DType'",
      "documentation": {
        "description": "Return the result of applying JAX promotion rules to the inputs.\nJAX implementation of :func:`numpy.result_type`.\nJAX's dtype promotion behavior is described in :ref:`type-promotion`.\nArgs:\nargs: one or more arrays or dtype-like objects.",
        "parameters": {},
        "returns": "A :class:`numpy.dtype` instance representing the result of type\npromotion for the inputs.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Inputs can be dtype specifiers:\n>>> jnp.result_type('int32', 'float32')\ndtype('float32')\n>>> jnp.result_type(np.uint16, np.dtype('int32'))\ndtype('int32')\nInputs may also be scalars or arrays:\n>>> jnp.result_type(1.0, jnp.bfloat16(2))\ndtype(bfloat16)\n>>> jnp.result_type(jnp.arange(4), jnp.zeros(4))\ndtype('float32')\nBe aware that the result type will be canonicalized based on the state\nof the ``jax_enable_x64`` configuration flag, meaning that 64-bit types\nmay be downcast to 32-bit:\n>>> jnp.result_type('float64')\ndtype('float32')\nFor details on 64-bit values, refer to `Sharp bits - double precision`_:\n.. _Sharp bits - double precision: https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#double-64bit-precision"
      }
    },
    {
      "name": "right_shift",
      "signature": "right_shift(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Right shift the bits of ``x1`` to the amount specified in ``x2``.\nJAX implementation of :obj:`numpy.right_shift`.\nArgs:\nx1: Input array, only accepts unsigned integer subtypes\nx2: The amount of bits to shift each element in ``x1`` to the right, only accepts\ninteger subtypes",
        "parameters": {},
        "returns": "An array-like object containing the right shifted elements of ``x1`` by the\namount specified in ``x2``, with the same shape as the broadcasted shape of\n``x1`` and ``x2``.\nNote:\nIf ``x1.shape != x2.shape``, they must be compatible for broadcasting to a\nshared shape, this shared shape will also be the shape of the output. Right shifting\na scalar x1 by scalar x2 is equivalent to ``x1 // 2**x2``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> def print_binary(x):\n...   return [bin(int(val)) for val in x]\n>>> x1 = jnp.array([1, 2, 4, 8])\n>>> print_binary(x1)\n['0b1', '0b10', '0b100', '0b1000']\n>>> x2 = 1\n>>> result = jnp.right_shift(x1, x2)\n>>> result\nArray([0, 1, 2, 4], dtype=int32)\n>>> print_binary(result)\n['0b0', '0b1', '0b10', '0b100']\n>>> x1 = 16\n>>> print_binary([x1])\n['0b10000']\n>>> x2 = jnp.array([1, 2, 3, 4])\n>>> result = jnp.right_shift(x1, x2)\n>>> result\nArray([8, 4, 2, 1], dtype=int32)\n>>> print_binary(result)\n['0b1000', '0b100', '0b10', '0b1']"
      }
    },
    {
      "name": "rint",
      "signature": "rint(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Rounds the elements of x to the nearest integer\nJAX implementation of :obj:`numpy.rint`.\nArgs:\nx: Input array",
        "parameters": {},
        "returns": "An array-like object containing the rounded elements of ``x``. Always promotes\nto inexact.\nNote:\nIf an element of x is exactly half way, e.g. ``0.5`` or ``1.5``, rint will round\nto the nearest even integer.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.array([5, 4, 7])\n>>> jnp.rint(x1)\nArray([5., 4., 7.], dtype=float32)\n>>> x2 = jnp.array([-2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5, 4.5])\n>>> jnp.rint(x2)\nArray([-2., -2., -0.,  0.,  2.,  2.,  4.,  4.], dtype=float32)\n>>> x3 = jnp.array([-2.5+3.5j, 4.5-0.5j])\n>>> jnp.rint(x3)\nArray([-2.+4.j,  4.-0.j], dtype=complex64)"
      }
    },
    {
      "name": "roll",
      "signature": "roll(a: 'ArrayLike', shift: 'ArrayLike | Sequence[int]', axis: 'int | Sequence[int] | None' = None) -> 'Array'",
      "documentation": {
        "description": "Roll the elements of an array along a specified axis.\nJAX implementation of :func:`numpy.roll`.\nArgs:\na: input array.\nshift: the number of positions to shift the specified axis. If an integer,\nall axes are shifted by the same amount. If a tuple, the shift for each\naxis is specified individually.\naxis: the axis or axes to roll. If ``None``, the array is flattened, shifted,\nand then reshaped to its original shape.",
        "parameters": {},
        "returns": "A copy of ``a`` with elements rolled along the specified axis or axes.\nSee also:\n- :func:`jax.numpy.rollaxis`: roll the specified axis to a given position.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> a = jnp.array([0, 1, 2, 3, 4, 5])\n>>> jnp.roll(a, 2)\nArray([4, 5, 0, 1, 2, 3], dtype=int32)\nRoll elements along a specific axis:\n>>> a = jnp.array([[ 0,  1,  2,  3],\n...                [ 4,  5,  6,  7],\n...                [ 8,  9, 10, 11]])\n>>> jnp.roll(a, 1, axis=0)\nArray([[ 8,  9, 10, 11],\n[ 0,  1,  2,  3],\n[ 4,  5,  6,  7]], dtype=int32)\n>>> jnp.roll(a, [2, 3], axis=[0, 1])\nArray([[ 5,  6,  7,  4],\n[ 9, 10, 11,  8],\n[ 1,  2,  3,  0]], dtype=int32)"
      }
    },
    {
      "name": "rollaxis",
      "signature": "rollaxis(a: 'ArrayLike', axis: 'int', start: 'int' = 0) -> 'Array'",
      "documentation": {
        "description": "Roll the specified axis to a given position.\nJAX implementation of :func:`numpy.rollaxis`.\nThis function exists for compatibility with NumPy, but in most cases the newer\n:func:`jax.numpy.moveaxis` instead, because the meaning of its arguments is\nmore intuitive.\nArgs:\na: input array.\naxis: index of the axis to roll forward.\nstart: index toward which the axis will be rolled (default = 0). After\nnormalizing negative axes, if ``start <= axis``, the axis is rolled to\nthe ``start`` index; if ``start > axis``, the axis is rolled until the\nposition before ``start``.",
        "parameters": {},
        "returns": "Copy of ``a`` with rolled axis.",
        "raises": "",
        "see_also": "",
        "notes": "Unlike :func:`numpy.rollaxis`, :func:`jax.numpy.rollaxis` will return a copy rather\nthan a view of the input array. However, under JIT, the compiler will optimize away\nsuch copies when possible, so this doesn't have performance impacts in practice.\nSee also:\n- :func:`jax.numpy.moveaxis`: newer API with clearer semantics than ``rollaxis``;\nthis should be preferred to ``rollaxis`` in most cases.\n- :func:`jax.numpy.swapaxes`: swap two axes.\n- :func:`jax.numpy.transpose`: general permutation of axes.",
        "examples": ">>> a = jnp.ones((2, 3, 4, 5))\nRoll axis 2 to the start of the array:\n>>> jnp.rollaxis(a, 2).shape\n(4, 2, 3, 5)\nRoll axis 1 to the end of the array:\n>>> jnp.rollaxis(a, 1, a.ndim).shape\n(2, 4, 5, 3)\nEquivalent of these two with :func:`~jax.numpy.moveaxis`\n>>> jnp.moveaxis(a, 2, 0).shape\n(4, 2, 3, 5)\n>>> jnp.moveaxis(a, 1, -1).shape\n(2, 4, 5, 3)"
      }
    },
    {
      "name": "roots",
      "signature": "roots(p: 'ArrayLike', *, strip_zeros: 'bool' = True) -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "JAX implementations of :func:`numpy.roots`.\nArgs:\np: Array of polynomial coefficients having rank-1.\nstrip_zeros : bool, default=True. If True, then leading zeros in the\ncoefficients will be stripped, similar to :func:`numpy.roots`. If set to\nFalse, leading zeros will not be stripped, and undefined roots will be\nrepresented by NaN values in the function output. ``strip_zeros`` must be\nset to ``False`` for the function to be compatible with :func:`jax.jit` and\nother JAX transformations.\nAn array containing the roots of the polynomial.\nNote:\nUnlike ``np.roots`` of this function, the ``jnp.roots`` returns the roots\nin a complex array regardless of the values of the roots.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.poly`: Finds the polynomial coefficients of the given\nsequence of roots.\n- :func:`jax.numpy.polyfit`: Least squares polynomial fit to data.\n- :func:`jax.numpy.polyval`: Evaluate a polynomial at specific values.",
        "notes": "",
        "examples": ">>> coeffs = jnp.array([0, 1, 2])\nThe default behavior matches numpy and strips leading zeros:\n>>> jnp.roots(coeffs)\nArray([-2.+0.j], dtype=complex64)\nWith ``strip_zeros=False``, extra roots are set to NaN:\n>>> jnp.roots(coeffs, strip_zeros=False)\nArray([-2. +0.j, nan+nanj], dtype=complex64)"
      }
    },
    {
      "name": "rot90",
      "signature": "rot90(m: 'ArrayLike', k: 'int' = 1, axes: 'tuple[int, int]' = (0, 1)) -> 'Array'",
      "documentation": {
        "description": "Rotate an array by 90 degrees counterclockwise in the plane specified by axes.\nJAX implementation of :func:`numpy.rot90`.\nArgs:\nm: input array. Must have ``m.ndim >= 2``.\nk: int, optional, default=1. Specifies the number of times the array is rotated.\nFor negative values of ``k``, the array is rotated in clockwise direction.\naxes: tuple of 2 integers, optional, default= (0, 1). The axes define the plane\nin which the array is rotated. Both the axes must be different.",
        "parameters": {},
        "returns": "An array containing the copy of the input, ``m`` rotated by 90 degrees.\nSee also:\n- :func:`jax.numpy.flip`: reverse the order along the given axis\n- :func:`jax.numpy.fliplr`: reverse the order along axis 1 (left/right)\n- :func:`jax.numpy.flipud`: reverse the order along axis 0 (up/down)",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> m = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> jnp.rot90(m)\nArray([[3, 6],\n[2, 5],\n[1, 4]], dtype=int32)\n>>> jnp.rot90(m, k=2)\nArray([[6, 5, 4],\n[3, 2, 1]], dtype=int32)\n``jnp.rot90(m, k=1, axes=(1, 0))`` is equivalent to\n``jnp.rot90(m, k=-1, axes(0,1))``.\n>>> jnp.rot90(m, axes=(1, 0))\nArray([[4, 1],\n[5, 2],\n[6, 3]], dtype=int32)\n>>> jnp.rot90(m, k=-1, axes=(0, 1))\nArray([[4, 1],\n[5, 2],\n[6, 3]], dtype=int32)\nwhen input array has ``ndim>2``:\n>>> m1 = jnp.array([[[1, 2, 3],\n...                  [4, 5, 6]],\n...                 [[7, 8, 9],\n...                  [10, 11, 12]]])\n>>> jnp.rot90(m1, k=1, axes=(2, 1))\nArray([[[ 4,  1],\n[ 5,  2],\n[ 6,  3]],\n<BLANKLINE>\n[[10,  7],\n[11,  8],\n[12,  9]]], dtype=int32)"
      }
    },
    {
      "name": "round",
      "signature": "round(a: 'ArrayLike', decimals: 'int' = 0, out: 'None' = None) -> 'Array'",
      "documentation": {
        "description": "Round input evenly to the given number of decimals.\nJAX implementation of :func:`numpy.round`.\nArgs:\na: input array or scalar.\ndecimals: int, default=0. Number of decimal points to which the input needs\nto be rounded. It must be specified statically. Not implemented for\n``decimals < 0``.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array containing the rounded values to the specified ``decimals`` with\nsame shape and dtype as ``a``.\nNote:\n``jnp.round`` rounds to the nearest even integer for the values exactly halfway\nbetween rounded decimal values.\nSee also:\n- :func:`jax.numpy.floor`: Rounds the input to the nearest integer downwards.\n- :func:`jax.numpy.ceil`: Rounds the input to the nearest integer upwards.\n- :func:`jax.numpy.fix` and :func:numpy.trunc`: Rounds the input to the\nnearest integer towards zero.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([1.532, 3.267, 6.149])\n>>> jnp.round(x)\nArray([2., 3., 6.], dtype=float32)\n>>> jnp.round(x, decimals=2)\nArray([1.53, 3.27, 6.15], dtype=float32)\nFor values exactly halfway between rounded values:\n>>> x1 = jnp.array([10.5, 21.5, 12.5, 31.5])\n>>> jnp.round(x1)\nArray([10., 22., 12., 32.], dtype=float32)"
      }
    },
    {
      "name": "save",
      "signature": "save(file, arr, allow_pickle=True, fix_imports=True)",
      "documentation": {
        "description": "Save an array to a binary file in NumPy ``.npy`` format.",
        "parameters": {
          "file": {
            "type": "file, str, or pathlib.Path",
            "description": "File or filename to which the data is saved.  If file is a file-object,\nthen the filename is unchanged.  If file is a string or Path, a ``.npy``\nextension will be appended to the filename if it does not already\nhave one."
          },
          "arr": {
            "type": "array_like",
            "description": "Array data to be saved."
          },
          "allow_pickle": {
            "type": "bool, optional",
            "description": "Allow saving object arrays using Python pickles. Reasons for disallowing\npickles include security (loading pickled data can execute arbitrary\ncode) and portability (pickled objects may not be loadable on different\nPython installations, for example if the stored objects require libraries\nthat are not available, and not all pickled data is compatible between\nPython 2 and Python 3)."
          },
          "Default": {
            "type": "True",
            "description": ""
          },
          "fix_imports": {
            "type": "bool, optional",
            "description": "Only useful in forcing objects in object arrays on Python 3 to be\npickled in a Python 2 compatible way. If `fix_imports` is True, pickle\nwill try to map the new Python 3 names to the old module names used in\nPython 2, so that the pickle data stream is readable with Python 2."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\nsavez : Save several arrays into a ``.npz`` archive\nsavetxt, load",
        "notes": "-----\nFor a description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.\nAny data saved to the file is appended to the end of the file.",
        "examples": "--------\n>>> from tempfile import TemporaryFile\n>>> outfile = TemporaryFile()\n>>> x = np.arange(10)\n>>> np.save(outfile, x)\n>>> _ = outfile.seek(0) # Only needed here to simulate closing & reopening file\n>>> np.load(outfile)\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> with open('test.npy', 'wb') as f:\n...     np.save(f, np.array([1, 2]))\n...     np.save(f, np.array([1, 3]))\n>>> with open('test.npy', 'rb') as f:\n...     a = np.load(f)\n...     b = np.load(f)\n>>> print(a, b)\n# [1 2] [1 3]"
      }
    },
    {
      "name": "savez",
      "signature": "savez(file, *args, **kwds)",
      "documentation": {
        "description": "Save several arrays into a single file in uncompressed ``.npz`` format.\nProvide arrays as keyword arguments to store them under the\ncorresponding name in the output file: ``savez(fn, x=x, y=y)``.\nIf arrays are specified as positional arguments, i.e., ``savez(fn,\nx, y)``, their names will be `arr_0`, `arr_1`, etc.",
        "parameters": {
          "file": {
            "type": "str or file",
            "description": "Either the filename (string) or an open file (file-like object)\nwhere the data will be saved. If file is a string or a Path, the\n``.npz`` extension will be appended to the filename if it is not\nalready there."
          },
          "args": {
            "type": "Arguments, optional",
            "description": "Arrays to save to the file. Please use keyword arguments (see\n`kwds` below) to assign names to arrays.  Arrays specified as\nargs will be named \"arr_0\", \"arr_1\", and so on."
          },
          "kwds": {
            "type": "Keyword arguments, optional",
            "description": "Arrays to save to the file. Each array will be saved to the\noutput file with its corresponding keyword name."
          }
        },
        "returns": "-------\nNone",
        "raises": "",
        "see_also": "--------\nsave : Save a single array to a binary file in NumPy format.\nsavetxt : Save an array to a file as plain text.\nsavez_compressed : Save several arrays into a compressed ``.npz`` archive",
        "notes": "-----\nThe ``.npz`` file format is a zipped archive of files named after the\nvariables they contain.  The archive is not compressed and each file\nin the archive contains one variable in ``.npy`` format. For a\ndescription of the ``.npy`` format, see :py:mod:`numpy.lib.format`.\nWhen opening the saved ``.npz`` file with `load` a `NpzFile` object is\nreturned. This is a dictionary-like object which can be queried for\nits list of arrays (with the ``.files`` attribute), and for the arrays\nthemselves.\nKeys passed in `kwds` are used as filenames inside the ZIP archive.\nTherefore, keys should be valid filenames; e.g., avoid keys that begin with\n``/`` or contain ``.``.\nWhen naming variables with keyword arguments, it is not possible to name a\nvariable ``file``, as this would cause the ``file`` argument to be defined\ntwice in the call to ``savez``.",
        "examples": "--------\n>>> from tempfile import TemporaryFile\n>>> outfile = TemporaryFile()\n>>> x = np.arange(10)\n>>> y = np.sin(x)\nUsing `savez` with \\*args, the arrays are saved with default names.\n>>> np.savez(outfile, x, y)\n>>> _ = outfile.seek(0) # Only needed here to simulate closing & reopening file\n>>> npzfile = np.load(outfile)\n>>> npzfile.files\n['arr_0', 'arr_1']\n>>> npzfile['arr_0']\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\nUsing `savez` with \\**kwds, the arrays are saved with the keyword names.\n>>> outfile = TemporaryFile()\n>>> np.savez(outfile, x=x, y=y)\n>>> _ = outfile.seek(0)\n>>> npzfile = np.load(outfile)\n>>> sorted(npzfile.files)\n['x', 'y']\n>>> npzfile['x']\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])"
      }
    },
    {
      "name": "searchsorted",
      "signature": "searchsorted(a: 'ArrayLike', v: 'ArrayLike', side: 'str' = 'left', sorter: 'ArrayLike | None' = None, *, method: 'str' = 'scan') -> 'Array'",
      "documentation": {
        "description": "Perform a binary search within a sorted array.\nJAX implementation of :func:`numpy.searchsorted`.\nThis will return the indices within a sorted array ``a`` where values in ``v``\ncan be inserted to maintain its sort order.\nArgs:\na: one-dimensional array, assumed to be in sorted order unless ``sorter`` is specified.\nv: N-dimensional array of query values\nside: ``'left'`` (default) or ``'right'``; specifies whether insertion indices will be\nto the left or the right in case of ties.\nsorter: optional array of indices specifying the sort order of ``a``. If specified,\nthen the algorithm assumes that ``a[sorter]`` is in sorted order.\nmethod: one of ``'scan'`` (default), ``'scan_unrolled'``, ``'sort'`` or ``'compare_all'``.\nSee *Note* below.",
        "parameters": {},
        "returns": "Array of insertion indices of shape ``v.shape``.\nNote:\nThe ``method`` argument controls the algorithm used to compute the insertion indices.\n- ``'scan'`` (the default) tends to be more performant on CPU, particularly when ``a`` is\nvery large.\n- ``'scan_unrolled'`` is more performant on GPU at the expense of additional compile time.\n- ``'sort'`` is often more performant on accelerator backends like GPU and TPU, particularly\nwhen ``v`` is very large.\n- ``'compare_all'`` tends to be the most performant when ``a`` is very small.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Searching for a single value:\n>>> a = jnp.array([1, 2, 2, 3, 4, 5, 5])\n>>> jnp.searchsorted(a, 2)\nArray(1, dtype=int32)\n>>> jnp.searchsorted(a, 2, side='right')\nArray(3, dtype=int32)\nSearching for a batch of values:\n>>> vals = jnp.array([0, 3, 8, 1.5, 2])\n>>> jnp.searchsorted(a, vals)\nArray([0, 3, 7, 1, 1], dtype=int32)\nOptionally, the ``sorter`` argument can be used to find insertion indices into\nan array sorted via :func:`jax.numpy.argsort`:\n>>> a = jnp.array([4, 3, 5, 1, 2])\n>>> sorter = jnp.argsort(a)\n>>> jnp.searchsorted(a, vals, sorter=sorter)\nArray([0, 2, 5, 1, 1], dtype=int32)\nThe result is equivalent to passing the sorted array:\n>>> jnp.searchsorted(jnp.sort(a), vals)\nArray([0, 2, 5, 1, 1], dtype=int32)"
      }
    },
    {
      "name": "select",
      "signature": "select(condlist: 'Sequence[ArrayLike]', choicelist: 'Sequence[ArrayLike]', default: 'ArrayLike' = 0) -> 'Array'",
      "documentation": {
        "description": "Select values based on a series of conditions.\nJAX implementation of :func:`numpy.select`, implemented in terms\nof :func:`jax.lax.select_n`\nArgs:\ncondlist: sequence of array-like conditions. All entries must be mutually\nbroadcast-compatible.\nchoicelist: sequence of array-like values to choose. Must have the same length\nas ``condlist``, and all entries must be broadcast-compatible with entries\nof ``condlist``.\ndefault: value to return when every condition is False (default: 0).",
        "parameters": {},
        "returns": "Array of selected values from ``choicelist`` corresponding to the first\n``True`` entry in ``condlist`` at each location.\nSee also:\n- :func:`jax.numpy.where`: select between two values based on a single condition.\n- :func:`jax.lax.select_n`: select between *N* values based on an index.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> condlist = [\n...    jnp.array([False, True, False, False]),\n...    jnp.array([True, False, False, False]),\n...    jnp.array([False, True, True, False]),\n... ]\n>>> choicelist = [\n...    jnp.array([1, 2, 3, 4]),\n...    jnp.array([10, 20, 30, 40]),\n...    jnp.array([100, 200, 300, 400]),\n... ]\n>>> jnp.select(condlist, choicelist, default=0)\nArray([ 10,   2, 300,   0], dtype=int32)\nThis is logically equivalent to the following nested ``where`` statement:\n>>> default = 0\n>>> jnp.where(condlist[0],\n...   choicelist[0],\n...   jnp.where(condlist[1],\n...     choicelist[1],\n...     jnp.where(condlist[2],\n...       choicelist[2],\n...       default)))\nArray([ 10,   2, 300,   0], dtype=int32)\nHowever, for efficiency it is implemented in terms of :func:`jax.lax.select_n`."
      }
    },
    {
      "name": "set_printoptions",
      "signature": "set_printoptions(*args, **kwargs)",
      "documentation": {
        "description": "Alias of :func:`numpy.set_printoptions`.\nJAX arrays are printed via NumPy, so NumPy's `printoptions`\nconfigurations will apply to printed JAX arrays.\nSee the :func:`numpy.set_printoptions` documentation for details\non the available options and their meanings.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "setdiff1d",
      "signature": "setdiff1d(ar1: 'ArrayLike', ar2: 'ArrayLike', assume_unique: 'bool' = False, *, size: 'int | None' = None, fill_value: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Compute the set difference of two 1D arrays.\nJAX implementation of :func:`numpy.setdiff1d`.\nBecause the size of the output of ``setdiff1d`` is data-dependent, the function\nis not typically compatible with :func:`~jax.jit` and other JAX transformations.\nThe JAX version adds the optional ``size`` argument which must be specified statically\nfor ``jnp.setdiff1d`` to be used in such contexts.\nArgs:\nar1: first array of elements to be differenced.\nar2: second array of elements to be differenced.\nassume_unique: if True, assume the input arrays contain unique values. This allows\na more efficient implementation, but if ``assume_unique`` is True and the input\narrays contain duplicates, the behavior is undefined. default: False.\nsize: if specified, return only the first ``size`` sorted elements. If there are fewer\nelements than ``size`` indicates, the return value will be padded with ``fill_value``.\nfill_value: when ``size`` is specified and there are fewer than the indicated number of\nelements, fill the remaining entries ``fill_value``. Defaults to the minimum value.",
        "parameters": {},
        "returns": "an array containing the set difference of elements in the input array: i.e. the elements\nin ``ar1`` that are not contained in ``ar2``.\nSee also:\n- :func:`jax.numpy.intersect1d`: the set intersection of two 1D arrays.\n- :func:`jax.numpy.setxor1d`: the set XOR of two 1D arrays.\n- :func:`jax.numpy.union1d`: the set union of two 1D arrays.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Computing the set difference of two arrays:\n>>> ar1 = jnp.array([1, 2, 3, 4])\n>>> ar2 = jnp.array([3, 4, 5, 6])\n>>> jnp.setdiff1d(ar1, ar2)\nArray([1, 2], dtype=int32)\nBecause the output shape is dynamic, this will fail under :func:`~jax.jit` and other\ntransformations:\n>>> jax.jit(jnp.setdiff1d)(ar1, ar2)  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nConcretizationTypeError: Abstract tracer value encountered where concrete value is expected: traced array with shape int32[4].\nThe error occurred while tracing the function setdiff1d at /Users/vanderplas/github/jax-ml/jax/jax/_src/numpy/setops.py:64 for jit. This concrete value was not available in Python because it depends on the value of the argument ar1.\nIn order to ensure statically-known output shapes, you can pass a static ``size``\nargument:\n>>> jit_setdiff1d = jax.jit(jnp.setdiff1d, static_argnames=['size'])\n>>> jit_setdiff1d(ar1, ar2, size=2)\nArray([1, 2], dtype=int32)\nIf ``size`` is too small, the difference is truncated:\n>>> jit_setdiff1d(ar1, ar2, size=1)\nArray([1], dtype=int32)\nIf ``size`` is too large, then the output is padded with ``fill_value``:\n>>> jit_setdiff1d(ar1, ar2, size=4, fill_value=0)\nArray([1, 2, 0, 0], dtype=int32)"
      }
    },
    {
      "name": "setxor1d",
      "signature": "setxor1d(ar1: 'ArrayLike', ar2: 'ArrayLike', assume_unique: 'bool' = False, *, size: 'int | None' = None, fill_value: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Compute the set-wise xor of elements in two arrays.\nJAX implementation of :func:`numpy.setxor1d`.\nBecause the size of the output of ``setxor1d`` is data-dependent, the function is not\ncompatible with JIT or other JAX transformations.\nArgs:\nar1: first array of values to intersect.\nar2: second array of values to intersect.\nassume_unique: if True, assume the input arrays contain unique values. This allows\na more efficient implementation, but if ``assume_unique`` is True and the input\narrays contain duplicates, the behavior is undefined. default: False.\nsize: if specified, return only the first ``size`` sorted elements. If there are fewer\nelements than ``size`` indicates, the return value will be padded with ``fill_value``,\nand returned indices will be padded with an out-of-bound index.\nfill_value: when ``size`` is specified and there are fewer than the indicated number of\nelements, fill the remaining entries ``fill_value``. Defaults to the smallest value\nin the xor result.",
        "parameters": {},
        "returns": "An array of values that are found in exactly one of the input arrays.\nSee also:\n- :func:`jax.numpy.intersect1d`: the set intersection of two 1D arrays.\n- :func:`jax.numpy.union1d`: the set union of two 1D arrays.\n- :func:`jax.numpy.setdiff1d`: the set difference of two 1D arrays.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> ar1 = jnp.array([1, 2, 3, 4])\n>>> ar2 = jnp.array([3, 4, 5, 6])\n>>> jnp.setxor1d(ar1, ar2)\nArray([1, 2, 5, 6], dtype=int32)"
      }
    },
    {
      "name": "shape",
      "signature": "shape(a: 'ArrayLike') -> 'tuple[int, ...]'",
      "documentation": {
        "description": "Return the shape an array.\nJAX implementation of :func:`numpy.shape`. Unlike ``np.shape``, this function\nraises a :class:`TypeError` if the input is a collection such as a list or\ntuple.\nArgs:\na: array-like object.",
        "parameters": {},
        "returns": "An tuple of integers representing the shape of ``a``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Shape for arrays:\n>>> x = jnp.arange(10)\n>>> jnp.shape(x)\n(10,)\n>>> y = jnp.ones((2, 3))\n>>> jnp.shape(y)\n(2, 3)\nThis also works for scalars:\n>>> jnp.shape(3.14)\n()\nFor arrays, this can also be accessed via the :attr:`jax.Array.shape` property:\n>>> x.shape\n(10,)"
      }
    },
    {
      "name": "sign",
      "signature": "sign(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return an element-wise indication of sign of the input.\nJAX implementation of :obj:`numpy.sign`.\nThe sign of ``x`` for real-valued input is:\n.. math::\n\\mathrm{sign}(x) = \\begin{cases}\n1, & x > 0\\\\\n0, & x = 0\\\\\n-1, & x < 0\n\\end{cases}\nFor complex valued input, ``jnp.sign`` returns a unit vector repesenting the\nphase. For generalized case, the sign of ``x`` is given by:\n.. math::\n\\mathrm{sign}(x) = \\begin{cases}\n\\frac{x}{abs(x)}, & x \\ne 0\\\\\n0, & x = 0\n\\end{cases}\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array with same shape and dtype as ``x`` containing the sign indication.\nSee also:\n- :func:`jax.numpy.positive`: Returns element-wise positive values of the input.\n- :func:`jax.numpy.negative`: Returns element-wise negative values of the input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "For Real-valued inputs:\n>>> x = jnp.array([0., -3., 7.])\n>>> jnp.sign(x)\nArray([ 0., -1.,  1.], dtype=float32)\nFor complex-inputs:\n>>> x1 = jnp.array([1, 3+4j, 5j])\n>>> jnp.sign(x1)\nArray([1. +0.j , 0.6+0.8j, 0. +1.j ], dtype=complex64)"
      }
    },
    {
      "name": "signbit",
      "signature": "signbit(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return the sign bit of array elements.\nJAX implementation of :obj:`numpy.signbit`.\nArgs:\nx: input array. Complex values are not supported.",
        "parameters": {},
        "returns": "A boolean array of the same shape as ``x``, containing ``True``\nwhere the sign of ``x`` is negative, and ``False`` otherwise.\nSee also:\n- :func:`jax.numpy.sign`: return the mathematical sign of array elements,\ni.e. ``-1``, ``0``, or ``+1``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ":func:`signbit` on boolean values is always ``False``:\n>>> x = jnp.array([True, False])\n>>> jnp.signbit(x)\nArray([False, False], dtype=bool)\n:func:`signbit` on integer values is equivalent to ``x < 0``:\n>>> x = jnp.array([-2, -1, 0, 1, 2])\n>>> jnp.signbit(x)\nArray([ True,  True, False, False, False], dtype=bool)\n:func:`signbit` on floating point values returns the value of the actual\nsign bit from the float representation, including signed zero:\n>>> x = jnp.array([-1.5, -0.0, 0.0, 1.5])\n>>> jnp.signbit(x)\nArray([ True, True, False, False], dtype=bool)\nThis also returns the sign bit for special values such as signed NaN\nand signed infinity:\n>>> x = jnp.array([jnp.nan, -jnp.nan, jnp.inf, -jnp.inf])\n>>> jnp.signbit(x)\nArray([False,  True, False,  True], dtype=bool)"
      }
    },
    {
      "name": "sin",
      "signature": "sin(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Compute a trigonometric sine of each element of input.\nJAX implementation of :obj:`numpy.sin`.\nArgs:\nx: array or scalar. Angle in radians.",
        "parameters": {},
        "returns": "An array containing the sine of each element in ``x``, promotes to inexact\ndtype.\nSee also:\n- :func:`jax.numpy.cos`: Computes a trigonometric cosine of each element of\ninput.\n- :func:`jax.numpy.tan`: Computes a trigonometric tangent of each element of\ninput.\n- :func:`jax.numpy.arcsin` and :func:`jax.numpy.asin`: Computes the inverse of\ntrigonometric sine of each element of input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> pi = jnp.pi\n>>> x = jnp.array([pi/4, pi/2, 3*pi/4, pi])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   print(jnp.sin(x))\n[ 0.707  1.     0.707 -0.   ]"
      }
    },
    {
      "name": "sinc",
      "signature": "sinc(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate the normalized sinc function.\nJAX implementation of :func:`numpy.sinc`.\nThe normalized sinc function is given by\n.. math::\n\\mathrm{sinc}(x) = \\frac{\\sin({\\pi x})}{\\pi x}\nwhere ``sinc(0)`` returns the limit value of ``1``. The sinc function is\nsmooth and infinitely differentiable.\nArgs:\nx : input array; will be promoted to an inexact type.",
        "parameters": {},
        "returns": "An array of the same shape as ``x`` containing the result.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([-1, -0.5, 0, 0.5, 1])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.sinc(x)\nArray([-0.   ,  0.637,  1.   ,  0.637, -0.   ], dtype=float32)\nCompare this to the naive approach to computing the function, which is\nundefined at zero:\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.sin(jnp.pi * x) / (jnp.pi * x)\nArray([-0.   ,  0.637,    nan,  0.637, -0.   ], dtype=float32)\nJAX defines a custom gradient rule for sinc to allow accurate evaluation\nof the gradient at zero even for higher-order derivatives:\n>>> f = jnp.sinc\n>>> for i in range(1, 6):\n...   f = jax.grad(f)\n...   print(f\"(d/dx)^{i} f(0.0) = {f(0.0):.2f}\")\n...\n(d/dx)^1 f(0.0) = 0.00\n(d/dx)^2 f(0.0) = -3.29\n(d/dx)^3 f(0.0) = 0.00\n(d/dx)^4 f(0.0) = 19.48\n(d/dx)^5 f(0.0) = 0.00"
      }
    },
    {
      "name": "sinh",
      "signature": "sinh(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise hyperbolic sine of input.\nJAX implementation of :obj:`numpy.sinh`.\nThe hyperbolic sine is defined by:\n.. math::\nsinh(x) = \\frac{e^x - e^{-x}}{2}\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array containing the hyperbolic sine of each element of ``x``, promoting\nto inexact dtype.\nNote:\n``jnp.sinh`` is equivalent to computing ``-1j * jnp.sin(1j * x)``.\nSee also:\n- :func:`jax.numpy.cosh`: Computes the element-wise hyperbolic cosine of the\ninput.\n- :func:`jax.numpy.tanh`: Computes the element-wise hyperbolic tangent of the\ninput.\n- :func:`jax.numpy.arcsinh`:  Computes the element-wise inverse of hyperbolic\nsine of the input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[-2, 3, 5],\n...                [0, -1, 4]])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.sinh(x)\nArray([[-3.627, 10.018, 74.203],\n[ 0.   , -1.175, 27.29 ]], dtype=float32)\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   -1j * jnp.sin(1j * x)\nArray([[-3.627+0.j, 10.018-0.j, 74.203-0.j],\n[ 0.   -0.j, -1.175+0.j, 27.29 -0.j]],      dtype=complex64, weak_type=True)\nFor complex-valued input:\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.sinh(3-2j)\nArray(-4.169-9.154j, dtype=complex64, weak_type=True)\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   -1j * jnp.sin(1j * (3-2j))\nArray(-4.169-9.154j, dtype=complex64, weak_type=True)"
      }
    },
    {
      "name": "size",
      "signature": "size(a: 'ArrayLike', axis: 'int | None' = None) -> 'int'",
      "documentation": {
        "description": "Return number of elements along a given axis.\nJAX implementation of :func:`numpy.size`. Unlike ``np.size``, this function\nraises a :class:`TypeError` if the input is a collection such as a list or\ntuple.\nArgs:\na: array-like object\naxis: optional integer along which to count elements. By default, return\nthe total number of elements.",
        "parameters": {},
        "returns": "An integer specifying the number of elements in ``a``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Size for arrays:\n>>> x = jnp.arange(10)\n>>> jnp.size(x)\n10\n>>> y = jnp.ones((2, 3))\n>>> jnp.size(y)\n6\n>>> jnp.size(y, axis=1)\n3\nThis also works for scalars:\n>>> jnp.size(3.14)\n1\nFor arrays, this can also be accessed via the :attr:`jax.Array.size` property:\n>>> y.size\n6"
      }
    },
    {
      "name": "sort",
      "signature": "sort(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: int | None = -1, *, kind: None = None, order: None = None, stable: bool = True, descending: bool = False) -> jax.Array",
      "documentation": {
        "description": "Return a sorted copy of an array.\nJAX implementation of :func:`numpy.sort`.\nArgs:\na: array to sort\naxis: integer axis along which to sort. Defaults to ``-1``, i.e. the last\naxis. If ``None``, then ``a`` is flattened before being sorted.\nstable: boolean specifying whether a stable sort should be used. Default=True.\ndescending: boolean specifying whether to sort in descending order. Default=False.\nkind: deprecated; instead specify sort algorithm using stable=True or stable=False.\norder: not supported by JAX",
        "parameters": {},
        "returns": "Sorted array of shape ``a.shape`` (if ``axis`` is an integer) or of shape\n``(a.size,)`` (if ``axis`` is None).",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Simple 1-dimensional sort\n>>> x = jnp.array([1, 3, 5, 4, 2, 1])\n>>> jnp.sort(x)\nArray([1, 1, 2, 3, 4, 5], dtype=int32)\nSort along the last axis of an array:\n>>> x = jnp.array([[2, 1, 3],\n...                [4, 3, 6]])\n>>> jnp.sort(x, axis=1)\nArray([[1, 2, 3],\n[3, 4, 6]], dtype=int32)\nSee also:\n- :func:`jax.numpy.argsort`: return indices of sorted values.\n- :func:`jax.numpy.lexsort`: lexicographical sort of multiple arrays.\n- :func:`jax.lax.sort`: lower-level function wrapping XLA's Sort operator."
      }
    },
    {
      "name": "sort_complex",
      "signature": "sort_complex(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex]) -> jax.Array",
      "documentation": {
        "description": "Return a sorted copy of complex array.\nJAX implementation of :func:`numpy.sort_complex`.\nComplex numbers are sorted lexicographically, meaning by their real part\nfirst, and then by their imaginary part if real parts are equal.\nArgs:\na: input array. If dtype is not complex, the array will be upcast to complex.",
        "parameters": {},
        "returns": "A sorted array of the same shape and complex dtype as the input. If ``a``\nis multi-dimensional, it is sorted along the last axis.\nSee also:\n- :func:`jax.numpy.sort`: Return a sorted copy of an array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> a = jnp.array([1+2j, 2+4j, 3-1j, 2+3j])\n>>> jnp.sort_complex(a)\nArray([1.+2.j, 2.+3.j, 2.+4.j, 3.-1.j], dtype=complex64)\nMulti-dimensional arrays are sorted along the last axis:\n>>> a = jnp.array([[5, 3, 4],\n...                [6, 9, 2]])\n>>> jnp.sort_complex(a)\nArray([[3.+0.j, 4.+0.j, 5.+0.j],\n[2.+0.j, 6.+0.j, 9.+0.j]], dtype=complex64)"
      }
    },
    {
      "name": "spacing",
      "signature": "spacing(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Return the spacing between ``x`` and the next adjacent number.\nJAX implementation of :func:`numpy.spacing`.\nArgs:\nx: real-valued array. Integer or boolean types will be cast to float.",
        "parameters": {},
        "returns": "Array of same shape as ``x`` containing spacing between each entry of\n``x`` and its closest adjacent value.\nSee also:\n- :func:`jax.numpy.nextafter`: find the next representable value.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([0.0, 0.25, 0.5, 0.75, 1.0], dtype='float32')\n>>> jnp.spacing(x)\nArray([1.4012985e-45, 2.9802322e-08, 5.9604645e-08, 5.9604645e-08,\n1.1920929e-07], dtype=float32)\nFor ``x = 1``, the spacing is equal to the ``eps`` value given by\n:class:`jax.numpy.finfo`:\n>>> x = jnp.float32(1)\n>>> jnp.spacing(x) == jnp.finfo(x.dtype).eps\nArray(True, dtype=bool)"
      }
    },
    {
      "name": "split",
      "signature": "split(ary: 'ArrayLike', indices_or_sections: 'int | Sequence[int] | ArrayLike', axis: 'int' = 0) -> 'list[Array]'",
      "documentation": {
        "description": "Split an array into sub-arrays.\nJAX implementation of :func:`numpy.split`.\nArgs:\nary: N-dimensional array-like object to split\nindices_or_sections: either a single integer or a sequence of indices.\n- if ``indices_or_sections`` is an integer *N*, then *N* must evenly divide\n``ary.shape[axis]`` and ``ary`` will be divided into *N* equally-sized\nchunks along ``axis``.\n- if ``indices_or_sections`` is a sequence of integers, then these integers\nspecify the boundary between unevenly-sized chunks along ``axis``; see\nexamples below.\naxis: the axis along which to split; defaults to 0.",
        "parameters": {},
        "returns": "A list of arrays. If ``indices_or_sections`` is an integer *N*, then the list is\nof length *N*. If ``indices_or_sections`` is a sequence *seq*, then the list is\nis of length *len(seq) + 1*.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Splitting a 1-dimensional array:\n>>> x = jnp.array([1, 2, 3, 4, 5, 6, 7, 8, 9])\nSplit into three equal sections:\n>>> chunks = jnp.split(x, 3)\n>>> print(*chunks)\n[1 2 3] [4 5 6] [7 8 9]\nSplit into sections by index:\n>>> chunks = jnp.split(x, [2, 7])  # [x[0:2], x[2:7], x[7:]]\n>>> print(*chunks)\n[1 2] [3 4 5 6 7] [8 9]\nSplitting a two-dimensional array along axis 1:\n>>> x = jnp.array([[1, 2, 3, 4],\n...                [5, 6, 7, 8]])\n>>> x1, x2 = jnp.split(x, 2, axis=1)\n>>> print(x1)\n[[1 2]\n[5 6]]\n>>> print(x2)\n[[3 4]\n[7 8]]\nSee also:\n- :func:`jax.numpy.array_split`: like ``split``, but allows ``indices_or_sections``\nto be an integer that does not evenly divide the size of the array.\n- :func:`jax.numpy.vsplit`: split vertically, i.e. along axis=0\n- :func:`jax.numpy.hsplit`: split horizontally, i.e. along axis=1\n- :func:`jax.numpy.dsplit`: split depth-wise, i.e. along axis=2"
      }
    },
    {
      "name": "sqrt",
      "signature": "sqrt(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculates element-wise non-negative square root of the input array.\nJAX implementation of :obj:`numpy.sqrt`.\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array containing the non-negative square root of the elements of ``x``.\nNote:\n- For real-valued negative inputs, ``jnp.sqrt`` produces a ``nan`` output.\n- For complex-valued negative inputs, ``jnp.sqrt`` produces a ``complex`` output.\nSee also:\n- :func:`jax.numpy.square`: Calculates the element-wise square of the input.\n- :func:`jax.numpy.power`: Calculates the element-wise base ``x1`` exponential\nof ``x2``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([-8-6j, 1j, 4])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.sqrt(x)\nArray([1.   -3.j   , 0.707+0.707j, 2.   +0.j   ], dtype=complex64)\n>>> jnp.sqrt(-1)\nArray(nan, dtype=float32, weak_type=True)"
      }
    },
    {
      "name": "square",
      "signature": "square(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise square of the input array.\nJAX implementation of :obj:`numpy.square`.\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array containing the square of the elements of ``x``.\nNote:\n``jnp.square`` is equivalent to computing ``jnp.power(x, 2)``.\nSee also:\n- :func:`jax.numpy.sqrt`: Calculates the element-wise non-negative square root\nof the input array.\n- :func:`jax.numpy.power`: Calculates the element-wise base ``x1`` exponential\nof ``x2``.\n- :func:`jax.lax.integer_pow`: Computes element-wise power :math:`x^y`, where\n:math:`y` is a fixed integer.\n- :func:`jax.numpy.float_power`: Computes the first array raised to the power\nof second array, element-wise, by promoting to the inexact dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([3, -2, 5.3, 1])\n>>> jnp.square(x)\nArray([ 9.      ,  4.      , 28.090002,  1.      ], dtype=float32)\n>>> jnp.power(x, 2)\nArray([ 9.      ,  4.      , 28.090002,  1.      ], dtype=float32)\nFor integer inputs:\n>>> x1 = jnp.array([2, 4, 5, 6])\n>>> jnp.square(x1)\nArray([ 4, 16, 25, 36], dtype=int32)\nFor complex-valued inputs:\n>>> x2 = jnp.array([1-3j, -1j, 2])\n>>> jnp.square(x2)\nArray([-8.-6.j, -1.+0.j,  4.+0.j], dtype=complex64)"
      }
    },
    {
      "name": "squeeze",
      "signature": "squeeze(a: 'ArrayLike', axis: 'int | Sequence[int] | None' = None) -> 'Array'",
      "documentation": {
        "description": "Remove one or more length-1 axes from array\nJAX implementation of :func:`numpy.sqeeze`, implemented via :func:`jax.lax.squeeze`.\nArgs:\na: input array\naxis: integer or sequence of integers specifying axes to remove. If any specified\naxis does not have a length of 1, an error is raised. If not specified, squeeze\nall length-1 axes in ``a``.",
        "parameters": {},
        "returns": "copy of ``a`` with length-1 axes removed.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.expand_dims`: the inverse of ``squeeze``: add dimensions of length 1.\n- :meth:`jax.Array.squeeze`: equivalent functionality via an array method.\n- :func:`jax.lax.squeeze`: equivalent XLA API.\n- :func:`jax.numpy.ravel`: flatten an array into a 1D shape.\n- :func:`jax.numpy.reshape`: general array reshape.",
        "notes": "Unlike :func:`numpy.squeeze`, :func:`jax.numpy.squeeze` will return a copy rather\nthan a view of the input array. However, under JIT, the compiler will optimize-away\nsuch copies when possible, so this doesn't have performance impacts in practice.",
        "examples": ">>> x = jnp.array([[[0]], [[1]], [[2]]])\n>>> x.shape\n(3, 1, 1)\nSqueeze all length-1 dimensions:\n>>> jnp.squeeze(x)\nArray([0, 1, 2], dtype=int32)\n>>> _.shape\n(3,)\nEquivalent while specifying the axes explicitly:\n>>> jnp.squeeze(x, axis=(1, 2))\nArray([0, 1, 2], dtype=int32)\nAttempting to squeeze a non-unit axis results in an error:\n>>> jnp.squeeze(x, axis=0)  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nValueError: cannot select an axis to squeeze out which has size not equal to one, got shape=(3, 1, 1) and dimensions=(0,)\nFor convenience, this functionality is also available via the\n:meth:`jax.Array.squeeze` method:\n>>> x.squeeze()\nArray([0, 1, 2], dtype=int32)"
      }
    },
    {
      "name": "stack",
      "signature": "stack(arrays: 'np.ndarray | Array | Sequence[ArrayLike]', axis: 'int' = 0, out: 'None' = None, dtype: 'DTypeLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Join arrays along a new axis.\nJAX implementation of :func:`numpy.stack`.\nArgs:\narrays: a sequence of arrays to stack; each must have the same shape. If a\nsingle array is given it will be treated equivalently to\n`arrays = unstack(arrays)`, but the implementation will avoid explicit\nunstacking.\naxis: specify the axis along which to stack.\nout: unused by JAX\ndtype: optional dtype of the resulting array. If not specified, the dtype\nwill be determined via type promotion rules described in :ref:`type-promotion`.",
        "parameters": {},
        "returns": "the stacked result.\nSee also:\n- :func:`jax.numpy.unstack`: inverse of ``stack``.\n- :func:`jax.numpy.concatenate`: concatenation along existing axes.\n- :func:`jax.numpy.vstack`: stack vertically, i.e. along axis 0.\n- :func:`jax.numpy.hstack`: stack horizontally, i.e. along axis 1.\n- :func:`jax.numpy.dstack`: stack depth-wise, i.e. along axis 2.\n- :func:`jax.numpy.column_stack`: stack columns.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([1, 2, 3])\n>>> y = jnp.array([4, 5, 6])\n>>> jnp.stack([x, y])\nArray([[1, 2, 3],\n[4, 5, 6]], dtype=int32)\n>>> jnp.stack([x, y], axis=1)\nArray([[1, 4],\n[2, 5],\n[3, 6]], dtype=int32)\n:func:`~jax.numpy.unstack` performs the inverse operation:\n>>> arr = jnp.stack([x, y], axis=1)\n>>> x, y = jnp.unstack(arr, axis=1)\n>>> x\nArray([1, 2, 3], dtype=int32)\n>>> y\nArray([4, 5, 6], dtype=int32)"
      }
    },
    {
      "name": "std",
      "signature": "std(a: 'ArrayLike', axis: 'Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, ddof: 'int' = 0, keepdims: 'bool' = False, *, where: 'ArrayLike | None' = None, correction: 'int | float | None' = None) -> 'Array'",
      "documentation": {
        "description": "Compute the standard deviation along a given axis.\nJAX implementation of :func:`numpy.std`.\nArgs:\na: input array.\naxis: optional, int or sequence of ints, default=None. Axis along which the\nstandard deviation is computed. If None, standard deviaiton is computed\nalong all the axes.\ndtype: The type of the output array. Default=None.\nddof: int, default=0. Degrees of freedom. The divisor in the standard deviation\ncomputation is ``N-ddof``, ``N`` is number of elements along given axis.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\nwhere: optional, boolean array, default=None. The elements to be used in the\nstandard deviation. Array should be broadcast compatible to the input.\ncorrection: int or float, default=None. Alternative name for ``ddof``.\nBoth ddof and correction can't be provided simultaneously.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array of the standard deviation along the given axis.\nSee also:\n- :func:`jax.numpy.var`: Compute the variance of array elements over given\naxis.\n- :func:`jax.numpy.mean`: Compute the mean of array elements over a given axis.\n- :func:`jax.numpy.nanvar`: Compute the variance along a given axis, ignoring\nNaNs values.\n- :func:`jax.numpy.nanstd`: Computed the standard deviation of a given axis,\nignoring NaN values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.std`` computes the standard deviation along all axes.\n>>> x = jnp.array([[1, 3, 4, 2],\n...                [4, 2, 5, 3],\n...                [5, 4, 2, 3]])\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   jnp.std(x)\nArray(1.21, dtype=float32)\nIf ``axis=0``, computes along axis 0.\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.std(x, axis=0))\n[1.7  0.82 1.25 0.47]\nTo preserve the dimensions of input, you can set ``keepdims=True``.\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.std(x, axis=0, keepdims=True))\n[[1.7  0.82 1.25 0.47]]\nIf ``ddof=1``:\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.std(x, axis=0, keepdims=True, ddof=1))\n[[2.08 1.   1.53 0.58]]\nTo include specific elements of the array to compute standard deviation, you\ncan use ``where``.\n>>> where = jnp.array([[1, 0, 1, 0],\n...                    [0, 1, 0, 1],\n...                    [1, 1, 1, 0]], dtype=bool)\n>>> jnp.std(x, axis=0, keepdims=True, where=where)\nArray([[2., 1., 1., 0.]], dtype=float32)"
      }
    },
    {
      "name": "subtract",
      "signature": "subtract(*args: 'ArrayLike', out: 'None' = None, where: 'None' = None) -> 'Any'",
      "documentation": {
        "description": "Subtract two arrays element-wise.\nJAX implementation of :obj:`numpy.subtract`. This is a universal function,\nand supports the additional APIs described at :class:`jax.numpy.ufunc`.\nThis function provides the implementation of the ``-`` operator for\nJAX arrays.\nArgs:\nx, y: arrays to subtract. Must be broadcastable to a common shape.",
        "parameters": {},
        "returns": "Array containing the result of the element-wise subtraction.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Calling ``subtract`` explicitly:\n>>> x = jnp.arange(4)\n>>> jnp.subtract(x, 10)\nArray([-10,  -9,  -8,  -7], dtype=int32)\nCalling ``subtract`` via the ``-`` operator:\n>>> x - 10\nArray([-10,  -9,  -8,  -7], dtype=int32)"
      }
    },
    {
      "name": "sum",
      "signature": "sum(a: 'ArrayLike', axis: 'Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None, promote_integers: 'bool' = True) -> 'Array'",
      "documentation": {
        "description": "Sum of the elements of the array over a given axis.\nJAX implementation of :func:`numpy.sum`.\nArgs:\na: Input array.\naxis: int or array, default=None. Axis along which the sum to be computed.\nIf None, the sum is computed along all the axes.\ndtype: The type of the output array. Default=None.\nout: Unused by JAX\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\ninitial: int or array, Default=None. Initial value for the sum.\nwhere: int or array, default=None. The elements to be used in the sum. Array\nshould be broadcast compatible to the input.\npromote_integers : bool, default=True. If True, then integer inputs will be\npromoted to the widest available integer dtype, following numpy's behavior.\nIf False, the result will have the same dtype as the input.\n``promote_integers`` is ignored if ``dtype`` is specified.",
        "parameters": {},
        "returns": "An array of the sum along the given axis.\nSee also:\n- :func:`jax.numpy.prod`: Compute the product of array elements over a given\naxis.\n- :func:`jax.numpy.max`: Compute the maximum of array elements over given axis.\n- :func:`jax.numpy.min`: Compute the minimum of array elements over given axis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, the sum is computed along all the axes.\n>>> x = jnp.array([[1, 3, 4, 2],\n...                [5, 2, 6, 3],\n...                [8, 1, 3, 9]])\n>>> jnp.sum(x)\nArray(47, dtype=int32)\nIf ``axis=1``, the sum is computed along axis 1.\n>>> jnp.sum(x, axis=1)\nArray([10, 16, 21], dtype=int32)\nIf ``keepdims=True``, ``ndim`` of the output is equal to that of the input.\n>>> jnp.sum(x, axis=1, keepdims=True)\nArray([[10],\n[16],\n[21]], dtype=int32)\nTo include only specific elements in the sum, you can use ``where``.\n>>> where=jnp.array([[0, 0, 1, 0],\n...                  [0, 0, 1, 1],\n...                  [1, 1, 1, 0]], dtype=bool)\n>>> jnp.sum(x, axis=1, keepdims=True, where=where)\nArray([[ 4],\n[ 9],\n[12]], dtype=int32)\n>>> where=jnp.array([[False],\n...                  [False],\n...                  [False]])\n>>> jnp.sum(x, axis=0, keepdims=True, where=where)\nArray([[0, 0, 0, 0]], dtype=int32)"
      }
    },
    {
      "name": "swapaxes",
      "signature": "swapaxes(a: 'ArrayLike', axis1: 'int', axis2: 'int') -> 'Array'",
      "documentation": {
        "description": "Swap two axes of an array.\nJAX implementation of :func:`numpy.swapaxes`, implemented in terms of\n:func:`jax.lax.transpose`.\nArgs:\na: input array\naxis1: index of first axis\naxis2: index of second axis",
        "parameters": {},
        "returns": "Copy of ``a`` with specified axes swapped.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.moveaxis`: move a single axis of an array.\n- :func:`jax.numpy.rollaxis`: older API for ``moveaxis``.\n- :func:`jax.lax.transpose`: more general axes permutations.\n- :meth:`jax.Array.swapaxes`: same functionality via an array method.",
        "notes": "Unlike :func:`numpy.swapaxes`, :func:`jax.numpy.swapaxes` will return a copy rather\nthan a view of the input array. However, under JIT, the compiler will optimize away\nsuch copies when possible, so this doesn't have performance impacts in practice.",
        "examples": ">>> a = jnp.ones((2, 3, 4, 5))\n>>> jnp.swapaxes(a, 1, 3).shape\n(2, 5, 4, 3)\nEquivalent output via the ``swapaxes`` array method:\n>>> a.swapaxes(1, 3).shape\n(2, 5, 4, 3)\nEquivalent output via :func:`~jax.numpy.transpose`:\n>>> a.transpose(0, 3, 2, 1).shape\n(2, 5, 4, 3)"
      }
    },
    {
      "name": "take",
      "signature": "take(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], indices: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: int | None = None, out: None = None, mode: str | None = None, unique_indices: bool = False, indices_are_sorted: bool = False, fill_value: Union[numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
      "documentation": {
        "description": "Take elements from an array.\nJAX implementation of :func:`numpy.take`, implemented in terms of\n:func:`jax.lax.gather`. JAX's behavior differs from NumPy in the case\nof out-of-bound indices; see the ``mode`` parameter below.\nArgs:\na: array from which to take values.\nindices: N-dimensional array of integer indices of values to take from the array.\naxis: the axis along which to take values. If not specified, the array will\nbe flattened before indexing is applied.\nmode: Out-of-bounds indexing mode, either ``\"fill\"`` or ``\"clip\"``. The default\n``mode=\"fill\"`` returns invalid values (e.g. NaN) for out-of bounds indices;\nthe ``fill_value`` argument gives control over this value. For more discussion\nof ``mode`` options, see :attr:`jax.numpy.ndarray.at`.\nfill_value: The fill value to return for out-of-bounds slices when mode is 'fill'.\nIgnored otherwise. Defaults to NaN for inexact types, the largest negative value for\nsigned types, the largest positive value for unsigned types, and True for booleans.\nunique_indices: If True, the implementation will assume that the indices are unique,\nwhich can result in more efficient execution on some backends. If set to True and\nindices are not unique, the output is undefined.\nindices_are_sorted : If True, the implementation will assume that the indices are\nsorted in ascending order, which can lead to more efficient execution on some\nbackends. If set to True and indices are not sorted, the output is undefined.",
        "parameters": {},
        "returns": "Array of values extracted from ``a``.\nSee also:\n- :attr:`jax.numpy.ndarray.at`: take values via indexing syntax.\n- :func:`jax.numpy.take_along_axis`: take values along an axis",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[1., 2., 3.],\n...                [4., 5., 6.]])\n>>> indices = jnp.array([2, 0])\nPassing no axis results in indexing into the flattened array:\n>>> jnp.take(x, indices)\nArray([3., 1.], dtype=float32)\n>>> x.ravel()[indices]  # equivalent indexing syntax\nArray([3., 1.], dtype=float32)\nPassing an axis results ind applying the index to every subarray along the axis:\n>>> jnp.take(x, indices, axis=1)\nArray([[3., 1.],\n[6., 4.]], dtype=float32)\n>>> x[:, indices]  # equivalent indexing syntax\nArray([[3., 1.],\n[6., 4.]], dtype=float32)\nOut-of-bound indices fill with invalid values. For float inputs, this is `NaN`:\n>>> jnp.take(x, indices, axis=0)\nArray([[nan, nan, nan],\n[ 1.,  2.,  3.]], dtype=float32)\n>>> x.at[indices].get(mode='fill', fill_value=jnp.nan)  # equivalent indexing syntax\nArray([[nan, nan, nan],\n[ 1.,  2.,  3.]], dtype=float32)\nThis default out-of-bound behavior can be adjusted using the ``mode`` parameter, for\nexample, we can instead clip to the last valid value:\n>>> jnp.take(x, indices, axis=0, mode='clip')\nArray([[4., 5., 6.],\n[1., 2., 3.]], dtype=float32)\n>>> x.at[indices].get(mode='clip')  # equivalent indexing syntax\nArray([[4., 5., 6.],\n[1., 2., 3.]], dtype=float32)"
      }
    },
    {
      "name": "take_along_axis",
      "signature": "take_along_axis(arr: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], indices: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axis: int | None, mode: str | jax._src.lax.slicing.GatherScatterMode | None = None, fill_value: Union[numpy.bool_, numpy.number, bool, int, float, complex, NoneType] = None) -> jax.Array",
      "documentation": {
        "description": "Take elements from an array.\nJAX implementation of :func:`numpy.take_along_axis`, implemented in\nterms of :func:`jax.lax.gather`. JAX's behavior differs from NumPy\nin the case of out-of-bound indices; see the ``mode`` parameter below.\nArgs:\na: array from which to take values.\nindices: array of integer indices. If ``axis`` is ``None``, must be one-dimensional.\nIf ``axis`` is not None, must have ``a.ndim == indices.ndim``, and ``a`` must be\nbroadcast-compatible with ``indices`` along dimensions other than ``axis``.\naxis: the axis along which to take values. If not specified, the array will\nbe flattened before indexing is applied.\nmode: Out-of-bounds indexing mode, either ``\"fill\"`` or ``\"clip\"``. The default\n``mode=\"fill\"`` returns invalid values (e.g. NaN) for out-of bounds indices.\nFor more discussion of ``mode`` options, see :attr:`jax.numpy.ndarray.at`.",
        "parameters": {},
        "returns": "Array of values extracted from ``a``.\nSee also:\n- :attr:`jax.numpy.ndarray.at`: take values via indexing syntax.\n- :func:`jax.numpy.take`: take the same indices along every axis slice.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[1., 2., 3.],\n...                [4., 5., 6.]])\n>>> indices = jnp.array([[0, 2],\n...                      [1, 0]])\n>>> jnp.take_along_axis(x, indices, axis=1)\nArray([[1., 3.],\n[5., 4.]], dtype=float32)\n>>> x[jnp.arange(2)[:, None], indices]  # equivalent via indexing syntax\nArray([[1., 3.],\n[5., 4.]], dtype=float32)\nOut-of-bound indices fill with invalid values. For float inputs, this is `NaN`:\n>>> indices = jnp.array([[1, 0, 2]])\n>>> jnp.take_along_axis(x, indices, axis=0)\nArray([[ 4.,  2., nan]], dtype=float32)\n>>> x.at[indices, jnp.arange(3)].get(\n...     mode='fill', fill_value=jnp.nan)  # equivalent via indexing syntax\nArray([[ 4.,  2., nan]], dtype=float32)\n``take_along_axis`` is helpful for extracting values from multi-dimensional\nargsorts and arg reductions. For, here we compute :func:`~jax.numpy.argsort`\nindices along an axis, and use ``take_along_axis`` to construct the sorted\narray:\n>>> x = jnp.array([[5, 3, 4],\n...                [2, 7, 6]])\n>>> indices = jnp.argsort(x, axis=1)\n>>> indices\nArray([[1, 2, 0],\n[0, 2, 1]], dtype=int32)\n>>> jnp.take_along_axis(x, indices, axis=1)\nArray([[3, 4, 5],\n[2, 6, 7]], dtype=int32)\nSimilarly, we can use :func:`~jax.numpy.argmin` with ``keepdims=True`` and\nuse ``take_along_axis`` to extract the minimum value:\n>>> idx = jnp.argmin(x, axis=1, keepdims=True)\n>>> idx\nArray([[1],\n[0]], dtype=int32)\n>>> jnp.take_along_axis(x, idx, axis=1)\nArray([[3],\n[2]], dtype=int32)"
      }
    },
    {
      "name": "tan",
      "signature": "tan(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Compute a trigonometric tangent of each element of input.\nJAX implementation of :obj:`numpy.tan`.\nArgs:\nx: scalar or array. Angle in radians.",
        "parameters": {},
        "returns": "An array containing the tangent of each element in ``x``, promotes to inexact\ndtype.\nSee also:\n- :func:`jax.numpy.sin`: Computes a trigonometric sine of each element of input.\n- :func:`jax.numpy.cos`: Computes a trigonometric cosine of each element of\ninput.\n- :func:`jax.numpy.arctan` and :func:`jax.numpy.atan`: Computes the inverse of\ntrigonometric tangent of each element of input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> pi = jnp.pi\n>>> x = jnp.array([0, pi/6, pi/4, 3*pi/4, 5*pi/6])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   print(jnp.tan(x))\n[ 0.     0.577  1.    -1.    -0.577]"
      }
    },
    {
      "name": "tanh",
      "signature": "tanh(x: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculate element-wise hyperbolic tangent of input.\nJAX implementation of :obj:`numpy.tanh`.\nThe hyperbolic tangent is defined by:\n.. math::\ntanh(x) = \\frac{sinh(x)}{cosh(x)} = \\frac{e^x - e^{-x}}{e^x + e^{-x}}\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array containing the hyperbolic tangent of each element of ``x``, promoting\nto inexact dtype.\nNote:\n``jnp.tanh`` is equivalent to computing ``-1j * jnp.tan(1j * x)``.\nSee also:\n- :func:`jax.numpy.sinh`: Computes the element-wise hyperbolic sine of the input.\n- :func:`jax.numpy.cosh`: Computes the element-wise hyperbolic cosine of the\ninput.\n- :func:`jax.numpy.arctanh`:  Computes the element-wise inverse of hyperbolic\ntangent of the input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[-1, 0, 1],\n...                [3, -2, 5]])\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.tanh(x)\nArray([[-0.762,  0.   ,  0.762],\n[ 0.995, -0.964,  1.   ]], dtype=float32)\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   -1j * jnp.tan(1j * x)\nArray([[-0.762+0.j,  0.   -0.j,  0.762-0.j],\n[ 0.995-0.j, -0.964+0.j,  1.   -0.j]],      dtype=complex64, weak_type=True)\nFor complex-valued input:\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   jnp.tanh(2-5j)\nArray(1.031+0.021j, dtype=complex64, weak_type=True)\n>>> with jnp.printoptions(precision=3, suppress=True):\n...   -1j * jnp.tan(1j * (2-5j))\nArray(1.031+0.021j, dtype=complex64, weak_type=True)"
      }
    },
    {
      "name": "tensordot",
      "signature": "tensordot(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], axes: int | collections.abc.Sequence[int] | collections.abc.Sequence[collections.abc.Sequence[int]] = 2, *, precision: Union[NoneType, str, jax._src.lax.lax.Precision, tuple[str, str], tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision], jax._src.lax.lax.DotAlgorithm, jax._src.lax.lax.DotAlgorithmPreset] = None, preferred_element_type: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None) -> jax.Array",
      "documentation": {
        "description": "Compute the tensor dot product of two N-dimensional arrays.\nJAX implementation of :func:`numpy.linalg.tensordot`.\nArgs:\na: N-dimensional array\nb: M-dimensional array\naxes: integer or tuple of sequences of integers. If an integer `k`, then\nsum over the last `k` axes of ``a`` and the first `k` axes of ``b``,\nin order. If a tuple, then ``axes[0]`` specifies the axes of ``a`` and\n``axes[1]`` specifies the axes of ``b``.\nprecision: either ``None`` (default), which means the default precision for\nthe backend, a :class:`~jax.lax.Precision` enum value (``Precision.DEFAULT``,\n``Precision.HIGH`` or ``Precision.HIGHEST``) or a tuple of two\nsuch values indicating precision of ``a`` and ``b``.\npreferred_element_type: either ``None`` (default), which means the default\naccumulation type for the input types, or a datatype, indicating to\naccumulate results to and return a result with that datatype.",
        "parameters": {},
        "returns": "array containing the tensor dot product of the inputs\nSee also:\n- :func:`jax.numpy.einsum`: NumPy API for more general tensor contractions.\n- :func:`jax.lax.dot_general`: XLA API for more general tensor contractions.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x1 = jnp.arange(24.).reshape(2, 3, 4)\n>>> x2 = jnp.ones((3, 4, 5))\n>>> jnp.tensordot(x1, x2)\nArray([[ 66.,  66.,  66.,  66.,  66.],\n[210., 210., 210., 210., 210.]], dtype=float32)\nEquivalent result when specifying the axes as explicit sequences:\n>>> jnp.tensordot(x1, x2, axes=([1, 2], [0, 1]))\nArray([[ 66.,  66.,  66.,  66.,  66.],\n[210., 210., 210., 210., 210.]], dtype=float32)\nEquivalent result via :func:`~jax.numpy.einsum`:\n>>> jnp.einsum('ijk,jkm->im', x1, x2)\nArray([[ 66.,  66.,  66.,  66.,  66.],\n[210., 210., 210., 210., 210.]], dtype=float32)\nSetting ``axes=1`` for two-dimensional inputs is equivalent to a matrix\nmultiplication:\n>>> x1 = jnp.array([[1, 2],\n...                 [3, 4]])\n>>> x2 = jnp.array([[1, 2, 3],\n...                 [4, 5, 6]])\n>>> jnp.linalg.tensordot(x1, x2, axes=1)\nArray([[ 9, 12, 15],\n[19, 26, 33]], dtype=int32)\n>>> x1 @ x2\nArray([[ 9, 12, 15],\n[19, 26, 33]], dtype=int32)\nSetting ``axes=0`` for one-dimensional inputs is equivalent to\n:func:`~jax.numpy.outer`:\n>>> x1 = jnp.array([1, 2])\n>>> x2 = jnp.array([1, 2, 3])\n>>> jnp.linalg.tensordot(x1, x2, axes=0)\nArray([[1, 2, 3],\n[2, 4, 6]], dtype=int32)\n>>> jnp.outer(x1, x2)\nArray([[1, 2, 3],\n[2, 4, 6]], dtype=int32)"
      }
    },
    {
      "name": "tile",
      "signature": "tile(A: 'ArrayLike', reps: 'DimSize | Sequence[DimSize]') -> 'Array'",
      "documentation": {
        "description": "Construct an array by repeating ``A`` along specified dimensions.\nJAX implementation of :func:`numpy.tile`.\nIf ``A`` is an array of shape ``(d1, d2, ..., dn)`` and ``reps`` is a sequence of integers,\nthe resulting array will have a shape of ``(reps[0] * d1, reps[1] * d2, ..., reps[n] * dn)``,\nwith ``A`` tiled along each dimension.\nArgs:\nA: input array to be repeated. Can be of any shape or dimension.\nreps: specifies the number of repetitions along each axis.",
        "parameters": {},
        "returns": "a new array where the input array has been repeated according to ``reps``.\nSee also:\n- :func:`jax.numpy.repeat`: Construct an array from repeated elements.\n- :func:`jax.numpy.broadcast_to`: Broadcast an array to a specified shape.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> arr = jnp.array([1, 2])\n>>> jnp.tile(arr, 2)\nArray([1, 2, 1, 2], dtype=int32)\n>>> arr = jnp.array([[1, 2],\n...                  [3, 4,]])\n>>> jnp.tile(arr, (2, 1))\nArray([[1, 2],\n[3, 4],\n[1, 2],\n[3, 4]], dtype=int32)"
      }
    },
    {
      "name": "trace",
      "signature": "trace(a: 'ArrayLike', offset: 'int | ArrayLike' = 0, axis1: 'int' = 0, axis2: 'int' = 1, dtype: 'DTypeLike | None' = None, out: 'None' = None) -> 'Array'",
      "documentation": {
        "description": "Calculate sum of the diagonal of input along the given axes.\nJAX implementation of :func:`numpy.trace`.\nArgs:\na: input array. Must have ``a.ndim >= 2``.\noffset: optional, int, default=0. Diagonal offset from the main diagonal.\nCan be positive or negative.\naxis1: optional, default=0. The first axis along which to take the sum of\ndiagonal. Must be a static integer value.\naxis2: optional, default=1. The second axis along which to take the sum of\ndiagonal. Must be a static integer value.\ndtype: optional. The dtype of the output array. Should be provided as static\nargument in JIT compilation.\nout: Not used by JAX.",
        "parameters": {},
        "returns": "An array of dimension x.ndim-2 containing the sum of the diagonal elements\nalong axes (axis1, axis2)\nSee also:\n- :func:`jax.numpy.diag`: Returns the specified diagonal or constructs a diagonal\narray\n- :func:`jax.numpy.diagonal`: Returns the specified diagonal of an array.\n- :func:`jax.numpy.diagflat`: Returns a 2-D array with the flattened input array\nlaid out on the diagonal.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.arange(1, 9).reshape(2, 2, 2)\n>>> x\nArray([[[1, 2],\n[3, 4]],\n<BLANKLINE>\n[[5, 6],\n[7, 8]]], dtype=int32)\n>>> jnp.trace(x)\nArray([ 8, 10], dtype=int32)\n>>> jnp.trace(x, offset=1)\nArray([3, 4], dtype=int32)\n>>> jnp.trace(x, axis1=1, axis2=2)\nArray([ 5, 13], dtype=int32)\n>>> jnp.trace(x, offset=1, axis1=1, axis2=2)\nArray([2, 6], dtype=int32)"
      }
    },
    {
      "name": "transpose",
      "signature": "transpose(a: 'ArrayLike', axes: 'Sequence[int] | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return a transposed version of an N-dimensional array.\nJAX implementation of :func:`numpy.transpose`, implemented in terms of\n:func:`jax.lax.transpose`.\nArgs:\na: input array\naxes: optionally specify the permutation using a length-`a.ndim` sequence of integers\n``i`` satisfying ``0 <= i < a.ndim``. Defaults to ``range(a.ndim)[::-1]``, i.e.\nreverses the order of all axes.",
        "parameters": {},
        "returns": "transposed copy of the array.",
        "raises": "",
        "see_also": "- :func:`jax.Array.transpose`: equivalent function via an :class:`~jax.Array` method.\n- :attr:`jax.Array.T`: equivalent function via an :class:`~jax.Array`  property.\n- :func:`jax.numpy.matrix_transpose`: transpose the last two axes of an array. This is\nsuitable for working with batched 2D matrices.\n- :func:`jax.numpy.swapaxes`: swap any two axes in an array.\n- :func:`jax.numpy.moveaxis`: move an axis to another position in the array.\nNote:\nUnlike :func:`numpy.transpose`, :func:`jax.numpy.transpose` will return a copy rather\nthan a view of the input array. However, under JIT, the compiler will optimize-away\nsuch copies when possible, so this doesn't have performance impacts in practice.",
        "notes": "",
        "examples": "For a 1D array, the transpose is the identity:\n>>> x = jnp.array([1, 2, 3, 4])\n>>> jnp.transpose(x)\nArray([1, 2, 3, 4], dtype=int32)\nFor a 2D array, the transpose is a matrix transpose:\n>>> x = jnp.array([[1, 2],\n...                [3, 4]])\n>>> jnp.transpose(x)\nArray([[1, 3],\n[2, 4]], dtype=int32)\nFor an N-dimensional array, the transpose reverses the order of the axes:\n>>> x = jnp.zeros(shape=(3, 4, 5))\n>>> jnp.transpose(x).shape\n(5, 4, 3)\nThe ``axes`` argument can be specified to change this default behavior:\n>>> jnp.transpose(x, (0, 2, 1)).shape\n(3, 5, 4)\nSince swapping the last two axes is a common operation, it can be done\nvia its own API, :func:`jax.numpy.matrix_transpose`:\n>>> jnp.matrix_transpose(x).shape\n(3, 5, 4)\nFor convenience, transposes may also be performed using the :meth:`jax.Array.transpose`\nmethod or the :attr:`jax.Array.T` property:\n>>> x = jnp.array([[1, 2],\n...                [3, 4]])\n>>> x.transpose()\nArray([[1, 3],\n[2, 4]], dtype=int32)\n>>> x.T\nArray([[1, 3],\n[2, 4]], dtype=int32)"
      }
    },
    {
      "name": "trapezoid",
      "signature": "trapezoid(y: 'ArrayLike', x: 'ArrayLike | None' = None, dx: 'ArrayLike' = 1.0, axis: 'int' = -1) -> 'Array'",
      "documentation": {
        "description": "Integrate along the given axis using the composite trapezoidal rule.\nJAX implementation of :func:`numpy.trapezoid`\nThe trapezoidal rule approximates the integral under a curve by summing the\nareas of trapezoids formed between adjacent data points.\nArgs:\ny: array of data to integrate.\nx: optional array of sample points corresponding to the ``y`` values. If not\nprovided, ``x`` defaults to equally spaced with spacing given by ``dx``.\ndx: The spacing between sample points when `x` is None (default: 1.0).\naxis: The axis along which to integrate (default: -1)",
        "parameters": {},
        "returns": "The definite integral approximated by the trapezoidal rule.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Integrate over a regular grid, with spacing 1.0:\n>>> y = jnp.array([1, 2, 3, 2, 3, 2, 1])\n>>> jnp.trapezoid(y, dx=1.0)\nArray(13., dtype=float32)\nIntegrate over an irregular grid:\n>>> x = jnp.array([0, 2, 5, 7, 10, 15, 20])\n>>> jnp.trapezoid(y, x)\nArray(43., dtype=float32)\nApproximate :math:`\\int_0^{2\\pi} \\sin^2(x)dx`, which equals :math:`\\pi`:\n>>> x = jnp.linspace(0, 2 * jnp.pi, 1000)\n>>> y = jnp.sin(x) ** 2\n>>> result = jnp.trapezoid(y, x)\n>>> jnp.allclose(result, jnp.pi)\nArray(True, dtype=bool)"
      }
    },
    {
      "name": "tri",
      "signature": "tri(N: 'int', M: 'int | None' = None, k: 'int' = 0, dtype: 'DTypeLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return an array with ones on and below the diagonal and zeros elsewhere.\nJAX implementation of :func:`numpy.tri`\nArgs:\nN: int. Dimension of the rows of the returned array.\nM: optional, int. Dimension of the columns of the returned array. If not\nspecified, then ``M = N``.\nk: optional, int, default=0. Specifies the sub-diagonal on and below which\nthe array is filled with ones. ``k=0`` refers to main diagonal, ``k<0``\nrefers to sub-diagonal below the main diagonal and ``k>0`` refers to\nsub-diagonal above the main diagonal.\ndtype: optional, data type of the returned array. The default type is float.",
        "parameters": {},
        "returns": "An array of shape ``(N, M)`` containing the lower triangle with elements\nbelow the sub-diagonal specified by ``k`` are set to one and zero elsewhere.\nSee also:\n- :func:`jax.numpy.tril`: Returns a lower triangle of an array.\n- :func:`jax.numpy.triu`: Returns an upper triangle of an array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.tri(3)\nArray([[1., 0., 0.],\n[1., 1., 0.],\n[1., 1., 1.]], dtype=float32)\nWhen ``M`` is not equal to ``N``:\n>>> jnp.tri(3, 4)\nArray([[1., 0., 0., 0.],\n[1., 1., 0., 0.],\n[1., 1., 1., 0.]], dtype=float32)\nwhen ``k>0``:\n>>> jnp.tri(3, k=1)\nArray([[1., 1., 0.],\n[1., 1., 1.],\n[1., 1., 1.]], dtype=float32)\nWhen ``k<0``:\n>>> jnp.tri(3, 4, k=-1)\nArray([[0., 0., 0., 0.],\n[1., 0., 0., 0.],\n[1., 1., 0., 0.]], dtype=float32)"
      }
    },
    {
      "name": "tril",
      "signature": "tril(m: 'ArrayLike', k: 'int' = 0) -> 'Array'",
      "documentation": {
        "description": "Return lower triangle of an array.\nJAX implementation of :func:`numpy.tril`\nArgs:\nm: input array. Must have ``m.ndim >= 2``.\nk: k: optional, int, default=0. Specifies the sub-diagonal above which the\nelements of the array are set to zero. ``k=0`` refers to main diagonal,\n``k<0`` refers to sub-diagonal below the main diagonal and ``k>0`` refers\nto sub-diagonal above the main diagonal.",
        "parameters": {},
        "returns": "An array with same shape as input containing the lower triangle of the given\narray with elements above the sub-diagonal specified by ``k`` are set to\nzero.\nSee also:\n- :func:`jax.numpy.triu`: Returns an upper triangle of an array.\n- :func:`jax.numpy.tri`: Returns an array with ones on and below the\ndiagonal and zeros elsewhere.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[1, 2, 3, 4],\n...                [5, 6, 7, 8],\n...                [9, 10, 11, 12]])\n>>> jnp.tril(x)\nArray([[ 1,  0,  0,  0],\n[ 5,  6,  0,  0],\n[ 9, 10, 11,  0]], dtype=int32)\n>>> jnp.tril(x, k=1)\nArray([[ 1,  2,  0,  0],\n[ 5,  6,  7,  0],\n[ 9, 10, 11, 12]], dtype=int32)\n>>> jnp.tril(x, k=-1)\nArray([[ 0,  0,  0,  0],\n[ 5,  0,  0,  0],\n[ 9, 10,  0,  0]], dtype=int32)\nWhen ``m.ndim > 2``, ``jnp.tril`` operates batch-wise on the trailing axes.\n>>> x1 = jnp.array([[[1, 2],\n...                  [3, 4]],\n...                 [[5, 6],\n...                  [7, 8]]])\n>>> jnp.tril(x1)\nArray([[[1, 0],\n[3, 4]],\n<BLANKLINE>\n[[5, 0],\n[7, 8]]], dtype=int32)"
      }
    },
    {
      "name": "tril_indices",
      "signature": "tril_indices(n: 'int', k: 'int' = 0, m: 'int | None' = None) -> 'tuple[Array, Array]'",
      "documentation": {
        "description": "Return the indices of lower triangle of an array of size ``(n, m)``.\nJAX implementation of :func:`numpy.tril_indices`.\nArgs:\nn: int. Number of rows of the array for which the indices are returned.\nk: optional, int, default=0. Specifies the sub-diagonal on and below which\nthe indices of lower triangle are returned. ``k=0`` refers to main diagonal,\n``k<0`` refers to sub-diagonal below the main diagonal and ``k>0`` refers\nto sub-diagonal above the main diagonal.\nm: optional, int. Number of columns of the array for which the indices are\nreturned. If not specified, then ``m = n``.",
        "parameters": {},
        "returns": "A tuple of two arrays containing the indices of the lower triangle, one along\neach axis.\nSee also:\n- :func:`jax.numpy.triu_indices`: Returns the indices of upper triangle of an\narray of size ``(n, m)``.\n- :func:`jax.numpy.triu_indices_from`: Returns the indices of upper triangle\nof a given array.\n- :func:`jax.numpy.tril_indices_from`: Returns the indices of lower triangle\nof a given array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "If only ``n`` is provided in input, the indices of lower triangle of an array\nof size ``(n, n)`` array are returned.\n>>> jnp.tril_indices(3)\n(Array([0, 1, 1, 2, 2, 2], dtype=int32), Array([0, 0, 1, 0, 1, 2], dtype=int32))\nIf both ``n`` and ``m`` are provided in input, the indices of lower triangle\nof an ``(n, m)`` array are returned.\n>>> jnp.tril_indices(3, m=2)\n(Array([0, 1, 1, 2, 2], dtype=int32), Array([0, 0, 1, 0, 1], dtype=int32))\nIf ``k = 1``, the indices on and below the first sub-diagonal above the main\ndiagonal are returned.\n>>> jnp.tril_indices(3, k=1)\n(Array([0, 0, 1, 1, 1, 2, 2, 2], dtype=int32), Array([0, 1, 0, 1, 2, 0, 1, 2], dtype=int32))\nIf ``k = -1``, the indices on and below the first sub-diagonal below the main\ndiagonal are returned.\n>>> jnp.tril_indices(3, k=-1)\n(Array([1, 2, 2], dtype=int32), Array([0, 0, 1], dtype=int32))"
      }
    },
    {
      "name": "tril_indices_from",
      "signature": "tril_indices_from(arr: 'ArrayLike', k: 'int' = 0) -> 'tuple[Array, Array]'",
      "documentation": {
        "description": "Return the indices of lower triangle of a given array.\nJAX implementation of :func:`numpy.tril_indices_from`.\nArgs:\narr: input array. Must have ``arr.ndim == 2``.\nk: optional, int, default=0. Specifies the sub-diagonal on and below which\nthe indices of upper triangle are returned. ``k=0`` refers to main diagonal,\n``k<0`` refers to sub-diagonal below the main diagonal and ``k>0`` refers\nto sub-diagonal above the main diagonal.",
        "parameters": {},
        "returns": "A tuple of two arrays containing the indices of the lower triangle, one along\neach axis.\nSee also:\n- :func:`jax.numpy.triu_indices_from`: Returns the indices of upper triangle\nof a given array.\n- :func:`jax.numpy.tril_indices`: Returns the indices of lower triangle of an\narray of size ``(n, m)``.\n- :func:`jax.numpy.tril`: Returns a lower triangle of an array",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> arr = jnp.array([[1, 2, 3],\n...                  [4, 5, 6],\n...                  [7, 8, 9]])\n>>> jnp.tril_indices_from(arr)\n(Array([0, 1, 1, 2, 2, 2], dtype=int32), Array([0, 0, 1, 0, 1, 2], dtype=int32))\nElements indexed by ``jnp.tril_indices_from`` correspond to those in the\noutput of ``jnp.tril``.\n>>> ind = jnp.tril_indices_from(arr)\n>>> arr[ind]\nArray([1, 4, 5, 7, 8, 9], dtype=int32)\n>>> jnp.tril(arr)\nArray([[1, 0, 0],\n[4, 5, 0],\n[7, 8, 9]], dtype=int32)\nWhen ``k > 0``:\n>>> jnp.tril_indices_from(arr, k=1)\n(Array([0, 0, 1, 1, 1, 2, 2, 2], dtype=int32), Array([0, 1, 0, 1, 2, 0, 1, 2], dtype=int32))\nWhen ``k < 0``:\n>>> jnp.tril_indices_from(arr, k=-1)\n(Array([1, 2, 2], dtype=int32), Array([0, 0, 1], dtype=int32))"
      }
    },
    {
      "name": "trim_zeros",
      "signature": "trim_zeros(filt: 'ArrayLike', trim: 'str' = 'fb') -> 'Array'",
      "documentation": {
        "description": "Trim leading and/or trailing zeros of the input array.\nJAX implementation of :func:`numpy.trim_zeros`.\nArgs:\nfilt: input array. Must have ``filt.ndim == 1``.\ntrim: string, optional, default = ``fb``. Specifies from which end the input\nis trimmed.\n- ``f`` - trims only the leading zeros.\n- ``b`` - trims only the trailing zeros.\n- ``fb`` - trims both leading and trailing zeros.",
        "parameters": {},
        "returns": "An array containing the trimmed input with same dtype as ``filt``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([0, 0, 2, 0, 1, 4, 3, 0, 0, 0])\n>>> jnp.trim_zeros(x)\nArray([2, 0, 1, 4, 3], dtype=int32)"
      }
    },
    {
      "name": "triu",
      "signature": "triu(m: 'ArrayLike', k: 'int' = 0) -> 'Array'",
      "documentation": {
        "description": "Return upper triangle of an array.\nJAX implementation of :func:`numpy.triu`\nArgs:\nm: input array. Must have ``m.ndim >= 2``.\nk: optional, int, default=0. Specifies the sub-diagonal below which the\nelements of the array are set to zero. ``k=0`` refers to main diagonal,\n``k<0`` refers to sub-diagonal below the main diagonal and ``k>0`` refers\nto sub-diagonal above the main diagonal.",
        "parameters": {},
        "returns": "An array with same shape as input containing the upper triangle of the given\narray with elements below the sub-diagonal specified by ``k`` are set to\nzero.\nSee also:\n- :func:`jax.numpy.tril`: Returns a lower triangle of an array.\n- :func:`jax.numpy.tri`: Returns an array with ones on and below the\ndiagonal and zeros elsewhere.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6],\n...                [7, 8, 9],\n...                [10, 11, 12]])\n>>> jnp.triu(x)\nArray([[1, 2, 3],\n[0, 5, 6],\n[0, 0, 9],\n[0, 0, 0]], dtype=int32)\n>>> jnp.triu(x, k=1)\nArray([[0, 2, 3],\n[0, 0, 6],\n[0, 0, 0],\n[0, 0, 0]], dtype=int32)\n>>> jnp.triu(x, k=-1)\nArray([[ 1,  2,  3],\n[ 4,  5,  6],\n[ 0,  8,  9],\n[ 0,  0, 12]], dtype=int32)\nWhen ``m.ndim > 2``, ``jnp.triu`` operates batch-wise on the trailing axes.\n>>> x1 = jnp.array([[[1, 2],\n...                  [3, 4]],\n...                 [[5, 6],\n...                  [7, 8]]])\n>>> jnp.triu(x1)\nArray([[[1, 2],\n[0, 4]],\n<BLANKLINE>\n[[5, 6],\n[0, 8]]], dtype=int32)"
      }
    },
    {
      "name": "triu_indices",
      "signature": "triu_indices(n: 'int', k: 'int' = 0, m: 'int | None' = None) -> 'tuple[Array, Array]'",
      "documentation": {
        "description": "Return the indices of upper triangle of an array of size ``(n, m)``.\nJAX implementation of :func:`numpy.triu_indices`.\nArgs:\nn: int. Number of rows of the array for which the indices are returned.\nk: optional, int, default=0. Specifies the sub-diagonal on and above which\nthe indices of upper triangle are returned. ``k=0`` refers to main diagonal,\n``k<0`` refers to sub-diagonal below the main diagonal and ``k>0`` refers\nto sub-diagonal above the main diagonal.\nm: optional, int. Number of columns of the array for which the indices are\nreturned. If not specified, then ``m = n``.",
        "parameters": {},
        "returns": "A tuple of two arrays containing the indices of the upper triangle, one along\neach axis.\nSee also:\n- :func:`jax.numpy.tril_indices`: Returns the indices of lower triangle of an\narray of size ``(n, m)``.\n- :func:`jax.numpy.triu_indices_from`: Returns the indices of upper triangle\nof a given array.\n- :func:`jax.numpy.tril_indices_from`: Returns the indices of lower triangle\nof a given array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "If only ``n`` is provided in input, the indices of upper triangle of an array\nof size ``(n, n)`` array are returned.\n>>> jnp.triu_indices(3)\n(Array([0, 0, 0, 1, 1, 2], dtype=int32), Array([0, 1, 2, 1, 2, 2], dtype=int32))\nIf both ``n`` and ``m`` are provided in input, the indices of upper triangle\nof an ``(n, m)`` array are returned.\n>>> jnp.triu_indices(3, m=2)\n(Array([0, 0, 1], dtype=int32), Array([0, 1, 1], dtype=int32))\nIf ``k = 1``, the indices on and above the first sub-diagonal above the main\ndiagonal are returned.\n>>> jnp.triu_indices(3, k=1)\n(Array([0, 0, 1], dtype=int32), Array([1, 2, 2], dtype=int32))\nIf ``k = -1``, the indices on and above the first sub-diagonal below the main\ndiagonal are returned.\n>>> jnp.triu_indices(3, k=-1)\n(Array([0, 0, 0, 1, 1, 1, 2, 2], dtype=int32), Array([0, 1, 2, 0, 1, 2, 1, 2], dtype=int32))"
      }
    },
    {
      "name": "triu_indices_from",
      "signature": "triu_indices_from(arr: 'ArrayLike', k: 'int' = 0) -> 'tuple[Array, Array]'",
      "documentation": {
        "description": "Return the indices of upper triangle of a given array.\nJAX implementation of :func:`numpy.triu_indices_from`.\nArgs:\narr: input array. Must have ``arr.ndim == 2``.\nk: optional, int, default=0. Specifies the sub-diagonal on and above which\nthe indices of upper triangle are returned. ``k=0`` refers to main diagonal,\n``k<0`` refers to sub-diagonal below the main diagonal and ``k>0`` refers\nto sub-diagonal above the main diagonal.",
        "parameters": {},
        "returns": "A tuple of two arrays containing the indices of the upper triangle, one along\neach axis.\nSee also:\n- :func:`jax.numpy.tril_indices_from`: Returns the indices of lower triangle\nof a given array.\n- :func:`jax.numpy.triu_indices`: Returns the indices of upper triangle of an\narray of size ``(n, m)``.\n- :func:`jax.numpy.triu`: Return an upper triangle of an array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> arr = jnp.array([[1, 2, 3],\n...                  [4, 5, 6],\n...                  [7, 8, 9]])\n>>> jnp.triu_indices_from(arr)\n(Array([0, 0, 0, 1, 1, 2], dtype=int32), Array([0, 1, 2, 1, 2, 2], dtype=int32))\nElements indexed by ``jnp.triu_indices_from`` correspond to those in the\noutput of ``jnp.triu``.\n>>> ind = jnp.triu_indices_from(arr)\n>>> arr[ind]\nArray([1, 2, 3, 5, 6, 9], dtype=int32)\n>>> jnp.triu(arr)\nArray([[1, 2, 3],\n[0, 5, 6],\n[0, 0, 9]], dtype=int32)\nWhen ``k > 0``:\n>>> jnp.triu_indices_from(arr, k=1)\n(Array([0, 0, 1], dtype=int32), Array([1, 2, 2], dtype=int32))\nWhen ``k < 0``:\n>>> jnp.triu_indices_from(arr, k=-1)\n(Array([0, 0, 0, 1, 1, 1, 2, 2], dtype=int32), Array([0, 1, 2, 0, 1, 2, 1, 2], dtype=int32))"
      }
    },
    {
      "name": "true_divide",
      "signature": "true_divide(x1: 'ArrayLike', x2: 'ArrayLike', /) -> 'Array'",
      "documentation": {
        "description": "Calculates the division of x1 by x2 element-wise\nJAX implementation of :func:`numpy.true_divide`.\nArgs:\nx1: Input array, the dividend\nx2: Input array, the divisor",
        "parameters": {},
        "returns": "An array containing the elementwise quotients, will always use\nfloating point division.",
        "raises": "",
        "see_also": ":func:`jax.numpy.floor_divide` for integer division",
        "notes": "",
        "examples": ">>> x1 = jnp.array([3, 4, 5])\n>>> x2 = 2\n>>> jnp.true_divide(x1, x2)\nArray([1.5, 2. , 2.5], dtype=float32)\n>>> x1 = 24\n>>> x2 = jnp.array([3, 4, 6j])\n>>> jnp.true_divide(x1, x2)\nArray([8.+0.j, 6.+0.j, 0.-4.j], dtype=complex64)\n>>> x1 = jnp.array([1j, 9+5j, -4+2j])\n>>> x2 = 3j\n>>> jnp.true_divide(x1, x2)\nArray([0.33333334+0.j       , 1.6666666 -3.j       ,\n0.6666667 +1.3333334j], dtype=complex64)"
      }
    },
    {
      "name": "trunc",
      "signature": "trunc(x: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "Round input to the nearest integer towards zero.\nJAX implementation of :func:`numpy.trunc`.\nArgs:\nx: input array or scalar.",
        "parameters": {},
        "returns": "An array with same shape and dtype as ``x`` containing the rounded values.\nSee also:\n- :func:`jax.numpy.fix`: Rounds the input to the nearest integer towards zero.\n- :func:`jax.numpy.ceil`: Rounds the input up to the nearest integer.\n- :func:`jax.numpy.floor`: Rounds the input down to the nearest integer.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> key = jax.random.key(42)\n>>> x = jax.random.uniform(key, (3, 3), minval=-10, maxval=10)\n>>> with jnp.printoptions(precision=2, suppress=True):\n...     print(x)\n[[-0.23  3.6   2.33]\n[ 1.22 -0.99  1.72]\n[-8.5   5.5   3.98]]\n>>> jnp.trunc(x)\nArray([[-0.,  3.,  2.],\n[ 1., -0.,  1.],\n[-8.,  5.,  3.]], dtype=float32)"
      }
    },
    {
      "name": "union1d",
      "signature": "union1d(ar1: 'ArrayLike', ar2: 'ArrayLike', *, size: 'int | None' = None, fill_value: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Compute the set union of two 1D arrays.\nJAX implementation of :func:`numpy.union1d`.\nBecause the size of the output of ``union1d`` is data-dependent, the function\nis not typically compatible with :func:`~jax.jit` and other JAX transformations.\nThe JAX version adds the optional ``size`` argument which must be specified\nstatically for ``jnp.union1d`` to be used in such contexts.\nArgs:\nar1: first array of elements to be unioned.\nar2: second array of elements to be unioned\nsize: if specified, return only the first ``size`` sorted elements. If there are fewer\nelements than ``size`` indicates, the return value will be padded with ``fill_value``.\nfill_value: when ``size`` is specified and there are fewer than the indicated number of\nelements, fill the remaining entries ``fill_value``. Defaults to the minimum value.",
        "parameters": {},
        "returns": "an array containing the union of elements in the input array.\nSee also:\n- :func:`jax.numpy.intersect1d`: the set intersection of two 1D arrays.\n- :func:`jax.numpy.setxor1d`: the set XOR of two 1D arrays.\n- :func:`jax.numpy.setdiff1d`: the set difference of two 1D arrays.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Computing the union of two arrays:\n>>> ar1 = jnp.array([1, 2, 3, 4])\n>>> ar2 = jnp.array([3, 4, 5, 6])\n>>> jnp.union1d(ar1, ar2)\nArray([1, 2, 3, 4, 5, 6], dtype=int32)\nBecause the output shape is dynamic, this will fail under :func:`~jax.jit` and other\ntransformations:\n>>> jax.jit(jnp.union1d)(ar1, ar2)  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nConcretizationTypeError: Abstract tracer value encountered where concrete value is expected: traced array with shape int32[4].\nThe error occurred while tracing the function union1d at /Users/vanderplas/github/jax-ml/jax/jax/_src/numpy/setops.py:101 for jit. This concrete value was not available in Python because it depends on the value of the argument ar1.\nIn order to ensure statically-known output shapes, you can pass a static ``size``\nargument:\n>>> jit_union1d = jax.jit(jnp.union1d, static_argnames=['size'])\n>>> jit_union1d(ar1, ar2, size=6)\nArray([1, 2, 3, 4, 5, 6], dtype=int32)\nIf ``size`` is too small, the union is truncated:\n>>> jit_union1d(ar1, ar2, size=4)\nArray([1, 2, 3, 4], dtype=int32)\nIf ``size`` is too large, then the output is padded with ``fill_value``:\n>>> jit_union1d(ar1, ar2, size=8, fill_value=0)\nArray([1, 2, 3, 4, 5, 6, 0, 0], dtype=int32)"
      }
    },
    {
      "name": "unique",
      "signature": "unique(ar: 'ArrayLike', return_index: 'bool' = False, return_inverse: 'bool' = False, return_counts: 'bool' = False, axis: 'int | None' = None, *, equal_nan: 'bool' = True, size: 'int | None' = None, fill_value: 'ArrayLike | None' = None, sorted: 'bool' = True)",
      "documentation": {
        "description": "Return the unique values from an array.\nJAX implementation of :func:`numpy.unique`.\nBecause the size of the output of ``unique`` is data-dependent, the function\nis not typically compatible with :func:`~jax.jit` and other JAX transformations.\nThe JAX version adds the optional ``size`` argument which must be specified\nstatically for ``jnp.unique`` to be used in such contexts.\nArgs:\nar: N-dimensional array from which unique values will be extracted.\nreturn_index: if True, also return the indices in ``ar`` where each value occurs\nreturn_inverse: if True, also return the indices that can be used to reconstruct\n``ar`` from the unique values.\nreturn_counts: if True, also return the number of occurrences of each unique value.\naxis: if specified, compute unique values along the specified axis. If None (default),\nthen flatten ``ar`` before computing the unique values.\nequal_nan: if True, consider NaN values equivalent when determining uniqueness.\nsize: if specified, return only the first ``size`` sorted unique elements. If there are fewer\nunique elements than ``size`` indicates, the return value will be padded with ``fill_value``.\nfill_value: when ``size`` is specified and there are fewer than the indicated number of\nelements, fill the remaining entries ``fill_value``. Defaults to the minimum unique value.\nsorted: unused by JAX.",
        "parameters": {},
        "returns": "An array or tuple of arrays, depending on the values of ``return_index``, ``return_inverse``,\nand ``return_counts``. Returned values are\n- ``unique_values``:\nif ``axis`` is None, a 1D array of length ``n_unique``, If ``axis`` is\nspecified, shape is ``(*ar.shape[:axis], n_unique, *ar.shape[axis + 1:])``.\n- ``unique_index``:\n*(returned only if return_index is True)* An array of shape ``(n_unique,)``. Contains\nthe indices of the first occurrence of each unique value in ``ar``. For 1D inputs,\n``ar[unique_index]`` is equivalent to ``unique_values``.\n- ``unique_inverse``:\n*(returned only if return_inverse is True)* An array of shape ``(ar.size,)`` if ``axis``\nis None, or of shape ``(ar.shape[axis],)`` if ``axis`` is specified.\nContains the indices within ``unique_values`` of each value in ``ar``. For 1D inputs,\n``unique_values[unique_inverse]`` is equivalent to ``ar``.\n- ``unique_counts``:\n*(returned only if return_counts is True)* An array of shape ``(n_unique,)``.\nContains the number of occurrences of each unique value in ``ar``.\nSee also:\n- :func:`jax.numpy.unique_counts`: shortcut to ``unique(arr, return_counts=True)``.\n- :func:`jax.numpy.unique_inverse`: shortcut to ``unique(arr, return_inverse=True)``.\n- :func:`jax.numpy.unique_all`: shortcut to ``unique`` with all return values.\n- :func:`jax.numpy.unique_values`: like ``unique``, but no optional return values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([3, 4, 1, 3, 1])\n>>> jnp.unique(x)\nArray([1, 3, 4], dtype=int32)\n**JIT compilation & the size argument**\nIf you try this under :func:`~jax.jit` or another transformation, you will get an\nerror because the output shape is dynamic:\n>>> jax.jit(jnp.unique)(x)  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\njax.errors.ConcretizationTypeError: Abstract tracer value encountered where concrete value is expected: traced array with shape int32[5].\nThe error arose for the first argument of jnp.unique(). To make jnp.unique() compatible with JIT and other transforms, you can specify a concrete value for the size argument, which will determine the output size.\nThe issue is that the output of transformed functions must have static shapes.\nIn order to make this work, you can pass a static ``size`` parameter:\n>>> jit_unique = jax.jit(jnp.unique, static_argnames=['size'])\n>>> jit_unique(x, size=3)\nArray([1, 3, 4], dtype=int32)\nIf your static size is smaller than the true number of unique values, they will be truncated.\n>>> jit_unique(x, size=2)\nArray([1, 3], dtype=int32)\nIf the static size is larger than the true number of unique values, they will be padded with\n``fill_value``, which defaults to the minimum unique value:\n>>> jit_unique(x, size=5)\nArray([1, 3, 4, 1, 1], dtype=int32)\n>>> jit_unique(x, size=5, fill_value=0)\nArray([1, 3, 4, 0, 0], dtype=int32)\n**Multi-dimensional unique values**\nIf you pass a multi-dimensional array to ``unique``, it will be flattened by default:\n>>> M = jnp.array([[1, 2],\n...                [2, 3],\n...                [1, 2]])\n>>> jnp.unique(M)\nArray([1, 2, 3], dtype=int32)\nIf you pass an ``axis`` keyword, you can find unique *slices* of the array along\nthat axis:\n>>> jnp.unique(M, axis=0)\nArray([[1, 2],\n[2, 3]], dtype=int32)\n**Returning indices**\nIf you set ``return_index=True``, then ``unique`` returns the indices of the\nfirst occurrence of each unique value:\n>>> x = jnp.array([3, 4, 1, 3, 1])\n>>> values, indices = jnp.unique(x, return_index=True)\n>>> print(values)\n[1 3 4]\n>>> print(indices)\n[2 0 1]\n>>> jnp.all(values == x[indices])\nArray(True, dtype=bool)\nIn multiple dimensions, the unique values can be extracted with :func:`jax.numpy.take`\nevaluated along the specified axis:\n>>> values, indices = jnp.unique(M, axis=0, return_index=True)\n>>> jnp.all(values == jnp.take(M, indices, axis=0))\nArray(True, dtype=bool)\n**Returning inverse**\nIf you set ``return_inverse=True``, then ``unique`` returns the indices within the\nunique values for every entry in the input array:\n>>> x = jnp.array([3, 4, 1, 3, 1])\n>>> values, inverse = jnp.unique(x, return_inverse=True)\n>>> print(values)\n[1 3 4]\n>>> print(inverse)\n[1 2 0 1 0]\n>>> jnp.all(values[inverse] == x)\nArray(True, dtype=bool)\nIn multiple dimensions, the input can be reconstructed using\n:func:`jax.numpy.take`:\n>>> values, inverse = jnp.unique(M, axis=0, return_inverse=True)\n>>> jnp.all(jnp.take(values, inverse, axis=0) == M)\nArray(True, dtype=bool)\n**Returning counts**\nIf you set ``return_counts=True``, then ``unique`` returns the number of occurrences\nwithin the input for every unique value:\n>>> x = jnp.array([3, 4, 1, 3, 1])\n>>> values, counts = jnp.unique(x, return_counts=True)\n>>> print(values)\n[1 3 4]\n>>> print(counts)\n[2 2 1]\nFor multi-dimensional arrays, this also returns a 1D array of counts\nindicating number of occurrences along the specified axis:\n>>> values, counts = jnp.unique(M, axis=0, return_counts=True)\n>>> print(values)\n[[1 2]\n[2 3]]\n>>> print(counts)\n[2 1]"
      }
    },
    {
      "name": "unique_all",
      "signature": "unique_all(x: 'ArrayLike', /, *, size: 'int | None' = None, fill_value: 'ArrayLike | None' = None) -> '_UniqueAllResult'",
      "documentation": {
        "description": "Return unique values from x, along with indices, inverse indices, and counts.\nJAX implementation of :func:`numpy.unique_all`; this is equivalent to calling\n:func:`jax.numpy.unique` with `return_index`, `return_inverse`, `return_counts`,\nand `equal_nan` set to True.\nBecause the size of the output of ``unique_all`` is data-dependent, the function\nis not typically compatible with :func:`~jax.jit` and other JAX transformations.\nThe JAX version adds the optional ``size`` argument which must be specified\nstatically for ``jnp.unique`` to be used in such contexts.\nArgs:\nx: N-dimensional array from which unique values will be extracted.\nsize: if specified, return only the first ``size`` sorted unique elements. If there are fewer\nunique elements than ``size`` indicates, the return value will be padded with ``fill_value``.\nfill_value: when ``size`` is specified and there are fewer than the indicated number of\nelements, fill the remaining entries ``fill_value``. Defaults to the minimum unique value.",
        "parameters": {},
        "returns": "A tuple ``(values, indices, inverse_indices, counts)``, with the following properties:\n- ``values``:\nan array of shape ``(n_unique,)`` containing the unique values from ``x``.\n- ``indices``:\nAn array of shape ``(n_unique,)``. Contains the indices of the first occurrence of\neach unique value in ``x``. For 1D inputs, ``x[indices]`` is equivalent to ``values``.\n- ``inverse_indices``:\nAn array of shape ``x.shape``. Contains the indices within ``values`` of each value\nin ``x``. For 1D inputs, ``values[inverse_indices]`` is equivalent to ``x``.\n- ``counts``:\nAn array of shape ``(n_unique,)``. Contains the number of occurrences of each unique\nvalue in ``x``.\nSee also:\n- :func:`jax.numpy.unique`: general function for computing unique values.\n- :func:`jax.numpy.unique_values`: compute only ``values``.\n- :func:`jax.numpy.unique_counts`: compute only ``values`` and ``counts``.\n- :func:`jax.numpy.unique_inverse`: compute only ``values`` and ``inverse``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Here we compute the unique values in a 1D array:\n>>> x = jnp.array([3, 4, 1, 3, 1])\n>>> result = jnp.unique_all(x)\nThe result is a :class:`~typing.NamedTuple` with four named attributes.\nThe ``values`` attribute contains the unique values from the array:\n>>> result.values\nArray([1, 3, 4], dtype=int32)\nThe ``indices`` attribute contains the indices of the unique ``values`` within\nthe input array:\n>>> result.indices\nArray([2, 0, 1], dtype=int32)\n>>> jnp.all(result.values == x[result.indices])\nArray(True, dtype=bool)\nThe ``inverse_indices`` attribute contains the indices of the input within ``values``:\n>>> result.inverse_indices\nArray([1, 2, 0, 1, 0], dtype=int32)\n>>> jnp.all(x == result.values[result.inverse_indices])\nArray(True, dtype=bool)\nThe ``counts`` attribute contains the counts of each unique value in the input:\n>>> result.counts\nArray([2, 2, 1], dtype=int32)\nFor examples of the ``size`` and ``fill_value`` arguments, see :func:`jax.numpy.unique`."
      }
    },
    {
      "name": "unique_counts",
      "signature": "unique_counts(x: 'ArrayLike', /, *, size: 'int | None' = None, fill_value: 'ArrayLike | None' = None) -> '_UniqueCountsResult'",
      "documentation": {
        "description": "Return unique values from x, along with counts.\nJAX implementation of :func:`numpy.unique_counts`; this is equivalent to calling\n:func:`jax.numpy.unique` with `return_counts` and `equal_nan` set to True.\nBecause the size of the output of ``unique_counts`` is data-dependent, the function\nis not typically compatible with :func:`~jax.jit` and other JAX transformations.\nThe JAX version adds the optional ``size`` argument which must be specified\nstatically for ``jnp.unique`` to be used in such contexts.\nArgs:\nx: N-dimensional array from which unique values will be extracted.\nsize: if specified, return only the first ``size`` sorted unique elements. If there are fewer\nunique elements than ``size`` indicates, the return value will be padded with ``fill_value``.\nfill_value: when ``size`` is specified and there are fewer than the indicated number of\nelements, fill the remaining entries ``fill_value``. Defaults to the minimum unique value.",
        "parameters": {},
        "returns": "A tuple ``(values, counts)``, with the following properties:\n- ``values``:\nan array of shape ``(n_unique,)`` containing the unique values from ``x``.\n- ``counts``:\nAn array of shape ``(n_unique,)``. Contains the number of occurrences of each unique\nvalue in ``x``.\nSee also:\n- :func:`jax.numpy.unique`: general function for computing unique values.\n- :func:`jax.numpy.unique_values`: compute only ``values``.\n- :func:`jax.numpy.unique_inverse`: compute only ``values`` and ``inverse``.\n- :func:`jax.numpy.unique_all`: compute ``values``, ``indices``, ``inverse_indices``,\nand ``counts``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Here we compute the unique values in a 1D array:\n>>> x = jnp.array([3, 4, 1, 3, 1])\n>>> result = jnp.unique_counts(x)\nThe result is a :class:`~typing.NamedTuple` with two named attributes.\nThe ``values`` attribute contains the unique values from the array:\n>>> result.values\nArray([1, 3, 4], dtype=int32)\nThe ``counts`` attribute contains the counts of each unique value in the input:\n>>> result.counts\nArray([2, 2, 1], dtype=int32)\nFor examples of the ``size`` and ``fill_value`` arguments, see :func:`jax.numpy.unique`."
      }
    },
    {
      "name": "unique_inverse",
      "signature": "unique_inverse(x: 'ArrayLike', /, *, size: 'int | None' = None, fill_value: 'ArrayLike | None' = None) -> '_UniqueInverseResult'",
      "documentation": {
        "description": "Return unique values from x, along with indices, inverse indices, and counts.\nJAX implementation of :func:`numpy.unique_inverse`; this is equivalent to calling\n:func:`jax.numpy.unique` with `return_inverse` and `equal_nan` set to True.\nBecause the size of the output of ``unique_inverse`` is data-dependent, the function\nis not typically compatible with :func:`~jax.jit` and other JAX transformations.\nThe JAX version adds the optional ``size`` argument which must be specified\nstatically for ``jnp.unique`` to be used in such contexts.\nArgs:\nx: N-dimensional array from which unique values will be extracted.\nsize: if specified, return only the first ``size`` sorted unique elements. If there are fewer\nunique elements than ``size`` indicates, the return value will be padded with ``fill_value``.\nfill_value: when ``size`` is specified and there are fewer than the indicated number of\nelements, fill the remaining entries ``fill_value``. Defaults to the minimum unique value.",
        "parameters": {},
        "returns": "A tuple ``(values, indices, inverse_indices, counts)``, with the following properties:\n- ``values``:\nan array of shape ``(n_unique,)`` containing the unique values from ``x``.\n- ``inverse_indices``:\nAn array of shape ``x.shape``. Contains the indices within ``values`` of each value\nin ``x``. For 1D inputs, ``values[inverse_indices]`` is equivalent to ``x``.\nSee also:\n- :func:`jax.numpy.unique`: general function for computing unique values.\n- :func:`jax.numpy.unique_values`: compute only ``values``.\n- :func:`jax.numpy.unique_counts`: compute only ``values`` and ``counts``.\n- :func:`jax.numpy.unique_all`: compute ``values``, ``indices``, ``inverse_indices``,\nand ``counts``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Here we compute the unique values in a 1D array:\n>>> x = jnp.array([3, 4, 1, 3, 1])\n>>> result = jnp.unique_inverse(x)\nThe result is a :class:`~typing.NamedTuple` with two named attributes.\nThe ``values`` attribute contains the unique values from the array:\n>>> result.values\nArray([1, 3, 4], dtype=int32)\nThe ``indices`` attribute contains the indices of the unique ``values`` within\nthe input array:\nThe ``inverse_indices`` attribute contains the indices of the input within ``values``:\n>>> result.inverse_indices\nArray([1, 2, 0, 1, 0], dtype=int32)\n>>> jnp.all(x == result.values[result.inverse_indices])\nArray(True, dtype=bool)\nFor examples of the ``size`` and ``fill_value`` arguments, see :func:`jax.numpy.unique`."
      }
    },
    {
      "name": "unique_values",
      "signature": "unique_values(x: 'ArrayLike', /, *, size: 'int | None' = None, fill_value: 'ArrayLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Return unique values from x, along with indices, inverse indices, and counts.\nJAX implementation of :func:`numpy.unique_values`; this is equivalent to calling\n:func:`jax.numpy.unique` with `equal_nan` set to True.\nBecause the size of the output of ``unique_values`` is data-dependent, the function\nis not typically compatible with :func:`~jax.jit` and other JAX transformations.\nThe JAX version adds the optional ``size`` argument which must be specified statically\nfor ``jnp.unique`` to be used in such contexts.\nArgs:\nx: N-dimensional array from which unique values will be extracted.\nsize: if specified, return only the first ``size`` sorted unique elements. If there are fewer\nunique elements than ``size`` indicates, the return value will be padded with ``fill_value``.\nfill_value: when ``size`` is specified and there are fewer than the indicated number of\nelements, fill the remaining entries ``fill_value``. Defaults to the minimum unique value.",
        "parameters": {},
        "returns": "An array ``values`` of shape ``(n_unique,)`` containing the unique values from ``x``.\nSee also:\n- :func:`jax.numpy.unique`: general function for computing unique values.\n- :func:`jax.numpy.unique_values`: compute only ``values``.\n- :func:`jax.numpy.unique_counts`: compute only ``values`` and ``counts``.\n- :func:`jax.numpy.unique_inverse`: compute only ``values`` and ``inverse``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Here we compute the unique values in a 1D array:\n>>> x = jnp.array([3, 4, 1, 3, 1])\n>>> jnp.unique_values(x)\nArray([1, 3, 4], dtype=int32)\nFor examples of the ``size`` and ``fill_value`` arguments, see :func:`jax.numpy.unique`."
      }
    },
    {
      "name": "unpackbits",
      "signature": "unpackbits(a: 'ArrayLike', axis: 'int | None' = None, count: 'int | None' = None, bitorder: 'str' = 'big') -> 'Array'",
      "documentation": {
        "description": "Unpack the bits in a uint8 array.\nJAX implementation of :func:`numpy.unpackbits`.\nArgs:\na: N-dimensional array of type ``uint8``.\naxis: optional axis along which to unpack. If not specified, ``a`` will\nbe flattened\ncount: specify the number of bits to unpack (if positive) or the number\nof bits to trim from the end (if negative).\nbitorder: ``\"big\"`` (default) or ``\"little\"``: specify whether the bit order\nis big-endian or little-endian.",
        "parameters": {},
        "returns": "a uint8 array of unpacked bits.\nSee also:\n- :func:`jax.numpy.packbits`: this inverse of ``unpackbits``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Unpacking bits from a scalar:\n>>> jnp.unpackbits(jnp.uint8(27))  # big-endian by default\nArray([0, 0, 0, 1, 1, 0, 1, 1], dtype=uint8)\n>>> jnp.unpackbits(jnp.uint8(27), bitorder=\"little\")\nArray([1, 1, 0, 1, 1, 0, 0, 0], dtype=uint8)\nCompare this to the Python binary representation:\n>>> 0b00011011\n27\nUnpacking bits along an axis:\n>>> vals = jnp.array([[154],\n...                   [ 49]], dtype='uint8')\n>>> bits = jnp.unpackbits(vals, axis=1)\n>>> bits\nArray([[1, 0, 0, 1, 1, 0, 1, 0],\n[0, 0, 1, 1, 0, 0, 0, 1]], dtype=uint8)\nUsing :func:`~jax.numpy.packbits` to invert this:\n>>> jnp.packbits(bits, axis=1)\nArray([[154],\n[ 49]], dtype=uint8)\nThe ``count`` keyword lets ``unpackbits`` serve as an inverse of ``packbits``\nin cases where not all bits are present:\n>>> bits = jnp.array([1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1])  # 11 bits\n>>> vals = jnp.packbits(bits)\n>>> vals\nArray([219,  96], dtype=uint8)\n>>> jnp.unpackbits(vals)  # 16 zero-padded bits\nArray([1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0], dtype=uint8)\n>>> jnp.unpackbits(vals, count=11)  # specify 11 output bits\nArray([1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], dtype=uint8)\n>>> jnp.unpackbits(vals, count=-5)  # specify 5 bits to be trimmed\nArray([1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], dtype=uint8)"
      }
    },
    {
      "name": "unravel_index",
      "signature": "unravel_index(indices: 'ArrayLike', shape: 'Shape') -> 'tuple[Array, ...]'",
      "documentation": {
        "description": "Convert flat indices into multi-dimensional indices.\nJAX implementation of :func:`numpy.unravel_index`. The JAX version differs in\nits treatment of out-of-bound indices: unlike NumPy, negative indices are\nsupported, and out-of-bound indices are clipped to the nearest valid value.\nArgs:\nindices: integer array of flat indices\nshape: shape of multidimensional array to index into",
        "parameters": {},
        "returns": "Tuple of unraveled indices\nSee also:\n:func:`jax.numpy.ravel_multi_index`: Inverse of this function.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Start with a 1D array values and indices:\n>>> x = jnp.array([2., 3., 4., 5., 6., 7.])\n>>> indices = jnp.array([1, 3, 5])\n>>> print(x[indices])\n[3. 5. 7.]\nNow if ``x`` is reshaped, ``unravel_indices`` can be used to convert\nthe flat indices into a tuple of indices that access the same entries:\n>>> shape = (2, 3)\n>>> x_2D = x.reshape(shape)\n>>> indices_2D = jnp.unravel_index(indices, shape)\n>>> indices_2D\n(Array([0, 1, 1], dtype=int32), Array([1, 0, 2], dtype=int32))\n>>> print(x_2D[indices_2D])\n[3. 5. 7.]\nThe inverse function, ``ravel_multi_index``, can be used to obtain the\noriginal indices:\n>>> jnp.ravel_multi_index(indices_2D, shape)\nArray([1, 3, 5], dtype=int32)"
      }
    },
    {
      "name": "unstack",
      "signature": "unstack(x: 'ArrayLike', /, *, axis: 'int' = 0) -> 'tuple[Array, ...]'",
      "documentation": {
        "description": "Unstack an array along an axis.\nJAX implementation of :func:`array_api.unstack`.\nArgs:\nx: array to unstack. Must have ``x.ndim >= 1``.\naxis: integer axis along which to unstack. Must satisfy\n``-x.ndim <= axis < x.ndim``.",
        "parameters": {},
        "returns": "tuple of unstacked arrays.\nSee also:\n- :func:`jax.numpy.stack`: inverse of ``unstack``\n- :func:`jax.numpy.split`: split array into batches along an axis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> arr = jnp.array([[1, 2, 3],\n...                  [4, 5, 6]])\n>>> arrs = jnp.unstack(arr)\n>>> print(*arrs)\n[1 2 3] [4 5 6]\n:func:`~jax.numpy.stack` provides the inverse of this:\n>>> jnp.stack(arrs)\nArray([[1, 2, 3],\n[4, 5, 6]], dtype=int32)"
      }
    },
    {
      "name": "unwrap",
      "signature": "unwrap(p: 'ArrayLike', discont: 'ArrayLike | None' = None, axis: 'int' = -1, period: 'ArrayLike' = 6.283185307179586) -> 'Array'",
      "documentation": {
        "description": "Unwrap a periodic signal.\nJAX implementation of :func:`numpy.unwrap`.\nArgs:\np: input array\ndiscont: the maximum allowable discontinuity in the sequence. The\ndefault is ``period / 2``\naxis: the axis along which to unwrap; defaults to -1\nperiod: the period of the signal, which defaults to :math:`2\\pi`",
        "parameters": {},
        "returns": "An unwrapped copy of ``p``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Consider a situation in which you are making measurements of the position of\na rotating disk via the ``x`` and ``y`` locations of some point on that disk.\nThe underlying variable is an always-increating angle which we'll generate\nthis way, using degrees for ease of representation:\n>>> rng = np.random.default_rng(0)\n>>> theta = rng.integers(0, 90, size=(20,)).cumsum()\n>>> theta\narray([ 76, 133, 179, 203, 230, 233, 239, 240, 255, 328, 386, 468, 513,\n567, 654, 719, 775, 823, 873, 957])\nOur observations of this angle are the ``x`` and ``y`` coordinates, given by\nthe sine and cosine of this underlying angle:\n>>> x, y = jnp.sin(jnp.deg2rad(theta)), jnp.cos(jnp.deg2rad(theta))\nNow, say that given these ``x`` and ``y`` coordinates, we wish to recover\nthe original angle ``theta``. We might do this via the :func:`atan2` function:\n>>> theta_out = jnp.rad2deg(jnp.atan2(x, y)).round()\n>>> theta_out\nArray([  76.,  133.,  179., -157., -130., -127., -121., -120., -105.,\n-32.,   26.,  108.,  153., -153.,  -66.,   -1.,   55.,  103.,\n153., -123.], dtype=float32)\nThe first few values match the input angle ``theta`` above, but after this the\nvalues are wrapped because the ``sin`` and ``cos`` observations obscure the phase\ninformation. The purpose of the :func:`unwrap` function is to recover the original\nsignal from this wrapped view of it:\n>>> jnp.unwrap(theta_out, period=360)\nArray([ 76., 133., 179., 203., 230., 233., 239., 240., 255., 328., 386.,\n468., 513., 567., 654., 719., 775., 823., 873., 957.],      dtype=float32)\nIt does this by assuming that the true underlying sequence does not differ by more than\n``discont`` (which defaults to ``period / 2``) within a single step, and when it encounters\na larger discontinuity it adds factors of the period to the data. For periodic signals\nthat satisfy this assumption, :func:`unwrap` can recover the original phased signal."
      }
    },
    {
      "name": "vander",
      "signature": "vander(x: 'ArrayLike', N: 'int | None' = None, increasing: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "Generate a Vandermonde matrix.\nJAX implementation of :func:`numpy.vander`.\nArgs:\nx: input array. Must have ``x.ndim == 1``.\nN: int, optional, default=None. Specifies the number of the columns the\noutput matrix. If not specified, ``N = len(x)``.\nincreasing: bool, optional, default=False. Specifies the order of the powers\nof the columns. If ``True``, the powers increase from left to right,\n:math:`[x^0, x^1, ..., x^{(N-1)}]`. By default, the powers decrease from left to\nright :math:`[x^{(N-1)}, ..., x^1, x^0]`.",
        "parameters": {},
        "returns": "An array of shape ``[len(x), N]`` containing the generated Vandermonde matrix.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.array([1, 2, 3, 4])\n>>> jnp.vander(x)\nArray([[ 1,  1,  1,  1],\n[ 8,  4,  2,  1],\n[27,  9,  3,  1],\n[64, 16,  4,  1]], dtype=int32)\nIf ``N = 2``, generates a Vandermonde matrix with ``2`` columns.\n>>> jnp.vander(x, N=2)\nArray([[1, 1],\n[2, 1],\n[3, 1],\n[4, 1]], dtype=int32)\nGenerates the Vandermonde matrix in increaing order of powers, when\n``increasing=True``.\n>>> jnp.vander(x, increasing=True)\nArray([[ 1,  1,  1,  1],\n[ 1,  2,  4,  8],\n[ 1,  3,  9, 27],\n[ 1,  4, 16, 64]], dtype=int32)"
      }
    },
    {
      "name": "var",
      "signature": "var(a: 'ArrayLike', axis: 'Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, ddof: 'int' = 0, keepdims: 'bool' = False, *, where: 'ArrayLike | None' = None, correction: 'int | float | None' = None) -> 'Array'",
      "documentation": {
        "description": "Compute the variance along a given axis.\nJAX implementation of :func:`numpy.var`.\nArgs:\na: input array.\naxis: optional, int or sequence of ints, default=None. Axis along which the\nvariance is computed. If None, variance is computed along all the axes.\ndtype: The type of the output array. Default=None.\nddof: int, default=0. Degrees of freedom. The divisor in the variance computation\nis ``N-ddof``, ``N`` is number of elements along given axis.\nkeepdims: bool, default=False. If true, reduced axes are left in the result\nwith size 1.\nwhere: optional, boolean array, default=None. The elements to be used in the\nvariance. Array should be broadcast compatible to the input.\ncorrection: int or float, default=None. Alternative name for ``ddof``.\nBoth ddof and correction can't be provided simultaneously.\nout: Unused by JAX.",
        "parameters": {},
        "returns": "An array of the variance along the given axis.\nSee also:\n- :func:`jax.numpy.mean`: Compute the mean of array elements over a given axis.\n- :func:`jax.numpy.std`: Compute the standard deviation of array elements over\ngiven axis.\n- :func:`jax.numpy.nanvar`: Compute the variance along a given axis, ignoring\nNaNs values.\n- :func:`jax.numpy.nanstd`: Computed the standard deviation of a given axis,\nignoring NaN values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "By default, ``jnp.var`` computes the variance along all axes.\n>>> x = jnp.array([[1, 3, 4, 2],\n...                [5, 2, 6, 3],\n...                [8, 4, 2, 9]])\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   jnp.var(x)\nArray(5.74, dtype=float32)\nIf ``axis=1``, variance is computed along axis 1.\n>>> jnp.var(x, axis=1)\nArray([1.25  , 2.5   , 8.1875], dtype=float32)\nTo preserve the dimensions of input, you can set ``keepdims=True``.\n>>> jnp.var(x, axis=1, keepdims=True)\nArray([[1.25  ],\n[2.5   ],\n[8.1875]], dtype=float32)\nIf ``ddof=1``:\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.var(x, axis=1, keepdims=True, ddof=1))\n[[ 1.67]\n[ 3.33]\n[10.92]]\nTo include specific elements of the array to compute variance, you can use\n``where``.\n>>> where = jnp.array([[1, 0, 1, 0],\n...                    [0, 1, 1, 0],\n...                    [1, 1, 1, 0]], dtype=bool)\n>>> with jnp.printoptions(precision=2, suppress=True):\n...   print(jnp.var(x, axis=1, keepdims=True, where=where))\n[[2.25]\n[4.  ]\n[6.22]]"
      }
    },
    {
      "name": "vdot",
      "signature": "vdot(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], b: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], *, precision: Union[NoneType, str, jax._src.lax.lax.Precision, tuple[str, str], tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision], jax._src.lax.lax.DotAlgorithm, jax._src.lax.lax.DotAlgorithmPreset] = None, preferred_element_type: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None) -> jax.Array",
      "documentation": {
        "description": "Perform a conjugate multiplication of two 1D vectors.\nJAX implementation of :func:`numpy.vdot`.\nArgs:\na: first input array, if not 1D it will be flattened.\nb: second input array, if not 1D it will be flattened. Must have ``a.size == b.size``.\nprecision: either ``None`` (default), which means the default precision for\nthe backend, a :class:`~jax.lax.Precision` enum value (``Precision.DEFAULT``,\n``Precision.HIGH`` or ``Precision.HIGHEST``) or a tuple of two\nsuch values indicating precision of ``a`` and ``b``.\npreferred_element_type: either ``None`` (default), which means the default\naccumulation type for the input types, or a datatype, indicating to\naccumulate results to and return a result with that datatype.",
        "parameters": {},
        "returns": "Scalar array (shape ``()``) containing the conjugate vector product of the inputs.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.vecdot`: batched vector product.\n- :func:`jax.numpy.matmul`: general matrix multiplication.\n- :func:`jax.lax.dot_general`: general N-dimensional batched dot product.",
        "notes": "",
        "examples": ">>> x = jnp.array([1j, 2j, 3j])\n>>> y = jnp.array([1., 2., 3.])\n>>> jnp.vdot(x, y)\nArray(0.-14.j, dtype=complex64)\nNote the difference between this and :func:`~jax.numpy.dot`, which does not\nconjugate the first input when complex:\n>>> jnp.dot(x, y)\nArray(0.+14.j, dtype=complex64)"
      }
    },
    {
      "name": "vecdot",
      "signature": "vecdot(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /, *, axis: int = -1, precision: Union[NoneType, str, jax._src.lax.lax.Precision, tuple[str, str], tuple[jax._src.lax.lax.Precision, jax._src.lax.lax.Precision], jax._src.lax.lax.DotAlgorithm, jax._src.lax.lax.DotAlgorithmPreset] = None, preferred_element_type: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None) -> jax.Array",
      "documentation": {
        "description": "Perform a conjugate multiplication of two batched vectors.\nJAX implementation of :func:`numpy.vecdot`.\nArgs:\na: left-hand side array.\nb: right-hand side array. Size of ``b[axis]`` must match size of ``a[axis]``,\nand remaining dimensions must be broadcast-compatible.\naxis: axis along which to compute the dot product (default: -1)\nprecision: either ``None`` (default), which means the default precision for\nthe backend, a :class:`~jax.lax.Precision` enum value (``Precision.DEFAULT``,\n``Precision.HIGH`` or ``Precision.HIGHEST``) or a tuple of two\nsuch values indicating precision of ``a`` and ``b``.\npreferred_element_type: either ``None`` (default), which means the default\naccumulation type for the input types, or a datatype, indicating to\naccumulate results to and return a result with that datatype.",
        "parameters": {},
        "returns": "array containing the conjugate dot product of ``a`` and ``b`` along ``axis``.\nThe non-contracted dimensions are broadcast together.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.vdot`: flattened vector product.\n- :func:`jax.numpy.vecmat`: vector-matrix product.\n- :func:`jax.numpy.matmul`: general matrix multiplication.\n- :func:`jax.lax.dot_general`: general N-dimensional batched dot product.",
        "notes": "",
        "examples": "Vector conjugate-dot product of two 1D arrays:\n>>> a = jnp.array([1j, 2j, 3j])\n>>> b = jnp.array([4., 5., 6.])\n>>> jnp.linalg.vecdot(a, b)\nArray(0.-32.j, dtype=complex64)\nBatched vector dot product of two 2D arrays:\n>>> a = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n>>> b = jnp.array([[2, 3, 4]])\n>>> jnp.linalg.vecdot(a, b, axis=-1)\nArray([20, 47], dtype=int32)"
      }
    },
    {
      "name": "vecmat",
      "signature": "vecmat(x1: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], x2: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], /) -> jax.Array",
      "documentation": {
        "description": "Batched conjugate vector-matrix product.\nJAX implementation of :func:`numpy.vecmat`.\nArgs:\nx1: array of shape ``(..., M)``.\nx2: array of shape ``(..., M, N)``. Leading dimensions must be broadcast-compatible\nwith leading dimensions of ``x1``.",
        "parameters": {},
        "returns": "An array of shape ``(..., N)`` containing the batched conjugate vector-matrix product.\nSee also:\n- :func:`jax.numpy.linalg.vecdot`: batched vector product.\n- :func:`jax.numpy.matvec`: matrix-vector product.\n- :func:`jax.numpy.matmul`: general matrix multiplication.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Simple vector-matrix product:\n>>> x1 = jnp.array([[1, 2, 3]])\n>>> x2 = jnp.array([[4, 5],\n...                 [6, 7],\n...                 [8, 9]])\n>>> jnp.vecmat(x1, x2)\nArray([[40, 46]], dtype=int32)\nBatched vector-matrix product:\n>>> x1 = jnp.array([[1, 2, 3],\n...                 [4, 5, 6]])\n>>> jnp.vecmat(x1, x2)\nArray([[ 40,  46],\n[ 94, 109]], dtype=int32)"
      }
    },
    {
      "name": "vectorize",
      "signature": "vectorize(pyfunc, *, excluded=frozenset(), signature=None)",
      "documentation": {
        "description": "Define a vectorized function with broadcasting.\n:func:`vectorize` is a convenience wrapper for defining vectorized\nfunctions with broadcasting, in the style of NumPy's\n`generalized universal functions <https://numpy.org/doc/stable/reference/c-api/generalized-ufuncs.html>`_.\nIt allows for defining functions that are automatically repeated across\nany leading dimensions, without the implementation of the function needing to\nbe concerned about how to handle higher dimensional inputs.\n:func:`jax.numpy.vectorize` has the same interface as\n:class:`numpy.vectorize`, but it is syntactic sugar for an auto-batching\ntransformation (:func:`vmap`) rather than a Python loop. This should be\nconsiderably more efficient, but the implementation must be written in terms\nof functions that act on JAX arrays.\nArgs:\npyfunc: function to vectorize.\nexcluded: optional set of integers representing positional arguments for\nwhich the function will not be vectorized. These will be passed directly\nto ``pyfunc`` unmodified.\nsignature: optional generalized universal function signature, e.g.,\n``(m,n),(n)->(m)`` for vectorized matrix-vector multiplication. If\nprovided, ``pyfunc`` will be called with (and expected to return) arrays\nwith shapes given by the size of corresponding core dimensions. By\ndefault, pyfunc is assumed to take scalars arrays as input and output.",
        "parameters": {},
        "returns": "Vectorized version of the given function.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Here are a few examples of how one could write vectorized linear algebra\nroutines using :func:`vectorize`:\n>>> from functools import partial\n>>> @partial(jnp.vectorize, signature='(k),(k)->(k)')\n... def cross_product(a, b):\n...   assert a.shape == b.shape and a.ndim == b.ndim == 1\n...   return jnp.array([a[1] * b[2] - a[2] * b[1],\n...                     a[2] * b[0] - a[0] * b[2],\n...                     a[0] * b[1] - a[1] * b[0]])\n>>> @partial(jnp.vectorize, signature='(n,m),(m)->(n)')\n... def matrix_vector_product(matrix, vector):\n...   assert matrix.ndim == 2 and matrix.shape[1:] == vector.shape\n...   return matrix @ vector\nThese functions are only written to handle 1D or 2D arrays (the ``assert``\nstatements will never be violated), but with vectorize they support\narbitrary dimensional inputs with NumPy style broadcasting, e.g.,\n>>> cross_product(jnp.ones(3), jnp.ones(3)).shape\n(3,)\n>>> cross_product(jnp.ones((2, 3)), jnp.ones(3)).shape\n(2, 3)\n>>> cross_product(jnp.ones((1, 2, 3)), jnp.ones((2, 1, 3))).shape\n(2, 2, 3)\n>>> matrix_vector_product(jnp.ones(3), jnp.ones(3))  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nValueError: input with shape (3,) does not have enough dimensions for all\ncore dimensions ('n', 'k') on vectorized function with excluded=frozenset()\nand signature='(n,k),(k)->(k)'\n>>> matrix_vector_product(jnp.ones((2, 3)), jnp.ones(3)).shape\n(2,)\n>>> matrix_vector_product(jnp.ones((2, 3)), jnp.ones((4, 3))).shape\n(4, 2)\nNote that this has different semantics than `jnp.matmul`:\n>>> jnp.matmul(jnp.ones((2, 3)), jnp.ones((4, 3)))  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\nTypeError: dot_general requires contracting dimensions to have the same shape, got [3] and [4]."
      }
    },
    {
      "name": "vsplit",
      "signature": "vsplit(ary: 'ArrayLike', indices_or_sections: 'int | Sequence[int] | ArrayLike') -> 'list[Array]'",
      "documentation": {
        "description": "Split an array into sub-arrays vertically.\nJAX implementation of :func:`numpy.vsplit`.\nRefer to the documentation of :func:`jax.numpy.split` for details; ``vsplit`` is\nequivalent to ``split`` with ``axis=0``.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "1D array:\n>>> x = jnp.array([1, 2, 3, 4, 5, 6])\n>>> x1, x2 = jnp.vsplit(x, 2)\n>>> print(x1, x2)\n[1 2 3] [4 5 6]\n2D array:\n>>> x = jnp.array([[1, 2, 3, 4],\n...                [5, 6, 7, 8]])\n>>> x1, x2 = jnp.vsplit(x, 2)\n>>> print(x1, x2)\n[[1 2 3 4]] [[5 6 7 8]]\nSee also:\n- :func:`jax.numpy.split`: split an array along any axis.\n- :func:`jax.numpy.hsplit`: split horizontally, i.e. along axis=1\n- :func:`jax.numpy.dsplit`: split depth-wise, i.e. along axis=2\n- :func:`jax.numpy.array_split`: like ``split``, but allows ``indices_or_sections``\nto be an integer that does not evenly divide the size of the array."
      }
    },
    {
      "name": "vstack",
      "signature": "vstack(tup: 'np.ndarray | Array | Sequence[ArrayLike]', dtype: 'DTypeLike | None' = None) -> 'Array'",
      "documentation": {
        "description": "Vertically stack arrays.\nJAX implementation of :func:`numpy.vstack`.\nFor arrays of two or more dimensions, this is equivalent to\n:func:`jax.numpy.concatenate` with ``axis=0``.\nArgs:\ntup: a sequence of arrays to stack; each must have the same shape along all\nbut the first axis. If a single array is given it will be treated\nequivalently to `tup = unstack(tup)`, but the implementation will avoid\nexplicit unstacking.\ndtype: optional dtype of the resulting array. If not specified, the dtype\nwill be determined via type promotion rules described in :ref:`type-promotion`.",
        "parameters": {},
        "returns": "the stacked result.\nSee also:\n- :func:`jax.numpy.stack`: stack along arbitrary axes\n- :func:`jax.numpy.concatenate`: concatenation along existing axes.\n- :func:`jax.numpy.hstack`: stack horizontally, i.e. along axis 1.\n- :func:`jax.numpy.dstack`: stack depth-wise, i.e. along axis 2.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Scalar values:\n>>> jnp.vstack([1, 2, 3])\nArray([[1],\n[2],\n[3]], dtype=int32, weak_type=True)\n1D arrays:\n>>> x = jnp.arange(4)\n>>> y = jnp.ones(4)\n>>> jnp.vstack([x, y])\nArray([[0., 1., 2., 3.],\n[1., 1., 1., 1.]], dtype=float32)\n2D arrays:\n>>> x = x.reshape(1, 4)\n>>> y = y.reshape(1, 4)\n>>> jnp.vstack([x, y])\nArray([[0., 1., 2., 3.],\n[1., 1., 1., 1.]], dtype=float32)"
      }
    },
    {
      "name": "where",
      "signature": "where(condition, x=None, y=None, /, *, size=None, fill_value=None)",
      "documentation": {
        "description": "Select elements from two arrays based on a condition.\nJAX implementation of :func:`numpy.where`.\n.. note::\nwhen only ``condition`` is provided, ``jnp.where(condition)`` is equivalent\nto ``jnp.nonzero(condition)``. For that case, refer to the documentation of\n:func:`jax.numpy.nonzero`. The docstring below focuses on the case where\n``x`` and ``y`` are specified.\nThe three-term version of ``jnp.where`` lowers to :func:`jax.lax.select`.\nArgs:\ncondition: boolean array. Must be broadcast-compatible with ``x`` and ``y`` when\nthey are specified.\nx: arraylike. Should be broadcast-compatible with ``condition`` and ``y``, and\ntypecast-compatible with ``y``.\ny: arraylike. Should be broadcast-compatible with ``condition`` and ``x``, and\ntypecast-compatible with ``x``.\nsize: integer, only referenced when ``x`` and ``y`` are ``None``. For details,\nsee :func:`jax.numpy.nonzero`.\nfill_value: only referenced when ``x`` and ``y`` are ``None``. For details,\nsee :func:`jax.numpy.nonzero`.",
        "parameters": {},
        "returns": "An array of dtype ``jnp.result_type(x, y)`` with values drawn from ``x`` where ``condition``\nis True, and from ``y`` where condition is ``False``. If ``x`` and ``y`` are ``None``, the\nfunction behaves differently; see :func:`jax.numpy.nonzero` for a description of the return\ntype.",
        "raises": "",
        "see_also": "- :func:`jax.numpy.nonzero`\n- :func:`jax.numpy.argwhere`\n- :func:`jax.lax.select`",
        "notes": "Special care is needed when the ``x`` or ``y`` input to :func:`jax.numpy.where` could\nhave a value of NaN. Specifically, when a gradient is taken with :func:`jax.grad`\n(reverse-mode differentiation), a NaN in either ``x`` or ``y`` will propagate into the\ngradient, regardless of the value of ``condition``.  More information on this behavior\nand workarounds is available in the `JAX FAQ\n<https://jax.readthedocs.io/en/latest/faq.html#gradients-contain-nan-where-using-where>`_.",
        "examples": "When ``x`` and ``y`` are not provided, ``where`` behaves equivalently to\n:func:`jax.numpy.nonzero`:\n>>> x = jnp.arange(10)\n>>> jnp.where(x > 4)\n(Array([5, 6, 7, 8, 9], dtype=int32),)\n>>> jnp.nonzero(x > 4)\n(Array([5, 6, 7, 8, 9], dtype=int32),)\nWhen ``x`` and ``y`` are provided, ``where`` selects between them based on\nthe specified condition:\n>>> jnp.where(x > 4, x, 0)\nArray([0, 0, 0, 0, 0, 5, 6, 7, 8, 9], dtype=int32)"
      }
    },
    {
      "name": "zeros",
      "signature": "zeros(shape: Any, dtype: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None, *, device: jaxlib.xla_extension.Device | jaxlib.xla_extension.Sharding | None = None) -> jax.Array",
      "documentation": {
        "description": "Create an array full of zeros.\nJAX implementation of :func:`numpy.zeros`.\nArgs:\nshape: int or sequence of ints specifying the shape of the created array.\ndtype: optional dtype for the created array; defaults to floating point.\ndevice: (optional) :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.",
        "parameters": {},
        "returns": "Array of the specified shape and dtype, on the specified device if specified.\nSee also:\n- :func:`jax.numpy.zeros_like`\n- :func:`jax.numpy.empty`\n- :func:`jax.numpy.ones`\n- :func:`jax.numpy.full`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> jnp.zeros(4)\nArray([0., 0., 0., 0.], dtype=float32)\n>>> jnp.zeros((2, 3), dtype=bool)\nArray([[False, False, False],\n[False, False, False]], dtype=bool)"
      }
    },
    {
      "name": "zeros_like",
      "signature": "zeros_like(a: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex, jax._src.typing.DuckTypedArray], dtype: Union[str, type[Any], numpy.dtype, jax._src.typing.SupportsDType, NoneType] = None, shape: Any = None, *, device: jaxlib.xla_extension.Device | jaxlib.xla_extension.Sharding | None = None) -> jax.Array",
      "documentation": {
        "description": "Create an array full of zeros with the same shape and dtype as an array.\nJAX implementation of :func:`numpy.zeros_like`.\nArgs:\na: Array-like object with ``shape`` and ``dtype`` attributes.\nshape: optionally override the shape of the created array.\ndtype: optionally override the dtype of the created array.\ndevice: (optional) :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.",
        "parameters": {},
        "returns": "Array of the specified shape and dtype, on the specified device if specified.\nSee also:\n- :func:`jax.numpy.zeros`\n- :func:`jax.numpy.empty_like`\n- :func:`jax.numpy.ones_like`\n- :func:`jax.numpy.full_like`",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> x = jnp.arange(4)\n>>> jnp.zeros_like(x)\nArray([0, 0, 0, 0], dtype=int32)\n>>> jnp.zeros_like(x, dtype=bool)\nArray([False, False, False, False], dtype=bool)\n>>> jnp.zeros_like(x, shape=(2, 3))\nArray([[0, 0, 0],\n[0, 0, 0]], dtype=int32)"
      }
    }
  ],
  "classes": [
    {
      "name": "ComplexWarning",
      "documentation": {
        "description": "The warning raised when casting a complex dtype to a real dtype.\nAs implemented, casting a complex number to a real discards its imaginary\npart, but this behavior may not be what the user actually wants.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "documentation": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "bfloat16",
      "documentation": {
        "description": "A JAX scalar constructor of type bfloat16.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "bool",
      "documentation": {
        "description": "A JAX scalar constructor of type bool_.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "bool_",
      "documentation": {
        "description": "A JAX scalar constructor of type bool_.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "cdouble",
      "documentation": {
        "description": "A JAX scalar constructor of type complex128.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "character",
      "documentation": {
        "description": "Abstract base class of all character string scalar types.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "complex128",
      "documentation": {
        "description": "A JAX scalar constructor of type complex128.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "complex64",
      "documentation": {
        "description": "A JAX scalar constructor of type complex64.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "complex_",
      "documentation": {
        "description": "A JAX scalar constructor of type complex128.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "complexfloating",
      "documentation": {
        "description": "Abstract base class of all complex number scalar types that are made up of\nfloating-point numbers.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "csingle",
      "documentation": {
        "description": "A JAX scalar constructor of type complex64.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "double",
      "documentation": {
        "description": "A JAX scalar constructor of type float64.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "dtype",
      "documentation": {
        "description": "dtype(dtype, align=False, copy=False, [metadata])\nCreate a data type object.\nA numpy array is homogeneous, and contains elements described by a\ndtype object. A dtype object can be constructed from different\ncombinations of fundamental numeric types.",
        "parameters": {
          "align": {
            "type": "bool, optional",
            "description": "Add padding to the fields to match what a C compiler would output\nfor a similar C-struct. Can be ``True`` only if `obj` is a dictionary\nor a comma-separated string. If a struct dtype is being created,\nthis also sets a sticky alignment flag ``isalignedstruct``."
          },
          "copy": {
            "type": "bool, optional",
            "description": "Make a new copy of the data-type object. If ``False``, the result\nmay just be a reference to a built-in data-type object."
          },
          "metadata": {
            "type": "dict, optional",
            "description": "An optional dictionary with dtype metadata.\nSee also\n--------\nresult_type"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\nUsing array-scalar type:\n>>> np.dtype(np.int16)\ndtype('int16')\nStructured type, one field name 'f1', containing int16:\n>>> np.dtype([('f1', np.int16)])\ndtype([('f1', '<i2')])\nStructured type, one field named 'f1', in itself containing a structured\ntype with one field:\n>>> np.dtype([('f1', [('f1', np.int16)])])\ndtype([('f1', [('f1', '<i2')])])\nStructured type, two fields: the first field contains an unsigned int, the\nsecond an int32:\n>>> np.dtype([('f1', np.uint64), ('f2', np.int32)])\ndtype([('f1', '<u8'), ('f2', '<i4')])\nUsing array-protocol type strings:\n>>> np.dtype([('a','f8'),('b','S10')])\ndtype([('a', '<f8'), ('b', 'S10')])\nUsing comma-separated field formats.  The shape is (2,3):\n>>> np.dtype(\"i4, (2,3)f8\")\ndtype([('f0', '<i4'), ('f1', '<f8', (2, 3))])\nUsing tuples.  ``int`` is a fixed type, 3 the field's shape.  ``void``\nis a flexible type, here of size 10:\n>>> np.dtype([('hello',(np.int64,3)),('world',np.void,10)])\ndtype([('hello', '<i8', (3,)), ('world', 'V10')])\nSubdivide ``int16`` into 2 ``int8``'s, called x and y.  0 and 1 are\nthe offsets in bytes:\n>>> np.dtype((np.int16, {'x':(np.int8,0), 'y':(np.int8,1)}))\ndtype((numpy.int16, [('x', 'i1'), ('y', 'i1')]))\nUsing dictionaries.  Two fields named 'gender' and 'age':\n>>> np.dtype({'names':['gender','age'], 'formats':['S1',np.uint8]})\ndtype([('gender', 'S1'), ('age', 'u1')])\nOffsets in bytes, here 0 and 25:\n>>> np.dtype({'surname':('S25',0),'age':(np.uint8,25)})\ndtype([('surname', 'S25'), ('age', 'u1')])"
      },
      "methods": [
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new dtype with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.",
            "parameters": {
              "new_order": {
                "type": "string, optional",
                "description": "Byte order to force; a value from the byte order specifications\nbelow.  The default value ('S') results in swapping the current\nbyte order.  `new_order` codes can be any of:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)"
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew dtype object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nChanges are also made in all fields and sub-arrays of the data type.",
            "examples": "--------\n>>> import sys\n>>> sys_is_le = sys.byteorder == 'little'\n>>> native_code = '<' if sys_is_le else '>'\n>>> swapped_code = '>' if sys_is_le else '<'\n>>> native_dt = np.dtype(native_code+'i2')\n>>> swapped_dt = np.dtype(swapped_code+'i2')\n>>> native_dt.newbyteorder('S') == swapped_dt\nTrue\n>>> native_dt.newbyteorder() == swapped_dt\nTrue\n>>> native_dt == swapped_dt.newbyteorder('S')\nTrue\n>>> native_dt == swapped_dt.newbyteorder('=')\nTrue\n>>> native_dt == swapped_dt.newbyteorder('N')\nTrue\n>>> native_dt == native_dt.newbyteorder('|')\nTrue\n>>> np.dtype('<i2') == native_dt.newbyteorder('<')\nTrue\n>>> np.dtype('<i2') == native_dt.newbyteorder('L')\nTrue\n>>> np.dtype('>i2') == native_dt.newbyteorder('>')\nTrue\n>>> np.dtype('>i2') == native_dt.newbyteorder('B')\nTrue"
          }
        }
      ]
    },
    {
      "name": "finfo",
      "documentation": {
        "description": "finfo(dtype)\nMachine limits for floating point types.\nAttributes\n----------\nbits : int\nThe number of bits occupied by the type.\ndtype : dtype",
        "parameters": {
          "dtype": {
            "type": "float, dtype, or instance",
            "description": "Kind of floating point or complex floating point\ndata-type about which to get information."
          }
        },
        "returns": "input, the returned dtype is the associated ``float*`` dtype for its\nreal and complex components.\neps : float\nThe difference between 1.0 and the next smallest representable float\nlarger than 1.0. For example, for 64-bit binary floats in the IEEE-754\nstandard, ``eps = 2**-52``, approximately 2.22e-16.\nepsneg : float\nThe difference between 1.0 and the next smallest representable float\nless than 1.0. For example, for 64-bit binary floats in the IEEE-754\nstandard, ``epsneg = 2**-53``, approximately 1.11e-16.\niexp : int\nThe number of bits in the exponent portion of the floating point\nrepresentation.\nmachep : int\nThe exponent that yields `eps`.\nmax : floating point number of the appropriate type\nThe largest representable number.\nmaxexp : int\nThe smallest positive power of the base (2) that causes overflow.\nmin : floating point number of the appropriate type\nThe smallest representable number, typically ``-max``.\nminexp : int\nThe most negative power of the base (2) consistent with there\nbeing no leading 0's in the mantissa.\nnegep : int\nThe exponent that yields `epsneg`.\nnexp : int\nThe number of bits in the exponent including its sign and bias.\nnmant : int\nThe number of bits in the mantissa.\nprecision : int\nThe approximate number of decimal digits to which this kind of\nfloat is precise.\nresolution : floating point number of the appropriate type\nThe approximate decimal resolution of this type, i.e.,\n``10**-precision``.\ntiny : float\nAn alias for `smallest_normal`, kept for backwards compatibility.\nsmallest_normal : float\nThe smallest positive floating point number with 1 as leading bit in\nthe mantissa following IEEE-754 (see Notes).\nsmallest_subnormal : float\nThe smallest positive floating point number with 0 as leading bit in\nthe mantissa following IEEE-754.",
        "raises": "",
        "see_also": "--------\niinfo : The equivalent for integer data types.\nspacing : The distance between a value and the nearest adjacent number\nnextafter : The next floating point value after x1 towards x2",
        "notes": "-----\nFor developers of NumPy: do not instantiate this at the module level.\nThe initial calculation of these parameters is expensive and negatively\nimpacts import times.  These objects are cached, so calling ``finfo()``\nrepeatedly inside your functions is not a problem.\nNote that ``smallest_normal`` is not actually the smallest positive\nrepresentable value in a NumPy floating point type. As in the IEEE-754\nstandard [1]_, NumPy floating point types make use of subnormal numbers to\nfill the gap between 0 and ``smallest_normal``. However, subnormal numbers\nmay have significantly reduced precision [2]_.\nThis function can also be used for complex data types as well. If used,\nthe output will be the same as the corresponding real float type\n(e.g. numpy.finfo(numpy.csingle) is the same as numpy.finfo(numpy.single)).\nHowever, the output is true for the real and imaginary components.\nReferences\n----------\n.. [1] IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008,\npp.1-70, 2008, http://www.doi.org/10.1109/IEEESTD.2008.4610935\n.. [2] Wikipedia, \"Denormal Numbers\",\nhttps://en.wikipedia.org/wiki/Denormal_number",
        "examples": "--------\n>>> np.finfo(np.float64).dtype\ndtype('float64')\n>>> np.finfo(np.complex64).dtype\ndtype('float32')"
      },
      "methods": []
    },
    {
      "name": "flexible",
      "documentation": {
        "description": "Abstract base class of all scalar types without predefined length.\nThe actual size of these types depends on the specific `np.dtype`\ninstantiation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "float16",
      "documentation": {
        "description": "A JAX scalar constructor of type float16.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "float32",
      "documentation": {
        "description": "A JAX scalar constructor of type float32.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "float4_e2m1fn",
      "documentation": {
        "description": "A JAX scalar constructor of type float4_e2m1fn.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "float64",
      "documentation": {
        "description": "A JAX scalar constructor of type float64.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "float8_e3m4",
      "documentation": {
        "description": "A JAX scalar constructor of type float8_e3m4.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "float8_e4m3",
      "documentation": {
        "description": "A JAX scalar constructor of type float8_e4m3.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "float8_e4m3b11fnuz",
      "documentation": {
        "description": "A JAX scalar constructor of type float8_e4m3b11fnuz.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "float8_e4m3fn",
      "documentation": {
        "description": "A JAX scalar constructor of type float8_e4m3fn.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "float8_e4m3fnuz",
      "documentation": {
        "description": "A JAX scalar constructor of type float8_e4m3fnuz.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "float8_e5m2",
      "documentation": {
        "description": "A JAX scalar constructor of type float8_e5m2.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "float8_e5m2fnuz",
      "documentation": {
        "description": "A JAX scalar constructor of type float8_e5m2fnuz.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "float8_e8m0fnu",
      "documentation": {
        "description": "A JAX scalar constructor of type float8_e8m0fnu.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "float_",
      "documentation": {
        "description": "A JAX scalar constructor of type float64.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "floating",
      "documentation": {
        "description": "Abstract base class of all floating-point scalar types.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "generic",
      "documentation": {
        "description": "Base class for numpy scalar types.\nClass from which most (all?) numpy scalar types are derived.  For\nconsistency, exposes the same API as `ndarray`, despite many\nconsequent attributes being either \"get-only,\" or completely irrelevant.\nThis is the class from which it is strongly suggested users should derive\ncustom scalar types.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "iinfo",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "inexact",
      "documentation": {
        "description": "Abstract base class of all numeric scalar types with a (potentially)\ninexact representation of the values in its range, such as\nfloating-point numbers.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "int16",
      "documentation": {
        "description": "A JAX scalar constructor of type int16.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "int2",
      "documentation": {
        "description": "A JAX scalar constructor of type int2.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "int32",
      "documentation": {
        "description": "A JAX scalar constructor of type int32.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "int4",
      "documentation": {
        "description": "A JAX scalar constructor of type int4.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "int64",
      "documentation": {
        "description": "A JAX scalar constructor of type int64.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "int8",
      "documentation": {
        "description": "A JAX scalar constructor of type int8.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "int_",
      "documentation": {
        "description": "A JAX scalar constructor of type int64.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "integer",
      "documentation": {
        "description": "Abstract base class of all integer scalar types.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_integer",
          "signature": "is_integer(...)",
          "documentation": {
            "description": "integer.is_integer() -> bool\nReturn ``True`` if the number is finite with integral value.\n.. versionadded:: 1.22",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> np.int64(-2).is_integer()\nTrue\n>>> np.uint32(5).is_integer()\nTrue"
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ndarray",
      "documentation": {
        "description": "Array base class for JAX\n``jax.Array`` is the public interface for instance checks and type annotation\nof JAX arrays and tracers. Its main applications are in instance checks and\ntype annotations; for example::\nx = jnp.arange(5)\nisinstance(x, jax.Array)  # returns True both inside and outside traced functions.\ndef f(x: Array) -> Array:  # type annotations are valid for traced and non-traced types.\nreturn x\n``jax.Array`` should not be used directly for creation of arrays; instead you\nshould use array creation routines offered in :mod:`jax.numpy`, such as\n:func:`jax.numpy.array`, :func:`jax.numpy.zeros`, :func:`jax.numpy.ones`,\n:func:`jax.numpy.full`, :func:`jax.numpy.arange`, etc.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "addressable_data",
          "signature": "addressable_data(self, index: 'int') -> 'Array'",
          "documentation": {
            "description": "Return an array of the addressable data at a particular index.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "all",
          "signature": "_all(self: 'Array', axis: 'reductions.Axis' = None, out: 'None' = None, keepdims: 'bool' = False, *, where: 'ArrayLike | None' = None) -> 'Array'",
          "documentation": {
            "description": "Test whether all array elements along a given axis evaluate to True.\nRefer to :func:`jax.numpy.all` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "_any(self: 'Array', axis: 'reductions.Axis' = None, out: 'None' = None, keepdims: 'bool' = False, *, where: 'ArrayLike | None' = None) -> 'Array'",
          "documentation": {
            "description": "Test whether any array elements along a given axis evaluate to True.\nRefer to :func:`jax.numpy.any` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "_argmax(self: 'Array', axis: 'int | None' = None, out: 'None' = None, keepdims: 'bool | None' = None) -> 'Array'",
          "documentation": {
            "description": "Return the index of the maximum value.\nRefer to :func:`jax.numpy.argmax` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "_argmin(self: 'Array', axis: 'int | None' = None, out: 'None' = None, keepdims: 'bool | None' = None) -> 'Array'",
          "documentation": {
            "description": "Return the index of the minimum value.\nRefer to :func:`jax.numpy.argmin` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argpartition",
          "signature": "_argpartition(self: 'Array', kth: 'int', axis: 'int' = -1) -> 'Array'",
          "documentation": {
            "description": "Return the indices that partially sort the array.\nRefer to :func:`jax.numpy.argpartition` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "_argsort(self: 'Array', axis: 'int | None' = -1, *, kind: 'None' = None, order: 'None' = None, stable: 'bool' = True, descending: 'bool' = False) -> 'Array'",
          "documentation": {
            "description": "Return the indices that sort the array.\nRefer to :func:`jax.numpy.argsort` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "_astype(self: 'Array', dtype: 'DTypeLike | None', copy: 'bool' = False, device: 'xc.Device | Sharding | None' = None) -> 'Array'",
          "documentation": {
            "description": "Copy the array and cast to a specified dtype.\nThis is implemented via :func:`jax.lax.convert_element_type`, which may\nhave slightly different behavior than :meth:`numpy.ndarray.astype` in\nsome cases. In particular, the details of float-to-int and int-to-float\ncasts are implementation dependent.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "_choose(self: 'Array', choices: 'Sequence[ArrayLike]', out: 'None' = None, mode: 'str' = 'raise') -> 'Array'",
          "documentation": {
            "description": "Construct an array choosing from elements of multiple arrays.\nRefer to :func:`jax.numpy.choose` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "_clip(self: 'Array', min: 'ArrayLike | None' = None, max: 'ArrayLike | None' = None) -> 'Array'",
          "documentation": {
            "description": "Return an array whose values are limited to a specified range.\nRefer to :func:`jax.numpy.clip` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "_compress(self: 'Array', condition: 'ArrayLike', axis: 'int | None' = None, *, out: 'None' = None, size: 'int | None' = None, fill_value: 'ArrayLike' = 0) -> 'Array'",
          "documentation": {
            "description": "Return selected slices of this array along given axis.\nRefer to :func:`jax.numpy.compress` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "_conj(self: 'Array') -> 'Array'",
          "documentation": {
            "description": "Return the complex conjugate of the array.\nRefer to :func:`jax.numpy.conj` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "_conjugate(self: 'Array') -> 'Array'",
          "documentation": {
            "description": "Return the complex conjugate of the array.\nRefer to :func:`jax.numpy.conjugate` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "_copy(self: 'Array') -> 'Array'",
          "documentation": {
            "description": "Return a copy of the array.\nRefer to :func:`jax.numpy.copy` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy_to_host_async",
          "signature": "copy_to_host_async(self)",
          "documentation": {
            "description": "Copies an ``Array`` to the host asynchronously.\nFor arrays that live an an accelerator, such as a GPU or a TPU, JAX may\ncache the value of the array on the host. Normally this happens\nbehind the scenes when the value of an on-device array is requested by the\nuser, but waiting to initiate a device-to-host copy until the value is\nrequested requires that JAX block the caller while waiting for the copy to\ncomplete.\n``copy_to_host_async`` requests that JAX populate its on-host cache of an\narray, but does not wait for the copy to complete. This may speed up a\nfuture on-host access to the array's contents.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "_cumprod(self: 'Array', axis: 'reductions.Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None) -> 'Array'",
          "documentation": {
            "description": "Return the cumulative product of the array.\nRefer to :func:`jax.numpy.cumprod` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "_cumsum(self: 'Array', axis: 'reductions.Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None) -> 'Array'",
          "documentation": {
            "description": "Return the cumulative sum of the array.\nRefer to :func:`jax.numpy.cumsum` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "_diagonal(self: 'Array', offset: 'int' = 0, axis1: 'int' = 0, axis2: 'int' = 1) -> 'Array'",
          "documentation": {
            "description": "Return the specified diagonal from the array.\nRefer to :func:`jax.numpy.diagonal` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dot",
          "signature": "_dot(self: 'Array', b: 'ArrayLike', *, precision: 'lax_internal.PrecisionLike' = None, preferred_element_type: 'DTypeLike | None' = None) -> 'Array'",
          "documentation": {
            "description": "Compute the dot product of two arrays.\nRefer to :func:`jax.numpy.dot` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "_flatten(self: 'Array', order: 'str' = 'C') -> 'Array'",
          "documentation": {
            "description": "Flatten array into a 1-dimensional shape.\nRefer to :func:`jax.numpy.ravel` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "_item(self: 'Array', *args: 'int') -> 'bool | int | float | complex'",
          "documentation": {
            "description": "Copy an element of an array to a standard Python scalar and return it.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "_max(self: 'Array', axis: 'reductions.Axis' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None) -> 'Array'",
          "documentation": {
            "description": "Return the maximum of array elements along a given axis.\nRefer to :func:`jax.numpy.max` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "_mean(self: 'Array', axis: 'reductions.Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, keepdims: 'bool' = False, *, where: 'ArrayLike | None' = None) -> 'Array'",
          "documentation": {
            "description": "Return the mean of array elements along a given axis.\nRefer to :func:`jax.numpy.mean` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "_min(self: 'Array', axis: 'reductions.Axis' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None) -> 'Array'",
          "documentation": {
            "description": "Return the minimum of array elements along a given axis.\nRefer to :func:`jax.numpy.min` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "_nonzero(self: 'Array', *, fill_value: 'None | ArrayLike | tuple[ArrayLike, ...]' = None, size: 'int | None' = None) -> 'tuple[Array, ...]'",
          "documentation": {
            "description": "Return indices of nonzero elements of an array.\nRefer to :func:`jax.numpy.nonzero` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "_prod(self: 'Array', axis: 'reductions.Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None, promote_integers: 'bool' = True) -> 'Array'",
          "documentation": {
            "description": "Return product of the array elements over a given axis.\nRefer to :func:`jax.numpy.prod` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "_ptp(self: 'Array', axis: 'reductions.Axis' = None, out: 'None' = None, keepdims: 'bool' = False) -> 'Array'",
          "documentation": {
            "description": "Return the peak-to-peak range along a given axis.\nRefer to :func:`jax.numpy.ptp` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "_flatten(self: 'Array', order: 'str' = 'C') -> 'Array'",
          "documentation": {
            "description": "Flatten array into a 1-dimensional shape.\nRefer to :func:`jax.numpy.ravel` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "_repeat(self: 'Array', repeats: 'ArrayLike', axis: 'int | None' = None, *, total_repeat_length: 'int | None' = None) -> 'Array'",
          "documentation": {
            "description": "Construct an array from repeated elements.\nRefer to :func:`jax.numpy.repeat` for the full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "_reshape(self: 'Array', *args: 'Any', order: 'str' = 'C') -> 'Array'",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "Refer to :func:`jax.numpy.reshape` for full documentation.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "_round(self: 'Array', decimals: 'int' = 0, out: 'None' = None) -> 'Array'",
          "documentation": {
            "description": "Round array elements to a given decimal.\nRefer to :func:`jax.numpy.round` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "_searchsorted(self: 'Array', v: 'ArrayLike', side: 'str' = 'left', sorter: 'ArrayLike | None' = None, *, method: 'str' = 'scan') -> 'Array'",
          "documentation": {
            "description": "Perform a binary search within a sorted array.\nRefer to :func:`jax.numpy.searchsorted` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "_sort(self: 'Array', axis: 'int | None' = -1, *, kind: 'None' = None, order: 'None' = None, stable: 'bool' = True, descending: 'bool' = False) -> 'Array'",
          "documentation": {
            "description": "Return a sorted copy of an array.\nRefer to :func:`jax.numpy.sort` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "_squeeze(self: 'Array', axis: 'reductions.Axis' = None) -> 'Array'",
          "documentation": {
            "description": "Remove one or more length-1 axes from array.\nRefer to :func:`jax.numpy.squeeze` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "_std(self: 'Array', axis: 'reductions.Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, ddof: 'int' = 0, keepdims: 'bool' = False, *, where: 'ArrayLike | None' = None, correction: 'int | float | None' = None) -> 'Array'",
          "documentation": {
            "description": "Compute the standard deviation along a given axis.\nRefer to :func:`jax.numpy.std` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "_sum(self: 'Array', axis: 'reductions.Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None, promote_integers: 'bool' = True) -> 'Array'",
          "documentation": {
            "description": "Sum of the elements of the array over a given axis.\nRefer to :func:`jax.numpy.sum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "_swapaxes(self: 'Array', axis1: 'int', axis2: 'int') -> 'Array'",
          "documentation": {
            "description": "Swap two axes of an array.\nRefer to :func:`jax.numpy.swapaxes` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "_take(self: 'Array', indices: 'ArrayLike', axis: 'int | None' = None, out: 'None' = None, mode: 'str | None' = None, unique_indices: 'bool' = False, indices_are_sorted: 'bool' = False, fill_value: 'StaticScalar | None' = None) -> 'Array'",
          "documentation": {
            "description": "Take elements from an array.\nRefer to :func:`jax.numpy.take` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to_device",
          "signature": "_to_device(self: 'Array', device: 'xc.Device | Sharding', *, stream: 'int | Any | None' = None)",
          "documentation": {
            "description": "Return a copy of the array on the specified device\nArgs:\ndevice: :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\nto which the created array will be committed.\nstream: not implemented, passing a non-None value will lead to an error.",
            "parameters": {},
            "returns": "copy of array placed on the specified device or devices.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "_trace(self: 'Array', offset: 'int | ArrayLike' = 0, axis1: 'int' = 0, axis2: 'int' = 1, dtype: 'DTypeLike | None' = None, out: 'None' = None) -> 'Array'",
          "documentation": {
            "description": "Return the sum along the diagonal.\nRefer to :func:`jax.numpy.trace` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "_transpose(self: 'Array', *args: 'Any') -> 'Array'",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "Refer to :func:`jax.numpy.transpose` for full documentation.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "_var(self: 'Array', axis: 'reductions.Axis' = None, dtype: 'DTypeLike | None' = None, out: 'None' = None, ddof: 'int' = 0, keepdims: 'bool' = False, *, where: 'ArrayLike | None' = None, correction: 'int | float | None' = None) -> 'Array'",
          "documentation": {
            "description": "Compute the variance along a given axis.\nRefer to :func:`jax.numpy.var` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "_view(self: 'Array', dtype: 'DTypeLike | None' = None, type: 'None' = None) -> 'Array'",
          "documentation": {
            "description": "Return a bitwise copy of the array, viewed as a new dtype.\nThis is fuller-featured wrapper around :func:`jax.lax.bitcast_convert_type`.\nIf the source and target dtype have the same bitwidth, the result has the same\nshape as the input array. If the bitwidth of the target dtype is different\nfrom the source, the size of the last axis of the result is adjusted\naccordingly.\n>>> jnp.zeros([1,2,3], dtype=jnp.int16).view(jnp.int8).shape\n(1, 2, 6)\n>>> jnp.zeros([1,2,4], dtype=jnp.int8).view(jnp.int16).shape\n(1, 2, 2)\nConversions involving booleans are not well-defined in all situations. With\nregards to the shape of result as explained above, booleans are treated as\nhaving a bitwidth of 8. However, when converting to a boolean array, the input\nshould only contain 0 or 1 bytes. Otherwise, results may be unpredictable or\nmay change depending on how the result is used.\nThis conversion is guaranteed and safe::\n>>> jnp.array([1, 0, 1], dtype=jnp.int8).view(jnp.bool_)\nArray([ True, False,  True], dtype=bool)\nHowever, there are no guarantees about the results of any expression involving\na view such as this: `jnp.array([1, 2, 3], dtype=jnp.int8).view(jnp.bool_)`.\nIn particular, the results may change between JAX releases and depending on\nthe platform. To safely convert such an array to a boolean array, compare it\nwith `0`::\n>>> jnp.array([1, 2, 0], dtype=jnp.int8) != 0\nArray([ True,  True, False], dtype=bool)",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "number",
      "documentation": {
        "description": "Abstract base class of all numeric scalar types.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "object_",
      "documentation": {
        "description": "Any Python object.\n:Character code: ``'O'``",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "signedinteger",
      "documentation": {
        "description": "Abstract base class of all signed integer scalar types.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_integer",
          "signature": "is_integer(...)",
          "documentation": {
            "description": "integer.is_integer() -> bool\nReturn ``True`` if the number is finite with integral value.\n.. versionadded:: 1.22",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> np.int64(-2).is_integer()\nTrue\n>>> np.uint32(5).is_integer()\nTrue"
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "single",
      "documentation": {
        "description": "A JAX scalar constructor of type float32.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "ufunc",
      "documentation": {
        "description": "Universal functions which operation element-by-element on arrays.\nJAX implementation of :class:`numpy.ufunc`.\nThis is a class for JAX-backed implementations of NumPy's ufunc APIs.\nMost users will never need to instantiate :class:`ufunc`, but rather\nwill use the pre-defined ufuncs in :mod:`jax.numpy`.\nFor constructing your own ufuncs, see :func:`jax.numpy.frompyfunc`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Universal functions are functions that apply element-wise to broadcasted\narrays, but they also come with a number of extra attributes and methods.\nAs an example, consider the function :obj:`jax.numpy.add`. The object\nacts as a function that applies addition to broadcasted arrays in an\nelement-wise manner:\n>>> x = jnp.array([1, 2, 3, 4, 5])\n>>> jnp.add(x, 1)\nArray([2, 3, 4, 5, 6], dtype=int32)\nEach :class:`ufunc` object includes a number of attributes that describe\nits behavior:\n>>> jnp.add.nin  # number of inputs\n2\n>>> jnp.add.nout  # number of outputs\n1\n>>> jnp.add.identity  # identity value, or None if no identity exists\n0\nBinary ufuncs like :obj:`jax.numpy.add` include  number of methods to\napply the function to arrays in different manners.\nThe :meth:`~ufunc.outer` method applies the function to the\npair-wise outer-product of the input array values:\n>>> jnp.add.outer(x, x)\nArray([[ 2,  3,  4,  5,  6],\n[ 3,  4,  5,  6,  7],\n[ 4,  5,  6,  7,  8],\n[ 5,  6,  7,  8,  9],\n[ 6,  7,  8,  9, 10]], dtype=int32)\nThe :meth:`ufunc.reduce` method perfoms a reduction over the array.\nFor example, :meth:`jnp.add.reduce` is equivalent to ``jnp.sum``:\n>>> jnp.add.reduce(x)\nArray(15, dtype=int32)\nThe :meth:`ufunc.accumulate` method performs a cumulative reduction\nover the array. For example, :meth:`jnp.add.accumulate` is equivalent\nto :func:`jax.numpy.cumulative_sum`:\n>>> jnp.add.accumulate(x)\nArray([ 1,  3,  6, 10, 15], dtype=int32)\nThe :meth:`ufunc.at` method applies the function at particular indices in the\narray; for ``jnp.add`` the computation is similar to :func:`jax.lax.scatter_add`:\n>>> jnp.add.at(x, 0, 100, inplace=False)\nArray([101,   2,   3,   4,   5], dtype=int32)\nAnd the :meth:`ufunc.reduceat` method performs a number of ``reduce``\noperations bewteen specified indices of an array; for ``jnp.add`` the\noperation is similar to :func:`jax.ops.segment_sum`:\n>>> jnp.add.reduceat(x, jnp.array([0, 2]))\nArray([ 3, 12], dtype=int32)\nIn this case, the first element is ``x[0:2].sum()``, and the second element\nis ``x[2:].sum()``."
      },
      "methods": [
        {
          "name": "accumulate",
          "signature": "accumulate(self, a: 'ArrayLike', axis: 'int' = 0, dtype: 'DTypeLike | None' = None, out: 'None' = None) -> 'Array'",
          "documentation": {
            "description": "Accumulate operation derived from binary ufunc.\nJAX implementation of :func:`numpy.ufunc.accumulate`.\nArgs:\na: N-dimensional array over which to accumulate.\naxis: integer axis over which accumulation will be performed (default = 0)\ndtype: optionally specify the type of the output array.\nout: Unused by JAX",
            "parameters": {},
            "returns": "An array containing the accumulated result.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "Consider the following array:\n>>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n:meth:`jax.numpy.add.accumulate` is equivalent to\n:func:`jax.numpy.cumsum` along the specified axis:\n>>> jnp.add.accumulate(x, axis=1)\nArray([[ 1,  3,  6],\n[ 4,  9, 15]], dtype=int32)\n>>> jnp.cumsum(x, axis=1)\nArray([[ 1,  3,  6],\n[ 4,  9, 15]], dtype=int32)\nSimilarly, :meth:`jax.numpy.multiply.accumulate` is equivalent to\n:func:`jax.numpy.cumprod` along the specified axis:\n>>> jnp.multiply.accumulate(x, axis=1)\nArray([[  1,   2,   6],\n[  4,  20, 120]], dtype=int32)\n>>> jnp.cumprod(x, axis=1)\nArray([[  1,   2,   6],\n[  4,  20, 120]], dtype=int32)\nFor other binary ufuncs, the accumulation is an operation not available\nvia standard APIs. For example, :meth:`jax.numpy.bitwise_or.accumulate`\nis essentially a bitwise cumulative ``any``:\n>>> jnp.bitwise_or.accumulate(x, axis=1)\nArray([[1, 3, 3],\n[4, 5, 7]], dtype=int32)"
          }
        },
        {
          "name": "at",
          "signature": "at(self, a: 'ArrayLike', indices: 'Any', b: 'ArrayLike | None' = None, /, *, inplace: 'bool' = True) -> 'Array'",
          "documentation": {
            "description": "Update elements of an array via the specified unary or binary ufunc.\nJAX implementation of :func:`numpy.ufunc.at`.\nNote:\n:meth:`numpy.ufunc.at` mutates arrays in-place. JAX arrays are immutable,\nso :meth:`jax.numpy.ufunc.at` cannot replicate these semantics. Instead, JAX\nwill return the updated value, but requires explicitly passing ``inplace=False``\nas a reminder of this difference.\nArgs:\na: N-dimensional array to update\nindices: index, slice, or tuple of indices and slices.\nb: array of values for binary ufunc updates.\ninplace: must be set to False to indicate that an updated copy will be returned.",
            "parameters": {},
            "returns": "an updated copy of the input array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "Add numbers to specified indices:\n>>> x = jnp.ones(10, dtype=int)\n>>> indices = jnp.array([2, 5, 7])\n>>> values = jnp.array([10, 20, 30])\n>>> jnp.add.at(x, indices, values, inplace=False)\nArray([ 1,  1, 11,  1,  1, 21,  1, 31,  1,  1], dtype=int32)\nThis is roughly equivalent to JAX's :meth:`jax.numpy.ndarray.at` method\ncalled this way:\n>>> x.at[indices].add(values)\nArray([ 1,  1, 11,  1,  1, 21,  1, 31,  1,  1], dtype=int32)"
          }
        },
        {
          "name": "outer",
          "signature": "outer(self, A: 'ArrayLike', B: 'ArrayLike', /) -> 'Array'",
          "documentation": {
            "description": "Apply the function to all pairs of values in ``A`` and ``B``.\nJAX implementation of :meth:`numpy.ufunc.outer`.\nArgs:\nA: N-dimensional array\nB: N-dimensional array",
            "parameters": {},
            "returns": "An array of shape `tuple(*A.shape, *B.shape)`",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "A times-table for integers 1...10 created via\n:meth:`jax.numpy.multiply.outer`:\n>>> x = jnp.arange(1, 11)\n>>> print(jnp.multiply.outer(x, x))\n[[  1   2   3   4   5   6   7   8   9  10]\n[  2   4   6   8  10  12  14  16  18  20]\n[  3   6   9  12  15  18  21  24  27  30]\n[  4   8  12  16  20  24  28  32  36  40]\n[  5  10  15  20  25  30  35  40  45  50]\n[  6  12  18  24  30  36  42  48  54  60]\n[  7  14  21  28  35  42  49  56  63  70]\n[  8  16  24  32  40  48  56  64  72  80]\n[  9  18  27  36  45  54  63  72  81  90]\n[ 10  20  30  40  50  60  70  80  90 100]]\nFor input arrays with ``N`` and ``M`` dimensions respectively, the output\nwill have dimesion ``N + M``:\n>>> x = jnp.ones((1, 3, 5))\n>>> y = jnp.ones((2, 4))\n>>> jnp.add.outer(x, y).shape\n(1, 3, 5, 2, 4)"
          }
        },
        {
          "name": "reduce",
          "signature": "reduce(self, a: 'ArrayLike', axis: 'int' = 0, dtype: 'DTypeLike | None' = None, out: 'None' = None, keepdims: 'bool' = False, initial: 'ArrayLike | None' = None, where: 'ArrayLike | None' = None) -> 'Array'",
          "documentation": {
            "description": "Reduction operation derived from a binary function.\nJAX implementation of :meth:`numpy.ufunc.reduce`.\nArgs:\na: Input array.\naxis: integer specifying the axis over which to reduce. default=0\ndtype: optionally specify the type of the output array.\nout: Unused by JAX\nkeepdims: If True, reduced axes are left in the result with size 1.\nIf False (default) then reduced axes are squeezed out.\ninitial: int or array, Default=None. Initial value for the reduction.\nwhere: boolean mask, default=None. The elements to be used in the sum. Array\nshould be broadcast compatible to the input.",
            "parameters": {},
            "returns": "array containing the result of the reduction operation.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "Consider the following array:\n>>> x = jnp.array([[1, 2, 3],\n...                [4, 5, 6]])\n:meth:`jax.numpy.add.reduce` is equivalent to :func:`jax.numpy.sum`\nalong ``axis=0``:\n>>> jnp.add.reduce(x)\nArray([5, 7, 9], dtype=int32)\n>>> x.sum(0)\nArray([5, 7, 9], dtype=int32)\nSimilarly, :meth:`jax.numpy.logical_and.reduce` is equivalent to\n:func:`jax.numpy.all`:\n>>> jnp.logical_and.reduce(x > 2)\nArray([False, False,  True], dtype=bool)\n>>> jnp.all(x > 2, axis=0)\nArray([False, False,  True], dtype=bool)\nSome reductions do not correspond to any built-in aggregation function;\nfor example here is the reduction of :func:`jax.numpy.bitwise_or` along\nthe first axis of ``x``:\n>>> jnp.bitwise_or.reduce(x, axis=1)\nArray([3, 7], dtype=int32)"
          }
        },
        {
          "name": "reduceat",
          "signature": "reduceat(self, a: 'ArrayLike', indices: 'Any', axis: 'int' = 0, dtype: 'DTypeLike | None' = None, out: 'None' = None) -> 'Array'",
          "documentation": {
            "description": "Reduce an array between specified indices via a binary ufunc.\nJAX implementation of :meth:`numpy.ufunc.reduceat`\nArgs:\na: N-dimensional array to reduce\nindices: a 1-dimensional array of increasing integer values which encodes\nsegments of the array to be reduced.\naxis: integer specifying the axis along which to reduce: default=0.\ndtype: optionally specify the dtype of the output array.\nout: unused by JAX",
            "parameters": {},
            "returns": "An array containing the reduced values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "The ``reduce`` method lets you efficiently compute reduction operations\nover array segments. For example:\n>>> x = jnp.array([1, 2, 3, 4, 5, 6, 7, 8])\n>>> indices = jnp.array([0, 2, 5])\n>>> jnp.add.reduce(x, indices)\nArray([ 3, 12, 21], dtype=int32)\nThis is more-or-less equivalent to the following:\n>>> jnp.array([x[0:2].sum(), x[2:5].sum(), x[5:].sum()])\nArray([ 3, 12, 21], dtype=int32)\nFor some binary ufuncs, JAX provides similar APIs within :mod:`jax.ops`.\nFor example, :meth:`jax.add.reduceat` is similar to :func:`jax.ops.segment_sum`,\nalthough in this case the segments are defined via an array of segment ids:\n>>> segments = jnp.array([0, 0, 1, 1, 1, 2, 2, 2])\n>>> jax.ops.segment_sum(x, segments)\nArray([ 3, 12, 21], dtype=int32)"
          }
        }
      ]
    },
    {
      "name": "uint",
      "documentation": {
        "description": "A JAX scalar constructor of type uint64.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "uint16",
      "documentation": {
        "description": "A JAX scalar constructor of type uint16.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "uint2",
      "documentation": {
        "description": "A JAX scalar constructor of type uint2.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "uint32",
      "documentation": {
        "description": "A JAX scalar constructor of type uint32.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "uint4",
      "documentation": {
        "description": "A JAX scalar constructor of type uint4.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "uint64",
      "documentation": {
        "description": "A JAX scalar constructor of type uint64.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "uint8",
      "documentation": {
        "description": "A JAX scalar constructor of type uint8.\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "unsignedinteger",
      "documentation": {
        "description": "Abstract base class of all unsigned integer scalar types.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_integer",
          "signature": "is_integer(...)",
          "documentation": {
            "description": "integer.is_integer() -> bool\nReturn ``True`` if the number is finite with integral value.\n.. versionadded:: 1.22",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> np.int64(-2).is_integer()\nTrue\n>>> np.uint32(5).is_integer()\nTrue"
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    }
  ]
}