{
  "description": "Utilities for pseudo-random number generation.\n\nThe :mod:`jax.random` package provides a number of routines for deterministic\ngeneration of sequences of pseudorandom numbers.\n\nBasic usage\n-----------\n\n>>> seed = 1701\n>>> num_steps = 100\n>>> key = jax.random.key(seed)\n>>> for i in range(num_steps):\n...   key, subkey = jax.random.split(key)\n...   params = compiled_update(subkey, params, next(batches))  # doctest: +SKIP\n\nPRNG keys\n---------\n\nUnlike the *stateful* pseudorandom number generators (PRNGs) that users of NumPy and\nSciPy may be accustomed to, JAX random functions all require an explicit PRNG state to\nbe passed as a first argument.\nThe random state is described by a special array element type that we call a **key**,\nusually generated by the :py:func:`jax.random.key` function::\n\n    >>> from jax import random\n    >>> key = random.key(0)\n    >>> key\n    Array((), dtype=key<fry>) overlaying:\n    [0 0]\n\nThis key can then be used in any of JAX's random number generation routines::\n\n    >>> random.uniform(key)\n    Array(0.947667, dtype=float32)\n\nNote that using a key does not modify it, so reusing the same key will lead to the same result::\n\n    >>> random.uniform(key)\n    Array(0.947667, dtype=float32)\n\nIf you need a new random number, you can use :meth:`jax.random.split` to generate new subkeys::\n\n    >>> key, subkey = random.split(key)\n    >>> random.uniform(subkey)\n    Array(0.00729382, dtype=float32)\n\n.. note::\n\n   Typed key arrays, with element types such as ``key<fry>`` above,\n   were introduced in JAX v0.4.16. Before then, keys were\n   conventionally represented in ``uint32`` arrays, whose final\n   dimension represented the key's bit-level representation.\n\n   Both forms of key array can still be created and used with the\n   :mod:`jax.random` module. New-style typed key arrays are made with\n   :py:func:`jax.random.key`. Legacy ``uint32`` key arrays are made\n   with :py:func:`jax.random.PRNGKey`.\n\n   To convert between the two, use :py:func:`jax.random.key_data` and\n   :py:func:`jax.random.wrap_key_data`. The legacy key format may be\n   needed when interfacing with systems outside of JAX (e.g. exporting\n   arrays to a serializable format), or when passing keys to JAX-based\n   libraries that assume the legacy format.\n\n   Otherwise, typed keys are recommended. Caveats of legacy keys\n   relative to typed ones include:\n\n   * They have an extra trailing dimension.\n\n   * They have a numeric dtype (``uint32``), allowing for operations\n     that are typically not meant to be carried out over keys, such as\n     integer arithmetic.\n\n   * They do not carry information about the RNG implementation. When\n     legacy keys are passed to :mod:`jax.random` functions, a global\n     configuration setting determines the RNG implementation (see\n     \"Advanced RNG configuration\" below).\n\n   To learn more about this upgrade, and the design of key types, see\n   `JEP 9263\n   <https://jax.readthedocs.io/en/latest/jep/9263-typed-keys.html>`_.\n\nAdvanced\n--------\n\nDesign and background\n=====================\n\n**TLDR**: JAX PRNG = `Threefry counter PRNG <http://www.thesalmons.org/john/random123/papers/random123sc11.pdf>`_\n+ a functional array-oriented `splitting model <https://dl.acm.org/citation.cfm?id=2503784>`_\n\nSee `docs/jep/263-prng.md <https://github.com/jax-ml/jax/blob/main/docs/jep/263-prng.md>`_\nfor more details.\n\nTo summarize, among other requirements, the JAX PRNG aims to:\n\n1.  ensure reproducibility,\n2.  parallelize well, both in terms of vectorization (generating array values)\n    and multi-replica, multi-core computation. In particular it should not use\n    sequencing constraints between random function calls.\n\nAdvanced RNG configuration\n==========================\n\nJAX provides several PRNG implementations. A specific one can be\nselected with the optional ``impl`` keyword argument to\n``jax.random.key``. When no ``impl`` option is passed to the ``key``\nconstructor, the implementation is determined by the global\n``jax_default_prng_impl`` configuration flag. The string names of\navailable implementations are:\n\n-   ``\"threefry2x32\"`` (**default**):\n    A counter-based PRNG based on a variant of the Threefry hash function,\n    as described in `this paper by Salmon et al., 2011\n    <http://www.thesalmons.org/john/random123/papers/random123sc11.pdf>`_.\n\n-   ``\"rbg\"`` and ``\"unsafe_rbg\"`` (**experimental**): PRNGs built atop\n    `XLA's Random Bit Generator (RBG) algorithm\n    <https://openxla.org/xla/operation_semantics#rngbitgenerator>`_.\n\n    - ``\"rbg\"`` uses XLA RBG for random number generation, whereas for\n      key derivation (as in ``jax.random.split`` and\n      ``jax.random.fold_in``) it uses the same method as\n      ``\"threefry2x32\"``.\n\n    - ``\"unsafe_rbg\"`` uses XLA RBG for both generation as well as key\n      derivation.\n\n    Random numbers generated by these experimental schemes have not\n    been subject to empirical randomness testing (e.g. BigCrush).\n\n    Key derivation in ``\"unsafe_rbg\"`` has also not been empirically\n    tested. The name emphasizes \"unsafe\" because key derivation\n    quality and generation quality are not well understood.\n\n    Additionally, both ``\"rbg\"`` and ``\"unsafe_rbg\"`` behave unusually\n    under ``jax.vmap``. When vmapping a random function over a batch\n    of keys, its output values can differ from its true map over the\n    same keys. Instead, under ``vmap``, the entire batch of output\n    random numbers is generated from only the first key in the input\n    key batch. For example, if ``keys`` is a vector of 8 keys, then\n    ``jax.vmap(jax.random.normal)(keys)`` equals\n    ``jax.random.normal(keys[0], shape=(8,))``. This peculiarity\n    reflects a workaround to XLA RBG's limited batching support.\n\nReasons to use an alternative to the default RNG include that:\n\n1. It may be slow to compile for TPUs.\n2. It is relatively slower to execute on TPUs.\n\n**Automatic partitioning:**\n\nIn order for ``jax.jit`` to efficiently auto-partition functions that\ngenerate sharded random number arrays (or key arrays), all PRNG\nimplementations require extra flags:\n\n- For ``\"threefry2x32\"``, and ``\"rbg\"`` key derivation, set\n  ``jax_threefry_partitionable=True``.\n- For ``\"unsafe_rbg\"``, and ``\"rbg\"`` random generation\", set the XLA\n  flag ``--xla_tpu_spmd_rng_bit_generator_unsafe=1``.\n\nThe XLA flag can be set using an the ``XLA_FLAGS`` environment\nvariable, e.g. as\n``XLA_FLAGS=--xla_tpu_spmd_rng_bit_generator_unsafe=1``.\n\nFor more about ``jax_threefry_partitionable``, see\nhttps://jax.readthedocs.io/en/latest/notebooks/Distributed_arrays_and_automatic_parallelization.html#generating-random-numbers\n\n**Summary:**\n\n.. table::\n   :widths: auto\n\n   =================================   ========  =========  ===  ==========  =====  ============\n   Property                            Threefry  Threefry*  rbg  unsafe_rbg  rbg**  unsafe_rbg**\n   =================================   ========  =========  ===  ==========  =====  ============\n   Fastest on TPU                                           ✅   ✅          ✅     ✅\n   efficiently shardable (w/ pjit)                ✅                         ✅     ✅\n   identical across shardings           ✅        ✅        ✅   ✅\n   identical across CPU/GPU/TPU         ✅        ✅\n   exact ``jax.vmap`` over keys         ✅        ✅\n   =================================   ========  =========  ===  ==========  =====  ============\n\n(*): with ``jax_threefry_partitionable=1`` set\n\n(**): with ``XLA_FLAGS=--xla_tpu_spmd_rng_bit_generator_unsafe=1`` set",
  "functions": [
    {
      "name": "PRNGKey",
      "signature": "PRNGKey(seed: 'int | ArrayLike', *, impl: 'PRNGSpecDesc | None' = None) -> 'Array'",
      "documentation": {
        "description": "Create a legacy PRNG key given an integer seed.\nThis function produces old-style legacy PRNG keys, which are arrays\nof dtype ``uint32``. For more, see the note in the `PRNG keys\n<https://jax.readthedocs.io/en/latest/jax.random.html#prng-keys>`_\nsection. When possible, :func:`jax.random.key` is recommended for\nuse instead.\nThe resulting key does not carry a PRNG implementation. The returned\nkey matches the implementation given by the optional ``impl``\nargument or, otherwise, determined by the ``jax_default_prng_impl``\nconfig flag. Callers must ensure that same implementation is set as\nthe default when passing this key as an argument to other functions\n(such as ``jax.random.split`` and ``jax.random.normal``).\nArgs:\nseed: a 64- or 32-bit integer used as the value of the key.\nimpl: optional string specifying the PRNG implementation (e.g.\n``'threefry2x32'``)",
        "parameters": {},
        "returns": "A PRNG key, consumable by random functions as well as ``split``\nand ``fold_in``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ball",
      "signature": "ball(key: 'ArrayLike', d: 'int', p: 'float' = 2, shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>)",
      "documentation": {
        "description": "Sample uniformly from the unit Lp ball.\nReference: https://arxiv.org/abs/math/0503650.\nArgs:\nkey: a PRNG key used as the random key.\nd: a nonnegative int representing the dimensionality of the ball.\np: a float representing the p parameter of the Lp norm.\nshape: optional, the batch dimensions of the result. Default ().\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array of shape `(*shape, d)` and specified dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "bernoulli",
      "signature": "bernoulli(key: 'ArrayLike', p: 'RealArray' = 0.5, shape: 'Shape | None' = None) -> 'Array'",
      "documentation": {
        "description": "Sample Bernoulli random values with given shape and mean.\nThe values are distributed according to the probability mass function:\n.. math::\nf(k; p) = p^k(1 - p)^{1 - k}\nwhere :math:`k \\in \\{0, 1\\}` and :math:`0 \\le p \\le 1`.\nArgs:\nkey: a PRNG key used as the random key.\np: optional, a float or array of floats for the mean of the random\nvariables. Must be broadcast-compatible with ``shape``. Default 0.5.\nshape: optional, a tuple of nonnegative integers representing the result\nshape. Must be broadcast-compatible with ``p.shape``. The default (None)\nproduces a result shape equal to ``p.shape``.",
        "parameters": {},
        "returns": "A random array with boolean dtype and shape given by ``shape`` if ``shape``\nis not None, or else ``p.shape``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "beta",
      "signature": "beta(key: 'ArrayLike', a: 'RealArray', b: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample Beta random values with given shape and float dtype.\nThe values are distributed according to the probability density function:\n.. math::\nf(x;a,b) \\propto x^{a - 1}(1 - x)^{b - 1}\non the domain :math:`0 \\le x \\le 1`.\nArgs:\nkey: a PRNG key used as the random key.\na: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the first parameter \"alpha\".\nb: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the second parameter \"beta\".\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. Must be broadcast-compatible with ``a`` and ``b``. The default\n(None) produces a result shape by broadcasting ``a`` and ``b``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and shape given by ``shape`` if\n``shape`` is not None, or else by broadcasting ``a`` and ``b``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "binomial",
      "signature": "binomial(key: 'Array', n: 'RealArray', p: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample Binomial random values with given shape and float dtype.\nThe values are returned according to the probability mass function:\n.. math::\nf(k;n,p) = \\binom{n}{k}p^k(1-p)^{n-k}\non the domain :math:`0 < p < 1`, and where :math:`n` is a nonnegative integer\nrepresenting the number of trials and :math:`p` is a float representing the\nprobability of success of an individual trial.\nArgs:\nkey: a PRNG key used as the random key.\nn: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the number of trials.\np: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the probability of success of an individual trial.\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. Must be broadcast-compatible with ``n`` and ``p``.\nThe default (None) produces a result shape equal to ``np.broadcast(n, p).shape``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and with shape given by\n``np.broadcast(n, p).shape``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "bits",
      "signature": "bits(key: 'ArrayLike', shape: 'Shape' = (), dtype: 'DTypeLikeUInt | None' = None) -> 'Array'",
      "documentation": {
        "description": "Sample uniform bits in the form of unsigned integers.\nArgs:\nkey: a PRNG key used as the random key.\nshape: optional, a tuple of nonnegative integers representing the result\nshape. Default ``()``.\ndtype: optional, an unsigned integer dtype for the returned values (default\n``uint64`` if ``jax_enable_x64`` is true, otherwise ``uint32``).",
        "parameters": {},
        "returns": "A random array with the specified shape and dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "categorical",
      "signature": "categorical(key: 'ArrayLike', logits: 'RealArray', axis: 'int' = -1, shape: 'Shape | None' = None, replace: 'bool' = True) -> 'Array'",
      "documentation": {
        "description": "Sample random values from categorical distributions.\nSampling with replacement uses the Gumbel max trick. Sampling without replacement uses\nthe Gumbel top-k trick. See [1] for reference.\nArgs:\nkey: a PRNG key used as the random key.\nlogits: Unnormalized log probabilities of the categorical distribution(s) to sample from,\nso that `softmax(logits, axis)` gives the corresponding probabilities.\naxis: Axis along which logits belong to the same categorical distribution.\nshape: Optional, a tuple of nonnegative integers representing the result shape.\nMust be broadcast-compatible with ``np.delete(logits.shape, axis)``.\nThe default (None) produces a result shape equal to ``np.delete(logits.shape, axis)``.\nreplace: If True, perform sampling without replacement. Default (False) is to\nperform sampling with replacement.",
        "parameters": {},
        "returns": "A random array with int dtype and shape given by ``shape`` if ``shape``\nis not None, or else ``np.delete(logits.shape, axis)``.\nReferences:\n.. [1] Wouter Kool, Herke van Hoof, Max Welling. \"Stochastic Beams and Where to Find\nThem: The Gumbel-Top-k Trick for Sampling Sequences Without Replacement\".\nProceedings of the 36th International Conference on Machine Learning, PMLR\n97:3499-3508, 2019. https://proceedings.mlr.press/v97/kool19a.html.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cauchy",
      "signature": "cauchy(key: 'ArrayLike', shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample Cauchy random values with given shape and float dtype.\nThe values are distributed according to the probability density function:\n.. math::\nf(x) \\propto \\frac{1}{x^2 + 1}\non the domain :math:`-\\infty < x < \\infty`\nArgs:\nkey: a PRNG key used as the random key.\nshape: optional, a tuple of nonnegative integers representing the result\nshape. Default ().\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified shape and dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "chisquare",
      "signature": "chisquare(key: 'ArrayLike', df: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample Chisquare random values with given shape and float dtype.\nThe values are distributed according to the probability density function:\n.. math::\nf(x; \\nu) \\propto x^{\\nu/2 - 1}e^{-x/2}\non the domain :math:`0 < x < \\infty`, where :math:`\\nu > 0` represents the\ndegrees of freedom, given by the parameter ``df``.\nArgs:\nkey: a PRNG key used as the random key.\ndf: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the parameter of the distribution.\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. Must be broadcast-compatible with ``df``. The default (None)\nproduces a result shape equal to ``df.shape``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and with shape given by ``shape`` if\n``shape`` is not None, or else by ``df.shape``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "choice",
      "signature": "choice(key: 'ArrayLike', a: 'int | ArrayLike', shape: 'Shape' = (), replace: 'bool' = True, p: 'RealArray | None' = None, axis: 'int' = 0) -> 'Array'",
      "documentation": {
        "description": "Generates a random sample from a given array.\n.. warning::\nIf ``p`` has fewer non-zero elements than the requested number of samples,\nas specified in ``shape``, and ``replace=False``, the output of this\nfunction is ill-defined. Please make sure to use appropriate inputs.\nArgs:\nkey: a PRNG key used as the random key.\na : array or int. If an ndarray, a random sample is generated from\nits elements. If an int, the random sample is generated as if a were\narange(a).\nshape : tuple of ints, optional. Output shape.  If the given shape is,\ne.g., ``(m, n)``, then ``m * n`` samples are drawn.  Default is (),\nin which case a single value is returned.\nreplace : boolean.  Whether the sample is with or without replacement.\nDefault is True.\np : 1-D array-like, The probabilities associated with each entry in a.\nIf not given the sample assumes a uniform distribution over all\nentries in a.\naxis: int, optional. The axis along which the selection is performed.\nThe default, 0, selects by row.",
        "parameters": {},
        "returns": "An array of shape `shape` containing samples from `a`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "clone",
      "signature": "clone(key)",
      "documentation": {
        "description": "Clone a key for reuse\nOutside the context of key reuse checking (see :mod:`jax.experimental.key_reuse`)\nthis function operates as an identity.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import jax\n>>> key = jax.random.key(0)\n>>> data = jax.random.uniform(key)\n>>> cloned_key = jax.random.clone(key)\n>>> same_data = jax.random.uniform(cloned_key)\n>>> assert data == same_data"
      }
    },
    {
      "name": "dirichlet",
      "signature": "dirichlet(key: 'ArrayLike', alpha: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample Dirichlet random values with given shape and float dtype.\nThe values are distributed according to the probability density function:\n.. math::\nf(\\{x_i\\}; \\{\\alpha_i\\}) \\propto \\prod_{i=1}^k x_i^{\\alpha_i - 1}\nWhere :math:`k` is the dimension, and :math:`\\{x_i\\}` satisfies\n.. math::\n\\sum_{i=1}^k x_i = 1\nand :math:`0 \\le x_i \\le 1` for all :math:`x_i`.\nArgs:\nkey: a PRNG key used as the random key.\nalpha: an array of shape ``(..., n)`` used as the concentration\nparameter of the random variables.\nshape: optional, a tuple of nonnegative integers specifying the result\nbatch shape; that is, the prefix of the result shape excluding the last\nelement of value ``n``. Must be broadcast-compatible with\n``alpha.shape[:-1]``. The default (None) produces a result shape equal to\n``alpha.shape``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and shape given by\n``shape + (alpha.shape[-1],)`` if ``shape`` is not None, or else\n``alpha.shape``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "double_sided_maxwell",
      "signature": "double_sided_maxwell(key: 'ArrayLike', loc: 'RealArray', scale: 'RealArray', shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample from a double sided Maxwell distribution.\nThe values are distributed according to the probability density function:\n.. math::\nf(x;\\mu,\\sigma) \\propto z^2 e^{-z^2 / 2}\nwhere :math:`z = (x - \\mu) / \\sigma`, with the center :math:`\\mu` specified by\n``loc`` and the scale :math:`\\sigma` specified by ``scale``.\nArgs:\nkey: a PRNG key.\nloc: The location parameter of the distribution.\nscale: The scale parameter of the distribution.\nshape: The shape added to the parameters loc and scale broadcastable shape.\ndtype: The type used for samples.",
        "parameters": {},
        "returns": "A jnp.array of samples.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "exponential",
      "signature": "exponential(key: 'ArrayLike', shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample Exponential random values with given shape and float dtype.\nThe values are distributed according to the probability density function:\n.. math::\nf(x) = e^{-x}\non the domain :math:`0 \\le x < \\infty`.\nArgs:\nkey: a PRNG key used as the random key.\nshape: optional, a tuple of nonnegative integers representing the result\nshape. Default ().\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified shape and dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "f",
      "signature": "f(key: 'ArrayLike', dfnum: 'RealArray', dfden: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample F-distribution random values with given shape and float dtype.\nThe values are distributed according to the probability density function:\n.. math::\nf(x; \\nu_1, \\nu_2) \\propto x^{\\nu_1/2 - 1}\\left(1 + \\frac{\\nu_1}{\\nu_2}x\\right)^{\n-(\\nu_1 + \\nu_2) / 2}\non the domain :math:`0 < x < \\infty`. Here :math:`\\nu_1` is the degrees of\nfreedom of the numerator (``dfnum``), and :math:`\\nu_2` is the degrees of\nfreedom of the denominator (``dfden``).\nArgs:\nkey: a PRNG key used as the random key.\ndfnum: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the numerator's ``df`` of the distribution.\ndfden: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the denominator's ``df`` of the distribution.\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. Must be broadcast-compatible with ``dfnum`` and ``dfden``.\nThe default (None) produces a result shape equal to ``dfnum.shape``,\nand ``dfden.shape``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and with shape given by ``shape`` if\n``shape`` is not None, or else by ``df.shape``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fold_in",
      "signature": "fold_in(key: 'ArrayLike', data: 'IntegerArray') -> 'Array'",
      "documentation": {
        "description": "Folds in data to a PRNG key to form a new PRNG key.\nArgs:\nkey: a PRNG key (from ``key``, ``split``, ``fold_in``).\ndata: a 32-bit integer representing data to be folded into the key.",
        "parameters": {},
        "returns": "A new PRNG key that is a deterministic function of the inputs and is\nstatistically safe for producing a stream of new pseudo-random values.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "gamma",
      "signature": "gamma(key: 'ArrayLike', a: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample Gamma random values with given shape and float dtype.\nThe values are distributed according to the probability density function:\n.. math::\nf(x;a) \\propto x^{a - 1} e^{-x}\non the domain :math:`0 \\le x < \\infty`, with :math:`a > 0`.\nThis is the standard gamma density, with a unit scale/rate parameter.\nDividing the sample output by the rate is equivalent to sampling from\n*gamma(a, rate)*, and multiplying the sample output by the scale is equivalent\nto sampling from *gamma(a, scale)*.\nArgs:\nkey: a PRNG key used as the random key.\na: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the parameter of the distribution.\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. Must be broadcast-compatible with ``a``. The default (None)\nproduces a result shape equal to ``a.shape``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and with shape given by ``shape`` if\n``shape`` is not None, or else by ``a.shape``.",
        "raises": "",
        "see_also": "loggamma : sample gamma values in log-space, which can provide improved\naccuracy for small values of ``a``.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "generalized_normal",
      "signature": "generalized_normal(key: 'ArrayLike', p: 'float', shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample from the generalized normal distribution.\nThe values are returned according to the probability density function:\n.. math::\nf(x;p) \\propto e^{-|x|^p}\non the domain :math:`-\\infty < x < \\infty`, where :math:`p > 0` is the\nshape parameter.\nArgs:\nkey: a PRNG key used as the random key.\np: a float representing the shape parameter.\nshape: optional, the batch dimensions of the result. Default ().\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified shape and dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "geometric",
      "signature": "geometric(key: 'ArrayLike', p: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeInt' = <class 'int'>) -> 'Array'",
      "documentation": {
        "description": "Sample Geometric random values with given shape and float dtype.\nThe values are returned according to the probability mass function:\n.. math::\nf(k;p) = p(1-p)^{k-1}\non the domain :math:`0 < p < 1`.\nArgs:\nkey: a PRNG key used as the random key.\np: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the probability of success of an individual trial.\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. Must be broadcast-compatible with ``p``. The default\n(None) produces a result shape equal to ``np.shape(p)``.\ndtype: optional, a int dtype for the returned values (default int64 if\njax_enable_x64 is true, otherwise int32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and with shape given by ``shape`` if\n``shape`` is not None, or else by ``p.shape``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "gumbel",
      "signature": "gumbel(key: 'ArrayLike', shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>, mode: 'str | None' = None) -> 'Array'",
      "documentation": {
        "description": "Sample Gumbel random values with given shape and float dtype.\nThe values are distributed according to the probability density function:\n.. math::\nf(x) = e^{-(x + e^{-x})}\nArgs:\nkey: a PRNG key used as the random key.\nshape: optional, a tuple of nonnegative integers representing the result\nshape. Default ().\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).\nmode: optional, \"high\" or \"low\" for how many bits to use when sampling.",
        "parameters": {},
        "returns": "A random array with the specified shape and dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "key",
      "signature": "key(seed: 'int | ArrayLike', *, impl: 'PRNGSpecDesc | None' = None) -> 'Array'",
      "documentation": {
        "description": "Create a pseudo-random number generator (PRNG) key given an integer seed.\nThe result is a scalar array containing a key, whose dtype indicates\nthe default PRNG implementation, as determined by the optional\n``impl`` argument or, otherwise, by the ``jax_default_prng_impl``\nconfig flag at the time when this function is called.\nArgs:\nseed: a 64- or 32-bit integer used as the value of the key.\nimpl: optional string specifying the PRNG implementation (e.g.\n``'threefry2x32'``)",
        "parameters": {},
        "returns": "A scalar PRNG key array, consumable by random functions as well as ``split``\nand ``fold_in``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "key_data",
      "signature": "key_data(keys: 'ArrayLike') -> 'Array'",
      "documentation": {
        "description": "Recover the bits of key data underlying a PRNG key array.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "key_impl",
      "signature": "key_impl(keys: 'ArrayLike') -> 'str | PRNGSpec'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "laplace",
      "signature": "laplace(key: 'ArrayLike', shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample Laplace random values with given shape and float dtype.\nThe values are distributed according to the probability density function:\n.. math::\nf(x) = \\frac{1}{2}e^{-|x|}\nArgs:\nkey: a PRNG key used as the random key.\nshape: optional, a tuple of nonnegative integers representing the result\nshape. Default ().\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified shape and dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "loggamma",
      "signature": "loggamma(key: 'ArrayLike', a: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample log-gamma random values with given shape and float dtype.\nThis function is implemented such that the following will hold for a\ndtype-appropriate tolerance::\nnp.testing.assert_allclose(jnp.exp(loggamma(*args)), gamma(*args), rtol=rtol)\nThe benefit of log-gamma is that for samples very close to zero (which occur frequently\nwhen `a << 1`) sampling in log space provides better precision.\nArgs:\nkey: a PRNG key used as the random key.\na: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the parameter of the distribution.\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. Must be broadcast-compatible with ``a``. The default (None)\nproduces a result shape equal to ``a.shape``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and with shape given by ``shape`` if\n``shape`` is not None, or else by ``a.shape``.",
        "raises": "",
        "see_also": "gamma : standard gamma sampler.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "logistic",
      "signature": "logistic(key: 'ArrayLike', shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample logistic random values with given shape and float dtype.\nThe values are distributed according to the probability density function:\n.. math::\nf(x) = \\frac{e^{-x}}{(1 + e^{-x})^2}\nArgs:\nkey: a PRNG key used as the random key.\nshape: optional, a tuple of nonnegative integers representing the result\nshape. Default ().\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified shape and dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "lognormal",
      "signature": "lognormal(key: 'ArrayLike', sigma: 'RealArray' = 1.0, shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample lognormal random values with given shape and float dtype.\nThe values are distributed according to the probability density function:\n.. math::\nf(x) = \\frac{1}{x\\sqrt{2\\pi\\sigma^2}}\\exp\\left(-\\frac{(\\log x)^2}{2\\sigma^2}\\right)\non the domain :math:`x > 0`.\nArgs:\nkey: a PRNG key used as the random key.\nsigma: a float or array of floats broadcast-compatible with ``shape`` representing\nthe standard deviation of the underlying normal distribution. Default 1.\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. The default (None) produces a result shape equal to ``()``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and with shape given by ``shape``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "maxwell",
      "signature": "maxwell(key: 'ArrayLike', shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample from a one sided Maxwell distribution.\nThe values are distributed according to the probability density function:\n.. math::\nf(x) \\propto x^2 e^{-x^2 / 2}\non the domain :math:`0 \\le x < \\infty`.\nArgs:\nkey: a PRNG key.\nshape: The shape of the returned samples.\ndtype: The type used for samples.",
        "parameters": {},
        "returns": "A jnp.array of samples, of shape `shape`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "multinomial",
      "signature": "multinomial(key: 'Array', n: 'RealArray', p: 'RealArray', *, shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>, unroll: 'int | bool' = 1)",
      "documentation": {
        "description": "Sample from a multinomial distribution.\nThe probability mass function is\n.. math::\nf(x;n,p) = \\frac{n!}{x_1! \\ldots x_k!} p_1^{x_1} \\ldots p_k^{x_k}\nArgs:\nkey: PRNG key.\nn: number of trials. Should have shape broadcastable to ``p.shape[:-1]``.\np: probability of each outcome, with outcomes along the last axis.\nshape: optional, a tuple of nonnegative integers specifying the result batch\nshape, that is, the prefix of the result shape excluding the last axis.\nMust be broadcast-compatible with ``p.shape[:-1]``. The default (None)\nproduces a result shape equal to ``p.shape``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).\nunroll: optional, unroll parameter passed to :func:`jax.lax.scan` inside the\nimplementation of this function.",
        "parameters": {},
        "returns": "An array of counts for each outcome with the specified dtype and with shape\n``p.shape`` if ``shape`` is None, otherwise ``shape + (p.shape[-1],)``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "multivariate_normal",
      "signature": "multivariate_normal(key: 'ArrayLike', mean: 'RealArray', cov: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat | None' = None, method: 'str' = 'cholesky') -> 'Array'",
      "documentation": {
        "description": "Sample multivariate normal random values with given mean and covariance.\nThe values are returned according to the probability density function:\n.. math::\nf(x;\\mu, \\Sigma) = (2\\pi)^{-k/2} \\det(\\Sigma)^{-1}e^{-\\frac{1}{2}(x - \\mu)^T \\Sigma^{-1} (x - \\mu)}\nwhere :math:`k` is the dimension, :math:`\\mu` is the mean (given by ``mean``) and\n:math:`\\Sigma` is the covariance matrix (given by ``cov``).\nArgs:\nkey: a PRNG key used as the random key.\nmean: a mean vector of shape ``(..., n)``.\ncov: a positive definite covariance matrix of shape ``(..., n, n)``. The\nbatch shape ``...`` must be broadcast-compatible with that of ``mean``.\nshape: optional, a tuple of nonnegative integers specifying the result\nbatch shape; that is, the prefix of the result shape excluding the last\naxis. Must be broadcast-compatible with ``mean.shape[:-1]`` and\n``cov.shape[:-2]``. The default (None) produces a result batch shape by\nbroadcasting together the batch shapes of ``mean`` and ``cov``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).\nmethod: optional, a method to compute the factor of ``cov``.\nMust be one of 'svd', 'eigh', and 'cholesky'. Default 'cholesky'. For\nsingular covariance matrices, use 'svd' or 'eigh'.",
        "parameters": {},
        "returns": "A random array with the specified dtype and shape given by\n``shape + mean.shape[-1:]`` if ``shape`` is not None, or else\n``broadcast_shapes(mean.shape[:-1], cov.shape[:-2]) + mean.shape[-1:]``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "normal",
      "signature": "normal(key: 'ArrayLike', shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample standard normal random values with given shape and float dtype.\nThe values are returned according to the probability density function:\n.. math::\nf(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}\non the domain :math:`-\\infty < x < \\infty`\nArgs:\nkey: a PRNG key used as the random key.\nshape: optional, a tuple of nonnegative integers representing the result\nshape. Default ().\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified shape and dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "orthogonal",
      "signature": "orthogonal(key: 'ArrayLike', n: 'int', shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>, m: 'int | None' = None) -> 'Array'",
      "documentation": {
        "description": "Sample uniformly from the orthogonal group O(n).\nIf the dtype is complex, sample uniformly from the unitary group U(n).\nFor unequal rows and columns, this samples a semi-orthogonal matrix instead.\nThat is, if :math:`A` is the resulting matrix and :math:`A^*` is its conjugate\ntranspose, then:\n- If :math:`n \\leq m`, the rows are mutually orthonormal: :math:`A A^* = I_n`.\n- If :math:`m \\leq n`, the columns are mutually orthonormal: :math:`A^* A = I_m`.\nArgs:\nkey: a PRNG key used as the random key.\nn: an integer indicating the number of rows.\nshape: optional, the batch dimensions of the result. Default ().\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).\nm: an integer indicating the number of columns. Defaults to `n`.",
        "parameters": {},
        "returns": "A random array of shape `(*shape, n, n)` and specified dtype.\nReferences:\n.. [1] Mezzadri, Francesco. (2007). \"How to generate random matrices from\nthe classical compact groups\". Notices of the American Mathematical\nSociety, 54(5), 592-604. https://arxiv.org/abs/math-ph/0609050.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "pareto",
      "signature": "pareto(key: 'ArrayLike', b: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample Pareto random values with given shape and float dtype.\nThe values are distributed according to the probability density function:\n.. math::\nf(x; b) = b / x^{b + 1}\non the domain :math:`1 \\le x < \\infty` with :math:`b > 0`\nArgs:\nkey: a PRNG key used as the random key.\nb: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the parameter of the distribution.\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. Must be broadcast-compatible with ``b``. The default (None)\nproduces a result shape equal to ``b.shape``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and with shape given by ``shape`` if\n``shape`` is not None, or else by ``b.shape``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "permutation",
      "signature": "permutation(key: 'ArrayLike', x: 'int | ArrayLike', axis: 'int' = 0, independent: 'bool' = False) -> 'Array'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "Args:\nkey: a PRNG key used as the random key.\nx: int or array. If x is an integer, randomly shuffle np.arange(x).\nIf x is an array, randomly shuffle its elements.\naxis: int, optional. The axis which x is shuffled along. Default is 0.\nindependent: bool, optional. If set to True, each individual vector along\nthe given axis is shuffled independently. Default is False.\nA shuffled version of x or array range",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "poisson",
      "signature": "poisson(key: 'ArrayLike', lam: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeInt' = <class 'int'>) -> 'Array'",
      "documentation": {
        "description": "Sample Poisson random values with given shape and integer dtype.\nThe values are distributed according to the probability mass function:\n.. math::\nf(k; \\lambda) = \\frac{\\lambda^k e^{-\\lambda}}{k!}\nWhere `k` is a non-negative integer and :math:`\\lambda > 0`.\nArgs:\nkey: a PRNG key used as the random key.\nlam: rate parameter (mean of the distribution), must be >= 0. Must be broadcast-compatible with ``shape``\nshape: optional, a tuple of nonnegative integers representing the result\nshape. Default (None) produces a result shape equal to ``lam.shape``.\ndtype: optional, a integer dtype for the returned values (default int64 if\njax_enable_x64 is true, otherwise int32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and with shape given by ``shape`` if\n``shape is not None, or else by ``lam.shape``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "rademacher",
      "signature": "rademacher(key: 'ArrayLike', shape: 'Shape' = (), dtype: 'DTypeLikeInt' = <class 'int'>) -> 'Array'",
      "documentation": {
        "description": "Sample from a Rademacher distribution.\nThe values are distributed according to the probability mass function:\n.. math::\nf(k) = \\frac{1}{2}(\\delta(k - 1) + \\delta(k + 1))\non the domain :math:`k \\in \\{-1, 1\\}`, where :math:`\\delta(x)` is the dirac delta function.\nArgs:\nkey: a PRNG key.\nshape: The shape of the returned samples. Default ().\ndtype: The type used for samples.",
        "parameters": {},
        "returns": "A jnp.array of samples, of shape `shape`. Each element in the output has\na 50% change of being 1 or -1.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "randint",
      "signature": "randint(key: 'ArrayLike', shape: 'Shape', minval: 'IntegerArray', maxval: 'IntegerArray', dtype: 'DTypeLikeInt' = <class 'int'>) -> 'Array'",
      "documentation": {
        "description": "Sample uniform random values in [minval, maxval) with given shape/dtype.\nArgs:\nkey: a PRNG key used as the random key.\nshape: a tuple of nonnegative integers representing the shape.\nminval: int or array of ints broadcast-compatible with ``shape``, a minimum\n(inclusive) value for the range.\nmaxval: int or array of ints broadcast-compatible with ``shape``, a maximum\n(exclusive) value for the range.\ndtype: optional, an int dtype for the returned values (default int64 if\njax_enable_x64 is true, otherwise int32).",
        "parameters": {},
        "returns": "A random array with the specified shape and dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "rayleigh",
      "signature": "rayleigh(key: 'ArrayLike', scale: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample Rayleigh random values with given shape and float dtype.\nThe values are returned according to the probability density function:\n.. math::\nf(x;\\sigma) \\propto xe^{-x^2/(2\\sigma^2)}\non the domain :math:`-\\infty < x < \\infty`, and where :math:`\\sigma > 0` is the scale\nparameter of the distribution.\nArgs:\nkey: a PRNG key used as the random key.\nscale: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the parameter of the distribution.\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. Must be broadcast-compatible with ``scale``. The default (None)\nproduces a result shape equal to ``scale.shape``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and with shape given by ``shape`` if\n``shape`` is not None, or else by ``scale.shape``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "split",
      "signature": "split(key: 'ArrayLike', num: 'int | tuple[int, ...]' = 2) -> 'Array'",
      "documentation": {
        "description": "Splits a PRNG key into `num` new keys by adding a leading axis.\nArgs:\nkey: a PRNG key (from ``key``, ``split``, ``fold_in``).\nnum: optional, a positive integer (or tuple of integers) indicating\nthe number (or shape) of keys to produce. Defaults to 2.",
        "parameters": {},
        "returns": "An array-like object of `num` new PRNG keys.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "t",
      "signature": "t(key: 'ArrayLike', df: 'RealArray', shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample Student's t random values with given shape and float dtype.\nThe values are distributed according to the probability density function:\n.. math::\nf(t; \\nu) \\propto \\left(1 + \\frac{t^2}{\\nu}\\right)^{-(\\nu + 1)/2}\nWhere :math:`\\nu > 0` is the degrees of freedom, given by the parameter ``df``.\nArgs:\nkey: a PRNG key used as the random key.\ndf: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the degrees of freedom parameter of the distribution.\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. Must be broadcast-compatible with ``df``. The default (None)\nproduces a result shape equal to ``df.shape``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and with shape given by ``shape`` if\n``shape`` is not None, or else by ``df.shape``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "triangular",
      "signature": "triangular(key: 'ArrayLike', left: 'RealArray', mode: 'RealArray', right: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample Triangular random values with given shape and float dtype.\nThe values are returned according to the probability density function:\n.. math::\nf(x; a, b, c) = \\frac{2}{c-a} \\left\\{ \\begin{array}{ll} \\frac{x-a}{b-a} & a \\leq x \\leq b \\\\ \\frac{c-x}{c-b} & b \\leq x \\leq c \\end{array} \\right.\non the domain :math:`a \\leq x \\leq c`.\nArgs:\nkey: a PRNG key used as the random key.\nleft: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the lower limit parameter of the distribution.\nmode: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the peak value parameter of the distribution, value must\nfulfill the condition ``left <= mode <= right``.\nright: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the upper limit parameter of the distribution, must be\nlarger than ``left``.\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. Must be broadcast-compatible with ``left``,``mode`` and ``right``.\nThe default (None) produces a result shape equal to ``left.shape``, ``mode.shape``\nand ``right.shape``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and with shape given by ``shape`` if\n``shape`` is not None, or else by ``left.shape``, ``mode.shape`` and ``right.shape``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "truncated_normal",
      "signature": "truncated_normal(key: 'ArrayLike', lower: 'RealArray', upper: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample truncated standard normal random values with given shape and dtype.\nThe values are returned according to the probability density function:\n.. math::\nf(x) \\propto e^{-x^2/2}\non the domain :math:`\\rm{lower} < x < \\rm{upper}`.\nArgs:\nkey: a PRNG key used as the random key.\nlower: a float or array of floats representing the lower bound for\ntruncation. Must be broadcast-compatible with ``upper``.\nupper: a float or array of floats representing the  upper bound for\ntruncation. Must be broadcast-compatible with ``lower``.\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. Must be broadcast-compatible with ``lower`` and ``upper``. The\ndefault (None) produces a result shape by broadcasting ``lower`` and\n``upper``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and shape given by ``shape`` if\n``shape`` is not None, or else by broadcasting ``lower`` and ``upper``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "uniform",
      "signature": "uniform(key: 'ArrayLike', shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>, minval: 'RealArray' = 0.0, maxval: 'RealArray' = 1.0) -> 'Array'",
      "documentation": {
        "description": "Sample uniform random values in [minval, maxval) with given shape/dtype.\nArgs:\nkey: a PRNG key used as the random key.\nshape: optional, a tuple of nonnegative integers representing the result\nshape. Default ().\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).\nminval: optional, a minimum (inclusive) value broadcast-compatible with shape for the range (default 0).\nmaxval: optional, a maximum (exclusive) value broadcast-compatible with shape for the range (default 1).",
        "parameters": {},
        "returns": "A random array with the specified shape and dtype.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "wald",
      "signature": "wald(key: 'ArrayLike', mean: 'RealArray', shape: 'Shape | None' = None, dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample Wald random values with given shape and float dtype.\nThe values are returned according to the probability density function:\n.. math::\nf(x;\\mu) = \\frac{1}{\\sqrt{2\\pi x^3}} \\exp\\left(-\\frac{(x - \\mu)^2}{2\\mu^2 x}\\right)\non the domain :math:`-\\infty < x < \\infty`, and where :math:`\\mu > 0` is the location\nparameter of the distribution.\nArgs:\nkey: a PRNG key used as the random key.\nmean: a float or array of floats broadcast-compatible with ``shape``\nrepresenting the mean parameter of the distribution.\nshape: optional, a tuple of nonnegative integers specifying the result\nshape. Must be broadcast-compatible with ``mean``. The default\n(None) produces a result shape equal to ``np.shape(mean)``.\ndtype: optional, a float dtype for the returned values (default float64 if\njax_enable_x64 is true, otherwise float32).",
        "parameters": {},
        "returns": "A random array with the specified dtype and with shape given by ``shape`` if\n``shape`` is not None, or else by ``mean.shape``.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "weibull_min",
      "signature": "weibull_min(key: 'ArrayLike', scale: 'RealArray', concentration: 'RealArray', shape: 'Shape' = (), dtype: 'DTypeLikeFloat' = <class 'float'>) -> 'Array'",
      "documentation": {
        "description": "Sample from a Weibull distribution.\nThe values are distributed according to the probability density function:\n.. math::\nf(x;\\sigma,c) \\propto x^{c - 1} \\exp(-(x / \\sigma)^c)\non the domain :math:`0 < x < \\infty`, where :math:`c > 0` is the concentration\nparameter, and :math:`\\sigma > 0` is the scale parameter.\nArgs:\nkey: a PRNG key.\nscale: The scale parameter of the distribution.\nconcentration: The concentration parameter of the distribution.\nshape: The shape added to the parameters loc and scale broadcastable shape.\ndtype: The type used for samples.",
        "parameters": {},
        "returns": "A jnp.array of samples.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "wrap_key_data",
      "signature": "wrap_key_data(key_bits_array: 'Array', *, impl: 'PRNGSpecDesc | None' = None)",
      "documentation": {
        "description": "Wrap an array of key data bits into a PRNG key array.\nArgs:\nkey_bits_array: a ``uint32`` array with trailing shape corresponding to\nthe key shape of the PRNG implementation specified by ``impl``.\nimpl: optional, specifies a PRNG implementation, as in ``random.key``.",
        "parameters": {},
        "returns": "A PRNG key array, whose dtype is a subdtype of ``jax.dtypes.prng_key``\ncorresponding to ``impl``, and whose shape equals the leading shape\nof ``key_bits_array.shape`` up to the key bit dimensions.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": []
}