{
  "description": "No description available",
  "functions": [
    {
      "name": "segment_max",
      "signature": "segment_max(data: 'ArrayLike', segment_ids: 'ArrayLike', num_segments: 'int | None' = None, indices_are_sorted: 'bool' = False, unique_indices: 'bool' = False, bucket_size: 'int | None' = None, mode: 'lax.GatherScatterMode | None' = None) -> 'Array'",
      "documentation": {
        "description": "Computes the maximum within segments of an array.\nSimilar to TensorFlow's `segment_max\n<https://www.tensorflow.org/api_docs/python/tf/math/segment_max>`_\nArgs:\ndata: an array with the values to be reduced.\nsegment_ids: an array with integer dtype that indicates the segments of\n`data` (along its leading axis) to be reduced. Values can be repeated and\nneed not be sorted. Values outside of the range [0, num_segments) are\ndropped and do not contribute to the result.\nnum_segments: optional, an int with nonnegative value indicating the number\nof segments. The default is set to be the minimum number of segments that\nwould support all indices in ``segment_ids``, calculated as\n``max(segment_ids) + 1``.\nSince `num_segments` determines the size of the output, a static value\nmust be provided to use ``segment_max`` in a JIT-compiled function.\nindices_are_sorted: whether ``segment_ids`` is known to be sorted.\nunique_indices: whether `segment_ids` is known to be free of duplicates.\nbucket_size: size of bucket to group indices into. ``segment_max`` is\nperformed on each bucket separately. Default ``None`` means no bucketing.\nmode: a :class:`jax.lax.GatherScatterMode` value describing how\nout-of-bounds indices should be handled. By default, values outside of the\nrange [0, num_segments) are dropped and do not contribute to the sum.",
        "parameters": {},
        "returns": "An array with shape :code:`(num_segments,) + data.shape[1:]` representing the\nsegment maximums.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Simple 1D segment max:\n>>> data = jnp.arange(6)\n>>> segment_ids = jnp.array([0, 0, 1, 1, 2, 2])\n>>> segment_max(data, segment_ids)\nArray([1, 3, 5], dtype=int32)\nUsing JIT requires static `num_segments`:\n>>> from jax import jit\n>>> jit(segment_max, static_argnums=2)(data, segment_ids, 3)\nArray([1, 3, 5], dtype=int32)"
      }
    },
    {
      "name": "segment_min",
      "signature": "segment_min(data: 'ArrayLike', segment_ids: 'ArrayLike', num_segments: 'int | None' = None, indices_are_sorted: 'bool' = False, unique_indices: 'bool' = False, bucket_size: 'int | None' = None, mode: 'lax.GatherScatterMode | None' = None) -> 'Array'",
      "documentation": {
        "description": "Computes the minimum within segments of an array.\nSimilar to TensorFlow's `segment_min\n<https://www.tensorflow.org/api_docs/python/tf/math/segment_min>`_\nArgs:\ndata: an array with the values to be reduced.\nsegment_ids: an array with integer dtype that indicates the segments of\n`data` (along its leading axis) to be reduced. Values can be repeated and\nneed not be sorted. Values outside of the range [0, num_segments) are\ndropped and do not contribute to the result.\nnum_segments: optional, an int with nonnegative value indicating the number\nof segments. The default is set to be the minimum number of segments that\nwould support all indices in ``segment_ids``, calculated as\n``max(segment_ids) + 1``.\nSince `num_segments` determines the size of the output, a static value\nmust be provided to use ``segment_min`` in a JIT-compiled function.\nindices_are_sorted: whether ``segment_ids`` is known to be sorted.\nunique_indices: whether `segment_ids` is known to be free of duplicates.\nbucket_size: size of bucket to group indices into. ``segment_min`` is\nperformed on each bucket separately. Default ``None`` means no bucketing.\nmode: a :class:`jax.lax.GatherScatterMode` value describing how\nout-of-bounds indices should be handled. By default, values outside of the\nrange [0, num_segments) are dropped and do not contribute to the sum.",
        "parameters": {},
        "returns": "An array with shape :code:`(num_segments,) + data.shape[1:]` representing the\nsegment minimums.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Simple 1D segment min:\n>>> data = jnp.arange(6)\n>>> segment_ids = jnp.array([0, 0, 1, 1, 2, 2])\n>>> segment_min(data, segment_ids)\nArray([0, 2, 4], dtype=int32)\nUsing JIT requires static `num_segments`:\n>>> from jax import jit\n>>> jit(segment_min, static_argnums=2)(data, segment_ids, 3)\nArray([0, 2, 4], dtype=int32)"
      }
    },
    {
      "name": "segment_prod",
      "signature": "segment_prod(data: 'ArrayLike', segment_ids: 'ArrayLike', num_segments: 'int | None' = None, indices_are_sorted: 'bool' = False, unique_indices: 'bool' = False, bucket_size: 'int | None' = None, mode: 'lax.GatherScatterMode | None' = None) -> 'Array'",
      "documentation": {
        "description": "Computes the product within segments of an array.\nSimilar to TensorFlow's `segment_prod\n<https://www.tensorflow.org/api_docs/python/tf/math/segment_prod>`_\nArgs:\ndata: an array with the values to be reduced.\nsegment_ids: an array with integer dtype that indicates the segments of\n`data` (along its leading axis) to be reduced. Values can be repeated and\nneed not be sorted. Values outside of the range [0, num_segments) are\ndropped and do not contribute to the result.\nnum_segments: optional, an int with nonnegative value indicating the number\nof segments. The default is set to be the minimum number of segments that\nwould support all indices in ``segment_ids``, calculated as\n``max(segment_ids) + 1``.\nSince `num_segments` determines the size of the output, a static value\nmust be provided to use ``segment_prod`` in a JIT-compiled function.\nindices_are_sorted: whether ``segment_ids`` is known to be sorted.\nunique_indices: whether `segment_ids` is known to be free of duplicates.\nbucket_size: size of bucket to group indices into. ``segment_prod`` is\nperformed on each bucket separately to improve numerical stability of\naddition. Default ``None`` means no bucketing.\nmode: a :class:`jax.lax.GatherScatterMode` value describing how\nout-of-bounds indices should be handled. By default, values outside of the\nrange [0, num_segments) are dropped and do not contribute to the sum.",
        "parameters": {},
        "returns": "An array with shape :code:`(num_segments,) + data.shape[1:]` representing the\nsegment products.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Simple 1D segment product:\n>>> data = jnp.arange(6)\n>>> segment_ids = jnp.array([0, 0, 1, 1, 2, 2])\n>>> segment_prod(data, segment_ids)\nArray([ 0,  6, 20], dtype=int32)\nUsing JIT requires static `num_segments`:\n>>> from jax import jit\n>>> jit(segment_prod, static_argnums=2)(data, segment_ids, 3)\nArray([ 0,  6, 20], dtype=int32)"
      }
    },
    {
      "name": "segment_sum",
      "signature": "segment_sum(data: 'ArrayLike', segment_ids: 'ArrayLike', num_segments: 'int | None' = None, indices_are_sorted: 'bool' = False, unique_indices: 'bool' = False, bucket_size: 'int | None' = None, mode: 'lax.GatherScatterMode | None' = None) -> 'Array'",
      "documentation": {
        "description": "Computes the sum within segments of an array.\nSimilar to TensorFlow's `segment_sum\n<https://www.tensorflow.org/api_docs/python/tf/math/segment_sum>`_\nArgs:\ndata: an array with the values to be summed.\nsegment_ids: an array with integer dtype that indicates the segments of\n`data` (along its leading axis) to be summed. Values can be repeated and\nneed not be sorted.\nnum_segments: optional, an int with nonnegative value indicating the number\nof segments. The default is set to be the minimum number of segments that\nwould support all indices in ``segment_ids``, calculated as\n``max(segment_ids) + 1``.\nSince `num_segments` determines the size of the output, a static value\nmust be provided to use ``segment_sum`` in a JIT-compiled function.\nindices_are_sorted: whether ``segment_ids`` is known to be sorted.\nunique_indices: whether `segment_ids` is known to be free of duplicates.\nbucket_size: size of bucket to group indices into. ``segment_sum`` is\nperformed on each bucket separately to improve numerical stability of\naddition. Default ``None`` means no bucketing.\nmode: a :class:`jax.lax.GatherScatterMode` value describing how\nout-of-bounds indices should be handled. By default, values outside of the\nrange [0, num_segments) are dropped and do not contribute to the sum.",
        "parameters": {},
        "returns": "An array with shape :code:`(num_segments,) + data.shape[1:]` representing the\nsegment sums.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "Simple 1D segment sum:\n>>> data = jnp.arange(5)\n>>> segment_ids = jnp.array([0, 0, 1, 1, 2])\n>>> segment_sum(data, segment_ids)\nArray([1, 5, 4], dtype=int32)\nUsing JIT requires static `num_segments`:\n>>> from jax import jit\n>>> jit(segment_sum, static_argnums=2)(data, segment_ids, 3)\nArray([1, 5, 4], dtype=int32)"
      }
    }
  ],
  "classes": []
}