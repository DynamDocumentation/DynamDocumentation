{
  "description": "No description available",
  "functions": [
    {
      "name": "as_hashable_function",
      "signature": "as_hashable_function(closure)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cache",
      "signature": "cache(max_size=4096, trace_context_in_key=True)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "safe_map",
      "signature": "safe_map(...)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "safe_zip",
      "signature": "safe_zip(...)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "split_dict",
      "signature": "split_dict(dct, names)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "split_list",
      "signature": "split_list(args: 'Sequence[T]', ns: 'Sequence[int]') -> 'list[list[T]]'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "split_list_checked",
      "signature": "split_list_checked(args: 'Sequence[T]', ns: 'Sequence[int]') -> 'list[list[T]]'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "split_merge",
      "signature": "split_merge(predicate, xs)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "subvals",
      "signature": "subvals(lst, replace)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "unzip2",
      "signature": "unzip2(xys: 'Iterable[tuple[T1, T2]]') -> 'tuple[tuple[T1, ...], tuple[T2, ...]]'",
      "documentation": {
        "description": "Unzip sequence of length-2 tuples into two tuples.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "wrap_name",
      "signature": "wrap_name(name, transform_name)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "wraps",
      "signature": "wraps(wrapped: 'Callable', namestr: 'str | None' = None, docstr: 'str | None' = None, **kwargs) -> 'Callable[[T], T]'",
      "documentation": {
        "description": "Like functools.wraps, but with finer-grained control over the name and docstring\nof the resulting function.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": [
    {
      "name": "HashableFunction",
      "documentation": {
        "description": "Decouples function equality and hash from its identity.\nLocal lambdas and function defs are reallocated on each function call, making\nthe functions created on different calls compare as unequal. This breaks our\ncaching logic, which should really only care about comparing the semantics and\nnot actual identity.\nThis class makes it possible to compare different functions based on their\nsemantics. The parts that are taken into account are: the bytecode of the\nwrapped function (which is cached by the CPython interpreter and is stable\nacross the invocations of the surrounding function), and `closure` which\nshould contain all values in scope that affect the function semantics. In\nparticular `closure` should contain all elements of the function closure, or\nit should be possible to derive the relevant elements of the true function\nclosure based solely on the contents of the `closure` argument (e.g. in case\nsome closed-over values are not hashable, but are entirely determined by\nhashable locals).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    }
  ]
}