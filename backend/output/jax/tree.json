{
  "description": "Utilities for working with tree-like container data structures.\n\nThe :mod:`jax.tree` namespace contains aliases of utilities from :mod:`jax.tree_util`.",
  "functions": [
    {
      "name": "all",
      "signature": "all(tree: 'Any', *, is_leaf: 'Callable[[Any], bool] | None' = None) -> 'bool'",
      "documentation": {
        "description": "Call all() over the leaves of a tree.\nArgs:\ntree: the pytree to evaluate\nis_leaf : an optionally specified function that will be called at each\nflattening step. It should return a boolean, which indicates whether the\nflattening should traverse the current object, or if it should be stopped\nimmediately, with the whole subtree being treated as a leaf.",
        "parameters": {},
        "returns": "result: boolean True or False",
        "raises": "",
        "see_also": "- :func:`jax.tree.reduce`\n- :func:`jax.tree.leaves`",
        "notes": "",
        "examples": ">>> import jax\n>>> jax.tree.all([True, {'a': True, 'b': (True, True)}])\nTrue\n>>> jax.tree.all([False, (True, False)])\nFalse"
      }
    },
    {
      "name": "flatten",
      "signature": "flatten(tree: 'Any', is_leaf: 'Callable[[Any], bool] | None' = None) -> 'tuple[list[tree_util.Leaf], tree_util.PyTreeDef]'",
      "documentation": {
        "description": "Flattens a pytree.\nThe flattening order (i.e. the order of elements in the output list)\nis deterministic, corresponding to a left-to-right depth-first tree\ntraversal.\nArgs:\ntree: a pytree to flatten.\nis_leaf: an optionally specified function that will be called at each\nflattening step. It should return a boolean, with true stopping the\ntraversal and the whole subtree being treated as a leaf, and false\nindicating the flattening should traverse the current object.",
        "parameters": {},
        "returns": "A pair where the first element is a list of leaf values and the second\nelement is a treedef representing the structure of the flattened tree.",
        "raises": "",
        "see_also": "- :func:`jax.tree.leaves`\n- :func:`jax.tree.structure`\n- :func:`jax.tree.unflatten`",
        "notes": "",
        "examples": ">>> import jax\n>>> vals, treedef = jax.tree.flatten([1, (2, 3), [4, 5]])\n>>> vals\n[1, 2, 3, 4, 5]\n>>> treedef\nPyTreeDef([*, (*, *), [*, *]])"
      }
    },
    {
      "name": "flatten_with_path",
      "signature": "flatten_with_path(tree: 'Any', is_leaf: 'Callable[[Any], bool] | None' = None) -> 'tuple[list[tuple[tree_util.KeyPath, Any]], tree_util.PyTreeDef]'",
      "documentation": {
        "description": "Flattens a pytree like ``tree_flatten``, but also returns each leaf's key path.\nArgs:\ntree: a pytree to flatten. If it contains a custom type, it is recommended\nto be registered with ``register_pytree_with_keys``.",
        "parameters": {},
        "returns": "A pair which the first element is a list of key-leaf pairs, each of\nwhich contains a leaf and its key path. The second element is a treedef\nrepresenting the structure of the flattened tree.",
        "raises": "",
        "see_also": "- :func:`jax.tree.flatten`\n- :func:`jax.tree.map_with_path`\n- :func:`jax.tree_util.register_pytree_with_keys`",
        "notes": "",
        "examples": ">>> import jax\n>>> path_vals, treedef = jax.tree.flatten_with_path([1, {'x': 3}])\n>>> path_vals\n[((SequenceKey(idx=0),), 1), ((SequenceKey(idx=1), DictKey(key='x')), 3)]\n>>> treedef\nPyTreeDef([*, {'x': *}])"
      }
    },
    {
      "name": "leaves",
      "signature": "leaves(tree: 'Any', is_leaf: 'Callable[[Any], bool] | None' = None) -> 'list[tree_util.Leaf]'",
      "documentation": {
        "description": "Gets the leaves of a pytree.\nArgs:\ntree: the pytree for which to get the leaves\nis_leaf : an optionally specified function that will be called at each\nflattening step. It should return a boolean, which indicates whether the\nflattening should traverse the current object, or if it should be stopped\nimmediately, with the whole subtree being treated as a leaf.",
        "parameters": {},
        "returns": "leaves: a list of tree leaves.",
        "raises": "",
        "see_also": "- :func:`jax.tree.flatten`\n- :func:`jax.tree.structure`\n- :func:`jax.tree.unflatten`",
        "notes": "",
        "examples": ">>> import jax\n>>> jax.tree.leaves([1, (2, 3), [4, 5]])\n[1, 2, 3, 4, 5]"
      }
    },
    {
      "name": "leaves_with_path",
      "signature": "leaves_with_path(tree: 'Any', is_leaf: 'Callable[[Any], bool] | None' = None) -> 'list[tuple[tree_util.KeyPath, Any]]'",
      "documentation": {
        "description": "Gets the leaves of a pytree like ``tree_leaves`` and returns each leaf's key path.\nArgs:\ntree: a pytree. If it contains a custom type, it is recommended to be\nregistered with ``register_pytree_with_keys``.",
        "parameters": {},
        "returns": "A list of key-leaf pairs, each of which contains a leaf and its key path.",
        "raises": "",
        "see_also": "- :func:`jax.tree.leaves`\n- :func:`jax.tree.flatten_with_path`\n- :func:`jax.tree_util.register_pytree_with_keys`",
        "notes": "",
        "examples": ">>> import jax\n>>> jax.tree.leaves_with_path([1, {'x': 3}])\n[((SequenceKey(idx=0),), 1), ((SequenceKey(idx=1), DictKey(key='x')), 3)]"
      }
    },
    {
      "name": "map",
      "signature": "map(f: 'Callable[..., Any]', tree: 'Any', *rest: 'Any', is_leaf: 'Callable[[Any], bool] | None' = None) -> 'Any'",
      "documentation": {
        "description": "Maps a multi-input function over pytree args to produce a new pytree.\nArgs:\nf: function that takes ``1 + len(rest)`` arguments, to be applied at the\ncorresponding leaves of the pytrees.\ntree: a pytree to be mapped over, with each leaf providing the first\npositional argument to ``f``.\nrest: a tuple of pytrees, each of which has the same structure as ``tree``\nor has ``tree`` as a prefix.\nis_leaf: an optionally specified function that will be called at each\nflattening step. It should return a boolean, which indicates whether the\nflattening should traverse the current object, or if it should be stopped\nimmediately, with the whole subtree being treated as a leaf.",
        "parameters": {},
        "returns": "A new pytree with the same structure as ``tree`` but with the value at each\nleaf given by ``f(x, *xs)`` where ``x`` is the value at the corresponding\nleaf in ``tree`` and ``xs`` is the tuple of values at corresponding nodes in\n``rest``.",
        "raises": "",
        "see_also": "- :func:`jax.tree.leaves`\n- :func:`jax.tree.reduce`",
        "notes": "",
        "examples": ">>> import jax\n>>> jax.tree.map(lambda x: x + 1, {\"x\": 7, \"y\": 42})\n{'x': 8, 'y': 43}\nIf multiple inputs are passed, the structure of the tree is taken from the\nfirst input; subsequent inputs need only have ``tree`` as a prefix:\n>>> jax.tree.map(lambda x, y: [x] + y, [5, 6], [[7, 9], [1, 2]])\n[[5, 7, 9], [6, 1, 2]]"
      }
    },
    {
      "name": "map_with_path",
      "signature": "map_with_path(f: 'Callable[..., Any]', tree: 'Any', *rest: 'Any', is_leaf: 'Callable[[Any], bool] | None' = None) -> 'Any'",
      "documentation": {
        "description": "Maps a multi-input function over pytree key path and args to produce a new pytree.\nThis is a more powerful alternative of ``tree_map`` that can take the key path\nof each leaf as input argument as well.\nArgs:\nf: function that takes ``2 + len(rest)`` arguments, aka. the key path and\neach corresponding leaves of the pytrees.\ntree: a pytree to be mapped over, with each leaf's key path as the first\npositional argument and the leaf itself as the second argument to ``f``.\n*rest: a tuple of pytrees, each of which has the same structure as ``tree``\nor has ``tree`` as a prefix.",
        "parameters": {},
        "returns": "A new pytree with the same structure as ``tree`` but with the value at each\nleaf given by ``f(kp, x, *xs)`` where ``kp`` is the key path of the leaf at\nthe corresponding leaf in ``tree``, ``x`` is the leaf value and ``xs`` is\nthe tuple of values at corresponding nodes in ``rest``.",
        "raises": "",
        "see_also": "- :func:`jax.tree.map`\n- :func:`jax.tree.flatten_with_path`\n- :func:`jax.tree.leaves_with_path`\n- :func:`jax.tree_util.register_pytree_with_keys`",
        "notes": "",
        "examples": ">>> import jax\n>>> jax.tree.map_with_path(lambda path, x: x + path[0].idx, [1, 2, 3])\n[1, 3, 5]"
      }
    },
    {
      "name": "reduce",
      "signature": "reduce(function: 'Callable[[T, Any], T]', tree: 'Any', initializer: 'Any' = <object object at 0x7b2236d7adb0>, is_leaf: 'Callable[[Any], bool] | None' = None) -> 'T'",
      "documentation": {
        "description": "Call reduce() over the leaves of a tree.\nArgs:\nfunction: the reduction function\ntree: the pytree to reduce over\ninitializer: the optional initial value\nis_leaf : an optionally specified function that will be called at each\nflattening step. It should return a boolean, which indicates whether the\nflattening should traverse the current object, or if it should be stopped\nimmediately, with the whole subtree being treated as a leaf.",
        "parameters": {},
        "returns": "result: the reduced value.",
        "raises": "",
        "see_also": "- :func:`jax.tree.leaves`\n- :func:`jax.tree.map`",
        "notes": "",
        "examples": ">>> import jax\n>>> import operator\n>>> jax.tree.reduce(operator.add, [1, (2, 3), [4, 5, 6]])\n21"
      }
    },
    {
      "name": "structure",
      "signature": "structure(tree: 'Any', is_leaf: 'None | Callable[[Any], bool]' = None) -> 'tree_util.PyTreeDef'",
      "documentation": {
        "description": "Gets the treedef for a pytree.\nArgs:\ntree: the pytree for which to get the leaves\nis_leaf : an optionally specified function that will be called at each\nflattening step. It should return a boolean, which indicates whether the\nflattening should traverse the current object, or if it should be stopped\nimmediately, with the whole subtree being treated as a leaf.",
        "parameters": {},
        "returns": "pytreedef: a PyTreeDef representing the structure of the tree.",
        "raises": "",
        "see_also": "- :func:`jax.tree.flatten`\n- :func:`jax.tree.leaves`\n- :func:`jax.tree.unflatten`",
        "notes": "",
        "examples": ">>> import jax\n>>> jax.tree.structure([1, (2, 3), [4, 5]])\nPyTreeDef([*, (*, *), [*, *]])"
      }
    },
    {
      "name": "transpose",
      "signature": "transpose(outer_treedef: 'tree_util.PyTreeDef', inner_treedef: 'tree_util.PyTreeDef | None', pytree_to_transpose: 'Any') -> 'Any'",
      "documentation": {
        "description": "Transform a tree having tree structure (outer, inner) into one having structure (inner, outer).\nArgs:\nouter_treedef: PyTreeDef representing the outer tree.\ninner_treedef: PyTreeDef representing the inner tree.\nIf None, then it will be inferred from outer_treedef and the structure of\npytree_to_transpose.\npytree_to_transpose: the pytree to be transposed.",
        "parameters": {},
        "returns": "transposed_pytree: the transposed pytree.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import jax\n>>> tree = [(1, 2, 3), (4, 5, 6)]\n>>> inner_structure = jax.tree.structure(('*', '*', '*'))\n>>> outer_structure = jax.tree.structure(['*', '*'])\n>>> jax.tree.transpose(outer_structure, inner_structure, tree)\n([1, 4], [2, 5], [3, 6])\nInferring the inner structure:\n>>> jax.tree.transpose(outer_structure, None, tree)\n([1, 4], [2, 5], [3, 6])"
      }
    },
    {
      "name": "unflatten",
      "signature": "unflatten(treedef: 'tree_util.PyTreeDef', leaves: 'Iterable[tree_util.Leaf]') -> 'Any'",
      "documentation": {
        "description": "Reconstructs a pytree from the treedef and the leaves.\nThe inverse of :func:`tree_flatten`.\nArgs:\ntreedef: the treedef to reconstruct\nleaves: the iterable of leaves to use for reconstruction. The iterable must\nmatch the leaves of the treedef.",
        "parameters": {},
        "returns": "The reconstructed pytree, containing the ``leaves`` placed in the structure\ndescribed by ``treedef``.",
        "raises": "",
        "see_also": "- :func:`jax.tree.flatten`\n- :func:`jax.tree.leaves`\n- :func:`jax.tree.structure`",
        "notes": "",
        "examples": ">>> import jax\n>>> vals, treedef = jax.tree.flatten([1, (2, 3), [4, 5]])\n>>> newvals = [100, 200, 300, 400, 500]\n>>> jax.tree.unflatten(treedef, newvals)\n[100, (200, 300), [400, 500]]"
      }
    }
  ],
  "classes": []
}