{
  "description": "No description available",
  "functions": [
    {
      "name": "default_export_platform",
      "signature": "default_export_platform() -> 'str'",
      "documentation": {
        "description": "Retrieves the default export platform.\nOne of: `tpu`, `cpu`, `cuda`, `rocm`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "deserialize",
      "signature": "deserialize(blob: 'bytearray') -> 'Exported'",
      "documentation": {
        "description": "Deserializes an Exported.\nArgs:\nblob: a bytearray obtained from `Exported.serialize`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "export",
      "signature": "export(fun_jit: 'stages.Wrapped', *, platforms: 'Sequence[str] | None' = None, disabled_checks: 'Sequence[DisabledSafetyCheck]' = ()) -> 'Callable[..., Exported]'",
      "documentation": {
        "description": "Exports a JAX function for persistent serialization.\nArgs:\nfun_jit: the function to export. Should be the result of `jax.jit`.\nplatforms:\nOptional sequence containing a subset of 'tpu', 'cpu',\n'cuda', 'rocm'. If more than one platform is specified, then\nthe exported code takes an argument specifying the platform.\nIf None, then use the default JAX backend.\nThe calling convention for multiple platforms is explained at\nhttps://jax.readthedocs.io/en/latest/export/export.html#module-calling-convention.\ndisabled_checks: the safety checks to disable. See documentation for\nof `jax.export.DisabledSafetyCheck`.",
        "parameters": {},
        "returns": "a function that takes args and kwargs pytrees of {class}`jax.ShapeDtypeStruct`,\nor values with `.shape` and `.dtype` attributes, and returns an\n`Exported`.\nUsage:\n>>> from jax import export\n>>> exported: export.Exported = export.export(jnp.sin)(\n...     np.arange(4, dtype=np.float32))\n>>>\n>>> # You can inspect the Exported object\n>>> exported.in_avals\n(ShapedArray(float32[4]),)\n>>> blob: bytearray = exported.serialize()\n>>>\n>>> # The serialized bytes are safe to use in a separate process\n>>> rehydrated: export.Exported = export.deserialize(blob)\n>>> rehydrated.fun_name\n'sin'\n>>> rehydrated.call(np.array([.1, .2, .3, .4], dtype=np.float32))\nArray([0.09983342, 0.19866933, 0.29552022, 0.38941833], dtype=float32)",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "is_symbolic_dim",
      "signature": "is_symbolic_dim(p: 'DimSize') -> 'bool'",
      "documentation": {
        "description": "Checks if a dimension is symbolic.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "register_namedtuple_serialization",
      "signature": "register_namedtuple_serialization(nodetype: 'type[T]', *, serialized_name: 'str') -> 'type[T]'",
      "documentation": {
        "description": "Registers a namedtuple for serialization and deserialization.\nJAX has native PyTree support for `collections.namedtuple`, and does not\nrequire a call to `jax.tree_util.register_pytree_node`. However, if you\nwant to serialize functions that have inputs of outputs of a\nnamedtuple type, you must register that type for serialization.\nArgs:\nnodetype: the type whose PyTree nodes we want to serialize. It is an\nerror to attempt to register multiple serializations for a `nodetype`.\nOn deserialization, this type must have the same set of keys that\nwere present during serialization.\nserialized_name: a string that will be present in the serialization and\nwill be used to look up the registration during deserialization. It is an\nerror to attempt to register multiple serializations for\na `serialized_name`.",
        "parameters": {},
        "returns": "the same type passed as `nodetype`, so that this function can\nbe used as a class decorator.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "register_pytree_node_serialization",
      "signature": "register_pytree_node_serialization(nodetype: 'type[T]', *, serialized_name: 'str', serialize_auxdata: '_SerializeAuxData', deserialize_auxdata: '_DeserializeAuxData', from_children: '_BuildFromChildren | None' = None) -> 'type[T]'",
      "documentation": {
        "description": "Registers a custom PyTree node for serialization and deserialization.\nYou must use this function before you can serialize and deserialize PyTree\nnodes for the types not supported natively. We serialize PyTree nodes for\nthe `in_tree` and `out_tree` fields of `Exported`, which are part of the\nexported function's calling convention.\nThis function must be called after calling\n`jax.tree_util.register_pytree_node` (except for `collections.namedtuple`,\nwhich do not require a call to `register_pytree_node`).\nArgs:\nnodetype: the type whose PyTree nodes we want to serialize. It is an\nerror to attempt to register multiple serializations for a `nodetype`.\nserialized_name: a string that will be present in the serialization and\nwill be used to look up the registration during deserialization. It is an\nerror to attempt to register multiple serializations for a\n`serialized_name`.\nserialize_auxdata: serialize the PyTree auxdata (returned by the\n`flatten_func` argument to `jax.tree_util.register_pytree_node`.).\ndeserialize_auxdata: deserialize the auxdata that was serialized by the\n`serialize_auxdata`.\nfrom_children: if present, this is a function that takes that result of\n`deserialize_auxdata` along with some children and creates an instance\nof `nodetype`. This is similar to the `unflatten_func` passed to\n`jax.tree_util.register_pytree_node`. If not present, we look up\nand use the `unflatten_func`. This is needed for `collections.namedtuple`,\nwhich does not have a `register_pytree_node`, but it can be useful to\noverride that function. Note that the result of `from_children` is\nonly used with `jax.tree_util.tree_structure` to construct a proper\nPyTree node, it is not used to construct the outputs of the serialized\nfunction.",
        "parameters": {},
        "returns": "the same type passed as `nodetype`, so that this function can\nbe used as a class decorator.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "symbolic_args_specs",
      "signature": "symbolic_args_specs(args, shapes_specs, constraints: 'Sequence[str]' = (), scope: 'SymbolicScope | None' = None)",
      "documentation": {
        "description": "Constructs a pytree of jax.ShapeDtypeSpec arguments specs for `export`.\nSee the documentation of :func:`jax.export.symbolic_shape` and\nthe [shape polymorphism documentation](https://jax.readthedocs.io/en/latest/export/shape_poly.html) for details.\nArgs:\nargs: a pytree of arguments. These can be jax.Array, or jax.ShapeDTypeSpec.\nThey are used to learn the pytree structure of the arguments, their dtypes,\nand to fill-in the actual shapes where the `shapes_specs` contains\nplaceholders. Note that only the shape dimensions for which\n`shapes_specs` is a placeholder are used from `args`.\nshapes_specs: should be `None` (all arguments have static shapes),\na single string (see `shape_spec` for :func:`jax.export.symbolic_shape`;\napplies to all arguments), or a pytree matching a prefix\nof the `args`.\nSee [how optional parameters are matched to\narguments](https://jax.readthedocs.io/en/latest/pytrees.html#applying-optional-parameters-to-pytrees).\nconstraints: as for :func:`jax.export.symbolic_shape`.\nscope: as for :func:`jax.export.symbolic_shape`.",
        "parameters": {},
        "returns": "replaced with symbolic dimensions as specified by `shapes_specs`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "symbolic_shape",
      "signature": "symbolic_shape(shape_spec: 'str | None', *, constraints: 'Sequence[str]' = (), scope: 'SymbolicScope | None' = None, like: 'Sequence[int | None] | None' = None) -> 'Sequence[DimSize]'",
      "documentation": {
        "description": "Constructs a symbolic shape from a string representation.\nSee https://jax.readthedocs.io/en/latest/export/shape_poly.html for examples.\nArgs:\nshape_spec: a symbolic shape specification. None stands for \"...\".\nA shape specification is the string representation of a tuple (the\nparentheses are optional) with comma-separated dimension expressions.\nA dimension expression can be either: an integer constant,\na dimension variable (alphanumeric\nstarting with a letter), e1 + e2, e1 - e2, e1 * e2, floordiv(e1, e2),\nmod(e1, e2), max(e1, e2), or min(e1, e2).\nconstraints: a sequence of constraints on symbolic dimension expressions, of\nthe form `e1 >= e2` or `e1 <= e2`, or `e1 == e2`.\nSee [the documentation](https://jax.readthedocs.io/en/latest/export/shape_poly.html#user-specified-symbolic-constraints)\nfor usage.\nscope: optionally, you can specify that the parsed symbolic expressions\nbe created in the given scope. If this is missing, then a new\n`SymbolicScope` is created with the given `constraints`.\nYou cannot specify both a `scope` and `constraints`.\nSee [the documentation](https://jax.readthedocs.io/en/latest/export/shape_poly.html#user-specified-symbolic-constraints)\nfor usage.\nlike: when `shape_spec` contains placeholders (\"_\", \"...\"), use this\nshape to fill in the placeholders.\nThe dimensions of `like` that are used for filling\nmust be not `None`. If a dimension in `like` is not `None` and\nthe corresponding dimension in `shape_spec` is a constant then they\nmust be equal.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": [
    {
      "name": "DisabledSafetyCheck",
      "documentation": {
        "description": "A safety check that should be skipped on (de)serialization.\nMost of these checks are performed on serialization, but some are deferred to\ndeserialization. The list of disabled checks is attached to the serialization,\ne.g., as a sequence of string attributes to `jax.export.Exported` or of\n`tf.XlaCallModuleOp`.\nWhen using jax2tf, you can disable more deserialization safety checks\nby passing `TF_XLA_FLAGS=--tf_xla_call_module_disabled_checks=platform`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "custom_call",
          "signature": "custom_call(target_name: 'str') -> 'DisabledSafetyCheck'",
          "documentation": {
            "description": "Allows the serialization of a call target not known to be stable.\nHas effect only on serialization.\nArgs:\ntarget_name: the name of the custom call target to allow.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_custom_call",
          "signature": "is_custom_call(self) -> 'str | None'",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "platform",
          "signature": "platform() -> 'DisabledSafetyCheck'",
          "documentation": {
            "description": "Allows the compilation platform to differ from the export platform.\nHas effect only on deserialization.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "Exported",
      "documentation": {
        "description": "A JAX function lowered to StableHLO.\nAttributes:\nfun_name: the name of the exported function, for error messages.\nin_tree: a PyTreeDef describing the tuple (args, kwargs) of the lowered JAX\nfunction. The actual lowering does not depend on the `in_tree`, but this\ncan be used to invoke the exported function using the same argument\nstructure.\nin_avals: the flat tuple of input abstract values. May contain dimension\nexpressions in the shapes.\nout_tree: a PyTreeDef describing the result of the lowered JAX function.\nout_avals: the flat tuple of output abstract values. May contain dimension\nexpressions in the shapes, with dimension variables among those in\n`in_avals`.\nin_shardings_hlo: the flattened input shardings, a sequence as long\nas `in_avals`. `None` means unspecified sharding.\nNote that these do not include the mesh or the actual devices used in\nthe mesh. See `in_shardings_jax` for a way to turn these\ninto sharding specification that can be used with JAX APIs.\nout_shardings_hlo: the flattened output shardings, a sequence as long\nas `out_avals`. `None` means unspecified sharding.\nNote that these do not include the mesh or the actual devices used in\nthe mesh. See `out_shardings_jax` for a way to turn these\ninto sharding specification that can be used with JAX APIs.\nnr_devices: the number of devices that the module has been lowered for.\nplatforms: a tuple containing the platforms for which the function should\nbe exported. The set of platforms in JAX is open-ended; users can\nadd platforms. JAX built-in platforms are: 'tpu', 'cpu', 'cuda', 'rocm'.\nSee https://jax.readthedocs.io/en/latest/export/export.html#cross-platform-and-multi-platform-export.\nordered_effects: the ordered effects present in the serialized module.\nThis is present from serialization version 9. See https://jax.readthedocs.io/en/latest/export/export.html#module-calling-convention\nfor the calling convention in presence of ordered effects.\nunordered_effects: the unordered effects present in the serialized module.\nThis is present from serialization version 9.\nmlir_module_serialized: the serialized lowered VHLO module.\ncalling_convention_version: a version number for the calling\nconvention of the exported module.\nSee more versioning details at https://jax.readthedocs.io/en/latest/export/export.html#calling-convention-versions.\nmodule_kept_var_idx: the sorted indices of the arguments among `in_avals` that\nmust be passed to the module. The other arguments have been dropped\nbecause they are not used.\nuses_global_constants: whether the `mlir_module_serialized` uses shape\npolymorphism or multi-platform export.\nThis may be because `in_avals` contains dimension\nvariables, or due to inner calls of Exported modules that have\ndimension variables or platform index arguments. Such modules need\nshape refinement before XLA compilation.\ndisabled_safety_checks: a list of descriptors of safety checks that have been\ndisabled at export time. See docstring for `DisabledSafetyCheck`.\n_get_vjp: an optional function that takes the current exported function and\nreturns the exported VJP function.\nThe VJP function takes a flat list of arguments,\nstarting with the primal arguments and followed by a cotangent argument\nfor each primal output. It returns a tuple with the cotangents\ncorresponding to the flattened primal inputs.\nSee a [description of the calling convention for the `mlir_module`](https://jax.readthedocs.io/en/latest/export/export.html#module-calling-convention).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "call",
          "signature": "call(self, *args, **kwargs)",
          "documentation": {
            "description": "Call an exported function from a JAX program.\nArgs:\nargs: the positional arguments to pass to the exported function. This\nshould be a pytree of arrays with the same pytree structure as the\narguments for which the function was exported.\nkwargs: the keyword arguments to pass to the exported function.",
            "parameters": {},
            "returns": "results of the exported function.\nThe invocation supports reverse-mode AD, and all the features supported\nby exporting: shape polymorphism, multi-platform, device polymorphism.\nSee the examples in the [JAX export documentation](https://jax.readthedocs.io/en/latest/export/export.html).",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "has_vjp",
          "signature": "has_vjp(self) -> 'bool'",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "in_shardings_jax",
          "signature": "in_shardings_jax(self, mesh: 'sharding.Mesh') -> 'Sequence[sharding.Sharding | None]'",
          "documentation": {
            "description": "Creates Shardings corresponding to self.in_shardings_hlo.\nThe Exported object stores `in_shardings_hlo` as HloShardings, which are\nindependent of a mesh or set of devices. This method constructs\nSharding that can be used in JAX APIs such as `jax.jit` or\n`jax.device_put`.\nExample usage:\n>>> from jax import export\n>>> # Prepare the exported object:\n>>> exp_mesh = sharding.Mesh(jax.devices(), (\"a\",))\n>>> exp = export.export(jax.jit(lambda x: jax.numpy.add(x, x),\n...                             in_shardings=sharding.NamedSharding(exp_mesh, sharding.PartitionSpec(\"a\")))\n...     )(np.arange(jax.device_count()))\n>>> exp.in_shardings_hlo\n({devices=[8]<=[8]},)\n>>> # Create a mesh for running the exported object\n>>> run_mesh = sharding.Mesh(jax.devices()[::-1], (\"b\",))\n>>> # Put the args and kwargs on the appropriate devices\n>>> run_arg = jax.device_put(np.arange(jax.device_count()),\n...     exp.in_shardings_jax(run_mesh)[0])\n>>> res = exp.call(run_arg)\n>>> res.addressable_shards\n[Shard(device=CpuDevice(id=7), index=(slice(0, 1, None),), replica_id=0, data=[0]),\nShard(device=CpuDevice(id=6), index=(slice(1, 2, None),), replica_id=0, data=[2]),\nShard(device=CpuDevice(id=5), index=(slice(2, 3, None),), replica_id=0, data=[4]),\nShard(device=CpuDevice(id=4), index=(slice(3, 4, None),), replica_id=0, data=[6]),\nShard(device=CpuDevice(id=3), index=(slice(4, 5, None),), replica_id=0, data=[8]),\nShard(device=CpuDevice(id=2), index=(slice(5, 6, None),), replica_id=0, data=[10]),\nShard(device=CpuDevice(id=1), index=(slice(6, 7, None),), replica_id=0, data=[12]),\nShard(device=CpuDevice(id=0), index=(slice(7, 8, None),), replica_id=0, data=[14])]",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mlir_module",
          "signature": "mlir_module(self) -> 'str'",
          "documentation": {
            "description": "A string representation of the `mlir_module_serialized`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "out_shardings_jax",
          "signature": "out_shardings_jax(self, mesh: 'sharding.Mesh') -> 'Sequence[sharding.Sharding | None]'",
          "documentation": {
            "description": "Creates Shardings corresponding to `self.out_shardings_hlo`.\nSee documentation for in_shardings_jax.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "serialize",
          "signature": "serialize(self, vjp_order: 'int' = 0) -> 'bytearray'",
          "documentation": {
            "description": "Serializes an Exported.\nArgs:\nvjp_order: The maximum vjp order to include. E.g., the value 2 means that we\nserialize the primal functions and two orders of the `vjp` function. This\nshould allow 2nd order reverse mode differentiation of the deserialized\nfunction. i.e., `jax.grad(jax.grad(f)).`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "vjp",
          "signature": "vjp(self) -> 'Exported'",
          "documentation": {
            "description": "Gets the exported VJP.",
            "parameters": {},
            "returns": "loaded from an external format without a VJP.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "SymbolicScope",
      "documentation": {
        "description": "Indentifies a scope for symbolic expressions.\nAll symbolic expressions that interact (e.g., appear in the argument shapes\nfor one JAX function invocation, or are involved in arithmetic operations)\nmust be from the same scope and must share the same SymbolicScope object.\nHolds the constraints on symbolic expressions.\nSee [the README](https://jax.readthedocs.io/en/latest/export/shape_poly.html#user-specified-symbolic-constraints)\nfor more details.\nArgs:\nconstraints_str: A sequence of constraints on symbolic dimension expressions,\nof the form `e1 >= e2` or `e1 <= e2` or `e1 == e2`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    }
  ]
}