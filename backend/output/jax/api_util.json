{
  "description": "No description available",
  "functions": [
    {
      "name": "argnums_partial",
      "signature": "argnums_partial(f, dyn_argnums, args, require_static_args_hashable=True)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "debug_info",
      "signature": "debug_info(traced_for: 'str', fun: 'Callable', args: 'Sequence[Any]', kwargs: 'dict[str, Any]', *, static_argnums: 'Sequence[int]' = (), static_argnames: 'Sequence[str]' = (), result_paths_thunk: 'Callable[[], tuple[str, ...]] | None' = None, sourceinfo: 'str | None' = None, signature: 'inspect.Signature | None' = None) -> 'core.DebugInfo'",
      "documentation": {
        "description": "Constructd core.DebugInfo for a function given example args and kwargs.\n`args` and `kwargs` are example positional and keyword arguments, users with\n`inspect.Signature` to get the names of argments. The arguments that are\nconsidered static for tracing purposes should be included, and designated\nusing `static_argnums` and `static_argnames`.\nSee docstring for linear_util.DebugInfo.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "donation_vector",
      "signature": "donation_vector(donate_argnums, donate_argnames, in_tree, kws: 'bool' = True) -> 'tuple[bool, ...]'",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "What if a user specifies donate_argnums but calls the function with kwargs\nor vice-versa? In that case, in `resolve_argnums` using the signature of the\nfunction, the counterpart (donate_argnames or donate_argnums respectively) is\ncalculated so when this function is called both donate_argnums and\ndonate_argnames are available. This allows JAX to donate kwargs when only\ndonate_argnums is specified and vice-versa.\nWhen both donate_argnums and donate_argnames are specified, only the args and\nkwargs specified are donated.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "flatten_axes",
      "signature": "flatten_axes(name, treedef, axis_tree, *, kws=False, tupled_args=False)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "rebase_donate_argnums",
      "signature": "rebase_donate_argnums(donate_argnums, static_argnums) -> 'tuple[int, ...]'",
      "documentation": {
        "description": "Shifts donate to account for static.\n>>> rebase_donate_argnums((3, 4), (0, 1))\n(1, 2)\nArgs:\ndonate_argnums: An iterable of ints.\nstatic_argnums: An iterable of ints.",
        "parameters": {},
        "returns": "A tuple of unique, sorted integer values based on donate_argnums with each\nelement offset to account for static_argnums.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "safe_map",
      "signature": "safe_map(...)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "shaped_abstractify",
      "signature": "shaped_abstractify(x)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": []
}