{
  "description": "No description available",
  "functions": [
    {
      "name": "is_from_package",
      "signature": "is_from_package(obj: Any) -> bool",
      "documentation": {
        "description": "Return whether an object was loaded from a package.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": [
    {
      "name": "Directory",
      "documentation": {
        "description": "A file structure representation. Organized as Directory nodes that have lists of\ntheir Directory children. Directories for a package are created by calling\n:meth:`PackageImporter.file_structure`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "has_file",
          "signature": "has_file(self, filename: str) -> bool",
          "documentation": {
            "description": "Checks if a file is present in a :class:`Directory`.",
            "parameters": {
              "filename": {
                "type": "str",
                "description": "Path of file to search for."
              }
            },
            "returns": "bool: If a :class:`Directory` contains the specified file.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "EmptyMatchError",
      "documentation": {
        "description": "This is an exception that is thrown when a mock or extern is marked as\n``allow_empty=False``, and is not matched with any module during packaging.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "documentation": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "GlobGroup",
      "documentation": {
        "description": "A set of patterns that candidate strings will be matched against.\n\nA candidate is composed of a list of segments separated by ``separator``, e.g. \"foo.bar.baz\".\n\nA pattern contains one or more segments. Segments can be:\n    - A literal string (e.g. \"foo\"), which matches exactly.\n    - A string containing a wildcard (e.g. \"torch*\", or \"foo*baz*\"). The wildcard matches\n      any string, including the empty string.\n    - A double wildcard (\"**\"). This matches against zero or more complete segments.",
        "parameters": {
          "include": {
            "type": "Union[str, Iterable[str]]",
            "description": "A string or list of strings,"
          },
          "each": {
            "type": "",
            "description": "representing a pattern to be matched against. A candidate"
          },
          "will": {
            "type": "",
            "description": "be excluded from matching if it matches *any* exclude pattern."
          },
          "exclude": {
            "type": "Union[str, Iterable[str]]",
            "description": "A string or list of strings,"
          },
          "separator": {
            "type": "str",
            "description": "A string that delimits segments in candidates and"
          },
          "patterns": {
            "type": "",
            "description": ". By default this is \".\" which corresponds to how modules are"
          },
          "named": {
            "type": "",
            "description": "in Python. Another common value for this is \"/\", which is"
          },
          "the": {
            "type": "",
            "description": "Unix path separator."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "``torch.**``: matches ``torch`` and all its submodules, e.g. ``torch.nn`` and ``torch.nn.functional``.\n    ``torch.*``: matches ``torch.nn`` or ``torch.functional``, but not ``torch.nn.functional``.\n    ``torch*.**``: matches ``torch``, ``torchvision``, and all their submodules.\n\nA candidates will match the ``GlobGroup`` if it matches any of the ``include`` patterns and\nnone of the ``exclude`` patterns.\n\nArgs:\n    include (Union[str, Iterable[str]]): A string or list of strings,\n        each representing a pattern to be matched against. A candidate\n        will match if it matches *any* include pattern\n    exclude (Union[str, Iterable[str]]): A string or list of strings,\n        each representing a pattern to be matched against. A candidate\n        will be excluded from matching if it matches *any* exclude pattern.\n    separator (str): A string that delimits segments in candidates and\n        patterns. By default this is \".\" which corresponds to how modules are\n        named in Python. Another common value for this is \"/\", which is\n        the Unix path separator."
      },
      "methods": [
        {
          "name": "matches",
          "signature": "matches(self, candidate: str) -> bool",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "Importer",
      "documentation": {
        "description": "Represents an environment to import modules from.\n\nBy default, you can figure out what module an object belongs by checking\n__module__ and importing the result using __import__ or importlib.import_module.\n\ntorch.package introduces module importers other than the default one.\nEach PackageImporter introduces a new namespace. Potentially a single\nname (e.g. 'foo.bar') is present in multiple namespaces.\n\nIt supports two main operations:\n    import_module: module_name -> module object\n    get_name: object -> (parent module name, name of obj within module)\n\nThe guarantee is that following round-trip will succeed or throw an ObjNotFoundError/ObjMisMatchError.\n    module_name, obj_name = env.get_name(obj)\n    module = env.import_module(module_name)\n    obj2 = getattr(module, obj_name)\n    assert obj1 is obj2",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "get_name",
          "signature": "get_name(self, obj: Any, name: Optional[str] = None) -> Tuple[str, str]",
          "documentation": {
            "description": "Given an object, return a name that can be used to retrieve the\nobject from this environment.",
            "parameters": {
              "obj": {
                "type": "",
                "description": "An object to get the module-environment-relative name for."
              },
              "name": {
                "type": "",
                "description": "If set, use this name instead of looking up __name__ or __qualname__ on `obj`."
              },
              "This": {
                "type": "",
                "description": "is only here to match how Pickler handles __reduce__ functions that return a string,"
              },
              "don": {
                "type": "",
                "description": "'t use otherwise."
              }
            },
            "returns": "A tuple (parent_module_name, attr_name) that can be used to retrieve `obj` from this environment.\n    Use it like:\n        mod = importer.import_module(parent_module_name)\n        obj = getattr(mod, attr_name)",
            "raises": "ObjNotFoundError: we couldn't retrieve `obj by name.\n    ObjMisMatchError: we found a different object with the same name as `obj`.",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "import_module",
          "signature": "import_module(self, module_name: str) -> module",
          "documentation": {
            "description": "Import `module_name` from this environment.\n\nThe contract is the same as for importlib.import_module.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "whichmodule",
          "signature": "whichmodule(self, obj: Any, name: str) -> str",
          "documentation": {
            "description": "Find the module name an object belongs to.\n\nThis should be considered internal for end-users, but developers of\nan importer can override it to customize the behavior.\n\nTaken from pickle.py, but modified to exclude the search into sys.modules",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ObjMismatchError",
      "documentation": {
        "description": "Raised when an importer found a different object with the same name as the user-provided one.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "documentation": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ObjNotFoundError",
      "documentation": {
        "description": "Raised when an importer cannot find an object by searching for its name.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "documentation": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "OrderedImporter",
      "documentation": {
        "description": "A compound importer that takes a list of importers and tries them one at a time.\n\nThe first importer in the list that returns a result \"wins\".",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "get_name",
          "signature": "get_name(self, obj: Any, name: Optional[str] = None) -> Tuple[str, str]",
          "documentation": {
            "description": "Given an object, return a name that can be used to retrieve the\nobject from this environment.",
            "parameters": {
              "obj": {
                "type": "",
                "description": "An object to get the module-environment-relative name for."
              },
              "name": {
                "type": "",
                "description": "If set, use this name instead of looking up __name__ or __qualname__ on `obj`."
              },
              "This": {
                "type": "",
                "description": "is only here to match how Pickler handles __reduce__ functions that return a string,"
              },
              "don": {
                "type": "",
                "description": "'t use otherwise."
              }
            },
            "returns": "A tuple (parent_module_name, attr_name) that can be used to retrieve `obj` from this environment.\n    Use it like:\n        mod = importer.import_module(parent_module_name)\n        obj = getattr(mod, attr_name)",
            "raises": "ObjNotFoundError: we couldn't retrieve `obj by name.\n    ObjMisMatchError: we found a different object with the same name as `obj`.",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "import_module",
          "signature": "import_module(self, module_name: str) -> module",
          "documentation": {
            "description": "Import `module_name` from this environment.\n\nThe contract is the same as for importlib.import_module.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "whichmodule",
          "signature": "whichmodule(self, obj: Any, name: str) -> str",
          "documentation": {
            "description": "Find the module name an object belongs to.\n\nThis should be considered internal for end-users, but developers of\nan importer can override it to customize the behavior.\n\nTaken from pickle.py, but modified to exclude the search into sys.modules",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "PackageExporter",
      "documentation": {
        "description": "Exporters allow you to write packages of code, pickled Python data, and\narbitrary binary and text resources into a self-contained package.\n\nImports can load this code in a hermetic way, such that code is loaded\nfrom the package rather than the normal Python import system. This allows\nfor the packaging of PyTorch model code and data so that it can be run\non a server or used in the future for transfer learning.\n\nThe code contained in packages is copied file-by-file from the original\nsource when it is created, and the file format is a specially organized\nzip file. Future users of the package can unzip the package, and edit the code\nin order to perform custom modifications to it.\n\nThe importer for packages ensures that code in the module can only be loaded from\nwithin the package, except for modules explicitly listed as external using :meth:`extern`.\nThe file ``extern_modules`` in the zip archive lists all the modules that a package externally depends on.\nThis prevents \"implicit\" dependencies where the package runs locally because it is importing\na locally-installed package, but then fails when the package is copied to another machine.\n\nWhen source code is added to the package, the exporter can optionally scan it\nfor further code dependencies (``dependencies=True``). It looks for import statements,\nresolves relative references to qualified module names, and performs an action specified by the user\n(See: :meth:`extern`, :meth:`mock`, and :meth:`intern`).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_dependency",
          "signature": "add_dependency(self, module_name: str, dependencies=True)",
          "documentation": {
            "description": "Given a module, add it to the dependency graph according to patterns\nspecified by the user.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "all_paths",
          "signature": "all_paths(self, src: str, dst: str) -> str",
          "documentation": {
            "description": "Return a dot representation of the subgraph\n   that has all paths from src to dst.",
            "parameters": {},
            "returns": "A dot representation containing all paths from src to dst.\n    (https://graphviz.org/doc/info/lang.html)",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "close",
          "signature": "close(self)",
          "documentation": {
            "description": "Write the package to the filesystem. Any calls after :meth:`close` are now invalid.\nIt is preferable to use resource guard syntax instead::\n\n    with PackageExporter(\"file.zip\") as e:\n        ...",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "denied_modules",
          "signature": "denied_modules(self) -> List[str]",
          "documentation": {
            "description": "Return all modules that are currently denied.",
            "parameters": {},
            "returns": "A list containing the names of modules which will be\n    denied in this package.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "deny",
          "signature": "deny(self, include: 'GlobPattern', *, exclude: 'GlobPattern' = ())",
          "documentation": {
            "description": "Blocklist modules who names match the given glob patterns from the list of modules the package can import.\nIf a dependency on any matching packages is found, a :class:`PackagingError` is raised.",
            "parameters": {
              "include": {
                "type": "Union[List[str], str]",
                "description": "A string e.g. ``\"my_package.my_subpackage\"``, or list of strings"
              },
              "for": {
                "type": "",
                "description": "the names of the modules to be externed. This can also be a glob-style pattern, as described in :meth:`mock`."
              },
              "exclude": {
                "type": "Union[List[str], str]",
                "description": "An optional pattern that excludes some patterns that match the include string."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dependency_graph_string",
          "signature": "dependency_graph_string(self) -> str",
          "documentation": {
            "description": "Returns digraph string representation of dependencies in package.",
            "parameters": {},
            "returns": "A string representation of dependencies in package.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "extern",
          "signature": "extern(self, include: 'GlobPattern', *, exclude: 'GlobPattern' = (), allow_empty: bool = True)",
          "documentation": {
            "description": "Include ``module`` in the list of external modules the package can import.\nThis will prevent dependency discovery from saving\nit in the package. The importer will load an external module directly from the standard import system.\nCode for extern modules must also exist in the process loading the package.",
            "parameters": {
              "include": {
                "type": "",
                "description": "string."
              },
              "for": {
                "type": "",
                "description": "the names of the modules to be externed. This can also be a glob-style pattern, as"
              },
              "described": {
                "type": "",
                "description": "in :meth:`mock`."
              },
              "exclude": {
                "type": "Union[List[str], str]",
                "description": "An optional pattern that excludes some patterns that match the"
              },
              "allow_empty": {
                "type": "bool",
                "description": "An optional flag that specifies whether the extern modules specified by this call"
              },
              "to": {
                "type": "",
                "description": "the ``extern`` method must be matched to some module during packaging. If an extern module glob"
              },
              "pattern": {
                "type": "",
                "description": "is added with ``allow_empty=False``, and :meth:`close` is called (either explicitly or via\n``__exit__``) before any modules match that pattern, an exception is thrown. If ``allow_empty=True``,"
              },
              "no": {
                "type": "",
                "description": "such exception is thrown."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "externed_modules",
          "signature": "externed_modules(self) -> List[str]",
          "documentation": {
            "description": "Return all modules that are currently externed.",
            "parameters": {},
            "returns": "A list containing the names of modules which will be\n    externed in this package.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_rdeps",
          "signature": "get_rdeps(self, module_name: str) -> List[str]",
          "documentation": {
            "description": "Return a list of all modules which depend on the module ``module_name``.",
            "parameters": {},
            "returns": "A list containing the names of modules which depend on ``module_name``.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_unique_id",
          "signature": "get_unique_id(self) -> str",
          "documentation": {
            "description": "Get an id. This id is guaranteed to only be handed out once for this package.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "intern",
          "signature": "intern(self, include: 'GlobPattern', *, exclude: 'GlobPattern' = (), allow_empty: bool = True)",
          "documentation": {
            "description": "Specify modules that should be packaged. A module must match some ``intern`` pattern in order to be\nincluded in the package and have its dependencies processed recursively.",
            "parameters": {
              "include": {
                "type": "Union[List[str], str]",
                "description": "A string e.g. \"my_package.my_subpackage\", or list of strings"
              },
              "for": {
                "type": "",
                "description": "the names of the modules to be externed. This can also be a glob-style pattern, as described in :meth:`mock`."
              },
              "exclude": {
                "type": "Union[List[str], str]",
                "description": "An optional pattern that excludes some patterns that match the include string."
              },
              "allow_empty": {
                "type": "bool",
                "description": "An optional flag that specifies whether the intern modules specified by this call"
              },
              "to": {
                "type": "",
                "description": "the ``intern`` method must be matched to some module during packaging. If an ``intern`` module glob"
              },
              "pattern": {
                "type": "",
                "description": "is added with ``allow_empty=False``, and :meth:`close` is called (either explicitly or via ``__exit__``)"
              },
              "before": {
                "type": "",
                "description": "any modules match that pattern, an exception is thrown. If ``allow_empty=True``, no such exception is thrown."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "interned_modules",
          "signature": "interned_modules(self) -> List[str]",
          "documentation": {
            "description": "Return all modules that are currently interned.",
            "parameters": {},
            "returns": "A list containing the names of modules which will be\n    interned in this package.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mock",
          "signature": "mock(self, include: 'GlobPattern', *, exclude: 'GlobPattern' = (), allow_empty: bool = True)",
          "documentation": {
            "description": "Replace some required modules with a mock implementation.  Mocked modules will return a fake\nobject for any attribute accessed from it. Because we copy file-by-file, the dependency resolution will sometimes\nfind files that are imported by model files but whose functionality is never used\n(e.g. custom serialization code or training helpers).\nUse this function to mock this functionality out without having to modify the original code.",
            "parameters": {
              "include": {
                "type": "Union[List[str], str]",
                "description": "A string e.g. ``\"my_package.my_subpackage\"``, or list of strings"
              },
              "for": {
                "type": "",
                "description": "the names of the modules to be mocked out. Strings can also be a glob-style pattern"
              },
              "string": {
                "type": "",
                "description": "will be mocked out automatically."
              },
              "Examples": {
                "type": "",
                "description": "``'torch.**'`` -- matches ``torch`` and all submodules of torch, e.g. ``'torch.nn'``"
              },
              "and": {
                "type": "",
                "description": "``'torch.nn.functional'``\n``'torch.*'`` -- matches ``'torch.nn'`` or ``'torch.functional'``, but not\n``'torch.nn.functional'``"
              },
              "exclude": {
                "type": "Union[List[str], str]",
                "description": "An optional pattern that excludes some patterns that match the include string."
              },
              "e": {
                "type": "",
                "description": ".g. ``include='torch.**', exclude='torch.foo'`` will mock all torch packages except ``'torch.foo'``,"
              },
              "Default": {
                "type": "",
                "description": "is ``[]``."
              },
              "allow_empty": {
                "type": "bool",
                "description": "An optional flag that specifies whether the mock implementation(s) specified by this call"
              },
              "to": {
                "type": "",
                "description": "the :meth:`mock` method must be matched to some module during packaging. If a mock is added with\n``allow_empty=False``, and :meth:`close` is called (either explicitly or via ``__exit__``) and the mock has"
              },
              "not": {
                "type": "",
                "description": "been matched to a module used by the package being exported, an exception is thrown."
              },
              "If": {
                "type": "",
                "description": "``allow_empty=True``, no such exception is thrown."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mocked_modules",
          "signature": "mocked_modules(self) -> List[str]",
          "documentation": {
            "description": "Return all modules that are currently mocked.",
            "parameters": {},
            "returns": "A list containing the names of modules which will be\n    mocked in this package.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_extern_hook",
          "signature": "register_extern_hook(self, hook: Callable[[ForwardRef('PackageExporter'), str], NoneType]) -> torch.utils.hooks.RemovableHandle",
          "documentation": {
            "description": "Registers an extern hook on the exporter.\n\nThe hook will be called each time a module matches against an :meth:`extern` pattern.\nIt should have the following signature::\n\n    hook(exporter: PackageExporter, module_name: str) -> None\n\nHooks will be called in order of registration.",
            "parameters": {},
            "returns": ":class:`torch.utils.hooks.RemovableHandle`:\n        A handle that can be used to remove the added hook by calling\n        ``handle.remove()``.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_intern_hook",
          "signature": "register_intern_hook(self, hook: Callable[[ForwardRef('PackageExporter'), str], NoneType]) -> torch.utils.hooks.RemovableHandle",
          "documentation": {
            "description": "Registers an intern hook on the exporter.\n\nThe hook will be called each time a module matches against an :meth:`intern` pattern.\nIt should have the following signature::\n\n    hook(exporter: PackageExporter, module_name: str) -> None\n\nHooks will be called in order of registration.",
            "parameters": {},
            "returns": ":class:`torch.utils.hooks.RemovableHandle`:\n        A handle that can be used to remove the added hook by calling\n        ``handle.remove()``.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_mock_hook",
          "signature": "register_mock_hook(self, hook: Callable[[ForwardRef('PackageExporter'), str], NoneType]) -> torch.utils.hooks.RemovableHandle",
          "documentation": {
            "description": "Registers a mock hook on the exporter.\n\nThe hook will be called each time a module matches against a :meth:`mock` pattern.\nIt should have the following signature::\n\n    hook(exporter: PackageExporter, module_name: str) -> None\n\nHooks will be called in order of registration.",
            "parameters": {},
            "returns": ":class:`torch.utils.hooks.RemovableHandle`:\n        A handle that can be used to remove the added hook by calling\n        ``handle.remove()``.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "save_binary",
          "signature": "save_binary(self, package, resource, binary: bytes)",
          "documentation": {
            "description": "Save raw bytes to the package.",
            "parameters": {
              "package": {
                "type": "str",
                "description": "The name of module package this resource should go it (e.g. ``\"my_package.my_subpackage\"``)."
              },
              "resource": {
                "type": "str",
                "description": "A unique name for the resource, used to identify it to load."
              },
              "binary": {
                "type": "str",
                "description": "The data to save."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "save_module",
          "signature": "save_module(self, module_name: str, dependencies=True)",
          "documentation": {
            "description": "Save the code for ``module`` into the package. Code for the module is resolved using the ``importers`` path to find the\nmodule object, and then using its ``__file__`` attribute to find the source code.",
            "parameters": {
              "module_name": {
                "type": "str",
                "description": "e.g. ``my_package.my_subpackage``, code will be saved to provide code"
              },
              "for": {
                "type": "",
                "description": "this package."
              },
              "dependencies": {
                "type": "bool, optional",
                "description": "If ``True``, we scan the source for dependencies."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "save_pickle",
          "signature": "save_pickle(self, package: str, resource: str, obj: Any, dependencies: bool = True, pickle_protocol: int = 3)",
          "documentation": {
            "description": "Save a python object to the archive using pickle. Equivalent to :func:`torch.save` but saving into\nthe archive rather than a stand-alone file. Standard pickle does not save the code, only the objects.\nIf ``dependencies`` is true, this method will also scan the pickled objects for which modules are required\nto reconstruct them and save the relevant code.\n\nTo be able to save an object where ``type(obj).__name__`` is ``my_module.MyObject``,\n``my_module.MyObject`` must resolve to the class of the object according to the ``importer`` order. When saving objects that\nhave previously been packaged, the importer's ``import_module`` method will need to be present in the ``importer`` list\nfor this to work.",
            "parameters": {
              "package": {
                "type": "str",
                "description": "The name of module package this resource should go in (e.g. ``\"my_package.my_subpackage\"``)."
              },
              "resource": {
                "type": "str",
                "description": "A unique name for the resource, used to identify it to load."
              },
              "obj": {
                "type": "Any",
                "description": "The object to save, must be picklable."
              },
              "dependencies": {
                "type": "bool, optional",
                "description": "If ``True``, we scan the source for dependencies."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "save_source_file",
          "signature": "save_source_file(self, module_name: str, file_or_directory: str, dependencies=True)",
          "documentation": {
            "description": "Adds the local file system ``file_or_directory`` to the source package to provide the code\nfor ``module_name``.",
            "parameters": {
              "module_name": {
                "type": "str",
                "description": "e.g. ``\"my_package.my_subpackage\"``, code will be saved to provide code for this package."
              },
              "file_or_directory": {
                "type": "str",
                "description": "the path to a file or directory of code. When a directory, all python files in the directory"
              },
              "are": {
                "type": "",
                "description": "recursively copied using :meth:`save_source_file`. If a file is named ``\"/__init__.py\"`` the code is treated"
              },
              "as": {
                "type": "",
                "description": "a package."
              },
              "dependencies": {
                "type": "bool, optional",
                "description": "If ``True``, we scan the source for dependencies."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "save_source_string",
          "signature": "save_source_string(self, module_name: str, src: str, is_package: bool = False, dependencies: bool = True)",
          "documentation": {
            "description": "Adds ``src`` as the source code for ``module_name`` in the exported package.",
            "parameters": {
              "module_name": {
                "type": "str",
                "description": "e.g. ``my_package.my_subpackage``, code will be saved to provide code for this package."
              },
              "src": {
                "type": "str",
                "description": "The Python source code to save for this package."
              },
              "is_package": {
                "type": "bool, optional",
                "description": "If ``True``, this module is treated as a package. Packages are allowed to have submodules\n(e.g. ``my_package.my_subpackage.my_subsubpackage``), and resources can be saved inside them. Defaults to ``False``."
              },
              "dependencies": {
                "type": "bool, optional",
                "description": "If ``True``, we scan the source for dependencies."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "save_text",
          "signature": "save_text(self, package: str, resource: str, text: str)",
          "documentation": {
            "description": "Save text data to the package.",
            "parameters": {
              "package": {
                "type": "str",
                "description": "The name of module package this resource should go it (e.g. ``\"my_package.my_subpackage\"``)."
              },
              "resource": {
                "type": "str",
                "description": "A unique name for the resource, used to identify it to load."
              },
              "text": {
                "type": "str",
                "description": "The contents to save."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "PackageImporter",
      "documentation": {
        "description": "Importers allow you to load code written to packages by :class:`PackageExporter`.\nCode is loaded in a hermetic way, using files from the package\nrather than the normal python import system. This allows\nfor the packaging of PyTorch model code and data so that it can be run\non a server or used in the future for transfer learning.\n\nThe importer for packages ensures that code in the module can only be loaded from\nwithin the package, except for modules explicitly listed as external during export.\nThe file ``extern_modules`` in the zip archive lists all the modules that a package externally depends on.\nThis prevents \"implicit\" dependencies where the package runs locally because it is importing\na locally-installed package, but then fails when the package is copied to another machine.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "file_structure",
          "signature": "file_structure(self, *, include: 'GlobPattern' = '**', exclude: 'GlobPattern' = ()) -> torch.package.file_structure_representation.Directory",
          "documentation": {
            "description": "Returns a file structure representation of package's zipfile.",
            "parameters": {
              "include": {
                "type": "Union[List[str], str]",
                "description": "An optional string e.g. ``\"my_package.my_subpackage\"``, or optional list of strings"
              },
              "for": {
                "type": "",
                "description": "the names of the files to be included in the zipfile representation. This can also be"
              },
              "a": {
                "type": "",
                "description": "glob-style pattern, as described in :meth:`PackageExporter.mock`"
              },
              "exclude": {
                "type": "Union[List[str], str]",
                "description": "An optional pattern that excludes files whose name match the pattern."
              }
            },
            "returns": ":class:`Directory`",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_name",
          "signature": "get_name(self, obj: Any, name: Optional[str] = None) -> Tuple[str, str]",
          "documentation": {
            "description": "Given an object, return a name that can be used to retrieve the\nobject from this environment.",
            "parameters": {
              "obj": {
                "type": "",
                "description": "An object to get the module-environment-relative name for."
              },
              "name": {
                "type": "",
                "description": "If set, use this name instead of looking up __name__ or __qualname__ on `obj`."
              },
              "This": {
                "type": "",
                "description": "is only here to match how Pickler handles __reduce__ functions that return a string,"
              },
              "don": {
                "type": "",
                "description": "'t use otherwise."
              }
            },
            "returns": "A tuple (parent_module_name, attr_name) that can be used to retrieve `obj` from this environment.\n    Use it like:\n        mod = importer.import_module(parent_module_name)\n        obj = getattr(mod, attr_name)",
            "raises": "ObjNotFoundError: we couldn't retrieve `obj by name.\n    ObjMisMatchError: we found a different object with the same name as `obj`.",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_resource_reader",
          "signature": "get_resource_reader(self, fullname)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_source",
          "signature": "get_source(self, module_name) -> str",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "id",
          "signature": "id(self)",
          "documentation": {
            "description": "Returns internal identifier that torch.package uses to distinguish :class:`PackageImporter` instances.\nLooks like::\n\n    <torch_package_0>",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "import_module",
          "signature": "import_module(self, name: str, package=None)",
          "documentation": {
            "description": "Load a module from the package if it hasn't already been loaded, and then return\nthe module. Modules are loaded locally\nto the importer and will appear in ``self.modules`` rather than ``sys.modules``.",
            "parameters": {
              "name": {
                "type": "str",
                "description": "Fully qualified name of the module to load."
              },
              "package": {
                "type": "[type], optional",
                "description": "Unused, but present to match the signature of importlib.import_module. Defaults to ``None``."
              }
            },
            "returns": "types.ModuleType: The (possibly already) loaded module.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "load_binary",
          "signature": "load_binary(self, package: str, resource: str) -> bytes",
          "documentation": {
            "description": "Load raw bytes.",
            "parameters": {
              "package": {
                "type": "str",
                "description": "The name of module package (e.g. ``\"my_package.my_subpackage\"``)."
              },
              "resource": {
                "type": "str",
                "description": "The unique name for the resource."
              }
            },
            "returns": "bytes: The loaded data.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "load_pickle",
          "signature": "load_pickle(self, package: str, resource: str, map_location=None) -> Any",
          "documentation": {
            "description": "Unpickles the resource from the package, loading any modules that are needed to construct the objects\nusing :meth:`import_module`.",
            "parameters": {
              "package": {
                "type": "str",
                "description": "The name of module package (e.g. ``\"my_package.my_subpackage\"``)."
              },
              "resource": {
                "type": "str",
                "description": "The unique name for the resource."
              },
              "map_location": {
                "type": "",
                "description": "Passed to `torch.load` to determine how tensors are mapped to devices. Defaults to ``None``."
              }
            },
            "returns": "Any: The unpickled object.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "load_text",
          "signature": "load_text(self, package: str, resource: str, encoding: str = 'utf-8', errors: str = 'strict') -> str",
          "documentation": {
            "description": "Load a string.",
            "parameters": {
              "package": {
                "type": "str",
                "description": "The name of module package (e.g. ``\"my_package.my_subpackage\"``)."
              },
              "resource": {
                "type": "str",
                "description": "The unique name for the resource."
              },
              "encoding": {
                "type": "str, optional",
                "description": "Passed to ``decode``. Defaults to ``'utf-8'``."
              },
              "errors": {
                "type": "str, optional",
                "description": "Passed to ``decode``. Defaults to ``'strict'``."
              }
            },
            "returns": "str: The loaded text.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "python_version",
          "signature": "python_version(self)",
          "documentation": {
            "description": "Returns the version of python that was used to create this package.",
            "parameters": {},
            "returns": ":class:`Optional[str]` a python version e.g. 3.8.9 or None if no version was stored with this package",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "whichmodule",
          "signature": "whichmodule(self, obj: Any, name: str) -> str",
          "documentation": {
            "description": "Find the module name an object belongs to.\n\nThis should be considered internal for end-users, but developers of\nan importer can override it to customize the behavior.\n\nTaken from pickle.py, but modified to exclude the search into sys.modules",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "PackagingError",
      "documentation": {
        "description": "This exception is raised when there is an issue with exporting a package.\n``PackageExporter`` will attempt to gather up all the errors and present\nthem to you at once.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "documentation": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    }
  ]
}