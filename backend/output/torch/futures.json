{
  "description": "No description available",
  "functions": [
    {
      "name": "Callable",
      "signature": "Callable(*args, **kwargs)",
      "documentation": {
        "description": "Deprecated alias to collections.abc.Callable.\n\nCallable[[int], str] signifies a function that takes a single\nparameter of type int and returns a str.\n\nThe subscription syntax must always be used with exactly two\nvalues: the argument list and the return type.\nThe argument list must be a list of types, a ParamSpec,\nConcatenate or ellipsis. The return type must be a single type.\n\nThere is no syntax to indicate optional or keyword arguments;\nsuch function types are rarely used as callback types.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "List",
      "signature": "List(*args, **kwargs)",
      "documentation": {
        "description": "A generic version of list.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "Optional",
      "signature": "Optional(*args, **kwds)",
      "documentation": {
        "description": "Optional[X] is equivalent to Union[X, None].",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "Type",
      "signature": "Type(*args, **kwargs)",
      "documentation": {
        "description": "Deprecated alias to builtins.type.\n\nbuiltins.type or typing.Type can be used to annotate class objects.\nFor example, suppose we have the following classes::\n\n    class User: ...  # Abstract base for User classes\n    class BasicUser(User): ...\n    class ProUser(User): ...\n    class TeamUser(User): ...\n\nAnd a function that takes a class argument that's a subclass of\nUser and returns an instance of the corresponding class::\n\n    def new_user[U](user_class: Type[U]) -> U:\n        user = user_class()\n        # (Here we could write the user object to a database)\n        return user\n\n    joe = new_user(BasicUser)\n\nAt this point the type checker knows that joe has type BasicUser.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "Union",
      "signature": "Union(*args, **kwds)",
      "documentation": {
        "description": "Union type; Union[X, Y] means either X or Y.\n\nOn Python 3.10 and higher, the | operator\ncan also be used to denote unions;\nX | Y means the same thing to the type checker as Union[X, Y].\n\nTo define a union, use e.g. Union[int, str]. Details:\n- The arguments must be types and there must be at least one.\n- None as an argument is a special case and is replaced by\n  type(None).\n- Unions of unions are flattened, e.g.::\n\n    assert Union[Union[int, str], float] == Union[int, str, float]\n\n- Unions of a single argument vanish, e.g.::\n\n    assert Union[int] == int  # The constructor actually returns int\n\n- Redundant arguments are skipped, e.g.::\n\n    assert Union[int, str, int] == Union[int, str]\n\n- When comparing unions, the argument order is ignored, e.g.::\n\n    assert Union[int, str] == Union[str, int]\n\n- You cannot subclass or instantiate a union.\n- You can use Optional[X] as a shorthand for Union[X, None].",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cast",
      "signature": "cast(typ, val)",
      "documentation": {
        "description": "Cast a value to a type.\n\nThis returns the value unchanged.  To the type checker this\nsignals that the return value has the designated type, but at\nruntime we intentionally don't check anything (we want this\nto be as fast as possible).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "collect_all",
      "signature": "collect_all(futures: 'List[Future]') -> 'Future[List[Future]]'",
      "documentation": {
        "description": "Collects the provided :class:`~torch.futures.Future` objects into a single\ncombined :class:`~torch.futures.Future` that is completed when all of the\nsub-futures are completed.",
        "parameters": {
          "futures": {
            "type": "list",
            "description": "a list of :class:`~torch.futures.Future` objects."
          }
        },
        "returns": "Returns a :class:`~torch.futures.Future` object to a list of the passed\n    in Futures.\n\nExample::\n    >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_FUTURES)\n    >>> fut0 = torch.futures.Future()\n    >>> fut1 = torch.futures.Future()\n    >>> fut = torch.futures.collect_all([fut0, fut1])\n    >>> fut0.set_result(0)\n    >>> fut1.set_result(1)\n    >>> fut_list = fut.wait()\n    >>> print(f\"fut0 result = {fut_list[0].wait()}\")\n    fut0 result = 0\n    >>> print(f\"fut1 result = {fut_list[1].wait()}\")\n    fut1 result = 1",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "wait_all",
      "signature": "wait_all(futures: 'List[Future]') -> 'List'",
      "documentation": {
        "description": "Waits for all provided futures to be complete, and returns\nthe list of completed values. If any of the futures encounters an error,\nthe method will exit early and report the error not waiting for other\nfutures to complete.",
        "parameters": {
          "futures": {
            "type": "list",
            "description": "a list of :class:`~torch.futures.Future` object."
          }
        },
        "returns": "A list of the completed :class:`~torch.futures.Future` results. This\n    method will throw an error if ``wait`` on any\n    :class:`~torch.futures.Future` throws.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": [
    {
      "name": "Future",
      "documentation": {
        "description": "Wrapper around a ``torch._C.Future`` which encapsulates an asynchronous\nexecution of a callable, e.g. :meth:`~torch.distributed.rpc.rpc_async`. It\nalso exposes a set of APIs to add callback functions and set results.\n\n.. warning:: GPU support is a beta feature, subject to changes.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_done_callback",
          "signature": "add_done_callback(self, callback: 'Callable[[Future[T]], None]') -> 'None'",
          "documentation": {
            "description": "Append the given callback function to this ``Future``, which will be run\nwhen the ``Future`` is completed.  Multiple callbacks can be added to\nthe same ``Future``, but the order in which they will be executed cannot\nbe guaranteed. The callback must take one argument, which is the\nreference to this ``Future``. The callback function can use the\n:meth:`value` method to get the value. Note that if this ``Future`` is\nalready completed, the given callback will be run inline.\n\nWe recommend that you use the :meth:`then` method as it provides a way\nto synchronize after your callback has completed. ``add_done_callback``\ncan be cheaper if your callback does not return anything. But both\n:meth:`then` and ``add_done_callback`` use the same callback\nregistration API under the hood.\n\nWith respect to GPU tensors, this method behaves in the same way as\n:meth:`then`.",
            "parameters": {
              "callback": {
                "type": "``Future``",
                "description": "a ``Callable`` that takes in one argument,"
              },
              "which": {
                "type": "",
                "description": "is the reference to this ``Future``.\n.. note:: Note that if the callback function throws, either"
              },
              "through": {
                "type": "",
                "description": "the original future being completed with an exception and"
              },
              "calling": {
                "type": "",
                "description": "``fut.wait()``, or through other code in the callback,"
              },
              "error": {
                "type": "",
                "description": "handling must be carefully taken care of. For example, if"
              },
              "this": {
                "type": "",
                "description": "callback later completes additional futures, those futures are"
              },
              "not": {
                "type": "",
                "description": "marked as completed with an error and the user is responsible"
              },
              "for": {
                "type": "",
                "description": "handling completion/waiting on those futures independently."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_FUTURES)\n>>> def callback(fut):\n...     print(\"This will run after the future has finished.\")\n...     print(fut.wait())\n>>> fut = torch.futures.Future()\n>>> fut.add_done_callback(callback)\n>>> fut.set_result(5)"
              },
              "This": {
                "type": "",
                "description": "will run after the future has finished."
              },
              "5": {
                "type": "",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "done",
          "signature": "done(self) -> 'bool'",
          "documentation": {
            "description": "Return ``True`` if this ``Future`` is done. A ``Future`` is done if it\nhas a result or an exception.\n\nIf the value contains tensors that reside on GPUs, ``Future.done()``\nwill return ``True`` even if the asynchronous kernels that are\npopulating those tensors haven't yet completed running on the device,\nbecause at such stage the result is already usable, provided one\nperforms the appropriate synchronizations (see :meth:`wait`).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_exception",
          "signature": "set_exception(self, result: 'T') -> 'None'",
          "documentation": {
            "description": "Set an exception for this ``Future``, which will mark this ``Future`` as\ncompleted with an error and trigger all attached callbacks. Note that\nwhen calling wait()/value() on this ``Future``, the exception set here\nwill be raised inline.",
            "parameters": {
              "result": {
                "type": "BaseException",
                "description": "the exception for this ``Future``."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_FUTURES)\n>>> fut = torch.futures.Future()\n>>> fut.set_exception(ValueError(\"foo\"))\n>>> fut.wait()"
              },
              "Traceback": {
                "type": "most recent call last",
                "description": "..."
              },
              "ValueError": {
                "type": "",
                "description": "foo"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_result",
          "signature": "set_result(self, result: 'T') -> 'None'",
          "documentation": {
            "description": "Set the result for this ``Future``, which will mark this ``Future`` as\ncompleted and trigger all attached callbacks. Note that a ``Future``\ncannot be marked completed twice.\n\nIf the result contains tensors that reside on GPUs, this method can be\ncalled even if the asynchronous kernels that are populating those\ntensors haven't yet completed running on the device, provided that the\nstreams on which those kernels were enqueued are set as the current ones\nwhen this method is called. Put simply, it's safe to call this method\nimmediately after launching those kernels, without any additional\nsynchronization, as long as one doesn't change streams in between. This\nmethod will record events on all the relevant current streams and will\nuse them to ensure proper scheduling for all the consumers of this\n``Future``.",
            "parameters": {
              "result": {
                "type": "object",
                "description": "the result object of this ``Future``."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_FUTURES)\n>>> import threading\n>>> import time\n>>> def slow_set_future(fut, value):\n...     time.sleep(0.5)\n...     fut.set_result(value)\n>>> fut = torch.futures.Future()\n>>> t = threading.Thread(\n...     target=slow_set_future,\n...     args=(fut, torch.ones(2) * 3)\n... )\n>>> t.start()\n>>> print(fut.wait())"
              },
              "tensor": {
                "type": "[3., 3.]",
                "description": ">>> t.join()"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "then",
          "signature": "then(self, callback: 'Callable[[Future[T]], S]') -> 'Future[S]'",
          "documentation": {
            "description": "Append the given callback function to this ``Future``, which will be run\nwhen the ``Future`` is completed.  Multiple callbacks can be added to\nthe same ``Future``, but the order in which they will be executed cannot\nbe guaranteed (to enforce a certain order consider chaining:\n``fut.then(cb1).then(cb2)``). The callback must take one argument, which\nis the reference to this ``Future``. The callback function can use the\n:meth:`value` method to get the value. Note that if this ``Future`` is\nalready completed, the given callback will be run immediately inline.\n\nIf the ``Future``'s value contains tensors that reside on GPUs, the\ncallback might be invoked while the async kernels that are populating\nthose tensors haven't yet finished executing on the device. However, the\ncallback will be invoked with some dedicated streams set as current\n(fetched from a global pool) which will be synchronized with those\nkernels. Hence any operation performed by the callback on these tensors\nwill be scheduled on the device after the kernels complete. In other\nwords, as long as the callback doesn't switch streams, it can safely\nmanipulate the result without any additional synchronization. This is\nsimilar to the non-blocking behavior of :meth:`wait`.\n\nSimilarly, if the callback returns a value that contains tensors that\nreside on a GPU, it can do so even if the kernels that are producing\nthese tensors are still running on the device, as long as the callback\ndidn't change streams during its execution. If one wants to change\nstreams, one must be careful to re-synchronize them with the original\nstreams, that is, those that were current when the callback was invoked.",
            "parameters": {
              "callback": {
                "type": "``Callable``",
                "description": "a ``Callable`` that takes this ``Future`` as"
              },
              "the": {
                "type": "",
                "description": "only argument."
              }
            },
            "returns": "A new ``Future`` object that holds the return value of the\n    ``callback`` and will be marked as completed when the given\n    ``callback`` finishes.\n\n.. note:: Note that if the callback function throws, either\n    through the original future being completed with an exception and\n    calling ``fut.wait()``, or through other code in the callback, the\n    future returned by ``then`` will be marked appropriately with the\n    encountered error. However, if this callback later completes\n    additional futures, those futures are not marked as completed with\n    an error and the user is responsible for handling completion/waiting\n    on those futures independently.\n\nExample::\n    >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_FUTURES)\n    >>> def callback(fut):\n    ...     print(f\"RPC return value is {fut.wait()}.\")\n    >>> fut = torch.futures.Future()\n    >>> # The inserted callback will print the return value when\n    >>> # receiving the response from \"worker1\"\n    >>> cb_fut = fut.then(callback)\n    >>> chain_cb_fut = cb_fut.then(\n    ...     lambda x : print(f\"Chained cb done. {x.wait()}\")\n    ... )\n    >>> fut.set_result(5)\n    RPC return value is 5.\n    Chained cb done. None",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "value",
          "signature": "value(self) -> 'T'",
          "documentation": {
            "description": "Obtain the value of an already-completed future.\n\nThis method should only be called after a call to :meth:`wait` has\ncompleted, or inside a callback function passed to :meth:`then`. In\nother cases this ``Future`` may not yet hold a value and calling\n``value()`` could fail.\n\nIf the value contains tensors that reside on GPUs, then this method will\n*not* perform any additional synchronization. This should be done\nbeforehand, separately, through a call to :meth:`wait` (except within\ncallbacks, for which it's already being taken care of by :meth:`then`).",
            "parameters": {},
            "returns": "The value held by this ``Future``. If the function (callback or RPC)\n    creating the value has thrown an error, this ``value()`` method will\n    also throw an error.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "wait",
          "signature": "wait(self) -> 'T'",
          "documentation": {
            "description": "Block until the value of this ``Future`` is ready.\n\nIf the value contains tensors that reside on GPUs, then an additional\nsynchronization is performed with the kernels (executing on the device)\nwhich may be asynchronously populating those tensors. Such sync is\nnon-blocking, which means that ``wait()`` will insert the necessary\ninstructions in the current streams to ensure that further operations\nenqueued on those streams will be properly scheduled after the async\nkernels but, once that is done, ``wait()`` will return, even if those\nkernels are still running. No further synchronization is required when\naccessing and using the values, as long as one doesn't change streams.",
            "parameters": {},
            "returns": "The value held by this ``Future``. If the function (callback or RPC)\n    creating the value has thrown an error, this ``wait`` method will\n    also throw an error.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "Generic",
      "documentation": {
        "description": "Abstract base class for generic types.\n\nOn Python 3.12 and newer, generic classes implicitly inherit from\nGeneric when they declare a parameter list after the class's name::\n\n    class Mapping[KT, VT]:\n        def __getitem__(self, key: KT) -> VT:\n            ...\n        # Etc.\n\nOn older versions of Python, however, generic classes have to\nexplicitly inherit from Generic.\n\nAfter a class has been declared to be generic, it can then be used as\nfollows::\n\n    def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n        try:\n            return mapping[key]\n        except KeyError:\n            return default",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "TypeVar",
      "documentation": {
        "description": "Type variable.\n\nThe preferred way to construct a type variable is via the dedicated\nsyntax for generic functions, classes, and type aliases::\n\n    class Sequence[T]:  # T is a TypeVar\n        ...\n\nThis syntax can also be used to create bound and constrained type\nvariables::\n\n    # S is a TypeVar bound to str\n    class StrSequence[S: str]:\n        ...\n\n    # A is a TypeVar constrained to str or bytes\n    class StrOrBytesSequence[A: (str, bytes)]:\n        ...\n\nHowever, if desired, reusable type variables can also be constructed\nmanually, like so::\n\n   T = TypeVar('T')  # Can be anything\n   S = TypeVar('S', bound=str)  # Can be any subtype of str\n   A = TypeVar('A', str, bytes)  # Must be exactly str or bytes\n\nType variables exist primarily for the benefit of static type\ncheckers.  They serve as the parameters for generic types as well\nas for generic function and type alias definitions.\n\nThe variance of type variables is inferred by type checkers when they\nare created through the type parameter syntax and when\n``infer_variance=True`` is passed. Manually created type variables may\nbe explicitly marked covariant or contravariant by passing\n``covariant=True`` or ``contravariant=True``. By default, manually\ncreated type variables are invariant. See PEP 484 and PEP 695 for more\ndetails.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    }
  ]
}