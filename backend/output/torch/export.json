{
  "description": "No description available",
  "functions": [
    {
      "name": "Callable",
      "signature": "Callable(*args, **kwargs)",
      "documentation": {
        "description": "Deprecated alias to collections.abc.Callable.\n\nCallable[[int], str] signifies a function that takes a single\nparameter of type int and returns a str.\n\nThe subscription syntax must always be used with exactly two\nvalues: the argument list and the return type.\nThe argument list must be a list of types, a ParamSpec,\nConcatenate or ellipsis. The return type must be a single type.\n\nThere is no syntax to indicate optional or keyword arguments;\nsuch function types are rarely used as callback types.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "Constraint",
      "signature": "Union(*args, **kwargs)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "Dict",
      "signature": "Dict(*args, **kwargs)",
      "documentation": {
        "description": "A generic version of dict.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "Dim",
      "signature": "Dim(name: str, *, min: Optional[int] = None, max: Optional[int] = None)",
      "documentation": {
        "description": ":func:`Dim` constructs a type analogous to a named symbolic integer with a range.\nIt can be used to describe multiple possible values of a dynamic tensor dimension.\nNote that different dynamic dimensions of the same tensor, or of different tensors,\ncan be described by the same type.",
        "parameters": {
          "name": {
            "type": "str",
            "description": "Human-readable name for debugging."
          },
          "min": {
            "type": "Optional[int]",
            "description": "Minimum possible value of given symbol (inclusive)"
          },
          "max": {
            "type": "Optional[int]",
            "description": "Maximum possible value of given symbol (inclusive)"
          }
        },
        "returns": "A type that can be used in dynamic shape specifications for tensors.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "FlattenFunc",
      "signature": "Callable(*args, **kwargs)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "FromDumpableContextFn",
      "signature": "Callable(*args, **kwargs)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "Iterator",
      "signature": "Iterator(*args, **kwargs)",
      "documentation": {
        "description": "A generic version of collections.abc.Iterator.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "List",
      "signature": "List(*args, **kwargs)",
      "documentation": {
        "description": "A generic version of list.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "Optional",
      "signature": "Optional(*args, **kwds)",
      "documentation": {
        "description": "Optional[X] is equivalent to Union[X, None].",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "PassType",
      "signature": "Callable(*args, **kwargs)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ToDumpableContextFn",
      "signature": "Callable(*args, **kwargs)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "Tuple",
      "signature": "Tuple(*args, **kwargs)",
      "documentation": {
        "description": "Deprecated alias to builtins.tuple.\n\nTuple[X, Y] is the cross-product type of X and Y.\n\nExample: Tuple[T1, T2] is a tuple of two elements corresponding\nto type variables T1 and T2.  Tuple[int, float, str] is a tuple\nof an int, a float and a string.\n\nTo specify a variable-length tuple of homogeneous type, use Tuple[T, ...].",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "Type",
      "signature": "Type(*args, **kwargs)",
      "documentation": {
        "description": "Deprecated alias to builtins.type.\n\nbuiltins.type or typing.Type can be used to annotate class objects.\nFor example, suppose we have the following classes::\n\n    class User: ...  # Abstract base for User classes\n    class BasicUser(User): ...\n    class ProUser(User): ...\n    class TeamUser(User): ...\n\nAnd a function that takes a class argument that's a subclass of\nUser and returns an instance of the corresponding class::\n\n    def new_user[U](user_class: Type[U]) -> U:\n        user = user_class()\n        # (Here we could write the user object to a database)\n        return user\n\n    joe = new_user(BasicUser)\n\nAt this point the type checker knows that joe has type BasicUser.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "UnflattenFunc",
      "signature": "Callable(*args, **kwargs)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "Union",
      "signature": "Union(*args, **kwds)",
      "documentation": {
        "description": "Union type; Union[X, Y] means either X or Y.\n\nOn Python 3.10 and higher, the | operator\ncan also be used to denote unions;\nX | Y means the same thing to the type checker as Union[X, Y].\n\nTo define a union, use e.g. Union[int, str]. Details:\n- The arguments must be types and there must be at least one.\n- None as an argument is a special case and is replaced by\n  type(None).\n- Unions of unions are flattened, e.g.::\n\n    assert Union[Union[int, str], float] == Union[int, str, float]\n\n- Unions of a single argument vanish, e.g.::\n\n    assert Union[int] == int  # The constructor actually returns int\n\n- Redundant arguments are skipped, e.g.::\n\n    assert Union[int, str, int] == Union[int, str]\n\n- When comparing unions, the argument order is ignored, e.g.::\n\n    assert Union[int, str] == Union[str, int]\n\n- You cannot subclass or instantiate a union.\n- You can use Optional[X] as a shorthand for Union[X, None].",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compatibility",
      "signature": "compatibility(is_backward_compatible: bool) -> Callable[[~_T], ~_T]",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "default_decompositions",
      "signature": "default_decompositions() -> 'CustomDecompTable'",
      "documentation": {
        "description": "This is the default decomposition table which contains decomposition of\nall ATEN operators to core aten opset. Use this API together with\n:func:`run_decompositions()`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "dims",
      "signature": "dims(*names: str, min: Optional[int] = None, max: Optional[int] = None)",
      "documentation": {
        "description": "Util to create multiple :func:`Dim` types.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "export",
      "signature": "export(mod: torch.nn.modules.module.Module, args: Tuple[Any, ...], kwargs: Optional[Dict[str, Any]] = None, *, dynamic_shapes: Union[Dict[str, Any], Tuple[Any], List[Any], NoneType] = None, strict: bool = True, preserve_module_call_signature: Tuple[str, ...] = ()) -> torch.export.exported_program.ExportedProgram",
      "documentation": {
        "description": ":func:`export` takes any nn.Module along with example inputs, and produces a traced graph representing\nonly the Tensor computation of the function in an Ahead-of-Time (AOT) fashion,\nwhich can subsequently be executed with different inputs or serialized.  The\ntraced graph (1) produces normalized operators in the functional ATen operator set\n(as well as any user-specified custom operators), (2) has eliminated all Python control\nflow and data structures (with certain exceptions), and (3) records the set of\nshape constraints needed to show that this normalization and control-flow elimination\nis sound for future inputs.\n\n**Soundness Guarantee**\n\nWhile tracing, :func:`export()` takes note of shape-related assumptions\nmade by the user program and the underlying PyTorch operator kernels.\nThe output :class:`ExportedProgram` is considered valid only when these\nassumptions hold true.\n\nTracing makes assumptions on the shapes (not values) of input tensors.\nSuch assumptions must be validated at graph capture time for :func:`export`\nto succeed. Specifically:\n\n- Assumptions on static shapes of input tensors are automatically validated without additional effort.\n- Assumptions on dynamic shape of input tensors require explicit specification\n  by using the :func:`Dim` API to construct dynamic dimensions and by associating\n  them with example inputs through the ``dynamic_shapes`` argument.\n\nIf any assumption can not be validated, a fatal error will be raised. When that happens,\nthe error message will include suggested fixes to the specification that are needed\nto validate the assumptions. For example :func:`export` might suggest the\nfollowing fix to the definition of a dynamic dimension ``dim0_x``, say appearing in the\nshape associated with input ``x``, that was previously defined as ``Dim(\"dim0_x\")``::\n\n    dim = Dim(\"dim0_x\", max=5)\n\nThis example means the generated code requires dimension 0 of input ``x`` to be less\nthan or equal to 5 to be valid. You can inspect the suggested fixes to dynamic dimension\ndefinitions and then copy them verbatim into your code without needing to change the\n``dynamic_shapes`` argument to your :func:`export` call.",
        "parameters": {
          "mod": {
            "type": "",
            "description": "We will trace the forward method of this module."
          },
          "args": {
            "type": "",
            "description": "Example positional inputs."
          },
          "kwargs": {
            "type": "",
            "description": "Optional example keyword inputs."
          },
          "dynamic_shapes": {
            "type": "",
            "description": ""
          },
          "An": {
            "type": "",
            "description": "optional argument where the type should either be:"
          },
          "1": {
            "type": "",
            "description": ") a dict from argument names of ``f`` to their dynamic shape specifications,"
          },
          "2": {
            "type": "",
            "description": ") a tuple that specifies dynamic shape specifications for each input in original order."
          },
          "If": {
            "type": "",
            "description": "you are specifying dynamism on keyword args, you will need to pass them in the order that"
          },
          "is": {
            "type": "",
            "description": "passed here."
          },
          "The": {
            "type": "",
            "description": "dynamic shape of a tensor argument can be specified as either\n(1) a dict from dynamic dimension indices to :func:`Dim` types, where it is"
          },
          "not": {
            "type": "",
            "description": "required to include static dimension indices in this dict, but when they are,"
          },
          "they": {
            "type": "",
            "description": "should be mapped to None; or (2) a tuple / list of :func:`Dim` types or None,"
          },
          "where": {
            "type": "",
            "description": "the :func:`Dim` types correspond to dynamic dimensions, and static dimensions"
          },
          "are": {
            "type": "",
            "description": "denoted by None. Arguments that are dicts or tuples / lists of tensors are"
          },
          "recursively": {
            "type": "",
            "description": "specified by using mappings or sequences of contained specifications."
          },
          "strict": {
            "type": "",
            "description": "When enabled (default), the export function will trace the program through"
          },
          "TorchDynamo": {
            "type": "",
            "description": "which will ensure the soundness of the resulting graph. Otherwise, the"
          },
          "exported": {
            "type": "",
            "description": "program will not validate the implicit assumptions baked into the graph and"
          },
          "may": {
            "type": "",
            "description": "cause behavior divergence between the original model and the exported one. This is"
          },
          "useful": {
            "type": "",
            "description": "when users need to workaround bugs in the tracer, or simply want incrementally"
          },
          "enable": {
            "type": "",
            "description": "safety in their models. Note that this does not affect the resulting IR spec"
          },
          "to": {
            "type": "",
            "description": "be different and the model will be serialized in the same way regardless of what value"
          },
          "WARNING": {
            "type": "",
            "description": "This option is experimental and use this at your own risk."
          }
        },
        "returns": "An :class:`ExportedProgram` containing the traced callable.\n\n**Acceptable input/output types**\n\nAcceptable types of inputs (for ``args`` and ``kwargs``) and outputs include:\n\n- Primitive types, i.e. ``torch.Tensor``, ``int``, ``float``, ``bool`` and ``str``.\n- Dataclasses, but they must be registered by calling :func:`register_dataclass` first.\n- (Nested) Data structures comprising of ``dict``, ``list``, ``tuple``, ``namedtuple`` and\n  ``OrderedDict`` containing all above types.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "export_for_inference",
      "signature": "export_for_inference(mod: torch.nn.modules.module.Module, args: Tuple[Any, ...], kwargs: Optional[Dict[str, Any]] = None, *, dynamic_shapes: Union[Dict[str, Any], Tuple[Any], List[Any], NoneType] = None, strict: bool = True, preserve_module_call_signature: Tuple[str, ...] = (), decomp_table: Optional[Dict[ForwardRef('OpOverload'), Optional[Callable]]] = None) -> torch.export.exported_program.ExportedProgram",
      "documentation": {
        "description": ":func:`export_for_inference` takes any nn.Module along with example inputs, and produces a traced graph representing\nonly the Tensor computation of the function in an Ahead-of-Time (AOT) fashion,\nwhich can subsequently be executed with different inputs or serialized. The\ntraced graph (1) produces normalized operators in the ATen operator set\n(as well as any user-specified custom operators) which is customizable via decomp_table,\n(2) has eliminated all Python control flow and data structures (with certain exceptions),\nand (3) records the set of shape constraints needed to show that this normalization and control-flow\nelimination is sound for future inputs. This API is for convenience use as it combines :func:`export_for_training` and\n:func:`run_decompositions`.\n\n**Soundness Guarantee**\n\nSee :func:`export()` docstring for more details.",
        "parameters": {
          "mod": {
            "type": "",
            "description": "We will trace the forward method of this module."
          },
          "args": {
            "type": "",
            "description": "Example positional inputs."
          },
          "kwargs": {
            "type": "",
            "description": "Optional example keyword inputs."
          },
          "dynamic_shapes": {
            "type": "",
            "description": ""
          },
          "An": {
            "type": "",
            "description": "optional argument where the type should either be:"
          },
          "1": {
            "type": "",
            "description": ") a dict from argument names of ``f`` to their dynamic shape specifications,"
          },
          "2": {
            "type": "",
            "description": ") a tuple that specifies dynamic shape specifications for each input in original order."
          },
          "If": {
            "type": "",
            "description": "you are specifying dynamism on keyword args, you will need to pass them in the order that"
          },
          "is": {
            "type": "",
            "description": "passed here."
          },
          "The": {
            "type": "",
            "description": "dynamic shape of a tensor argument can be specified as either\n(1) a dict from dynamic dimension indices to :func:`Dim` types, where it is"
          },
          "not": {
            "type": "",
            "description": "required to include static dimension indices in this dict, but when they are,"
          },
          "they": {
            "type": "",
            "description": "should be mapped to None; or (2) a tuple / list of :func:`Dim` types or None,"
          },
          "where": {
            "type": "",
            "description": "the :func:`Dim` types correspond to dynamic dimensions, and static dimensions"
          },
          "are": {
            "type": "",
            "description": "denoted by None. Arguments that are dicts or tuples / lists of tensors are"
          },
          "recursively": {
            "type": "",
            "description": "specified by using mappings or sequences of contained specifications."
          },
          "strict": {
            "type": "",
            "description": "When enabled (default), the export function will trace the program through"
          },
          "TorchDynamo": {
            "type": "",
            "description": "which will ensure the soundness of the resulting graph. Otherwise, the"
          },
          "exported": {
            "type": "",
            "description": "program will not validate the implicit assumptions baked into the graph and"
          },
          "may": {
            "type": "",
            "description": "cause behavior divergence between the original model and the exported one. This is"
          },
          "useful": {
            "type": "",
            "description": "when users need to workaround bugs in the tracer, or simply want incrementally"
          },
          "enable": {
            "type": "",
            "description": "safety in their models. Note that this does not affect the resulting IR spec"
          },
          "to": {
            "type": "",
            "description": "be different and the model will be serialized in the same way regardless of what value"
          },
          "WARNING": {
            "type": "",
            "description": "This option is experimental and use this at your own risk."
          },
          "decomp_table": {
            "type": "",
            "description": "See :func:`run_decompositions` for more details."
          }
        },
        "returns": "An :class:`ExportedProgram` containing the traced callable.\n\n**Acceptable input/output types**\n\nAcceptable types of inputs (for ``args`` and ``kwargs``) and outputs include:\n\n- Primitive types, i.e. ``torch.Tensor``, ``int``, ``float``, ``bool`` and ``str``.\n- Dataclasses, but they must be registered by calling :func:`register_dataclass` first.\n- (Nested) Data structures comprising of ``dict``, ``list``, ``tuple``, ``namedtuple`` and\n  ``OrderedDict`` containing all above types.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "export_for_training",
      "signature": "export_for_training(mod: torch.nn.modules.module.Module, args: Tuple[Any, ...], kwargs: Optional[Dict[str, Any]] = None, *, dynamic_shapes: Union[Dict[str, Any], Tuple[Any], List[Any], NoneType] = None, strict: bool = True, preserve_module_call_signature: Tuple[str, ...] = ()) -> torch.export.exported_program.ExportedProgram",
      "documentation": {
        "description": ":func:`export_for_training` takes any nn.Module along with example inputs, and produces a traced graph representing\nonly the Tensor computation of the function in an Ahead-of-Time (AOT) fashion,\nwhich can subsequently be executed with different inputs or serialized. The\ntraced graph (1) produces normalized operators in the all ATen operator set\n(as well as any user-specified custom operators), (2) has eliminated all Python control\nflow and data structures (with certain exceptions), and (3) records the set of\nshape constraints needed to show that this normalization and control-flow elimination\nis sound for future inputs. This API is intended for PT2 quantization training use cases\nand will soon be the default IR of torch.export.export in the near future. To read further about\nthe motivation behind this change, please refer to\nhttps://dev-discuss.pytorch.org/t/why-pytorch-does-not-need-a-new-standardized-operator-set/2206\nWith this API, and :func:`run_decompositions()`, you should be able to get inference IR with\nyour custom decomposition behaviour.\n\n**Soundness Guarantee**\n\nSee :func:`export()` docstring for more details.",
        "parameters": {
          "mod": {
            "type": "",
            "description": "We will trace the forward method of this module."
          },
          "args": {
            "type": "",
            "description": "Example positional inputs."
          },
          "kwargs": {
            "type": "",
            "description": "Optional example keyword inputs."
          },
          "dynamic_shapes": {
            "type": "",
            "description": ""
          },
          "An": {
            "type": "",
            "description": "optional argument where the type should either be:"
          },
          "1": {
            "type": "",
            "description": ") a dict from argument names of ``f`` to their dynamic shape specifications,"
          },
          "2": {
            "type": "",
            "description": ") a tuple that specifies dynamic shape specifications for each input in original order."
          },
          "If": {
            "type": "",
            "description": "you are specifying dynamism on keyword args, you will need to pass them in the order that"
          },
          "is": {
            "type": "",
            "description": "passed here."
          },
          "The": {
            "type": "",
            "description": "dynamic shape of a tensor argument can be specified as either\n(1) a dict from dynamic dimension indices to :func:`Dim` types, where it is"
          },
          "not": {
            "type": "",
            "description": "required to include static dimension indices in this dict, but when they are,"
          },
          "they": {
            "type": "",
            "description": "should be mapped to None; or (2) a tuple / list of :func:`Dim` types or None,"
          },
          "where": {
            "type": "",
            "description": "the :func:`Dim` types correspond to dynamic dimensions, and static dimensions"
          },
          "are": {
            "type": "",
            "description": "denoted by None. Arguments that are dicts or tuples / lists of tensors are"
          },
          "recursively": {
            "type": "",
            "description": "specified by using mappings or sequences of contained specifications."
          },
          "strict": {
            "type": "",
            "description": "When enabled (default), the export function will trace the program through"
          },
          "TorchDynamo": {
            "type": "",
            "description": "which will ensure the soundness of the resulting graph. Otherwise, the"
          },
          "exported": {
            "type": "",
            "description": "program will not validate the implicit assumptions baked into the graph and"
          },
          "may": {
            "type": "",
            "description": "cause behavior divergence between the original model and the exported one. This is"
          },
          "useful": {
            "type": "",
            "description": "when users need to workaround bugs in the tracer, or simply want incrementally"
          },
          "enable": {
            "type": "",
            "description": "safety in their models. Note that this does not affect the resulting IR spec"
          },
          "to": {
            "type": "",
            "description": "be different and the model will be serialized in the same way regardless of what value"
          },
          "WARNING": {
            "type": "",
            "description": "This option is experimental and use this at your own risk."
          }
        },
        "returns": "An :class:`ExportedProgram` containing the traced callable.\n\n**Acceptable input/output types**\n\nAcceptable types of inputs (for ``args`` and ``kwargs``) and outputs include:\n\n- Primitive types, i.e. ``torch.Tensor``, ``int``, ``float``, ``bool`` and ``str``.\n- Dataclasses, but they must be registered by calling :func:`register_dataclass` first.\n- (Nested) Data structures comprising of ``dict``, ``list``, ``tuple``, ``namedtuple`` and\n  ``OrderedDict`` containing all above types.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "load",
      "signature": "load(f: Union[str, os.PathLike, _io.BytesIO], *, extra_files: Optional[Dict[str, Any]] = None, expected_opset_version: Optional[Dict[str, int]] = None) -> torch.export.exported_program.ExportedProgram",
      "documentation": {
        "description": ".. warning::\n    Under active development, saved files may not be usable in newer versions\n    of PyTorch.\n\nLoads an :class:`ExportedProgram` previously saved with\n:func:`torch.export.save <torch.export.save>`.",
        "parameters": {
          "ep": {
            "type": "ExportedProgram",
            "description": "The exported program to save."
          },
          "f": {
            "type": "Union[str, os.PathLike, io.BytesIO",
            "description": "A file-like object (has to"
          },
          "implement": {
            "type": "",
            "description": "write and flush) or a string containing a file name."
          },
          "extra_files": {
            "type": "Optional[Dict[str, Any]]",
            "description": "The extra filenames given in"
          },
          "this": {
            "type": "",
            "description": "map would be loaded and their content would be stored in the"
          },
          "provided": {
            "type": "",
            "description": "map."
          },
          "expected_opset_version": {
            "type": "Optional[Dict[str, int]]",
            "description": "A map of opset names"
          },
          "to": {
            "type": "",
            "description": "expected opset versions"
          }
        },
        "returns": "An :class:`ExportedProgram` object\n\nExample::\n\n    import torch\n    import io\n\n    # Load ExportedProgram from file\n    ep = torch.export.load('exported_program.pt2')\n\n    # Load ExportedProgram from io.BytesIO object\n    with open('exported_program.pt2', 'rb') as f:\n        buffer = io.BytesIO(f.read())\n    buffer.seek(0)\n    ep = torch.export.load(buffer)\n\n    # Load with extra files.\n    extra_files = {'foo.txt': ''}  # values will be replaced with data\n    ep = torch.export.load('exported_program.pt2', extra_files=extra_files)\n    print(extra_files['foo.txt'])\n    print(ep(torch.randn(5)))",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "register_dataclass",
      "signature": "register_dataclass(cls: Type[Any], *, serialized_type_name: Optional[str] = None) -> None",
      "documentation": {
        "description": "Registers a dataclass as a valid input/output type for :func:`torch.export.export`.",
        "parameters": {
          "cls": {
            "type": "",
            "description": "the dataclass type to register"
          },
          "serialized_type_name": {
            "type": "",
            "description": "The serialized name for the dataclass. This is"
          },
          "required": {
            "type": "",
            "description": "if you want to serialize the pytree TreeSpec containing this"
          },
          "dataclass": {
            "type": "",
            "description": "."
          },
          "Example": {
            "type": "",
            "description": ":"
          },
          "import": {
            "type": "",
            "description": "torch"
          },
          "from": {
            "type": "",
            "description": "dataclasses import dataclass\n@dataclass"
          },
          "class": {
            "type": "",
            "description": "Mod(torch.nn.Module):"
          },
          "feature": {
            "type": "",
            "description": "torch.Tensor"
          },
          "bias": {
            "type": "",
            "description": "int\n@dataclass"
          },
          "res": {
            "type": "",
            "description": "= x.feature + x.bias"
          },
          "torch": {
            "type": "",
            "description": ".export.register_dataclass(OutputDataClass)"
          },
          "def": {
            "type": "",
            "description": "forward(self, x: InputDataClass) -> OutputDataClass:"
          },
          "return": {
            "type": "",
            "description": "OutputDataClass(res=res)"
          },
          "ep": {
            "type": "",
            "description": "= torch.export.export(Mod(), (InputDataClass(torch.ones(2, 2), 1), ))"
          },
          "print": {
            "type": "ep",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "save",
      "signature": "save(ep: torch.export.exported_program.ExportedProgram, f: Union[str, os.PathLike, _io.BytesIO], *, extra_files: Optional[Dict[str, Any]] = None, opset_version: Optional[Dict[str, int]] = None) -> None",
      "documentation": {
        "description": ".. warning::\n    Under active development, saved files may not be usable in newer versions\n    of PyTorch.\n\nSaves an :class:`ExportedProgram` to a file-like object. It can then be\nloaded using the Python API :func:`torch.export.load <torch.export.load>`.",
        "parameters": {
          "ep": {
            "type": "",
            "description": "= torch.export.export(MyModule(), (torch.randn(5),))\n# Save to file"
          },
          "f": {
            "type": "Union[str, os.PathLike, io.BytesIO",
            "description": "A file-like object (has to"
          },
          "implement": {
            "type": "",
            "description": "write and flush) or a string containing a file name."
          },
          "extra_files": {
            "type": "",
            "description": "= {'foo.txt': b'bar'.decode('utf-8')}"
          },
          "which": {
            "type": "",
            "description": "will be stored as part of f."
          },
          "opset_version": {
            "type": "Optional[Dict[str, int]]",
            "description": "A map of opset names"
          },
          "to": {
            "type": "",
            "description": "the version of this opset"
          },
          "Example": {
            "type": "",
            "description": ":"
          },
          "import": {
            "type": "",
            "description": "io"
          },
          "class": {
            "type": "",
            "description": "MyModule(torch.nn.Module):"
          },
          "def": {
            "type": "",
            "description": "forward(self, x):"
          },
          "return": {
            "type": "",
            "description": "x + 10"
          },
          "torch": {
            "type": "",
            "description": ".export.save(ep, 'exported_program.pt2', extra_files=extra_files)"
          },
          "buffer": {
            "type": "",
            "description": "= io.BytesIO()"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "unflatten",
      "signature": "unflatten(module: torch.export.exported_program.ExportedProgram, flat_args_adapter: Optional[torch.export.unflatten.FlatArgsAdapter] = None) -> torch.export.unflatten.UnflattenedModule",
      "documentation": {
        "description": "Unflatten an ExportedProgram, producing a module with the same module\nhierarchy as the original eager module. This can be useful if you are trying\nto use :mod:`torch.export` with another system that expects a module\nhierachy instead of the flat graph that :mod:`torch.export` usually produces.\n\n.. note:: The args/kwargs of unflattened modules will not necessarily match\n    the eager module, so doing a module swap (e.g. :code:`self.submod =\n    new_mod`) will not necessarily work. If you need to swap a module out, you\n    need to set the :code:`preserve_module_call_signature` parameter of\n    :func:`torch.export.export`.",
        "parameters": {
          "module": {
            "type": "ExportedProgram",
            "description": "The ExportedProgram to unflatten."
          },
          "flat_args_adapter": {
            "type": "Optional[FlatArgsAdapter]",
            "description": "Adapt flat args if input TreeSpec does not match with exported module's."
          }
        },
        "returns": "An instance of :class:`UnflattenedModule`, which has the same module\n    hierarchy as the original eager module pre-export.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": [
    {
      "name": "Any",
      "documentation": {
        "description": "Special type indicating an unconstrained type.\n\n- Any is compatible with every type.\n- Any assumed to have all methods.\n- All values assumed to be instances of Any.\n\nNote that all the above statements are true from the point of view of\nstatic type checkers. At runtime, Any should not be used with instance\nchecks.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "CustomDecompTable",
      "documentation": {
        "description": "This is a custom dictionary that is specifically used for handling decomp_table in export.\nThe reason we need this is because in the new world, you can only *delete* an op from decomp\ntable to preserve it. This is problematic for custom ops because we don't know when the custom\nop will actually be loaded to the dispatcher. As a result, we need to record the custom ops operations\nuntil we really need to materialize it (which is when we run decomposition pass.)\n\nInvariants we hold are:\n 1. All aten decomp is loaded at the init time\n 2. We materialize ALL ops when user ever reads from the table to make it more likely\n    that dispatcher picks up the custom op.\n 3. If it is write operation, we don't necessarily materialize\n 4. We load the final time during export, right before calling run_decompositions()",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "clear",
          "signature": "clear()",
          "documentation": {
            "description": "D.clear() -> None.  Remove all items from D.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(self) -> 'CustomDecompTable'",
          "documentation": {
            "description": "D.copy() -> a shallow copy of D",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fromkeys",
          "signature": "fromkeys(iterable, value=None, /)",
          "documentation": {
            "description": "Create a new dictionary with keys from iterable and values set to value.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get",
          "signature": "get(self, key, default=None, /)",
          "documentation": {
            "description": "Return the value for key if key is in the dictionary, else default.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "items",
          "signature": "items(self)",
          "documentation": {
            "description": "D.items() -> a set-like object providing a view on D's items",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "keys",
          "signature": "keys(self)",
          "documentation": {
            "description": "D.keys() -> a set-like object providing a view on D's keys",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "materialize",
          "signature": "materialize(self) -> Dict[torch._ops.OperatorBase, Callable]",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "pop",
          "signature": "pop(self, *args)",
          "documentation": {
            "description": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n\nIf the key is not found, return the default if given; otherwise,\nraise a KeyError.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "popitem",
          "signature": "popitem(self, /)",
          "documentation": {
            "description": "Remove and return a (key, value) pair as a 2-tuple.\n\nPairs are returned in LIFO (last-in, first-out) order.\nRaises KeyError if the dict is empty.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setdefault",
          "signature": "setdefault(self, key, default=None, /)",
          "documentation": {
            "description": "Insert key with a value of default if key is not in the dictionary.\n\nReturn the value for key if key is in the dictionary, else default.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "update",
          "signature": "update(self, other_dict)",
          "documentation": {
            "description": "D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.\nIf E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]\nIf E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\nIn either case, this is followed by: for k in F:  D[k] = F[k]",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "values",
          "signature": "values()",
          "documentation": {
            "description": "D.values() -> an object providing a view on D's values",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "Enum",
      "documentation": {
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "ExportBackwardSignature",
      "documentation": {
        "description": "ExportBackwardSignature(gradients_to_parameters: Dict[str, str], gradients_to_user_inputs: Dict[str, str], loss_output: str)",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "ExportGraphSignature",
      "documentation": {
        "description": ":class:`ExportGraphSignature` models the input/output signature of Export Graph,\nwhich is a fx.Graph with stronger invariants gurantees.\n\nExport Graph is functional and does not access \"states\" like parameters\nor buffers within the graph via ``getattr`` nodes. Instead, :func:`export`\ngurantees that parameters, buffers, and constant tensors are lifted out of\nthe graph as inputs.  Similarly, any mutations to buffers are not included\nin the graph either, instead the updated values of mutated buffers are\nmodeled as additional outputs of Export Graph.\n\nThe ordering of all inputs and outputs are::\n\n    Inputs = [*parameters_buffers_constant_tensors, *flattened_user_inputs]\n    Outputs = [*mutated_inputs, *flattened_user_outputs]\n\ne.g. If following module is exported::\n\n    class CustomModule(nn.Module):\n        def __init__(self) -> None:\n            super(CustomModule, self).__init__()\n\n            # Define a parameter\n            self.my_parameter = nn.Parameter(torch.tensor(2.0))\n\n            # Define two buffers\n            self.register_buffer('my_buffer1', torch.tensor(3.0))\n            self.register_buffer('my_buffer2', torch.tensor(4.0))\n\n        def forward(self, x1, x2):\n            # Use the parameter, buffers, and both inputs in the forward method\n            output = (x1 + self.my_parameter) * self.my_buffer1 + x2 * self.my_buffer2\n\n            # Mutate one of the buffers (e.g., increment it by 1)\n            self.my_buffer2.add_(1.0) # In-place addition\n\n            return output\n\nResulting Graph would be::\n\n    graph():\n        %arg0_1 := placeholder[target=arg0_1]\n        %arg1_1 := placeholder[target=arg1_1]\n        %arg2_1 := placeholder[target=arg2_1]\n        %arg3_1 := placeholder[target=arg3_1]\n        %arg4_1 := placeholder[target=arg4_1]\n        %add_tensor := call_function[target=torch.ops.aten.add.Tensor](args = (%arg3_1, %arg0_1), kwargs = {})\n        %mul_tensor := call_function[target=torch.ops.aten.mul.Tensor](args = (%add_tensor, %arg1_1), kwargs = {})\n        %mul_tensor_1 := call_function[target=torch.ops.aten.mul.Tensor](args = (%arg4_1, %arg2_1), kwargs = {})\n        %add_tensor_1 := call_function[target=torch.ops.aten.add.Tensor](args = (%mul_tensor, %mul_tensor_1), kwargs = {})\n        %add_tensor_2 := call_function[target=torch.ops.aten.add.Tensor](args = (%arg2_1, 1.0), kwargs = {})\n        return (add_tensor_2, add_tensor_1)\n\nResulting ExportGraphSignature would be::\n\n    ExportGraphSignature(\n        input_specs=[\n            InputSpec(kind=<InputKind.PARAMETER: 2>, arg=TensorArgument(name='arg0_1'), target='my_parameter'),\n            InputSpec(kind=<InputKind.BUFFER: 3>, arg=TensorArgument(name='arg1_1'), target='my_buffer1'),\n            InputSpec(kind=<InputKind.BUFFER: 3>, arg=TensorArgument(name='arg2_1'), target='my_buffer2'),\n            InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='arg3_1'), target=None),\n            InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='arg4_1'), target=None)\n        ],\n        output_specs=[\n            OutputSpec(kind=<OutputKind.BUFFER_MUTATION: 3>, arg=TensorArgument(name='add_2'), target='my_buffer2'),\n            OutputSpec(kind=<OutputKind.USER_OUTPUT: 1>, arg=TensorArgument(name='add_1'), target=None)\n        ]\n    )",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "get_replace_hook",
          "signature": "get_replace_hook(self, replace_inputs=False)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "replace_all_uses",
          "signature": "replace_all_uses(self, old: str, new: str)",
          "documentation": {
            "description": "Replace all uses of the old name with new name in the signature.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ExportedProgram",
      "documentation": {
        "description": "Package of a program from :func:`export`. It contains\nan :class:`torch.fx.Graph` that represents Tensor computation, a state_dict containing\ntensor values of all lifted parameters and buffers, and various metadata.\n\nYou can call an ExportedProgram like the original callable traced by\n:func:`export` with the same calling convention.\n\nTo perform transformations on the graph, use ``.module`` property to access\nan :class:`torch.fx.GraphModule`. You can then use\n`FX transformation <https://pytorch.org/docs/stable/fx.html#writing-transformations>`_\nto rewrite the graph. Afterwards, you can simply use :func:`export`\nagain to construct a correct ExportedProgram.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "buffers",
          "signature": "buffers(self) -> Iterator[torch.Tensor]",
          "documentation": {
            "description": "Returns an iterator over original module buffers.\n\n.. warning::\n    This API is experimental and is *NOT* backward-compatible.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "module",
          "signature": "module(self) -> torch.nn.modules.module.Module",
          "documentation": {
            "description": "Returns a self contained GraphModule with all the parameters/buffers inlined.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "named_buffers",
          "signature": "named_buffers(self) -> Iterator[Tuple[str, torch.Tensor]]",
          "documentation": {
            "description": "Returns an iterator over original module buffers, yielding\nboth the name of the buffer as well as the buffer itself.\n\n.. warning::\n    This API is experimental and is *NOT* backward-compatible.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "named_parameters",
          "signature": "named_parameters(self) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]]",
          "documentation": {
            "description": "Returns an iterator over original module parameters, yielding\nboth the name of the parameter as well as the parameter itself.\n\n.. warning::\n    This API is experimental and is *NOT* backward-compatible.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "parameters",
          "signature": "parameters(self) -> Iterator[torch.nn.parameter.Parameter]",
          "documentation": {
            "description": "Returns an iterator over original module's parameters.\n\n.. warning::\n    This API is experimental and is *NOT* backward-compatible.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "run_decompositions",
          "signature": "run_decompositions(self, decomp_table: Optional[Dict[torch._ops.OperatorBase, Callable]] = None) -> 'ExportedProgram'",
          "documentation": {
            "description": "Run a set of decompositions on the exported program and returns a new\nexported program. By default we will run the Core ATen decompositions to\nget operators in the\n`Core ATen Operator Set <https://pytorch.org/docs/stable/torch.compiler_ir.html>`_.\n\nFor now, we do not decompose joint graphs.",
            "parameters": {
              "decomp_table": {
                "type": "",
                "description": "[your_op] = your_custom_decomp"
              },
              "An": {
                "type": "",
                "description": "optional argument that specifies decomp behaviour for Aten ops\n(1) If None, we decompose to core aten decompositions\n(2) If empty, we don't decompose any operator"
              },
              "Some": {
                "type": "",
                "description": "examples:"
              },
              "If": {
                "type": "",
                "description": "you want to get a core aten operator set except for certain operator, you can do following:\n.. code-block:: python"
              },
              "ep": {
                "type": "",
                "description": "= ep.run_decompositions(decomp_table=decomp_table)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "validate",
          "signature": "validate(self)",
          "documentation": {
            "description": ".. warning::\n    This API is experimental and is *NOT* backward-compatible.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "FlatArgsAdapter",
      "documentation": {
        "description": "Adapts input arguments with ``input_spec`` to align ``target_spec``.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "adapt",
          "signature": "adapt(self, target_spec: torch.utils._pytree.TreeSpec, input_spec: torch.utils._pytree.TreeSpec, input_args: List[Any]) -> List[Any]",
          "documentation": {
            "description": "NOTE: This adapter may mutate given ``input_args_with_path``.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ModuleCallEntry",
      "documentation": {
        "description": "ModuleCallEntry(fqn: str, signature: Optional[torch.export.exported_program.ModuleCallSignature] = None)",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "ModuleCallSignature",
      "documentation": {
        "description": "ModuleCallSignature(inputs: List[Union[torch.export.graph_signature.TensorArgument, torch.export.graph_signature.SymIntArgument, torch.export.graph_signature.SymFloatArgument, torch.export.graph_signature.SymBoolArgument, torch.export.graph_signature.ConstantArgument, torch.export.graph_signature.CustomObjArgument, torch.export.graph_signature.TokenArgument]], outputs: List[Union[torch.export.graph_signature.TensorArgument, torch.export.graph_signature.SymIntArgument, torch.export.graph_signature.SymFloatArgument, torch.export.graph_signature.SymBoolArgument, torch.export.graph_signature.ConstantArgument, torch.export.graph_signature.CustomObjArgument, torch.export.graph_signature.TokenArgument]], in_spec: torch.utils._pytree.TreeSpec, out_spec: torch.utils._pytree.TreeSpec, forward_arg_names: Optional[List[str]] = None)",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "replace_all_uses_with",
          "signature": "replace_all_uses_with(self, original_node, new_node)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "PassManager",
      "documentation": {
        "description": "Construct a PassManager.\n\nCollects passes and constraints. This defines the pass schedule, manages\npass constraints and pass execution.",
        "parameters": {
          "passes": {
            "type": "Optional[List[Callable]]",
            "description": "List of passes. A pass is a"
          },
          "callable": {
            "type": "",
            "description": "which modifies an object and returns a PassResult"
          },
          "constraint": {
            "type": "",
            "description": "is a callable which takes two passes (A, B) and returns"
          },
          "True": {
            "type": "",
            "description": "if A depends on B and False otherwise. See implementation of\n`this_before_that_pass_constraint` for example."
          },
          "steps": {
            "type": "int",
            "description": "Max number of times we run the passes (default = 1)."
          },
          "run_checks_after_each_pass": {
            "type": "bool",
            "description": "Whether to run checks and linting"
          },
          "after": {
            "type": "",
            "description": "each pass"
          },
          "suppress_check_failures": {
            "type": "bool",
            "description": "Whether to raise errors when running"
          },
          "checks": {
            "type": "",
            "description": ".. warning::"
          },
          "This": {
            "type": "",
            "description": "API is experimental and is *NOT* backward-compatible."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_checks",
          "signature": "add_checks(self, check: Callable) -> None",
          "documentation": {
            "description": "Adds a function which takes runs various checks on a given graph module.\nThis function is run before and after each pass if the\n`run_checks_after_each_pass` flag is enabled.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "add_constraint",
          "signature": "add_constraint(self, constraint: Callable)",
          "documentation": {
            "description": "Adds a constraint into the current list of constraints.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "add_pass",
          "signature": "add_pass(self, _pass: Callable)",
          "documentation": {
            "description": "Adds a pass into the current list of passes.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "check",
          "signature": "check(self, module: torch.nn.modules.module.Module) -> None",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "solve_constraints",
          "signature": "solve_constraints(self)",
          "documentation": {
            "description": "Finds a valid traversal order based on the given constraints and orders\nthe passes based on this order.\n\nIf a circular dependency exists between the constraints and steps = 1,\nthen we will raise an error because if steps != 1 this means that we\nwill re-run the passes, allowing for circular dependencies.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "validate_constraints",
          "signature": "validate_constraints(self)",
          "documentation": {
            "description": "Validates that current pass schedule defined by `self.passes` is valid\naccording to all constraints in `self.constraints`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "PassResult",
      "documentation": {
        "description": "Result of a pass:\n    graph_module: The modified graph module\n    modified: A flag for if the pass has modified the graph module\n\n.. warning::\n    This API is experimental and is *NOT* backward-compatible.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "count",
          "signature": "count(self, value, /)",
          "documentation": {
            "description": "Return number of occurrences of value.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "index",
          "signature": "index(self, value, start=0, stop=9223372036854775807, /)",
          "documentation": {
            "description": "Return first index of value.\n\nRaises ValueError if the value is not present.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ShapesCollection",
      "documentation": {
        "description": "Builder for dynamic_shapes.\nUsed to assign dynamic shape specifications to tensors that appear in inputs.\n\nExample::\n    args = ({\"x\": tensor_x, \"others\": [tensor_y, tensor_z]})\n\n    dim = torch.export.Dim(...)\n    dynamic_shapes = torch.export.ShapesCollection()\n    dynamic_shapes[tensor_x] = (dim, dim + 1, 8)\n    dynamic_shapes[tensor_y] = {0: dim * 2}\n    # This is equivalent to the following (now auto-generated):\n    # dynamic_shapes = {\"x\": (dim, dim + 1, 8), \"others\": [{0: dim * 2}, None]}\n\n    torch.export(..., args, dynamic_shapes=dynamic_shapes)",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "dynamic_shapes",
          "signature": "dynamic_shapes(self, m, args, kwargs=None)",
          "documentation": {
            "description": "Generate dynamic_shapes.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "UnflattenedModule",
      "documentation": {
        "description": "Base class for all neural network modules.\n\nYour models should also subclass this class.\n\nModules can also contain other Modules, allowing them to be nested in\na tree structure. You can assign the submodules as regular attributes::\n\n    import torch.nn as nn\n    import torch.nn.functional as F\n\n    class Model(nn.Module):\n        def __init__(self) -> None:\n            super().__init__()\n            self.conv1 = nn.Conv2d(1, 20, 5)\n            self.conv2 = nn.Conv2d(20, 20, 5)\n\n        def forward(self, x):\n            x = F.relu(self.conv1(x))\n            return F.relu(self.conv2(x))\n\nSubmodules assigned in this way will be registered, and will also have their\nparameters converted when you call :meth:`to`, etc.\n\n.. note::\n    As per the example above, an ``__init__()`` call to the parent class\n    must be made before assignment on the child.\n\n:ivar training: Boolean represents whether this module is in training or\n                evaluation mode.\n:vartype training: bool",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_module",
          "signature": "add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None",
          "documentation": {
            "description": "Add a child module to the current module.\n\nThe module can be accessed as an attribute using the given name.",
            "parameters": {
              "name": {
                "type": "str",
                "description": "name of the child module. The child module can be"
              },
              "accessed": {
                "type": "",
                "description": "from this module using the given name"
              },
              "module": {
                "type": "Module",
                "description": "child module to be added to the module."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "apply",
          "signature": "apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T",
          "documentation": {
            "description": "Apply ``fn`` recursively to every submodule (as returned by ``.children()``) as well as self.\n\nTypical use includes initializing the parameters of a model\n(see also :ref:`nn-init-doc`).",
            "parameters": {
              "fn": {
                "type": ":class:`Module` -> None",
                "description": "function to be applied to each submodule"
              }
            },
            "returns": "Module: self\n\nExample::\n\n    >>> @torch.no_grad()\n    >>> def init_weights(m):\n    >>>     print(m)\n    >>>     if type(m) == nn.Linear:\n    >>>         m.weight.fill_(1.0)\n    >>>         print(m.weight)\n    >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))\n    >>> net.apply(init_weights)\n    Linear(in_features=2, out_features=2, bias=True)\n    Parameter containing:\n    tensor([[1., 1.],\n            [1., 1.]], requires_grad=True)\n    Linear(in_features=2, out_features=2, bias=True)\n    Parameter containing:\n    tensor([[1., 1.],\n            [1., 1.]], requires_grad=True)\n    Sequential(\n      (0): Linear(in_features=2, out_features=2, bias=True)\n      (1): Linear(in_features=2, out_features=2, bias=True)\n    )",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bfloat16",
          "signature": "bfloat16(self: ~T) -> ~T",
          "documentation": {
            "description": "Casts all floating point parameters and buffers to ``bfloat16`` datatype.\n\n.. note::\n    This method modifies the module in-place.",
            "parameters": {},
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "buffers",
          "signature": "buffers(self, recurse: bool = True) -> Iterator[torch.Tensor]",
          "documentation": {
            "description": "Return an iterator over module buffers.",
            "parameters": {
              "recurse": {
                "type": "bool",
                "description": "if True, then yields buffers of this module"
              },
              "and": {
                "type": "",
                "description": "all submodules. Otherwise, yields only buffers that"
              },
              "are": {
                "type": "",
                "description": "direct members of this module."
              },
              "Yields": {
                "type": "",
                "description": ""
              },
              "torch": {
                "type": "",
                "description": ".Tensor: module buffer"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> # xdoctest: +SKIP(\"undefined vars\")\n>>> for buf in model.buffers():\n>>>     print(type(buf), buf.size())\n<class 'torch.Tensor'> (20L,)\n<class 'torch.Tensor'> (20L, 1L, 5L, 5L)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "children",
          "signature": "children(self) -> Iterator[ForwardRef('Module')]",
          "documentation": {
            "description": "Return an iterator over immediate children modules.\n\nYields:\n    Module: a child module",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compile",
          "signature": "compile(self, *args, **kwargs)",
          "documentation": {
            "description": "Compile this Module's forward using :func:`torch.compile`.\n\nThis Module's `__call__` method is compiled and all arguments are passed as-is\nto :func:`torch.compile`.\n\nSee :func:`torch.compile` for details on the arguments for this function.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cpu",
          "signature": "cpu(self: ~T) -> ~T",
          "documentation": {
            "description": "Move all model parameters and buffers to the CPU.\n\n.. note::\n    This method modifies the module in-place.",
            "parameters": {},
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cuda",
          "signature": "cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T",
          "documentation": {
            "description": "Move all model parameters and buffers to the GPU.\n\nThis also makes associated parameters and buffers different objects. So\nit should be called before constructing the optimizer if the module will\nlive on GPU while being optimized.\n\n.. note::\n    This method modifies the module in-place.",
            "parameters": {
              "device": {
                "type": "int, optional",
                "description": "if specified, all parameters will be"
              },
              "copied": {
                "type": "",
                "description": "to that device"
              }
            },
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "double",
          "signature": "double(self: ~T) -> ~T",
          "documentation": {
            "description": "Casts all floating point parameters and buffers to ``double`` datatype.\n\n.. note::\n    This method modifies the module in-place.",
            "parameters": {},
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "eval",
          "signature": "eval(self: ~T) -> ~T",
          "documentation": {
            "description": "Set the module in evaluation mode.\n\nThis has an effect only on certain modules. See the documentation of\nparticular modules for details of their behaviors in training/evaluation\nmode, i.e. whether they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,\netc.\n\nThis is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.\n\nSee :ref:`locally-disable-grad-doc` for a comparison between\n`.eval()` and several similar mechanisms that may be confused with it.",
            "parameters": {},
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "extra_repr",
          "signature": "extra_repr(self) -> str",
          "documentation": {
            "description": "Return the extra representation of the module.\n\nTo print customized extra information, you should re-implement\nthis method in your own modules. Both single-line and multi-line\nstrings are acceptable.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "float",
          "signature": "float(self: ~T) -> ~T",
          "documentation": {
            "description": "Casts all floating point parameters and buffers to ``float`` datatype.\n\n.. note::\n    This method modifies the module in-place.",
            "parameters": {},
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "forward",
          "signature": "forward(self, *args, **kwargs)",
          "documentation": {
            "description": "Define the computation performed at every call.\n\nShould be overridden by all subclasses.\n\n.. note::\n    Although the recipe for forward pass needs to be defined within\n    this function, one should call the :class:`Module` instance afterwards\n    instead of this since the former takes care of running the\n    registered hooks while the latter silently ignores them.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_buffer",
          "signature": "get_buffer(self, target: str) -> 'Tensor'",
          "documentation": {
            "description": "Return the buffer given by ``target`` if it exists, otherwise throw an error.\n\nSee the docstring for ``get_submodule`` for a more detailed\nexplanation of this method's functionality as well as how to\ncorrectly specify ``target``.",
            "parameters": {
              "target": {
                "type": "",
                "description": "The fully-qualified string name of the buffer"
              },
              "to": {
                "type": "",
                "description": "look for. (See ``get_submodule`` for how to specify a"
              },
              "fully": {
                "type": "",
                "description": "-qualified string.)"
              }
            },
            "returns": "torch.Tensor: The buffer referenced by ``target``",
            "raises": "AttributeError: If the target string references an invalid\n        path or resolves to something that is not a\n        buffer",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_extra_state",
          "signature": "get_extra_state(self) -> Any",
          "documentation": {
            "description": "Return any extra state to include in the module's state_dict.\n\nImplement this and a corresponding :func:`set_extra_state` for your module\nif you need to store extra state. This function is called when building the\nmodule's `state_dict()`.\n\nNote that extra state should be picklable to ensure working serialization\nof the state_dict. We only provide backwards compatibility guarantees\nfor serializing Tensors; other objects may break backwards compatibility if\ntheir serialized pickled form changes.",
            "parameters": {},
            "returns": "object: Any extra state to store in the module's state_dict",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_parameter",
          "signature": "get_parameter(self, target: str) -> 'Parameter'",
          "documentation": {
            "description": "Return the parameter given by ``target`` if it exists, otherwise throw an error.\n\nSee the docstring for ``get_submodule`` for a more detailed\nexplanation of this method's functionality as well as how to\ncorrectly specify ``target``.",
            "parameters": {
              "target": {
                "type": "",
                "description": "The fully-qualified string name of the Parameter"
              },
              "to": {
                "type": "",
                "description": "look for. (See ``get_submodule`` for how to specify a"
              },
              "fully": {
                "type": "",
                "description": "-qualified string.)"
              }
            },
            "returns": "torch.nn.Parameter: The Parameter referenced by ``target``",
            "raises": "AttributeError: If the target string references an invalid\n        path or resolves to something that is not an\n        ``nn.Parameter``",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_submodule",
          "signature": "get_submodule(self, target: str) -> 'Module'",
          "documentation": {
            "description": "Return the submodule given by ``target`` if it exists, otherwise throw an error.\n\nFor example, let's say you have an ``nn.Module`` ``A`` that\nlooks like this:\n\n.. code-block:: text\n\n    A(\n        (net_b): Module(\n            (net_c): Module(\n                (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2))\n            )\n            (linear): Linear(in_features=100, out_features=200, bias=True)\n        )\n    )\n\n(The diagram shows an ``nn.Module`` ``A``. ``A`` which has a nested\nsubmodule ``net_b``, which itself has two submodules ``net_c``\nand ``linear``. ``net_c`` then has a submodule ``conv``.)\n\nTo check whether or not we have the ``linear`` submodule, we\nwould call ``get_submodule(\"net_b.linear\")``. To check whether\nwe have the ``conv`` submodule, we would call\n``get_submodule(\"net_b.net_c.conv\")``.\n\nThe runtime of ``get_submodule`` is bounded by the degree\nof module nesting in ``target``. A query against\n``named_modules`` achieves the same result, but it is O(N) in\nthe number of transitive modules. So, for a simple check to see\nif some submodule exists, ``get_submodule`` should always be\nused.",
            "parameters": {
              "target": {
                "type": "",
                "description": "The fully-qualified string name of the submodule"
              },
              "to": {
                "type": "",
                "description": "look for. (See above example for how to specify a"
              },
              "fully": {
                "type": "",
                "description": "-qualified string.)"
              }
            },
            "returns": "torch.nn.Module: The submodule referenced by ``target``",
            "raises": "AttributeError: If the target string references an invalid\n        path or resolves to something that is not an\n        ``nn.Module``",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "half",
          "signature": "half(self: ~T) -> ~T",
          "documentation": {
            "description": "Casts all floating point parameters and buffers to ``half`` datatype.\n\n.. note::\n    This method modifies the module in-place.",
            "parameters": {},
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ipu",
          "signature": "ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T",
          "documentation": {
            "description": "Move all model parameters and buffers to the IPU.\n\nThis also makes associated parameters and buffers different objects. So\nit should be called before constructing the optimizer if the module will\nlive on IPU while being optimized.\n\n.. note::\n    This method modifies the module in-place.",
            "parameters": {
              "device": {
                "type": "int, optional",
                "description": "if specified, all parameters will be"
              },
              "copied": {
                "type": "",
                "description": "to that device"
              }
            },
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "load_state_dict",
          "signature": "load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False)",
          "documentation": {
            "description": "Copy parameters and buffers from :attr:`state_dict` into this module and its descendants.\n\nIf :attr:`strict` is ``True``, then\nthe keys of :attr:`state_dict` must exactly match the keys returned\nby this module's :meth:`~torch.nn.Module.state_dict` function.\n\n.. warning::\n    If :attr:`assign` is ``True`` the optimizer must be created after\n    the call to :attr:`load_state_dict` unless\n    :func:`~torch.__future__.get_swap_module_params_on_conversion` is ``True``.",
            "parameters": {
              "state_dict": {
                "type": "dict",
                "description": "a dict containing parameters and"
              },
              "persistent": {
                "type": "",
                "description": "buffers."
              },
              "strict": {
                "type": "bool, optional",
                "description": "whether to strictly enforce that the keys"
              },
              "in": {
                "type": "",
                "description": "the current module are preserved whereas setting it to ``True`` preserves"
              },
              "assign": {
                "type": "bool, optional",
                "description": "When set to ``False``, the properties of the tensors"
              },
              "properties": {
                "type": "",
                "description": "of the Tensors in the state dict. The only"
              },
              "exception": {
                "type": "",
                "description": "is the ``requires_grad`` field of :class:`~torch.nn.Parameter`s"
              },
              "for": {
                "type": "",
                "description": "which the value from the module is preserved."
              },
              "Default": {
                "type": "",
                "description": "``False``"
              }
            },
            "returns": "``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:\n        * **missing_keys** is a list of str containing any keys that are expected\n            by this module but missing from the provided ``state_dict``.\n        * **unexpected_keys** is a list of str containing the keys that are not\n            expected by this module but present in the provided ``state_dict``.",
            "raises": "",
            "see_also": "",
            "notes": "If a parameter or buffer is registered as ``None`` and its corresponding key\n    exists in :attr:`state_dict`, :meth:`load_state_dict` will raise a\n    ``RuntimeError``.",
            "examples": ""
          }
        },
        {
          "name": "modules",
          "signature": "modules(self) -> Iterator[ForwardRef('Module')]",
          "documentation": {
            "description": "Return an iterator over all modules in the network.\n\nYields:\n    Module: a module in the network",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "Duplicate modules are returned only once. In the following\n    example, ``l`` will be returned only once.",
            "examples": ""
          }
        },
        {
          "name": "mtia",
          "signature": "mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T",
          "documentation": {
            "description": "Move all model parameters and buffers to the MTIA.\n\nThis also makes associated parameters and buffers different objects. So\nit should be called before constructing the optimizer if the module will\nlive on MTIA while being optimized.\n\n.. note::\n    This method modifies the module in-place.",
            "parameters": {
              "device": {
                "type": "int, optional",
                "description": "if specified, all parameters will be"
              },
              "copied": {
                "type": "",
                "description": "to that device"
              }
            },
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "named_buffers",
          "signature": "named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]]",
          "documentation": {
            "description": "Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself.",
            "parameters": {
              "prefix": {
                "type": "str",
                "description": "prefix to prepend to all buffer names."
              },
              "recurse": {
                "type": "bool, optional",
                "description": "if True, then yields buffers of this module"
              },
              "and": {
                "type": "",
                "description": "all submodules. Otherwise, yields only buffers that"
              },
              "are": {
                "type": "",
                "description": "direct members of this module. Defaults to True."
              },
              "remove_duplicate": {
                "type": "bool, optional",
                "description": "whether to remove the duplicated buffers in the result. Defaults to True."
              },
              "Yields": {
                "type": "",
                "description": "(str, torch.Tensor): Tuple containing the name and buffer"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> # xdoctest: +SKIP(\"undefined vars\")\n>>> for name, buf in self.named_buffers():\n>>>     if name in ['running_var']:\n>>>         print(buf.size())"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "named_children",
          "signature": "named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]]",
          "documentation": {
            "description": "Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself.\n\nYields:\n    (str, Module): Tuple containing a name and child module\n\nExample::\n\n    >>> # xdoctest: +SKIP(\"undefined vars\")\n    >>> for name, module in model.named_children():\n    >>>     if name in ['conv4', 'conv5']:\n    >>>         print(module)",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "named_modules",
          "signature": "named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True)",
          "documentation": {
            "description": "Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself.",
            "parameters": {
              "memo": {
                "type": "",
                "description": "a memo to store the set of modules already added to the result"
              },
              "prefix": {
                "type": "",
                "description": "a prefix that will be added to the name of the module"
              },
              "remove_duplicate": {
                "type": "",
                "description": "whether to remove the duplicated module instances in the result"
              },
              "or": {
                "type": "",
                "description": "not"
              },
              "Yields": {
                "type": "",
                "description": "(str, Module): Tuple of name and module"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "Duplicate modules are returned only once. In the following\n    example, ``l`` will be returned only once.",
            "examples": ""
          }
        },
        {
          "name": "named_parameters",
          "signature": "named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]]",
          "documentation": {
            "description": "Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself.",
            "parameters": {
              "prefix": {
                "type": "str",
                "description": "prefix to prepend to all parameter names."
              },
              "recurse": {
                "type": "bool",
                "description": "if True, then yields parameters of this module"
              },
              "and": {
                "type": "",
                "description": "all submodules. Otherwise, yields only parameters that"
              },
              "are": {
                "type": "",
                "description": "direct members of this module."
              },
              "remove_duplicate": {
                "type": "bool, optional",
                "description": "whether to remove the duplicated"
              },
              "parameters": {
                "type": "",
                "description": "in the result. Defaults to True."
              },
              "Yields": {
                "type": "",
                "description": "(str, Parameter): Tuple containing the name and parameter"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> # xdoctest: +SKIP(\"undefined vars\")\n>>> for name, param in self.named_parameters():\n>>>     if name in ['bias']:\n>>>         print(param.size())"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "parameters",
          "signature": "parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter]",
          "documentation": {
            "description": "Return an iterator over module parameters.\n\nThis is typically passed to an optimizer.",
            "parameters": {
              "recurse": {
                "type": "bool",
                "description": "if True, then yields parameters of this module"
              },
              "and": {
                "type": "",
                "description": "all submodules. Otherwise, yields only parameters that"
              },
              "are": {
                "type": "",
                "description": "direct members of this module."
              },
              "Yields": {
                "type": "",
                "description": ""
              },
              "Parameter": {
                "type": "",
                "description": "module parameter"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> # xdoctest: +SKIP(\"undefined vars\")\n>>> for param in model.parameters():\n>>>     print(type(param), param.size())\n<class 'torch.Tensor'> (20L,)\n<class 'torch.Tensor'> (20L, 1L, 5L, 5L)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "print_readable",
          "signature": "print_readable(self, print_output=True, include_stride=False, include_device=False, colored=False)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "process_forward_inputs",
          "signature": "process_forward_inputs(self, *args, **kwargs)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_backward_hook",
          "signature": "register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle",
          "documentation": {
            "description": "Register a backward hook on the module.\n\nThis function is deprecated in favor of :meth:`~torch.nn.Module.register_full_backward_hook` and\nthe behavior of this function will change in future versions.",
            "parameters": {},
            "returns": ":class:`torch.utils.hooks.RemovableHandle`:\n        a handle that can be used to remove the added hook by calling\n        ``handle.remove()``",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_buffer",
          "signature": "register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None",
          "documentation": {
            "description": "Add a buffer to the module.\n\nThis is typically used to register a buffer that should not to be\nconsidered a model parameter. For example, BatchNorm's ``running_mean``\nis not a parameter, but is part of the module's state. Buffers, by\ndefault, are persistent and will be saved alongside parameters. This\nbehavior can be changed by setting :attr:`persistent` to ``False``. The\nonly difference between a persistent buffer and a non-persistent buffer\nis that the latter will not be a part of this module's\n:attr:`state_dict`.\n\nBuffers can be accessed as attributes using given names.",
            "parameters": {
              "name": {
                "type": "str",
                "description": "name of the buffer. The buffer can be accessed"
              },
              "from": {
                "type": "",
                "description": "this module using the given name"
              },
              "tensor": {
                "type": "Tensor or None",
                "description": "buffer to be registered. If ``None``, then operations"
              },
              "that": {
                "type": "",
                "description": "run on buffers, such as :attr:`cuda`, are ignored. If ``None``,"
              },
              "the": {
                "type": "",
                "description": "buffer is **not** included in the module's :attr:`state_dict`."
              },
              "persistent": {
                "type": "bool",
                "description": "whether the buffer is part of this module's\n:attr:`state_dict`."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> # xdoctest: +SKIP(\"undefined vars\")\n>>> self.register_buffer('running_mean', torch.zeros(num_features))"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_forward_hook",
          "signature": "register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle",
          "documentation": {
            "description": "Register a forward hook on the module.\n\nThe hook will be called every time after :func:`forward` has computed an output.\n\nIf ``with_kwargs`` is ``False`` or not specified, the input contains only\nthe positional arguments given to the module. Keyword arguments won't be\npassed to the hooks and only to the ``forward``. The hook can modify the\noutput. It can modify the input inplace but it will not have effect on\nforward since this is called after :func:`forward` is called. The hook\nshould have the following signature::\n\n    hook(module, args, output) -> None or modified output\n\nIf ``with_kwargs`` is ``True``, the forward hook will be passed the\n``kwargs`` given to the forward function and be expected to return the\noutput possibly modified. The hook should have the following signature::\n\n    hook(module, args, kwargs, output) -> None or modified output",
            "parameters": {
              "hook": {
                "type": "Callable",
                "description": "The user defined hook to be registered."
              },
              "prepend": {
                "type": "bool",
                "description": "If ``True``, the provided ``hook`` will be fired"
              },
              "before": {
                "type": "",
                "description": "all existing ``forward`` hooks on this\n:class:`torch.nn.modules.Module`. Otherwise, the provided\n``hook`` will be fired after all existing ``forward`` hooks on"
              },
              "this": {
                "type": "",
                "description": "class:`torch.nn.modules.Module`. Note that global\n``forward`` hooks registered with\n:func:`register_module_forward_hook` will fire before all hooks"
              },
              "registered": {
                "type": "",
                "description": "by this method."
              },
              "Default": {
                "type": "",
                "description": "``False``"
              },
              "with_kwargs": {
                "type": "bool",
                "description": "If ``True``, the ``hook`` will be passed the"
              },
              "kwargs": {
                "type": "",
                "description": "given to the forward function."
              },
              "always_call": {
                "type": "bool",
                "description": "If ``True`` the ``hook`` will be run regardless of"
              },
              "whether": {
                "type": "",
                "description": "an exception is raised while calling the Module."
              }
            },
            "returns": ":class:`torch.utils.hooks.RemovableHandle`:\n        a handle that can be used to remove the added hook by calling\n        ``handle.remove()``",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_forward_pre_hook",
          "signature": "register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle",
          "documentation": {
            "description": "Register a forward pre-hook on the module.\n\nThe hook will be called every time before :func:`forward` is invoked.\n\n\nIf ``with_kwargs`` is false or not specified, the input contains only\nthe positional arguments given to the module. Keyword arguments won't be\npassed to the hooks and only to the ``forward``. The hook can modify the\ninput. User can either return a tuple or a single modified value in the\nhook. We will wrap the value into a tuple if a single value is returned\n(unless that value is already a tuple). The hook should have the\nfollowing signature::\n\n    hook(module, args) -> None or modified input\n\nIf ``with_kwargs`` is true, the forward pre-hook will be passed the\nkwargs given to the forward function. And if the hook modifies the\ninput, both the args and kwargs should be returned. The hook should have\nthe following signature::\n\n    hook(module, args, kwargs) -> None or a tuple of modified input and kwargs",
            "parameters": {
              "hook": {
                "type": "Callable",
                "description": "The user defined hook to be registered."
              },
              "prepend": {
                "type": "bool",
                "description": "If true, the provided ``hook`` will be fired before"
              },
              "all": {
                "type": "",
                "description": "existing ``forward_pre`` hooks on this\n:class:`torch.nn.modules.Module`. Otherwise, the provided\n``hook`` will be fired after all existing ``forward_pre`` hooks"
              },
              "on": {
                "type": "",
                "description": "this :class:`torch.nn.modules.Module`. Note that global\n``forward_pre`` hooks registered with\n:func:`register_module_forward_pre_hook` will fire before all"
              },
              "hooks": {
                "type": "",
                "description": "registered by this method."
              },
              "Default": {
                "type": "",
                "description": "``False``"
              },
              "with_kwargs": {
                "type": "bool",
                "description": "If true, the ``hook`` will be passed the kwargs"
              },
              "given": {
                "type": "",
                "description": "to the forward function."
              }
            },
            "returns": ":class:`torch.utils.hooks.RemovableHandle`:\n        a handle that can be used to remove the added hook by calling\n        ``handle.remove()``",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_full_backward_hook",
          "signature": "register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle",
          "documentation": {
            "description": "Register a backward hook on the module.\n\nThe hook will be called every time the gradients with respect to a module\nare computed, i.e. the hook will execute if and only if the gradients with\nrespect to module outputs are computed. The hook should have the following\nsignature::\n\n    hook(module, grad_input, grad_output) -> tuple(Tensor) or None\n\nThe :attr:`grad_input` and :attr:`grad_output` are tuples that contain the gradients\nwith respect to the inputs and outputs respectively. The hook should\nnot modify its arguments, but it can optionally return a new gradient with\nrespect to the input that will be used in place of :attr:`grad_input` in\nsubsequent computations. :attr:`grad_input` will only correspond to the inputs given\nas positional arguments and all kwarg arguments are ignored. Entries\nin :attr:`grad_input` and :attr:`grad_output` will be ``None`` for all non-Tensor\narguments.\n\nFor technical reasons, when this hook is applied to a Module, its forward function will\nreceive a view of each Tensor passed to the Module. Similarly the caller will receive a view\nof each Tensor returned by the Module's forward function.\n\n.. warning ::\n    Modifying inputs or outputs inplace is not allowed when using backward hooks and\n    will raise an error.",
            "parameters": {
              "hook": {
                "type": "Callable",
                "description": "The user-defined hook to be registered."
              },
              "prepend": {
                "type": "bool",
                "description": "If true, the provided ``hook`` will be fired before"
              },
              "all": {
                "type": "",
                "description": "hooks registered by this method."
              },
              "this": {
                "type": "",
                "description": "class:`torch.nn.modules.Module`. Note that global\n``backward`` hooks registered with\n:func:`register_module_full_backward_hook` will fire before"
              }
            },
            "returns": ":class:`torch.utils.hooks.RemovableHandle`:\n        a handle that can be used to remove the added hook by calling\n        ``handle.remove()``",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_full_backward_pre_hook",
          "signature": "register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle",
          "documentation": {
            "description": "Register a backward pre-hook on the module.\n\nThe hook will be called every time the gradients for the module are computed.\nThe hook should have the following signature::\n\n    hook(module, grad_output) -> tuple[Tensor] or None\n\nThe :attr:`grad_output` is a tuple. The hook should\nnot modify its arguments, but it can optionally return a new gradient with\nrespect to the output that will be used in place of :attr:`grad_output` in\nsubsequent computations. Entries in :attr:`grad_output` will be ``None`` for\nall non-Tensor arguments.\n\nFor technical reasons, when this hook is applied to a Module, its forward function will\nreceive a view of each Tensor passed to the Module. Similarly the caller will receive a view\nof each Tensor returned by the Module's forward function.\n\n.. warning ::\n    Modifying inputs inplace is not allowed when using backward hooks and\n    will raise an error.",
            "parameters": {
              "hook": {
                "type": "Callable",
                "description": "The user-defined hook to be registered."
              },
              "prepend": {
                "type": "bool",
                "description": "If true, the provided ``hook`` will be fired before"
              },
              "all": {
                "type": "",
                "description": "hooks registered by this method."
              },
              "on": {
                "type": "",
                "description": "this :class:`torch.nn.modules.Module`. Note that global\n``backward_pre`` hooks registered with\n:func:`register_module_full_backward_pre_hook` will fire before"
              }
            },
            "returns": ":class:`torch.utils.hooks.RemovableHandle`:\n        a handle that can be used to remove the added hook by calling\n        ``handle.remove()``",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_load_state_dict_post_hook",
          "signature": "register_load_state_dict_post_hook(self, hook)",
          "documentation": {
            "description": "Register a post-hook to be run after module's :meth:`~nn.Module.load_state_dict` is called.\n\nIt should have the following signature::\n    hook(module, incompatible_keys) -> None\n\nThe ``module`` argument is the current module that this hook is registered\non, and the ``incompatible_keys`` argument is a ``NamedTuple`` consisting\nof attributes ``missing_keys`` and ``unexpected_keys``. ``missing_keys``\nis a ``list`` of ``str`` containing the missing keys and\n``unexpected_keys`` is a ``list`` of ``str`` containing the unexpected keys.\n\nThe given incompatible_keys can be modified inplace if needed.\n\nNote that the checks performed when calling :func:`load_state_dict` with\n``strict=True`` are affected by modifications the hook makes to\n``missing_keys`` or ``unexpected_keys``, as expected. Additions to either\nset of keys will result in an error being thrown when ``strict=True``, and\nclearing out both missing and unexpected keys will avoid an error.",
            "parameters": {},
            "returns": ":class:`torch.utils.hooks.RemovableHandle`:\n        a handle that can be used to remove the added hook by calling\n        ``handle.remove()``",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_load_state_dict_pre_hook",
          "signature": "register_load_state_dict_pre_hook(self, hook)",
          "documentation": {
            "description": "Register a pre-hook to be run before module's :meth:`~nn.Module.load_state_dict` is called.\n\nIt should have the following signature::\n    hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None  # noqa: B950",
            "parameters": {
              "hook": {
                "type": "Callable",
                "description": "Callable hook that will be invoked before"
              },
              "loading": {
                "type": "",
                "description": "the state dict."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_module",
          "signature": "register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None",
          "documentation": {
            "description": "Alias for :func:`add_module`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_parameter",
          "signature": "register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None",
          "documentation": {
            "description": "Add a parameter to the module.\n\nThe parameter can be accessed as an attribute using given name.",
            "parameters": {
              "name": {
                "type": "str",
                "description": "name of the parameter. The parameter can be accessed"
              },
              "from": {
                "type": "",
                "description": "this module using the given name"
              },
              "param": {
                "type": "Parameter or None",
                "description": "parameter to be added to the module. If\n``None``, then operations that run on parameters, such as :attr:`cuda`,"
              },
              "are": {
                "type": "",
                "description": "ignored. If ``None``, the parameter is **not** included in the"
              },
              "module": {
                "type": "",
                "description": "'s :attr:`state_dict`."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_state_dict_post_hook",
          "signature": "register_state_dict_post_hook(self, hook)",
          "documentation": {
            "description": "Register a post-hook for the :meth:`~torch.nn.Module.state_dict` method.\n\nIt should have the following signature::\n    hook(module, state_dict, prefix, local_metadata) -> None\n\nThe registered hooks can modify the ``state_dict`` inplace.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_state_dict_pre_hook",
          "signature": "register_state_dict_pre_hook(self, hook)",
          "documentation": {
            "description": "Register a pre-hook for the :meth:`~torch.nn.Module.state_dict` method.\n\nIt should have the following signature::\n    hook(module, prefix, keep_vars) -> None\n\nThe registered hooks can be used to perform pre-processing before the ``state_dict``\ncall is made.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "requires_grad_",
          "signature": "requires_grad_(self: ~T, requires_grad: bool = True) -> ~T",
          "documentation": {
            "description": "Change if autograd should record operations on parameters in this module.\n\nThis method sets the parameters' :attr:`requires_grad` attributes\nin-place.\n\nThis method is helpful for freezing part of the module for finetuning\nor training parts of a model individually (e.g., GAN training).\n\nSee :ref:`locally-disable-grad-doc` for a comparison between\n`.requires_grad_()` and several similar mechanisms that may be confused with it.",
            "parameters": {
              "requires_grad": {
                "type": "bool",
                "description": "whether autograd should record operations on"
              },
              "parameters": {
                "type": "",
                "description": "in this module. Default: ``True``."
              }
            },
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_extra_state",
          "signature": "set_extra_state(self, state: Any) -> None",
          "documentation": {
            "description": "Set extra state contained in the loaded `state_dict`.\n\nThis function is called from :func:`load_state_dict` to handle any extra state\nfound within the `state_dict`. Implement this function and a corresponding\n:func:`get_extra_state` for your module if you need to store extra state within its\n`state_dict`.",
            "parameters": {
              "state": {
                "type": "dict",
                "description": "Extra state from the `state_dict`"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_submodule",
          "signature": "set_submodule(self, target: str, module: 'Module') -> None",
          "documentation": {
            "description": "Set the submodule given by ``target`` if it exists, otherwise throw an error.\n\nFor example, let's say you have an ``nn.Module`` ``A`` that\nlooks like this:\n\n.. code-block:: text\n\n    A(\n        (net_b): Module(\n            (net_c): Module(\n                (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2))\n            )\n            (linear): Linear(in_features=100, out_features=200, bias=True)\n        )\n    )\n\n(The diagram shows an ``nn.Module`` ``A``. ``A`` has a nested\nsubmodule ``net_b``, which itself has two submodules ``net_c``\nand ``linear``. ``net_c`` then has a submodule ``conv``.)\n\nTo overide the ``Conv2d`` with a new submodule ``Linear``, you\nwould call\n``set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16))``.",
            "parameters": {
              "target": {
                "type": "",
                "description": "The fully-qualified string name of the submodule"
              },
              "to": {
                "type": "",
                "description": "look for. (See above example for how to specify a"
              },
              "fully": {
                "type": "",
                "description": "-qualified string.)"
              },
              "module": {
                "type": "",
                "description": "The module to set the submodule to."
              }
            },
            "returns": "",
            "raises": "ValueError: If the target string is empty\n    AttributeError: If the target string references an invalid\n        path or resolves to something that is not an\n        ``nn.Module``",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "share_memory",
          "signature": "share_memory(self: ~T) -> ~T",
          "documentation": {
            "description": "See :meth:`torch.Tensor.share_memory_`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "state_dict",
          "signature": "state_dict(self, *args, destination=None, prefix='', keep_vars=False)",
          "documentation": {
            "description": "Return a dictionary containing references to the whole state of the module.\n\nBoth parameters and persistent buffers (e.g. running averages) are\nincluded. Keys are corresponding parameter and buffer names.\nParameters and buffers set to ``None`` are not included.\n\n.. note::\n    The returned object is a shallow copy. It contains references\n    to the module's parameters and buffers.\n\n.. warning::\n    Currently ``state_dict()`` also accepts positional arguments for\n    ``destination``, ``prefix`` and ``keep_vars`` in order. However,\n    this is being deprecated and keyword arguments will be enforced in\n    future releases.\n\n.. warning::\n    Please avoid the use of argument ``destination`` as it is not\n    designed for end-users.",
            "parameters": {
              "destination": {
                "type": "dict, optional",
                "description": "If provided, the state of module will"
              },
              "be": {
                "type": "",
                "description": "updated into the dict and the same object is returned."
              },
              "Otherwise": {
                "type": "",
                "description": ", an ``OrderedDict`` will be created and returned."
              },
              "Default": {
                "type": "",
                "description": "``False``."
              },
              "prefix": {
                "type": "str, optional",
                "description": "a prefix added to parameter and buffer"
              },
              "names": {
                "type": "",
                "description": "to compose the keys in state_dict. Default: ``''``."
              },
              "keep_vars": {
                "type": "bool, optional",
                "description": "by default the :class:`~torch.Tensor` s"
              },
              "returned": {
                "type": "",
                "description": "in the state dict are detached from autograd. If it's"
              },
              "set": {
                "type": "",
                "description": "to ``True``, detaching will not be performed."
              }
            },
            "returns": "dict:\n        a dictionary containing a whole state of the module\n\nExample::\n\n    >>> # xdoctest: +SKIP(\"undefined vars\")\n    >>> module.state_dict().keys()\n    ['bias', 'weight']",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to",
          "signature": "to(self, *args, **kwargs)",
          "documentation": {
            "description": "Move and/or cast the parameters and buffers.\n\nThis can be called as\n\n.. function:: to(device=None, dtype=None, non_blocking=False)\n   :noindex:\n\n.. function:: to(dtype, non_blocking=False)\n   :noindex:\n\n.. function:: to(tensor, non_blocking=False)\n   :noindex:\n\n.. function:: to(memory_format=torch.channels_last)\n   :noindex:\n\nIts signature is similar to :meth:`torch.Tensor.to`, but only accepts\nfloating point or complex :attr:`dtype`\\ s. In addition, this method will\nonly cast the floating point or complex parameters and buffers to :attr:`dtype`\n(if given). The integral parameters and buffers will be moved\n:attr:`device`, if that is given, but with dtypes unchanged. When\n:attr:`non_blocking` is set, it tries to convert/move asynchronously\nwith respect to the host if possible, e.g., moving CPU Tensors with\npinned memory to CUDA devices.\n\nSee below for examples.\n\n.. note::\n    This method modifies the module in-place.",
            "parameters": {
              "device": {
                "type": ":class:`torch.device`",
                "description": "the desired device of the parameters"
              },
              "and": {
                "type": "",
                "description": "buffers in this module"
              },
              "dtype": {
                "type": "",
                "description": "and device for all parameters and buffers in this module"
              },
              "the": {
                "type": "",
                "description": "parameters and buffers in this module"
              },
              "tensor": {
                "type": "torch.Tensor",
                "description": "Tensor whose dtype and device are the desired"
              },
              "memory_format": {
                "type": ":class:`torch.memory_format`",
                "description": "the desired memory"
              },
              "format": {
                "type": "",
                "description": "for 4D parameters and buffers in this module (keyword"
              },
              "only": {
                "type": "",
                "description": "argument)"
              }
            },
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to_empty",
          "signature": "to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T",
          "documentation": {
            "description": "Move the parameters and buffers to the specified device without copying storage.",
            "parameters": {
              "device": {
                "type": ":class:`torch.device`",
                "description": "The desired device of the parameters"
              },
              "and": {
                "type": "",
                "description": "buffers in this module."
              },
              "recurse": {
                "type": "bool",
                "description": "Whether parameters and buffers of submodules should"
              },
              "be": {
                "type": "",
                "description": "recursively moved to the specified device."
              }
            },
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "train",
          "signature": "train(self: ~T, mode: bool = True) -> ~T",
          "documentation": {
            "description": "Set the module in training mode.\n\nThis has an effect only on certain modules. See the documentation of\nparticular modules for details of their behaviors in training/evaluation\nmode, i.e., whether they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,\netc.",
            "parameters": {
              "mode": {
                "type": "``False``",
                "description": ". Default: ``True``."
              }
            },
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "type",
          "signature": "type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T",
          "documentation": {
            "description": "Casts all parameters and buffers to :attr:`dst_type`.\n\n.. note::\n    This method modifies the module in-place.",
            "parameters": {
              "dst_type": {
                "type": "type or string",
                "description": "the desired type"
              }
            },
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "xpu",
          "signature": "xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T",
          "documentation": {
            "description": "Move all model parameters and buffers to the XPU.\n\nThis also makes associated parameters and buffers different objects. So\nit should be called before constructing optimizer if the module will\nlive on XPU while being optimized.\n\n.. note::\n    This method modifies the module in-place.",
            "parameters": {
              "device": {
                "type": "int, optional",
                "description": "if specified, all parameters will be"
              },
              "copied": {
                "type": "",
                "description": "to that device"
              }
            },
            "returns": "Module: self",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "zero_grad",
          "signature": "zero_grad(self, set_to_none: bool = True) -> None",
          "documentation": {
            "description": "Reset gradients of all model parameters.\n\nSee similar function under :class:`torch.optim.Optimizer` for more context.",
            "parameters": {
              "set_to_none": {
                "type": "bool",
                "description": "instead of setting to zero, set the grads to None."
              },
              "See": {
                "type": "",
                "description": "meth:`torch.optim.Optimizer.zero_grad` for details."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "auto",
      "documentation": {
        "description": "Instances are replaced with an appropriate value in Enum class suites.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    }
  ]
}