{
  "description": "No description available",
  "functions": [
    {
      "name": "Callable",
      "signature": "Callable(*args, **kwargs)",
      "documentation": {
        "description": "Deprecated alias to collections.abc.Callable.\n\nCallable[[int], str] signifies a function that takes a single\nparameter of type int and returns a str.\n\nThe subscription syntax must always be used with exactly two\nvalues: the argument list and the return type.\nThe argument list must be a list of types, a ParamSpec,\nConcatenate or ellipsis. The return type must be a single type.\n\nThere is no syntax to indicate optional or keyword arguments;\nsuch function types are rarely used as callback types.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "List",
      "signature": "List(*args, **kwargs)",
      "documentation": {
        "description": "A generic version of list.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "allow_in_graph",
      "signature": "allow_in_graph(fn)",
      "documentation": {
        "description": "Tells the compiler frontend (Dynamo) to skip symbolic introspection of the function\nand instead directly write it to the graph when encountered.\n\nIf you are using :func:`torch.compile` (with backend=\"inductor\" (the default)), or\n:func:`torch.export.export`, and trying to black-box a Python function throughout\nall tracing, do not use this API.\nInstead, please create a custom operator (see `PyTorch Custom Operators Landing Page\n<https://pytorch.org/tutorials/advanced/custom_ops_landing_page.html>`_)\n\n.. warning::\n\n    If you're a typical torch.compile user (e.g. you're applying torch.compile to\n    a model to make it run faster), you probably don't want to use this function.\n    :func:`allow_in_graph` is a footgun because it skips the compiler frontend\n    (Dynamo) that is responsible for doing safety checks (graph breaks, handling\n    closures, etc). Incorrect usage will lead to difficult-to-debug silent\n    incorrectness issues.\n\nGiven a Python function with no allow_in_graph decorator, regular execution\nof torch.compile traces through the function. :func:`allow_in_graph` changes\nit so that the frontend does not trace inside the function, but the compiler\nbackend still traces through it. Compare this to custom operators, which\ntreats a function as a black box throughout the torch.compile stack. The following\ntable compares these mechanisms.\n\n+------------------------+-----------------------+--------------------------------+\n| Mechanism              | Frontend (Dynamo)     | Backend (AOTAutograd+Inductor) |\n+========================+=======================+================================+\n| no decorator           | trace inside          | trace inside                   |\n+------------------------+-----------------------+--------------------------------+\n| allow_in_graph         | opaque callable       | trace inside                   |\n+------------------------+-----------------------+--------------------------------+\n| custom op              | opaque callable       | opaque callable                |\n+------------------------+-----------------------+--------------------------------+\n\nOne common use case for :func:`allow_in_graph()` is as an escape hatch for the compiler\nfrontend: if you know the function works w.r.t. to the downstream components of the\ncompilation stack (AOTAutograd and Inductor) but there is a Dynamo bug that prevents it from\nsymbolically introspecting the function properly (or if your code is in C/C++ and\ntherefore cannot be introspected with Dynamo), then one can decorate said function\nwith :func:`allow_in_graph` to bypass Dynamo.\n\nWe require that ``fn`` adhere to the following restrictions. Failure to adhere\nresults in undefined behavior:\n\n- The inputs to ``fn`` must be Proxy-able types in the FX graph. Valid types include:\n  Tensor/int/bool/float/None/List[Tensor?]/List[int?]/List[float?]\n  Tuple[Tensor?, ...]/Tuple[int?, ...]/Tuple[float?, ...]/torch.dtype/torch.device\n- The outputs to ``fn`` must be Proxy-able types in the FX graph (see previous bullet)\n- all Tensors used inside of ``fn`` must be passed directly as inputs to ``fn``\n  (as opposed to being captured variables).",
        "parameters": {
          "fn": {
            "type": "...",
            "description": ""
          },
          "If": {
            "type": "",
            "description": "``fn`` is a list or tuple of callables it recursively applies\n:func:`allow_in_graph()` to each function and returns a new list or"
          },
          "tuple": {
            "type": "",
            "description": "containing the modified functions."
          },
          "Example": {
            "type": "",
            "description": ":"
          },
          "torch": {
            "type": "",
            "description": ".compiler.allow_in_graph(my_custom_function)\n@torch.compile(...)"
          },
          "def": {
            "type": "",
            "description": "fn(x):"
          },
          "x": {
            "type": "",
            "description": "= torch.add(x, 1)"
          },
          "return": {
            "type": "",
            "description": "x"
          },
          "Will": {
            "type": "",
            "description": "capture a single graph containing ``my_custom_function()``."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "assume_constant_result",
      "signature": "assume_constant_result(fn)",
      "documentation": {
        "description": "This function is used to mark a function `fn` as having a constant result.\nThis allows the compiler to optimize away your function\nReturns The same function `fn`",
        "parameters": {
          "fn": {
            "type": "",
            "description": "The function to be marked as having a constant result.\n.. warning::\n`assume_constant_result` can if invalid cause safety and soundness issues, :func:`torch.compile`"
          },
          "will": {
            "type": "",
            "description": "not attempt to validate whether the constant assumption is true or not"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compile",
      "signature": "compile(*args, **kwargs)",
      "documentation": {
        "description": "See :func:`torch.compile` for details on the arguments for this function.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cudagraph_mark_step_begin",
      "signature": "cudagraph_mark_step_begin()",
      "documentation": {
        "description": "Indicates that a new iteration of inference or training is about to begin.\n\nCUDA Graphs will free tensors of a prior iteration. A new iteration is started on each invocation of\ntorch.compile, so long as there is not a pending backward that has not been called.\n\nIf that heuristic is wrong, such as in the following example, manually mark it with this api.\n\n.. code-block:: python\n\n    @torch.compile(mode=\"reduce-overhead\")\n    def rand_foo():\n        return torch.rand([4], device=\"cuda\")\n\n    for _ in range(5):\n        torch.compiler.cudagraph_mark_step_begin()\n        rand_foo() + rand_foo()\n\nFor more details, see `torch.compiler_cudagraph_trees <https://pytorch.org/docs/main/torch.compiler_cudagraph_trees.html>`__",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "disable",
      "signature": "disable(fn=None, recursive=True)",
      "documentation": {
        "description": "This function provides a decorator to disable compilation on a function\nIt also provides the option of recursively disabling called functions",
        "parameters": {
          "fn": {
            "type": "optional",
            "description": "The function to disable"
          },
          "recursive": {
            "type": "optional",
            "description": "A boolean value indicating whether the disabling should be recursive."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "is_compiling",
      "signature": "is_compiling() -> bool",
      "documentation": {
        "description": "Indicates whether a graph is executed/traced as part of torch.compile() or torch.export().\n\nNote that there are 2 other related flags that should deprecated eventually:\n  * torch._dynamo.external_utils.is_compiling()\n  * torch._utils.is_compiling()\n\nExample::\n\n    >>> def forward(self, x):\n    >>>     if not torch.compiler.is_compiling():\n    >>>        pass # ...logic that is not needed in a compiled/traced graph...\n    >>>\n    >>>     # ...rest of the function...",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "is_dynamo_compiling",
      "signature": "is_dynamo_compiling() -> bool",
      "documentation": {
        "description": "Indicates whether a graph is traced via TorchDynamo.\n\nIt's stricter than is_compiling() flag, as it would only be set to True when\nTorchDynamo is used.\n\nExample::\n\n    >>> def forward(self, x):\n    >>>     if not torch.compiler.is_dynamo_compiling():\n    >>>        pass # ...logic that is not needed in a TorchDynamo-traced graph...\n    >>>\n    >>>     # ...rest of the function...",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "list_backends",
      "signature": "list_backends(exclude_tags=('debug', 'experimental')) -> List[str]",
      "documentation": {
        "description": "Return valid strings that can be passed to `torch.compile(..., backend=\"name\")`.",
        "parameters": {
          "exclude_tags": {
            "type": "optional",
            "description": "A tuple of strings representing tags to exclude."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "reset",
      "signature": "reset() -> None",
      "documentation": {
        "description": "This function clears all compilation caches and restores the system to its initial state.\nIt is recommended to call this function, especially after using operations like `torch.compile(...)`\nto ensure a clean state before another unrelated compilation",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "set_stance",
      "signature": "set_stance(stance: str = 'default', *, skip_guard_eval_unsafe=False, force_backend=None)",
      "documentation": {
        "description": "Set the current stance of the compiler.\nCan be used as a function, context manager, or decorator.\nDo not use this function inside a `torch.compile` region - an error will be raised otherwise.\n\n.. code-block:: python\n\n    @torch.compile\n    def foo(x):\n        ...\n\n    @torch.compiler.set_stance(\"force_eager\")\n    def bar():\n        # will not be compiled\n        foo(...)\n\n    bar()\n\n    with torch.compiler.set_stance(\"force_eager\"):\n        # will also not be compiled\n        foo(...)\n\n    torch.compiler.set_stance(\"force_eager\")\n    # will also not be compiled\n    foo(...)\n    torch.compiler.set_stance(\"default\")\n\n    # will be compiled\n    foo(...)",
        "parameters": {
          "stance": {
            "type": "",
            "description": "The stance to set the compiler to. Valid values are:\n- \"default\": The default stance, used for normal compilation.\n- \"force_eager\": Ignore all `torch.compile` directives.\n- \"eager_on_recompile\": Run code eagerly when a recompile is necessary."
          },
          "If": {
            "type": "",
            "description": "there is cached compiled code valid for the input, it will still be used.\n- \"fail_on_recompile\": Raise an error when recompiling a function."
          },
          "skip_guard_eval_unsafe": {
            "type": "",
            "description": "A flag to run only differentiating guards."
          },
          "CAUTION": {
            "type": "",
            "description": "- This flag is unsafe and should only be used if your setup"
          },
          "meets": {
            "type": "",
            "description": "the following conditions."
          },
          "torch": {
            "type": "",
            "description": ".compile uses a guard system to support recompilations and"
          },
          "choose": {
            "type": "",
            "description": "which compiled artifact to run at runtime.  These guards,"
          },
          "though": {
            "type": "",
            "description": "efficient, add some overhead, which may impact performance in"
          },
          "scenarios": {
            "type": "",
            "description": "where you need to optimize for minimal guard processing"
          },
          "time": {
            "type": "",
            "description": ".  This API enables you to disable guard evaluation, assuming"
          },
          "that": {
            "type": "",
            "description": "you have warmed up the compiled model with a sufficient variety"
          },
          "of": {
            "type": "",
            "description": "inputs. This assumption means that, after the warmup phase, no"
          },
          "further": {
            "type": "",
            "description": "recompilations will be necessary.  If this assumption fails,"
          },
          "there": {
            "type": "",
            "description": "is a risk of silently producing incorrect results (hence the"
          },
          "term": {
            "type": "",
            "description": "\"unsafe\" in the API name)."
          },
          "force_backend": {
            "type": "",
            "description": "If `stance` is \"default\", this argument can be used to force `torch.compile`"
          },
          "to": {
            "type": "",
            "description": "use a specific backend. Otherwise, an error is raised."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "substitute_in_graph",
      "signature": "substitute_in_graph(original_fn: ~_F, *, can_constant_fold_through: bool = False, skip_signature_check: bool = False) -> Callable[[~_F], ~_F]",
      "documentation": {
        "description": "Register a polyfill handler for a function, usually a C function from the C extension, to be\nused in place of the original function when inlining the original function in the graph.\n\n.. note::\n\n    The polyfill handler is only used when inlining the original function. It is not used when\n    the original function is called directly. In the eager mode, the decorated function calls\n    the performant C function rather than the polyfill handler.\n\nThe polyfill handler is a function that will be called in place of the original function when\ninlining the original function. The polyfill handler should have the same signature and the same\nbehavior as the original function.",
        "parameters": {
          "original_fn": {
            "type": "callable",
            "description": "The original function, usually a C function, to register a polyfill"
          },
          "handler": {
            "type": "",
            "description": "for."
          },
          "can_constant_fold_through": {
            "type": "bool, optional",
            "description": "Whether the polyfill handler can be constant"
          },
          "folded": {
            "type": "",
            "description": "through. That is, if the polyfill handler is a pure function and its arguments"
          },
          "are": {
            "type": "",
            "description": "constant, the result of the polyfill handler can be constant folded during the"
          },
          "compilation": {
            "type": "",
            "description": ". Defaults to ``False``."
          },
          "skip_signature_check": {
            "type": "bool, optional",
            "description": "Whether to skip the signature check between the"
          },
          "original": {
            "type": "",
            "description": "function and the polyfill handler. Defaults to ``False``."
          }
        },
        "returns": "A decorator that registers the polyfill handler for the original function.\n\nExample::\n\n    >>> import operator\n    >>> operator.indexOf([1, 2, 3, 4, 5], 3)\n    2\n    >>> torch.compile(operator.indexOf, fullgraph=True)([1, 2, 3, 4, 5], 3)\n    ... # xdoctest: +SKIP(\"Long tracebacks\")\n    Traceback (most recent call last):\n    ...\n    torch._dynamo.exc.Unsupported: ...\n\n    >>> @torch.compiler.substitute_in_graph(operator.indexOf)\n    ... def indexOf(a, b, /):\n    ...     for i, item in enumerate(a):\n    ...         if item is b or item == b:\n    ...             return i\n    ...     raise ValueError(\"sequence.index(x): x not in sequence\")\n    >>>\n    >>> torch.compile(operator.indexOf, fullgraph=True)([1, 2, 3, 4, 5], 3)\n    2",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "wrap_numpy",
      "signature": "wrap_numpy(fn)",
      "documentation": {
        "description": "Decorator that turns a function from ``np.ndarray``s to ``np.ndarray``s into a function\nfrom ``torch.Tensor``s to ``torch.Tensor``s.\n\nIt is designed to be used with :func:`torch.compile` with ``fullgraph=True``. It allows to\ncompile a NumPy function as if it were a PyTorch function. This allows you to run NumPy code\non CUDA or compute its gradients.\n\n.. note::\n\n    This decorator does not work without :func:`torch.compile`.\n\nExample::\n\n    >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA)\n    >>> # Compile a NumPy function as a Tensor -> Tensor function\n    >>> @torch.compile(fullgraph=True)\n    >>> @torch.compiler.wrap_numpy\n    >>> def fn(a: np.ndarray):\n    >>>     return np.sum(a * a)\n    >>> # Execute the NumPy function using Tensors on CUDA and compute the gradients\n    >>> x = torch.arange(6, dtype=torch.float32, device=\"cuda\", requires_grad=True)\n    >>> out = fn(x)\n    >>> out.backward()\n    >>> print(x.grad)\n    tensor([ 0.,  2.,  4.,  6.,  8., 10.], device='cuda:0')",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": [
    {
      "name": "Any",
      "documentation": {
        "description": "Special type indicating an unconstrained type.\n\n- Any is compatible with every type.\n- Any assumed to have all methods.\n- All values assumed to be instances of Any.\n\nNote that all the above statements are true from the point of view of\nstatic type checkers. At runtime, Any should not be used with instance\nchecks.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "TypeVar",
      "documentation": {
        "description": "Type variable.\n\nThe preferred way to construct a type variable is via the dedicated\nsyntax for generic functions, classes, and type aliases::\n\n    class Sequence[T]:  # T is a TypeVar\n        ...\n\nThis syntax can also be used to create bound and constrained type\nvariables::\n\n    # S is a TypeVar bound to str\n    class StrSequence[S: str]:\n        ...\n\n    # A is a TypeVar constrained to str or bytes\n    class StrOrBytesSequence[A: (str, bytes)]:\n        ...\n\nHowever, if desired, reusable type variables can also be constructed\nmanually, like so::\n\n   T = TypeVar('T')  # Can be anything\n   S = TypeVar('S', bound=str)  # Can be any subtype of str\n   A = TypeVar('A', str, bytes)  # Must be exactly str or bytes\n\nType variables exist primarily for the benefit of static type\ncheckers.  They serve as the parameters for generic types as well\nas for generic function and type alias definitions.\n\nThe variance of type variables is inferred by type checkers when they\nare created through the type parameter syntax and when\n``infer_variance=True`` is passed. Manually created type variables may\nbe explicitly marked covariant or contravariant by passing\n``covariant=True`` or ``contravariant=True``. By default, manually\ncreated type variables are invariant. See PEP 484 and PEP 695 for more\ndetails.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    }
  ]
}