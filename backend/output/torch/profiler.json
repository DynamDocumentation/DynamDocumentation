{
  "description": "PyTorch Profiler is a tool that allows the collection of performance metrics during training and inference.\nProfiler's context manager API can be used to better understand what model operators are the most expensive,\nexamine their input shapes and stack traces, study device kernel activity and visualize the execution trace.\n\n.. note::\n    An earlier version of the API in :mod:`torch.autograd` module is considered legacy and will be deprecated.",
  "functions": [
    {
      "name": "kineto_available",
      "signature": "kineto_available()",
      "documentation": {
        "description": "kineto_available() -> bool",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "register_optimizer_step_post_hook",
      "signature": "register_optimizer_step_post_hook(hook: Callable[[ForwardRef('Optimizer'), Tuple[Any, ...], Dict[str, Any]], NoneType]) -> torch.utils.hooks.RemovableHandle",
      "documentation": {
        "description": "Register a post hook common to all optimizers.\n\nThe hook should have the following signature::\n\n    hook(optimizer, args, kwargs) -> None",
        "parameters": {
          "hook": {
            "type": "Callable",
            "description": "A user defined hook which is registered on all optimizers."
          }
        },
        "returns": ":class:`torch.utils.hooks.RemovableHandle`:\n        a handle that can be used to remove the added hook by calling\n        ``handle.remove()``",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "schedule",
      "signature": "schedule(*, wait: int, warmup: int, active: int, repeat: int = 0, skip_first: int = 0, skip_first_wait: int = 0) -> Callable",
      "documentation": {
        "description": "Returns a callable that can be used as profiler ``schedule`` argument. The profiler will skip\nthe first ``skip_first`` steps, then wait for ``wait`` steps, then do the warmup for the next ``warmup`` steps,\nthen do the active recording for the next ``active`` steps and then repeat the cycle starting with ``wait`` steps.\nThe optional number of cycles is specified with the ``repeat`` parameter, the zero value means that\nthe cycles will continue until the profiling is finished.\n\nThe ``skip_first_wait`` parameter controls whether the first ``wait`` stage should be skipped.\nThis can be useful if a user wants to wait longer than ``skip_first`` between cycles, but not\nfor the first profile. For example, if ``skip_first`` is 10 and ``wait`` is 20, the first cycle will\nwait 10 + 20 = 30 steps before warmup if ``skip_first_wait`` is zero, but will wait only 10\nsteps if ``skip_first_wait`` is non-zero. All subsequent cycles will then wait 20 steps between the\nlast active and warmup.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "supported_activities",
      "signature": "supported_activities()",
      "documentation": {
        "description": "Returns a set of supported profiler tracing activities.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "tensorboard_trace_handler",
      "signature": "tensorboard_trace_handler(dir_name: str, worker_name: Optional[str] = None, use_gzip: bool = False)",
      "documentation": {
        "description": "Outputs tracing files to directory of ``dir_name``, then that directory can be\ndirectly delivered to tensorboard as logdir.\n``worker_name`` should be unique for each worker in distributed scenario,\nit will be set to '[hostname]_[pid]' by default.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": [
    {
      "name": "DeviceType",
      "documentation": {
        "description": "Members:\n\nCPU\n\nCUDA\n\nMKLDNN\n\nOPENGL\n\nOPENCL\n\nIDEEP\n\nHIP\n\nFPGA\n\nMAIA\n\nXLA\n\nVulkan\n\nMetal\n\nXPU\n\nMPS\n\nMTIA\n\nMeta\n\nHPU\n\nVE\n\nLazy\n\nIPU\n\nPrivateUse1",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "ExecutionTraceObserver",
      "documentation": {
        "description": "Execution Trace Observer\n\nEach process can have a single ExecutionTraceObserver instance. The observer\ncan be added to record function callbacks via calling register_callback()\nexplicitly. Without calling unregister_callback(), repeated calls to\nregister_callback() will not add additional observers to record function\ncallbacks. Once an ExecutionTraceObserver is created, the start() and stop()\nmethods control when the event data is recorded.\n\nDeleting or calling unregister_callback() will remove the observer from the\nrecord function callbacks, finalize the output file, and will stop\nincurring any overheads.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "cleanup",
          "signature": "cleanup(self)",
          "documentation": {
            "description": "Calls unregister_callback() to make sure to finalize outputs.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_output_file_path",
          "signature": "get_output_file_path(self) -> str",
          "documentation": {
            "description": "Returns the output file name.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_running",
          "signature": "is_running(self)",
          "documentation": {
            "description": "Returns True if the observer is running, otherwise False.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_callback",
          "signature": "register_callback(self, output_file_path: str) -> Self",
          "documentation": {
            "description": "Adds ET observer to record function callbacks. The data will be\nwritten to output_file_path.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "start",
          "signature": "start(self)",
          "documentation": {
            "description": "Starts to capture.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "stop",
          "signature": "stop(self)",
          "documentation": {
            "description": "Stops to capture.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unregister_callback",
          "signature": "unregister_callback(self)",
          "documentation": {
            "description": "Removes ET observer from record function callbacks.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "KinetoStepTracker",
      "documentation": {
        "description": "Provides an abstraction for incrementing the step count globally.\n\nPreviously, we only had one place to mark that a step() has occurred\nin the program via pytorch profiler step(). We will now add step hooks\nin the Optimizer class https://github.com/pytorch/pytorch/issues/88446\n\n- This could mean programs that already call profiler.step() every\n  iteration can end up double incrementing step count.\n- If a model uses multiple optimizers we can also have double or more\n  counting of the step.\n\nWe fix this by adding a layer of abstraction before calling step()\nto the kineto library. The idea is to maintain steps per requester in a dict:\n\n.. code-block::\n\n    {\n       \"ProfilerStep\": 100,  # triggered by profiler step() call\n       \"Optimizer1Step\": 100,   # Optimizer 1 or 2 are just examples, could be SGD, Adam etc\n       \"Optimizer2Step\": 100,\n    }\n\nTo figure out the global step count just take the max of dict values (100).\n\nIf one of the count increments the max will go up.\n\n.. code-block::\n\n    {\n       \"ProfilerStep\": 100,\n       \"Optimizer1Step\": 101,   # Optimizer1 got incremented first say\n       \"Optimizer2Step\": 100,\n    }\n\nThen global step count is 101\nWe only call the kineto step() function when global count increments.\n\nNOTE: Please do not use the KinetoStepTracker in modules beside the Optimizer\nfor now. The result could be incorrect increments of the step count.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "current_step",
          "signature": "current_step() -> int",
          "documentation": {
            "description": "Get the latest step for any requester",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "erase_step_count",
          "signature": "erase_step_count(requester: str) -> bool",
          "documentation": {
            "description": "Remove a given requester.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "increment_step",
          "signature": "increment_step(requester: str) -> int",
          "documentation": {
            "description": "Increments the step count for the requester.\n\nAdditionally if the max over all step counts has incremented then\ntrigger the _kineto_step() returns global step count",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "init_step_count",
          "signature": "init_step_count(requester: str)",
          "documentation": {
            "description": "Initialize for a given requester.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ProfilerAction",
      "documentation": {
        "description": "Profiler actions that can be taken at the specified intervals",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "ProfilerActivity",
      "documentation": {
        "description": "Members:\n\nCPU\n\nXPU\n\nMTIA\n\nCUDA\n\nPrivateUse1",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "RecordScope",
      "documentation": {
        "description": "Members:\n\nFUNCTION\n\nBACKWARD_FUNCTION\n\nTORCHSCRIPT_FUNCTION\n\nKERNEL_FUNCTION_DTYPE\n\nCUSTOM_CLASS\n\nBUILD_FEATURE\n\nLITE_INTERPRETER\n\nUSER_SCOPE\n\nSTATIC_RUNTIME_OP\n\nSTATIC_RUNTIME_MODEL",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "profile",
      "documentation": {
        "description": "Profiler context manager.",
        "parameters": {
          "activities": {
            "type": "iterable",
            "description": "list of activity groups (CPU, CUDA) to use in profiling, supported values:\n``torch.profiler.ProfilerActivity.CPU``, ``torch.profiler.ProfilerActivity.CUDA``,\n``torch.profiler.ProfilerActivity.XPU``."
          },
          "Default": {
            "type": "",
            "description": "value: ProfilerActivity.CPU and (when available) ProfilerActivity.CUDA"
          },
          "or": {
            "type": "when available",
            "description": "ProfilerActivity.XPU."
          },
          "schedule": {
            "type": "Callable",
            "description": "callable that takes step (int) as a single parameter and returns\n``ProfilerAction`` value that specifies the profiler action to perform at each step."
          },
          "on_trace_ready": {
            "type": "Callable",
            "description": "callable that is called at each step when ``schedule``"
          },
          "returns": {
            "type": "",
            "description": "``ProfilerAction.RECORD_AND_SAVE`` during the profiling."
          },
          "record_shapes": {
            "type": "bool",
            "description": "save information about operator's input shapes."
          },
          "profile_memory": {
            "type": "bool",
            "description": "track tensor memory allocation/deallocation."
          },
          "with_stack": {
            "type": "bool",
            "description": "record source information (file and line number) for the ops."
          },
          "with_flops": {
            "type": "bool",
            "description": "use formula to estimate the FLOPs (floating point operations) of specific operators\n(matrix multiplication and 2D convolution)."
          },
          "with_modules": {
            "type": "bool",
            "description": "record module hierarchy (including function names)"
          },
          "corresponding": {
            "type": "",
            "description": "to the callstack of the op. e.g. If module A's forward call's"
          },
          "module": {
            "type": "",
            "description": "B's forward which contains an aten::add op,"
          },
          "then": {
            "type": "",
            "description": "aten::add's module hierarchy is A.B"
          },
          "Note": {
            "type": "",
            "description": "that this support exist, at the moment, only for TorchScript models"
          },
          "and": {
            "type": "",
            "description": "allow the user to obtain multiple traces at the different iterations"
          },
          "experimental_config": {
            "type": "_ExperimentalConfig",
            "description": "A set of experimental options"
          },
          "used": {
            "type": "",
            "description": "for Kineto library features. Note, backward compatibility is not guaranteed."
          },
          "execution_trace_observer": {
            "type": "ExecutionTraceObserver",
            "description": "A PyTorch Execution Trace Observer object.\n`PyTorch Execution Traces <https://arxiv.org/pdf/2305.14516.pdf>`__ offer a graph based"
          },
          "representation": {
            "type": "",
            "description": "of AI/ML workloads and enable replay benchmarks, simulators, and emulators."
          },
          "When": {
            "type": "",
            "description": "record_shapes=True is specified, profiler will temporarily hold references to the tensors;"
          },
          "same": {
            "type": "",
            "description": "time window as PyTorch profiler. See the examples section below for a code sample."
          },
          "acc_events": {
            "type": "bool",
            "description": "Enable the accumulation of FunctionEvents across multiple profiling cycles"
          },
          "use_cuda": {
            "type": "bool",
            "description": ".. deprecated:: 1.8.1"
          },
          "use": {
            "type": "",
            "description": "``activities`` instead.\n.. note::"
          },
          "Use": {
            "type": "",
            "description": "func:`~torch.profiler.tensorboard_trace_handler` to generate result files for TensorBoard:\n``on_trace_ready=torch.profiler.tensorboard_trace_handler(dir_name)``"
          },
          "Non": {
            "type": "",
            "description": "-default schedules are useful when profiling long training jobs"
          },
          "of": {
            "type": "",
            "description": "the training process."
          },
          "The": {
            "type": "",
            "description": "default schedule simply records all the events continuously for the"
          },
          "duration": {
            "type": "",
            "description": "of the context manager.\n.. note::"
          },
          "After": {
            "type": "",
            "description": "profiling, result files can be found in the specified directory. Use the command:\n``tensorboard --logdir dir_name``"
          },
          "to": {
            "type": "",
            "description": "see the results in TensorBoard."
          },
          "For": {
            "type": "",
            "description": "more information, see\n`PyTorch Profiler TensorBoard Plugin <https://github.com/pytorch/kineto/tree/master/tb_plugin>`__\n.. note::"
          },
          "Enabling": {
            "type": "",
            "description": "shape and stack tracing results in additional overhead."
          },
          "that": {
            "type": "",
            "description": "may further prevent certain optimizations that depend on the reference count and introduce"
          },
          "extra": {
            "type": "",
            "description": "tensor copies."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ".. code-block:: python\n\n    with torch.profiler.profile(\n        activities=[\n            torch.profiler.ProfilerActivity.CPU,\n            torch.profiler.ProfilerActivity.CUDA,\n        ]\n    ) as p:\n        code_to_profile()\n    print(p.key_averages().table(\n        sort_by=\"self_cuda_time_total\", row_limit=-1))\n\nUsing the profiler's ``schedule``, ``on_trace_ready`` and ``step`` functions:\n\n.. code-block:: python\n\n    # Non-default profiler schedule allows user to turn profiler on and off\n    # on different iterations of the training loop;\n    # trace_handler is called every time a new trace becomes available\n    def trace_handler(prof):\n        print(prof.key_averages().table(\n            sort_by=\"self_cuda_time_total\", row_limit=-1))\n        # prof.export_chrome_trace(\"/tmp/test_trace_\" + str(prof.step_num) + \".json\")\n\n    with torch.profiler.profile(\n        activities=[\n            torch.profiler.ProfilerActivity.CPU,\n            torch.profiler.ProfilerActivity.CUDA,\n        ],\n\n        # In this example with wait=1, warmup=1, active=2, repeat=1,\n        # profiler will skip the first step/iteration,\n        # start warming up on the second, record\n        # the third and the forth iterations,\n        # after which the trace will become available\n        # and on_trace_ready (when set) is called;\n        # the cycle repeats starting with the next step\n\n        schedule=torch.profiler.schedule(\n            wait=1,\n            warmup=1,\n            active=2,\n            repeat=1),\n        on_trace_ready=trace_handler\n        # on_trace_ready=torch.profiler.tensorboard_trace_handler('./log')\n        # used when outputting for tensorboard\n        ) as p:\n            for iter in range(N):\n                code_iteration_to_profile(iter)\n                # send a signal to the profiler that the next iteration has started\n                p.step()\n\nThe following sample shows how to setup up an Execution Trace Observer (`execution_trace_observer`)\n\n.. code-block:: python\n\n    with torch.profiler.profile(\n        ...\n        execution_trace_observer=(\n            ExecutionTraceObserver().register_callback(\"./execution_trace.json\")\n        ),\n    ) as p:\n        for iter in range(N):\n            code_iteration_to_profile(iter)\n            p.step()\n\nYou can also refer to test_execution_trace_with_kineto() in tests/profiler/test_profiler.py."
      },
      "methods": [
        {
          "name": "add_metadata",
          "signature": "add_metadata(self, key: str, value: str)",
          "documentation": {
            "description": "Adds a user defined metadata with a string key and a string value\ninto the trace file",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "add_metadata_json",
          "signature": "add_metadata_json(self, key: str, value: str)",
          "documentation": {
            "description": "Adds a user defined metadata with a string key and a valid json value\ninto the trace file",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "events",
          "signature": "events(self)",
          "documentation": {
            "description": "Returns the list of unaggregated profiler events,\nto be used in the trace callback or after the profiling is finished",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "export_chrome_trace",
          "signature": "export_chrome_trace(self, path: str)",
          "documentation": {
            "description": "Exports the collected trace in Chrome JSON format. If kineto is enabled, only\nlast cycle in schedule is exported.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "export_memory_timeline",
          "signature": "export_memory_timeline(self, path: str, device: Optional[str] = None) -> None",
          "documentation": {
            "description": "Export memory event information from the profiler collected\ntree for a given device, and export a timeline plot. There are 3\nexportable files using ``export_memory_timeline``, each controlled by the\n``path``'s suffix.\n\n- For an HTML compatible plot, use the suffix ``.html``, and a memory timeline\n  plot will be embedded as a PNG file in the HTML file.\n\n- For plot points consisting of ``[times, [sizes by category]]``, where\n  ``times`` are timestamps and ``sizes`` are memory usage for each category.\n  The memory timeline plot will be saved a JSON (``.json``) or gzipped JSON\n  (``.json.gz``) depending on the suffix.\n\n- For raw memory points, use the suffix ``.raw.json.gz``. Each raw memory\n  event will consist of ``(timestamp, action, numbytes, category)``, where\n  ``action`` is one of ``[PREEXISTING, CREATE, INCREMENT_VERSION, DESTROY]``,\n  and ``category`` is one of the enums from\n  ``torch.profiler._memory_profiler.Category``.\n\nOutput: Memory timeline written as gzipped JSON, JSON, or HTML.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "export_stacks",
          "signature": "export_stacks(self, path: str, metric: str = 'self_cpu_time_total')",
          "documentation": {
            "description": "Save stack traces to a file",
            "parameters": {
              "path": {
                "type": "str",
                "description": "save stacks file to this location;"
              },
              "metric": {
                "type": "str",
                "description": "metric to use: \"self_cpu_time_total\" or \"self_cuda_time_total\""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_trace_id",
          "signature": "get_trace_id(self)",
          "documentation": {
            "description": "Returns the current trace ID.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "key_averages",
          "signature": "key_averages(self, group_by_input_shape: bool = False, group_by_stack_n: int = 0)",
          "documentation": {
            "description": "Averages events, grouping them by operator name and (optionally) input shapes and\nstack.\n\n.. note::\n    To use shape/stack functionality make sure to set record_shapes/with_stack\n    when creating profiler context manager.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prepare_trace",
          "signature": "prepare_trace(self)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "preset_metadata_json",
          "signature": "preset_metadata_json(self, key: str, value: str)",
          "documentation": {
            "description": "Preset a user defined metadata when the profiler is not started\nand added into the trace file later.\nMetadata is in the format of a string key and a valid json value",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_custom_trace_id_callback",
          "signature": "set_custom_trace_id_callback(self, callback)",
          "documentation": {
            "description": "Sets a callback to be called when a new trace ID is generated.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "start",
          "signature": "start(self)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "start_trace",
          "signature": "start_trace(self)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "step",
          "signature": "step(self)",
          "documentation": {
            "description": "Signals the profiler that the next profiling step has started.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "stop",
          "signature": "stop(self)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "stop_trace",
          "signature": "stop_trace(self)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "toggle_collection_dynamic",
          "signature": "toggle_collection_dynamic(self, enable: bool, activities: Iterable[torch._C._profiler.ProfilerActivity])",
          "documentation": {
            "description": "Toggle collection of activities on/off at any point of collection. Currently supports toggling Torch Ops\n(CPU) and CUDA activity supported in Kineto",
            "parameters": {
              "activities": {
                "type": "iterable",
                "description": "list of activity groups to use in profiling, supported values:\n``torch.profiler.ProfilerActivity.CPU``, ``torch.profiler.ProfilerActivity.CUDA``"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ".. code-block:: python\n\n    with torch.profiler.profile(\n        activities=[\n            torch.profiler.ProfilerActivity.CPU,\n            torch.profiler.ProfilerActivity.CUDA,\n        ]\n    ) as p:\n        code_to_profile_0()\n        // turn off collection of all CUDA activity\n        p.toggle_collection_dynamic(False, [torch.profiler.ProfilerActivity.CUDA])\n        code_to_profile_1()\n        // turn on collection of all CUDA activity\n        p.toggle_collection_dynamic(True, [torch.profiler.ProfilerActivity.CUDA])\n        code_to_profile_2()\n    print(p.key_averages().table(\n        sort_by=\"self_cuda_time_total\", row_limit=-1))"
          }
        }
      ]
    },
    {
      "name": "record_function",
      "documentation": {
        "description": "Context manager/function decorator that adds a label to a code block/function when running autograd profiler.\nLabel will only appear if CPU activity tracing is enabled.\n\nIt is useful when tracing the code profile.",
        "parameters": {
          "name": {
            "type": "str",
            "description": "Label assigned to the block of code."
          },
          "node_id": {
            "type": "int",
            "description": "ID of node, for distributed profiling. Unset in"
          },
          "non": {
            "type": "",
            "description": "-distributed cases."
          },
          "Example": {
            "type": "",
            "description": ">>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_AUTOGRAD_PROFILER)\n>>> x = torch.randn((1, 1), requires_grad=True)\n>>> with torch.autograd.profiler.profile() as prof:\n...     y = x ** 2\n...     with torch.autograd.profiler.record_function(\"label-z\"): # label the block\n...         z = y ** 3\n...     y.backward()\n...\n>>> # xdoctest: +IGNORE_WANT\n>>> # NOTE: some columns were removed for brevity\n>>> print(prof.key_averages().table(sort_by=\"self_cpu_time_total\"))\n-----------------------------------  ---------------  ---------------  ---------------"
          },
          "Name": {
            "type": "",
            "description": "Self CPU total %  CPU time avg     Number of Calls\n-----------------------------------  ---------------  ---------------  ---------------"
          },
          "pow": {
            "type": "",
            "description": "60.77%           47.470us         3"
          },
          "mul": {
            "type": "",
            "description": "21.73%           25.465us         2"
          },
          "PowBackward0": {
            "type": "",
            "description": "12.03%           121.891us        1"
          },
          "torch": {
            "type": "",
            "description": ":autograd::GraphRoot           0.64%            1.503us          1\n-----------------------------------  ---------------  ---------------  ---------------"
          },
          "label": {
            "type": "",
            "description": "-z                              2.13%            12.421us         1"
          },
          "Self": {
            "type": "",
            "description": "CPU time total: 234.344us"
          },
          "CUDA": {
            "type": "",
            "description": "time total: 0.000us"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_AUTOGRAD_PROFILER)\n    >>> x = torch.randn((1, 1), requires_grad=True)\n    >>> with torch.autograd.profiler.profile() as prof:\n    ...     y = x ** 2\n    ...     with torch.autograd.profiler.record_function(\"label-z\"): # label the block\n    ...         z = y ** 3\n    ...     y.backward()\n    ...\n    >>> # xdoctest: +IGNORE_WANT\n    >>> # NOTE: some columns were removed for brevity\n    >>> print(prof.key_averages().table(sort_by=\"self_cpu_time_total\"))\n    -----------------------------------  ---------------  ---------------  ---------------\n    Name                                 Self CPU total %  CPU time avg     Number of Calls\n    -----------------------------------  ---------------  ---------------  ---------------\n    pow                                  60.77%           47.470us         3\n    mul                                  21.73%           25.465us         2\n    PowBackward0                         12.03%           121.891us        1\n    torch::autograd::AccumulateGrad      2.70%            6.324us          1\n    label-z                              2.13%            12.421us         1\n    torch::autograd::GraphRoot           0.64%            1.503us          1\n    -----------------------------------  ---------------  ---------------  ---------------\n    Self CPU time total: 234.344us\n    CUDA time total: 0.000us"
      },
      "methods": []
    }
  ]
}