{
  "description": "No description available",
  "functions": [
    {
      "name": "cholesky",
      "signature": "linalg_cholesky(A, consisting)",
      "documentation": {
        "description": "linalg.cholesky(A, *, upper=False, out=None) -> Tensor\n\nComputes the Cholesky decomposition of a complex Hermitian or real symmetric positive-definite matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **Cholesky decomposition** of a complex Hermitian or real symmetric positive-definite matrix\n:math:`A \\in \\mathbb{K}^{n \\times n}` is defined as\n\n.. math::\n\n    A = LL^{\\text{H}}\\mathrlap{\\qquad L \\in \\mathbb{K}^{n \\times n}}\n\nwhere :math:`L` is a lower triangular matrix with real positive diagonal (even in the complex case) and\n:math:`L^{\\text{H}}` is the conjugate transpose when :math:`L` is complex, and the transpose when :math:`L` is real-valued.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU. For a version of this function that does not synchronize, see :func:`torch.linalg.cholesky_ex`.\n\n\n.. seealso::\n\n        :func:`torch.linalg.cholesky_ex` for a version of this operation that\n        skips the (slow) error checking by default and instead returns the debug\n        information. This makes it a faster way to check if a matrix is\n        positive-definite.\n\n        :func:`torch.linalg.eigh` for a different decomposition of a Hermitian matrix.\n        The eigenvalue decomposition gives more information about the matrix but it\n        slower to compute than the Cholesky decomposition.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions"
          },
          "consisting": {
            "type": "",
            "description": "of symmetric or Hermitian positive-definite matrices."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "upper": {
            "type": "bool, optional",
            "description": "whether to return an upper triangular matrix."
          },
          "The": {
            "type": "",
            "description": "tensor returned with upper=True is the conjugate transpose of the tensor"
          },
          "returned": {
            "type": "",
            "description": "with upper=False."
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "RuntimeError: if the :attr:`A` matrix or any matrix in a batched :attr:`A` is not Hermitian\n                  (resp. symmetric) positive-definite. If :attr:`A` is a batch of matrices,\n                  the error message will include the batch index of the first matrix that fails\n                  to meet this condition.",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cholesky_ex",
      "signature": "linalg_cholesky_ex(A)",
      "documentation": {
        "description": "linalg.cholesky_ex(A, *, upper=False, check_errors=False, out=None) -> (Tensor, Tensor)\n\nComputes the Cholesky decomposition of a complex Hermitian or real\nsymmetric positive-definite matrix.\n\nThis function skips the (slow) error checking and error message construction\nof :func:`torch.linalg.cholesky`, instead directly returning the LAPACK\nerror codes as part of a named tuple ``(L, info)``. This makes this function\na faster way to check if a matrix is positive-definite, and it provides an\nopportunity to handle decomposition errors more gracefully or performantly\nthan :func:`torch.linalg.cholesky` does.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nIf :attr:`A` is not a Hermitian positive-definite matrix, or if it's a batch of matrices\nand one or more of them is not a Hermitian positive-definite matrix,\nthen ``info`` stores a positive integer for the corresponding matrix.\nThe positive integer indicates the order of the leading minor that is not positive-definite,\nand the decomposition could not be completed.\n``info`` filled with zeros indicates that the decomposition was successful.\nIf ``check_errors=True`` and ``info`` contains positive integers, then a RuntimeError is thrown.\n\n\n.. note:: When the inputs are on a CUDA device, this function synchronizes only when :attr:`check_errors`\\ `= True`.\n\n.. warning:: This function is \"experimental\" and it may change in a future PyTorch release.\n\n\n.. seealso::\n        :func:`torch.linalg.cholesky` is a NumPy compatible variant that always checks for errors.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "the Hermitian `n \\times n` matrix or the batch of such matrices of size\n`(*, n, n)` where `*` is one or more batch dimensions."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "upper": {
            "type": "bool, optional",
            "description": "whether to return an upper triangular matrix."
          },
          "The": {
            "type": "",
            "description": "tensor returned with upper=True is the conjugate transpose of the tensor"
          },
          "returned": {
            "type": "",
            "description": "with upper=False."
          },
          "check_errors": {
            "type": "bool, optional",
            "description": "controls whether to check the content of ``infos``. Default: `False`."
          },
          "out": {
            "type": "tuple, optional",
            "description": "tuple of two tensors to write the output to. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cond",
      "signature": "linalg_cond(A, for, is, p, the)",
      "documentation": {
        "description": "linalg.cond(A, p=None, *, out=None) -> Tensor\n\nComputes the condition number of a matrix with respect to a matrix norm.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **condition number** :math:`\\kappa` of a matrix\n:math:`A \\in \\mathbb{K}^{n \\times n}` is defined as\n\n.. math::\n\n    \\kappa(A) = \\|A\\|_p\\|A^{-1}\\|_p\n\nThe condition number of :attr:`A` measures the numerical stability of the linear system `AX = B`\nwith respect to a matrix norm.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n:attr:`p` defines the matrix norm that is computed. The following norms are supported:\n\n=========    =================================\n:attr:`p`    matrix norm\n=========    =================================\n`None`       `2`-norm (largest singular value)\n`'fro'`      Frobenius norm\n`'nuc'`      nuclear norm\n`inf`        `max(sum(abs(x), dim=1))`\n`-inf`       `min(sum(abs(x), dim=1))`\n`1`          `max(sum(abs(x), dim=0))`\n`-1`         `min(sum(abs(x), dim=0))`\n`2`          largest singular value\n`-2`         smallest singular value\n=========    =================================\n\nwhere `inf` refers to `float('inf')`, NumPy's `inf` object, or any equivalent object.\n\nFor :attr:`p` is one of `('fro', 'nuc', inf, -inf, 1, -1)`, this function uses\n:func:`torch.linalg.norm` and :func:`torch.linalg.inv`.\nAs such, in this case, the matrix (or every matrix in the batch) :attr:`A` has to be square\nand invertible.\n\nFor :attr:`p` in `(2, -2)`, this function can be computed in terms of the singular values\n:math:`\\sigma_1 \\geq \\ldots \\geq \\sigma_n`\n\n.. math::\n\n    \\kappa_2(A) = \\frac{\\sigma_1}{\\sigma_n}\\qquad \\kappa_{-2}(A) = \\frac{\\sigma_n}{\\sigma_1}\n\nIn these cases, it is computed using :func:`torch.linalg.svdvals`. For these norms, the matrix\n(or every matrix in the batch) :attr:`A` may have any shape.\n\n.. note :: When inputs are on a CUDA device, this function synchronizes that device with the CPU\n           if :attr:`p` is one of `('fro', 'nuc', inf, -inf, 1, -1)`.\n\n.. seealso::\n\n        :func:`torch.linalg.solve` for a function that solves linear systems of square matrices.\n\n        :func:`torch.linalg.lstsq` for a function that solves linear systems of general matrices.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions"
          },
          "for": {
            "type": "",
            "description": "attr:`p` in `(2, -2)`, and of shape `(*, n, n)` where every matrix"
          },
          "is": {
            "type": "",
            "description": "invertible for :attr:`p` in `('fro', 'nuc', inf, -inf, 1, -1)`."
          },
          "p": {
            "type": "int, inf, -inf, 'fro', 'nuc', optional",
            "description": ""
          },
          "the": {
            "type": "",
            "description": "type of the matrix norm to use in the computations (see above). Default: `None`"
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A real-valued tensor, even when :attr:`A` is complex.",
        "raises": "RuntimeError:\n        if :attr:`p` is one of `('fro', 'nuc', inf, -inf, 1, -1)`\n        and the :attr:`A` matrix or any matrix in the batch :attr:`A` is not square\n        or invertible.",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cross",
      "signature": "linalg_cross(input, other, dim)",
      "documentation": {
        "description": "linalg.cross(input, other, *, dim=-1, out=None) -> Tensor\n\n\nComputes the cross product of two 3-dimensional vectors.\n\nSupports input of float, double, cfloat and cdouble dtypes. Also supports batches\nof vectors, for which it computes the product along the dimension :attr:`dim`.\nIt broadcasts over the batch dimensions.",
        "parameters": {
          "input": {
            "type": "Tensor",
            "description": "the first input tensor."
          },
          "other": {
            "type": "Tensor",
            "description": "the second input tensor."
          },
          "dim": {
            "type": "int, optional",
            "description": "the dimension along which to take the cross-product. Default: `-1`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "the output tensor. Ignored if `None`. Default: `None`."
          },
          "Example": {
            "type": "",
            "description": ">>> a = torch.randn(4, 3)\n>>> a"
          },
          "tensor": {
            "type": "",
            "description": "([[ 1.4653, -1.2325,  1.4507],\n[ 1.4119, -2.6163,  0.1073],\n[ 0.3957, -1.9666, -1.0840],\n[ 0.2956, -0.3357,  0.2139]])"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> a = torch.randn(4, 3)\n    >>> a\n    tensor([[-0.3956,  1.1455,  1.6895],\n            [-0.5849,  1.3672,  0.3599],\n            [-1.1626,  0.7180, -0.0521],\n            [-0.1339,  0.9902, -2.0225]])\n    >>> b = torch.randn(4, 3)\n    >>> b\n    tensor([[-0.0257, -1.4725, -1.2251],\n            [-1.1479, -0.7005, -1.9757],\n            [-1.3904,  0.3726, -1.1836],\n            [-0.9688, -0.7153,  0.2159]])\n    >>> torch.linalg.cross(a, b)\n    tensor([[ 1.0844, -0.5281,  0.6120],\n            [-2.4490, -1.5687,  1.9792],\n            [-0.8304, -1.3037,  0.5650],\n            [-1.2329,  1.9883,  1.0551]])\n    >>> a = torch.randn(1, 3)  # a is broadcast to match shape of b\n    >>> a\n    tensor([[-0.9941, -0.5132,  0.5681]])\n    >>> torch.linalg.cross(a, b)\n    tensor([[ 1.4653, -1.2325,  1.4507],\n            [ 1.4119, -2.6163,  0.1073],\n            [ 0.3957, -1.9666, -1.0840],\n            [ 0.2956, -0.3357,  0.2139]])"
      }
    },
    {
      "name": "det",
      "signature": "linalg_det(A)",
      "documentation": {
        "description": "linalg.det(A, *, out=None) -> Tensor\n\nComputes the determinant of a square matrix.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n.. seealso::\n\n        :func:`torch.linalg.slogdet` computes the sign and natural logarithm of the absolute\n        value of the determinant of square matrices.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "diagonal",
      "signature": "linalg_diagonal(...)",
      "documentation": {
        "description": "linalg.diagonal(A, *, offset=0, dim1=-2, dim2=-1) -> Tensor\n\nAlias for :func:`torch.diagonal` with defaults :attr:`dim1`\\ `= -2`, :attr:`dim2`\\ `= -1`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "eig",
      "signature": "linalg_eig(A, consisting)",
      "documentation": {
        "description": "linalg.eig(A, *, out=None) -> (Tensor, Tensor)\n\nComputes the eigenvalue decomposition of a square matrix if it exists.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **eigenvalue decomposition** of a square matrix\n:math:`A \\in \\mathbb{K}^{n \\times n}` (if it exists) is defined as\n\n.. math::\n\n    A = V \\operatorname{diag}(\\Lambda) V^{-1}\\mathrlap{\\qquad V \\in \\mathbb{C}^{n \\times n}, \\Lambda \\in \\mathbb{C}^n}\n\nThis decomposition exists if and only if :math:`A` is `diagonalizable`_.\nThis is the case when all its eigenvalues are different.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nThe returned eigenvalues are not guaranteed to be in any specific order.\n\n.. note:: The eigenvalues and eigenvectors of a real matrix may be complex.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\n.. warning:: This function assumes that :attr:`A` is `diagonalizable`_ (for example, when all the\n             eigenvalues are different). If it is not diagonalizable, the returned\n             eigenvalues will be correct but :math:`A \\neq V \\operatorname{diag}(\\Lambda)V^{-1}`.\n\n.. warning:: The returned eigenvectors are normalized to have norm `1`.\n             Even then, the eigenvectors of a matrix are not unique, nor are they continuous with respect to\n             :attr:`A`. Due to this lack of uniqueness, different hardware and software may compute\n             different eigenvectors.\n\n             This non-uniqueness is caused by the fact that multiplying an eigenvector by\n             by :math:`e^{i \\phi}, \\phi \\in \\mathbb{R}` produces another set of valid eigenvectors\n             of the matrix.  For this reason, the loss function shall not depend on the phase of the\n             eigenvectors, as this quantity is not well-defined.\n             This is checked when computing the gradients of this function. As such,\n             when inputs are on a CUDA device, the computation of the gradients\n             of this function synchronizes that device with the CPU.\n\n\n.. warning:: Gradients computed using the `eigenvectors` tensor will only be finite when\n             :attr:`A` has distinct eigenvalues.\n             Furthermore, if the distance between any two eigenvalues is close to zero,\n             the gradient will be numerically unstable, as it depends on the eigenvalues\n             :math:`\\lambda_i` through the computation of\n             :math:`\\frac{1}{\\min_{i \\neq j} \\lambda_i - \\lambda_j}`.\n\n.. seealso::\n\n        :func:`torch.linalg.eigvals` computes only the eigenvalues.\n        Unlike :func:`torch.linalg.eig`, the gradients of :func:`~eigvals` are always\n        numerically stable.\n\n        :func:`torch.linalg.eigh` for a (faster) function that computes the eigenvalue decomposition\n        for Hermitian and symmetric matrices.\n\n        :func:`torch.linalg.svd` for a function that computes another type of spectral\n        decomposition that works on matrices of any shape.\n\n        :func:`torch.linalg.qr` for another (much faster) decomposition that works on matrices of\n        any shape.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions"
          },
          "consisting": {
            "type": "",
            "description": "of diagonalizable matrices."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "tuple, optional",
            "description": "output tuple of two tensors. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A named tuple `(eigenvalues, eigenvectors)` which corresponds to :math:`\\Lambda` and :math:`V` above.\n\n    `eigenvalues` and `eigenvectors` will always be complex-valued, even when :attr:`A` is real. The eigenvectors\n    will be given by the columns of `eigenvectors`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "eigh",
      "signature": "linalg_eigh(A, consisting, UPLO, of)",
      "documentation": {
        "description": "linalg.eigh(A, UPLO='L', *, out=None) -> (Tensor, Tensor)\n\nComputes the eigenvalue decomposition of a complex Hermitian or real symmetric matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **eigenvalue decomposition** of a complex Hermitian or real symmetric matrix\n:math:`A \\in \\mathbb{K}^{n \\times n}` is defined as\n\n.. math::\n\n    A = Q \\operatorname{diag}(\\Lambda) Q^{\\text{H}}\\mathrlap{\\qquad Q \\in \\mathbb{K}^{n \\times n}, \\Lambda \\in \\mathbb{R}^n}\n\nwhere :math:`Q^{\\text{H}}` is the conjugate transpose when :math:`Q` is complex, and the transpose when :math:`Q` is real-valued.\n:math:`Q` is orthogonal in the real case and unitary in the complex case.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n:attr:`A` is assumed to be Hermitian (resp. symmetric), but this is not checked internally, instead:\n\n- If :attr:`UPLO`\\ `= 'L'` (default), only the lower triangular part of the matrix is used in the computation.\n- If :attr:`UPLO`\\ `= 'U'`, only the upper triangular part of the matrix is used.\n\nThe eigenvalues are returned in ascending order.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\n.. note:: The eigenvalues of real symmetric or complex Hermitian matrices are always real.\n\n.. warning:: The eigenvectors of a symmetric matrix are not unique, nor are they continuous with\n             respect to :attr:`A`. Due to this lack of uniqueness, different hardware and\n             software may compute different eigenvectors.\n\n             This non-uniqueness is caused by the fact that multiplying an eigenvector by\n             `-1` in the real case or by :math:`e^{i \\phi}, \\phi \\in \\mathbb{R}` in the complex\n             case produces another set of valid eigenvectors of the matrix.\n             For this reason, the loss function shall not depend on the phase of the eigenvectors, as\n             this quantity is not well-defined.\n             This is checked for complex inputs when computing the gradients of this function. As such,\n             when inputs are complex and are on a CUDA device, the computation of the gradients\n             of this function synchronizes that device with the CPU.\n\n.. warning:: Gradients computed using the `eigenvectors` tensor will only be finite when\n             :attr:`A` has distinct eigenvalues.\n             Furthermore, if the distance between any two eigenvalues is close to zero,\n             the gradient will be numerically unstable, as it depends on the eigenvalues\n             :math:`\\lambda_i` through the computation of\n             :math:`\\frac{1}{\\min_{i \\neq j} \\lambda_i - \\lambda_j}`.\n\n.. warning:: User may see pytorch crashes if running `eigh` on CUDA devices with CUDA versions before 12.1 update 1\n             with large ill-conditioned matrices as inputs.\n             Refer to :ref:`Linear Algebra Numerical Stability<Linear Algebra Stability>` for more details.\n             If this is the case, user may (1) tune their matrix inputs to be less ill-conditioned,\n             or (2) use :func:`torch.backends.cuda.preferred_linalg_library` to\n             try other supported backends.\n\n.. seealso::\n\n        :func:`torch.linalg.eigvalsh` computes only the eigenvalues of a Hermitian matrix.\n        Unlike :func:`torch.linalg.eigh`, the gradients of :func:`~eigvalsh` are always\n        numerically stable.\n\n        :func:`torch.linalg.cholesky` for a different decomposition of a Hermitian matrix.\n        The Cholesky decomposition gives less information about the matrix but is much faster\n        to compute than the eigenvalue decomposition.\n\n        :func:`torch.linalg.eig` for a (slower) function that computes the eigenvalue decomposition\n        of a not necessarily Hermitian square matrix.\n\n        :func:`torch.linalg.svd` for a (slower) function that computes the more general SVD\n        decomposition of matrices of any shape.\n\n        :func:`torch.linalg.qr` for another (much faster) decomposition that works on general\n        matrices.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions"
          },
          "consisting": {
            "type": "",
            "description": "of symmetric or Hermitian matrices."
          },
          "UPLO": {
            "type": "'L', 'U', optional",
            "description": "controls whether to use the upper or lower triangular part"
          },
          "of": {
            "type": "",
            "description": "attr:`A` in the computations. Default: `'L'`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "tuple, optional",
            "description": "output tuple of two tensors. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A named tuple `(eigenvalues, eigenvectors)` which corresponds to :math:`\\Lambda` and :math:`Q` above.\n\n    `eigenvalues` will always be real-valued, even when :attr:`A` is complex.\n    It will also be ordered in ascending order.\n\n    `eigenvectors` will have the same dtype as :attr:`A` and will contain the eigenvectors as its columns.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "eigvals",
      "signature": "linalg_eigvals(A)",
      "documentation": {
        "description": "linalg.eigvals(A, *, out=None) -> Tensor\n\nComputes the eigenvalues of a square matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **eigenvalues** of a square matrix :math:`A \\in \\mathbb{K}^{n \\times n}` are defined\nas the roots (counted with multiplicity) of the polynomial `p` of degree `n` given by\n\n.. math::\n\n    p(\\lambda) = \\operatorname{det}(A - \\lambda \\mathrm{I}_n)\\mathrlap{\\qquad \\lambda \\in \\mathbb{C}}\n\nwhere :math:`\\mathrm{I}_n` is the `n`-dimensional identity matrix.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nThe returned eigenvalues are not guaranteed to be in any specific order.\n\n.. note:: The eigenvalues of a real matrix may be complex, as the roots of a real polynomial may be complex.\n\n          The eigenvalues of a matrix are always well-defined, even when the matrix is not diagonalizable.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\n.. seealso::\n\n        :func:`torch.linalg.eig` computes the full eigenvalue decomposition.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A complex-valued tensor containing the eigenvalues even when :attr:`A` is real.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "eigvalsh",
      "signature": "linalg_eigvalsh(A, consisting, UPLO, of)",
      "documentation": {
        "description": "linalg.eigvalsh(A, UPLO='L', *, out=None) -> Tensor\n\nComputes the eigenvalues of a complex Hermitian or real symmetric matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **eigenvalues** of a complex Hermitian or real symmetric  matrix :math:`A \\in \\mathbb{K}^{n \\times n}`\nare defined as the roots (counted with multiplicity) of the polynomial `p` of degree `n` given by\n\n.. math::\n\n    p(\\lambda) = \\operatorname{det}(A - \\lambda \\mathrm{I}_n)\\mathrlap{\\qquad \\lambda \\in \\mathbb{R}}\n\nwhere :math:`\\mathrm{I}_n` is the `n`-dimensional identity matrix.\nThe eigenvalues of a real symmetric or complex Hermitian matrix are always real.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nThe eigenvalues are returned in ascending order.\n\n:attr:`A` is assumed to be Hermitian (resp. symmetric), but this is not checked internally, instead:\n\n- If :attr:`UPLO`\\ `= 'L'` (default), only the lower triangular part of the matrix is used in the computation.\n- If :attr:`UPLO`\\ `= 'U'`, only the upper triangular part of the matrix is used.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\n.. seealso::\n\n        :func:`torch.linalg.eigh` computes the full eigenvalue decomposition.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions"
          },
          "consisting": {
            "type": "",
            "description": "of symmetric or Hermitian matrices."
          },
          "UPLO": {
            "type": "'L', 'U', optional",
            "description": "controls whether to use the upper or lower triangular part"
          },
          "of": {
            "type": "",
            "description": "attr:`A` in the computations. Default: `'L'`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A real-valued tensor containing the eigenvalues even when :attr:`A` is complex.\n    The eigenvalues are returned in ascending order.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "householder_product",
      "signature": "linalg_householder_product(A, tau, *, out=None)",
      "documentation": {
        "description": "householder_product(A, tau, *, out=None) -> Tensor\n\nComputes the first `n` columns of a product of Householder matrices.\n\nLet :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`, and\nlet :math:`A \\in \\mathbb{K}^{m \\times n}` be a matrix with columns :math:`a_i \\in \\mathbb{K}^m`\nfor :math:`i=1,\\ldots,m` with :math:`m \\geq n`. Denote by :math:`b_i` the vector resulting from\nzeroing out the first :math:`i-1` components of :math:`a_i` and setting to `1` the :math:`i`-th.\nFor a vector :math:`\\tau \\in \\mathbb{K}^k` with :math:`k \\leq n`, this function computes the\nfirst :math:`n` columns of the matrix\n\n.. math::\n\n    H_1H_2 ... H_k \\qquad\\text{with}\\qquad H_i = \\mathrm{I}_m - \\tau_i b_i b_i^{\\text{H}}\n\nwhere :math:`\\mathrm{I}_m` is the `m`-dimensional identity matrix and :math:`b^{\\text{H}}` is the\nconjugate transpose when :math:`b` is complex, and the transpose when :math:`b` is real-valued.\nThe output matrix is the same size as the input matrix :attr:`A`.\n\nSee `Representation of Orthogonal or Unitary Matrices`_ for further details.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if the inputs are batches of matrices then\nthe output has the same batch dimensions.\n\n.. seealso::\n\n        :func:`torch.geqrf` can be used together with this function to form the `Q` from the\n        :func:`~qr` decomposition.\n\n        :func:`torch.ormqr` is a related function that computes the matrix multiplication\n        of a product of Householder matrices with another matrix.\n        However, that function is not supported by autograd.\n\n.. warning::\n    Gradient computations are only well-defined if :math:`\\tau_i \\neq \\frac{1}{||a_i||^2}`.\n    If this condition is not met, no error will be thrown, but the gradient produced may contain `NaN`.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions."
          },
          "tau": {
            "type": "Tensor",
            "description": "tensor of shape `(*, k)` where `*` is zero or more batch dimensions."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "RuntimeError: if :attr:`A` doesn't satisfy the requirement `m >= n`,\n                  or :attr:`tau` doesn't satisfy the requirement `n >= k`.",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "inv",
      "signature": "linalg_inv(A, consisting)",
      "documentation": {
        "description": "linalg.inv(A, *, out=None) -> Tensor\n\nComputes the inverse of a square matrix if it exists.\nThrows a `RuntimeError` if the matrix is not invertible.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nfor a matrix :math:`A \\in \\mathbb{K}^{n \\times n}`,\nits **inverse matrix** :math:`A^{-1} \\in \\mathbb{K}^{n \\times n}` (if it exists) is defined as\n\n.. math::\n\n    A^{-1}A = AA^{-1} = \\mathrm{I}_n\n\nwhere :math:`\\mathrm{I}_n` is the `n`-dimensional identity matrix.\n\nThe inverse matrix exists if and only if :math:`A` is `invertible`_. In this case,\nthe inverse is unique.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices\nthen the output has the same batch dimensions.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU. For a version of this function that does not synchronize, see :func:`torch.linalg.inv_ex`.\n\n\n.. note::\n    Consider using :func:`torch.linalg.solve` if possible for multiplying a matrix on the left by\n    the inverse, as::\n\n        linalg.solve(A, B) == linalg.inv(A) @ B  # When B is a matrix\n\n    It is always preferred to use :func:`~solve` when possible, as it is faster and more\n    numerically stable than computing the inverse explicitly.\n\n.. seealso::\n\n        :func:`torch.linalg.pinv` computes the pseudoinverse (Moore-Penrose inverse) of matrices\n        of any shape.\n\n        :func:`torch.linalg.solve` computes :attr:`A`\\ `.inv() @ \\ `:attr:`B` with a\n        numerically stable algorithm.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions"
          },
          "consisting": {
            "type": "",
            "description": "of invertible matrices."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "RuntimeError: if the matrix :attr:`A` or any matrix in the batch of matrices :attr:`A` is not invertible.",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "inv_ex",
      "signature": "linalg_inv_ex(A, consisting, check_errors)",
      "documentation": {
        "description": "linalg.inv_ex(A, *, check_errors=False, out=None) -> (Tensor, Tensor)\n\nComputes the inverse of a square matrix if it is invertible.\n\nReturns a namedtuple ``(inverse, info)``. ``inverse`` contains the result of\ninverting :attr:`A` and ``info`` stores the LAPACK error codes.\n\nIf :attr:`A` is not an invertible matrix, or if it's a batch of matrices\nand one or more of them is not an invertible matrix,\nthen ``info`` stores a positive integer for the corresponding matrix.\nThe positive integer indicates the diagonal element of the LU decomposition of\nthe input matrix that is exactly zero.\n``info`` filled with zeros indicates that the inversion was successful.\nIf ``check_errors=True`` and ``info`` contains positive integers, then a RuntimeError is thrown.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n\n.. note:: When the inputs are on a CUDA device, this function synchronizes only when :attr:`check_errors`\\ `= True`.\n\n.. warning:: This function is \"experimental\" and it may change in a future PyTorch release.\n\n\n.. seealso::\n\n        :func:`torch.linalg.inv` is a NumPy compatible variant that always checks for errors.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions"
          },
          "consisting": {
            "type": "",
            "description": "of square matrices."
          },
          "check_errors": {
            "type": "bool, optional",
            "description": "controls whether to check the content of ``info``. Default: `False`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "tuple, optional",
            "description": "tuple of two tensors to write the output to. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ldl_factor",
      "signature": "linalg_ldl_factor(A, consisting)",
      "documentation": {
        "description": "linalg.ldl_factor(A, *, hermitian=False, out=None) -> (Tensor, Tensor)\n\nComputes a compact representation of the LDL factorization of a Hermitian or symmetric (possibly indefinite) matrix.\n\nWhen :attr:`A` is complex valued it can be Hermitian (:attr:`hermitian`\\ `= True`)\nor symmetric (:attr:`hermitian`\\ `= False`).\n\nThe factorization is of the form the form :math:`A = L D L^T`.\nIf :attr:`hermitian` is `True` then transpose operation is the conjugate transpose.\n\n:math:`L` (or :math:`U`) and :math:`D` are stored in compact form in ``LD``.\nThey follow the format specified by `LAPACK's sytrf`_ function.\nThese tensors may be used in :func:`torch.linalg.ldl_solve` to solve linear systems.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU. For a version of this function that does not synchronize, see :func:`torch.linalg.ldl_factor_ex`.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions"
          },
          "consisting": {
            "type": "",
            "description": "of symmetric or Hermitian matrices."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "hermitian": {
            "type": "bool, optional",
            "description": "whether to consider the input to be Hermitian or symmetric."
          },
          "For": {
            "type": "",
            "description": "real-valued matrices, this switch has no effect. Default: `False`."
          },
          "out": {
            "type": "tuple, optional",
            "description": "tuple of two tensors to write the output to. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A named tuple `(LD, pivots)`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ldl_factor_ex",
      "signature": "linalg_ldl_factor_ex(A, consisting)",
      "documentation": {
        "description": "linalg.ldl_factor_ex(A, *, hermitian=False, check_errors=False, out=None) -> (Tensor, Tensor, Tensor)\n\nThis is a version of :func:`~ldl_factor` that does not perform error checks unless :attr:`check_errors`\\ `= True`.\nIt also returns the :attr:`info` tensor returned by `LAPACK's sytrf`_.\n``info`` stores integer error codes from the backend library.\nA positive integer indicates the diagonal element of :math:`D` that is zero.\nDivision by 0 will occur if the result is used for solving a system of linear equations.\n``info`` filled with zeros indicates that the factorization was successful.\nIf ``check_errors=True`` and ``info`` contains positive integers, then a `RuntimeError` is thrown.\n\n\n.. note:: When the inputs are on a CUDA device, this function synchronizes only when :attr:`check_errors`\\ `= True`.\n\n.. warning:: This function is \"experimental\" and it may change in a future PyTorch release.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions"
          },
          "consisting": {
            "type": "",
            "description": "of symmetric or Hermitian matrices."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "hermitian": {
            "type": "bool, optional",
            "description": "whether to consider the input to be Hermitian or symmetric."
          },
          "For": {
            "type": "",
            "description": "real-valued matrices, this switch has no effect. Default: `False`."
          },
          "check_errors": {
            "type": "bool, optional",
            "description": "controls whether to check the content of ``info`` and raise"
          },
          "an": {
            "type": "",
            "description": "error if it is non-zero. Default: `False`."
          },
          "out": {
            "type": "tuple, optional",
            "description": "tuple of three tensors to write the output to. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A named tuple `(LD, pivots, info)`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ldl_solve",
      "signature": "linalg_ldl_solve(LD, pivots, B)",
      "documentation": {
        "description": "linalg.ldl_solve(LD, pivots, B, *, hermitian=False, out=None) -> Tensor\n\nComputes the solution of a system of linear equations using the LDL factorization.\n\n:attr:`LD` and :attr:`pivots` are the compact representation of the LDL factorization and\nare expected to be computed by :func:`torch.linalg.ldl_factor_ex`.\n:attr:`hermitian` argument to this function should be the same\nas the corresponding arguments in :func:`torch.linalg.ldl_factor_ex`.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n\n.. warning:: This function is \"experimental\" and it may change in a future PyTorch release.",
        "parameters": {
          "LD": {
            "type": "Tensor",
            "description": "the `n \\times n` matrix or the batch of such matrices of size\n`(*, n, n)` where `*` is one or more batch dimensions."
          },
          "pivots": {
            "type": "Tensor",
            "description": "the pivots corresponding to the LDL factorization of :attr:`LD`."
          },
          "B": {
            "type": "Tensor",
            "description": "right-hand side tensor of shape `(*, n, k)`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "hermitian": {
            "type": "bool, optional",
            "description": "whether to consider the decomposed matrix to be Hermitian or symmetric."
          },
          "For": {
            "type": "",
            "description": "real-valued matrices, this switch has no effect. Default: `False`."
          },
          "out": {
            "type": "tuple, optional",
            "description": "output tensor. `B` may be passed as `out` and the result is computed in-place on `B`."
          },
          "Ignored": {
            "type": "",
            "description": "if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "lstsq",
      "signature": "linalg_lstsq(A, B, rcond, If, precision)",
      "documentation": {
        "description": "torch.linalg.lstsq(A, B, rcond=None, *, driver=None) -> (Tensor, Tensor, Tensor, Tensor)\n\nComputes a solution to the least squares problem of a system of linear equations.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **least squares problem** for a linear system :math:`AX = B` with\n:math:`A \\in \\mathbb{K}^{m \\times n}, B \\in \\mathbb{K}^{m \\times k}` is defined as\n\n.. math::\n\n    \\min_{X \\in \\mathbb{K}^{n \\times k}} \\|AX - B\\|_F\n\nwhere :math:`\\|-\\|_F` denotes the Frobenius norm.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if the inputs are batches of matrices then\nthe output has the same batch dimensions.\n\n:attr:`driver` chooses the backend function that will be used.\nFor CPU inputs the valid values are `'gels'`, `'gelsy'`, `'gelsd`, `'gelss'`.\nTo choose the best driver on CPU consider:\n\n- If :attr:`A` is well-conditioned (its `condition number`_ is not too large), or you do not mind some precision loss.\n\n  - For a general matrix: `'gelsy'` (QR with pivoting) (default)\n  - If :attr:`A` is full-rank: `'gels'` (QR)\n\n- If :attr:`A` is not well-conditioned.\n\n  - `'gelsd'` (tridiagonal reduction and SVD)\n  - But if you run into memory issues: `'gelss'` (full SVD).\n\nFor CUDA input, the only valid driver is `'gels'`, which assumes that :attr:`A` is full-rank.\n\nSee also the `full description of these drivers`_\n\n:attr:`rcond` is used to determine the effective rank of the matrices in :attr:`A`\nwhen :attr:`driver` is one of (`'gelsy'`, `'gelsd'`, `'gelss'`).\nIn this case, if :math:`\\sigma_i` are the singular values of `A` in decreasing order,\n:math:`\\sigma_i` will be rounded down to zero if :math:`\\sigma_i \\leq \\text{rcond} \\cdot \\sigma_1`.\nIf :attr:`rcond`\\ `= None` (default), :attr:`rcond` is set to the machine precision of the dtype of :attr:`A` times `max(m, n)`.\n\nThis function returns the solution to the problem and some extra information in a named tuple of\nfour tensors `(solution, residuals, rank, singular_values)`. For inputs :attr:`A`, :attr:`B`\nof shape `(*, m, n)`, `(*, m, k)` respectively, it contains\n\n- `solution`: the least squares solution. It has shape `(*, n, k)`.\n- `residuals`: the squared residuals of the solutions, that is, :math:`\\|AX - B\\|_F^2`.\n  It has shape equal to the batch dimensions of :attr:`A`.\n  It is computed when `m > n` and every matrix in :attr:`A` is full-rank,\n  otherwise, it is an empty tensor.\n  If :attr:`A` is a batch of matrices and any matrix in the batch is not full rank,\n  then an empty tensor is returned. This behavior may change in a future PyTorch release.\n- `rank`: tensor of ranks of the matrices in :attr:`A`.\n  It has shape equal to the batch dimensions of :attr:`A`.\n  It is computed when :attr:`driver` is one of (`'gelsy'`, `'gelsd'`, `'gelss'`),\n  otherwise it is an empty tensor.\n- `singular_values`: tensor of singular values of the matrices in :attr:`A`.\n  It has shape `(*, min(m, n))`.\n  It is computed when :attr:`driver` is one of (`'gelsd'`, `'gelss'`),\n  otherwise it is an empty tensor.\n\n.. note::\n    This function computes `X = \\ `:attr:`A`\\ `.pinverse() @ \\ `:attr:`B` in a faster and\n    more numerically stable way than performing the computations separately.\n\n.. warning::\n    The default value of :attr:`rcond` may change in a future PyTorch release.\n    It is therefore recommended to use a fixed value to avoid potential\n    breaking changes.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "lhs tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions."
          },
          "B": {
            "type": "Tensor",
            "description": "rhs tensor of shape `(*, m, k)` where `*` is zero or more batch dimensions."
          },
          "rcond": {
            "type": "float, optional",
            "description": "used to determine the effective rank of :attr:`A`."
          },
          "If": {
            "type": "",
            "description": "`None`, `'gelsy'` is used for CPU inputs and `'gels'` for CUDA inputs."
          },
          "precision": {
            "type": "",
            "description": "of the dtype of :attr:`A` times `max(m, n)`. Default: `None`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "driver": {
            "type": "str, optional",
            "description": "name of the LAPACK/MAGMA method to be used."
          },
          "Default": {
            "type": "",
            "description": "`None`."
          }
        },
        "returns": "A named tuple `(solution, residuals, rank, singular_values)`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "lu",
      "signature": "linalg_lu(A, *, pivot=True, out=None)",
      "documentation": {
        "description": "lu(A, *, pivot=True, out=None) -> (Tensor, Tensor, Tensor)\n\nComputes the LU decomposition with partial pivoting of a matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **LU decomposition with partial pivoting** of a matrix\n:math:`A \\in \\mathbb{K}^{m \\times n}` is defined as\n\n.. math::\n\n    A = PLU\\mathrlap{\\qquad P \\in \\mathbb{K}^{m \\times m}, L \\in \\mathbb{K}^{m \\times k}, U \\in \\mathbb{K}^{k \\times n}}\n\nwhere `k = min(m,n)`, :math:`P` is a `permutation matrix`_, :math:`L` is lower triangular with ones on the diagonal\nand :math:`U` is upper triangular.\n\nIf :attr:`pivot`\\ `= False` and :attr:`A` is on GPU, then the **LU decomposition without pivoting** is computed\n\n.. math::\n\n    A = LU\\mathrlap{\\qquad L \\in \\mathbb{K}^{m \\times k}, U \\in \\mathbb{K}^{k \\times n}}\n\nWhen :attr:`pivot`\\ `= False`, the returned matrix :attr:`P` will be empty.\nThe LU decomposition without pivoting `may not exist`_ if any of the principal minors of :attr:`A` is singular.\nIn this case, the output matrix may contain `inf` or `NaN`.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n.. seealso::\n\n        :func:`torch.linalg.solve` solves a system of linear equations using the LU decomposition\n        with partial pivoting.\n\n.. warning:: The LU decomposition is almost never unique, as often there are different permutation\n             matrices that can yield different LU decompositions.\n             As such, different platforms, like SciPy, or inputs on different devices,\n             may produce different valid decompositions.\n\n.. warning:: Gradient computations are only supported if the input matrix is full-rank.\n             If this condition is not met, no error will be thrown, but the gradient\n             may not be finite.\n             This is because the LU decomposition with pivoting is not differentiable at these points.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions."
          },
          "pivot": {
            "type": "bool, optional",
            "description": "Controls whether to compute the LU decomposition with partial pivoting or"
          },
          "no": {
            "type": "",
            "description": "pivoting. Default: `True`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "tuple, optional",
            "description": "output tuple of three tensors. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A named tuple `(P, L, U)`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "lu_factor",
      "signature": "linalg_lu_factor(A)",
      "documentation": {
        "description": "linalg.lu_factor(A, *, bool pivot=True, out=None) -> (Tensor, Tensor)\n\nComputes a compact representation of the LU factorization with partial pivoting of a matrix.\n\nThis function computes a compact representation of the decomposition given by :func:`torch.linalg.lu`.\nIf the matrix is square, this representation may be used in :func:`torch.linalg.lu_solve`\nto solve system of linear equations that share the matrix :attr:`A`.\n\nThe returned decomposition is represented as a named tuple `(LU, pivots)`.\nThe ``LU`` matrix has the same shape as the input matrix ``A``. Its upper and lower triangular\nparts encode the non-constant elements of ``L`` and ``U`` of the LU decomposition of ``A``.\n\nThe returned permutation matrix is represented by a 1-indexed vector. `pivots[i] == j` represents\nthat in the `i`-th step of the algorithm, the `i`-th row was permuted with the `j-1`-th row.\n\nOn CUDA, one may use :attr:`pivot`\\ `= False`. In this case, this function returns the LU\ndecomposition without pivoting if it exists.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if the inputs are batches of matrices then\nthe output has the same batch dimensions.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU. For a version of this function that does not synchronize, see :func:`torch.linalg.lu_factor_ex`.\n\n.. warning:: The LU decomposition is almost never unique, as often there are different permutation\n             matrices that can yield different LU decompositions.\n             As such, different platforms, like SciPy, or inputs on different devices,\n             may produce different valid decompositions.\n\n             Gradient computations are only supported if the input matrix is full-rank.\n             If this condition is not met, no error will be thrown, but the gradient may not be finite.\n             This is because the LU decomposition with pivoting is not differentiable at these points.\n\n.. seealso::\n\n        :func:`torch.linalg.lu_solve` solves a system of linear equations given the output of this\n        function provided the input matrix was square and invertible.\n\n        :func:`torch.lu_unpack` unpacks the tensors returned by :func:`~lu_factor` into the three\n        matrices `P, L, U` that form the decomposition.\n\n        :func:`torch.linalg.lu` computes the LU decomposition with partial pivoting of a possibly\n        non-square matrix. It is a composition of :func:`~lu_factor` and :func:`torch.lu_unpack`.\n\n        :func:`torch.linalg.solve` solves a system of linear equations. It is a composition\n        of :func:`~lu_factor` and :func:`~lu_solve`.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "pivot": {
            "type": "bool, optional",
            "description": "Whether to compute the LU decomposition with partial pivoting, or the regular LU"
          },
          "decomposition": {
            "type": "",
            "description": ". :attr:`pivot`\\ `= False` not supported on CPU. Default: `True`."
          },
          "out": {
            "type": "tuple, optional",
            "description": "tuple of two tensors to write the output to. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A named tuple `(LU, pivots)`.",
        "raises": "RuntimeError: if the :attr:`A` matrix is not invertible or any matrix in a batched :attr:`A`\n                  is not invertible.",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "lu_factor_ex",
      "signature": "linalg_lu_factor_ex(A)",
      "documentation": {
        "description": "linalg.lu_factor_ex(A, *, pivot=True, check_errors=False, out=None) -> (Tensor, Tensor, Tensor)\n\nThis is a version of :func:`~lu_factor` that does not perform error checks unless :attr:`check_errors`\\ `= True`.\nIt also returns the :attr:`info` tensor returned by `LAPACK's getrf`_.\n\n\n.. note:: When the inputs are on a CUDA device, this function synchronizes only when :attr:`check_errors`\\ `= True`.\n\n.. warning:: This function is \"experimental\" and it may change in a future PyTorch release.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "pivot": {
            "type": "bool, optional",
            "description": "Whether to compute the LU decomposition with partial pivoting, or the regular LU"
          },
          "decomposition": {
            "type": "",
            "description": ". :attr:`pivot`\\ `= False` not supported on CPU. Default: `True`."
          },
          "check_errors": {
            "type": "bool, optional",
            "description": "controls whether to check the content of ``infos`` and raise"
          },
          "an": {
            "type": "",
            "description": "error if it is non-zero. Default: `False`."
          },
          "out": {
            "type": "tuple, optional",
            "description": "tuple of three tensors to write the output to. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A named tuple `(LU, pivots, info)`.\n\n.. _LAPACK's getrf:\n    https://www.netlib.org/lapack/explore-html/dd/d9a/group__double_g_ecomputational_ga0019443faea08275ca60a734d0593e60.html",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "lu_solve",
      "signature": "linalg_lu_solve(LU, where, pivots, where, B)",
      "documentation": {
        "description": "linalg.lu_solve(LU, pivots, B, *, left=True, adjoint=False, out=None) -> Tensor\n\nComputes the solution of a square system of linear equations with a unique solution given an LU decomposition.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthis function computes the solution :math:`X \\in \\mathbb{K}^{n \\times k}` of the **linear system** associated to\n:math:`A \\in \\mathbb{K}^{n \\times n}, B \\in \\mathbb{K}^{n \\times k}`, which is defined as\n\n.. math:: AX = B\n\nwhere :math:`A` is given factorized as returned by :func:`~lu_factor`.\n\nIf :attr:`left`\\ `= False`, this function returns the matrix :math:`X \\in \\mathbb{K}^{n \\times k}` that solves the system\n\n.. math::\n\n    XA = B\\mathrlap{\\qquad A \\in \\mathbb{K}^{k \\times k}, B \\in \\mathbb{K}^{n \\times k}.}\n\nIf  :attr:`adjoint`\\ `= True` (and :attr:`left`\\ `= True`), given an LU factorization of :math:`A`\nthis function function returns the :math:`X \\in \\mathbb{K}^{n \\times k}` that solves the system\n\n.. math::\n\n    A^{\\text{H}}X = B\\mathrlap{\\qquad A \\in \\mathbb{K}^{k \\times k}, B \\in \\mathbb{K}^{n \\times k}.}\n\nwhere :math:`A^{\\text{H}}` is the conjugate transpose when :math:`A` is complex, and the\ntranspose when :math:`A` is real-valued. The :attr:`left`\\ `= False` case is analogous.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if the inputs are batches of matrices then\nthe output has the same batch dimensions.",
        "parameters": {
          "LU": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` (or `(*, k, k)` if :attr:`left`\\ `= True`)"
          },
          "where": {
            "type": "",
            "description": "`*` is zero or more batch dimensions as returned by :func:`~lu_factor`."
          },
          "pivots": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n)` (or `(*, k)` if :attr:`left`\\ `= True`)"
          },
          "B": {
            "type": "Tensor",
            "description": "right-hand side tensor of shape `(*, n, k)`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "left": {
            "type": "bool, optional",
            "description": "whether to solve the system :math:`AX=B` or :math:`XA = B`. Default: `True`."
          },
          "adjoint": {
            "type": "bool, optional",
            "description": "whether to solve the system :math:`AX=B` or :math:`A^{\\text{H}}X = B`. Default: `False`."
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "matmul",
      "signature": "linalg_matmul(...)",
      "documentation": {
        "description": "linalg.matmul(input, other, *, out=None) -> Tensor\n\nAlias for :func:`torch.matmul`",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "matrix_exp",
      "signature": "linalg_matrix_exp(A)",
      "documentation": {
        "description": "linalg.matrix_exp(A) -> Tensor\n\nComputes the matrix exponential of a square matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthis function computes the **matrix exponential** of :math:`A \\in \\mathbb{K}^{n \\times n}`, which is defined as\n\n.. math::\n    \\mathrm{matrix\\_exp}(A) = \\sum_{k=0}^\\infty \\frac{1}{k!}A^k \\in \\mathbb{K}^{n \\times n}.\n\nIf the matrix :math:`A` has eigenvalues :math:`\\lambda_i \\in \\mathbb{C}`,\nthe matrix :math:`\\mathrm{matrix\\_exp}(A)` has eigenvalues :math:`e^{\\lambda_i} \\in \\mathbb{C}`.\n\nSupports input of bfloat16, float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions."
          },
          "Example": {
            "type": "",
            "description": ":\n>>> A = torch.empty(2, 2, 2)\n>>> A[0, :, :] = torch.eye(2, 2)\n>>> A[1, :, :] = 2 * torch.eye(2, 2)\n>>> A"
          },
          "tensor": {
            "type": "",
            "description": "([[ 0.5000,  0.8660],\n[-0.8660,  0.5000]])"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "matrix_norm",
      "signature": "linalg_matrix_norm(A, shape, batch, ord, dim, keepdim, in)",
      "documentation": {
        "description": "linalg.matrix_norm(A, ord='fro', dim=(-2, -1), keepdim=False, *, dtype=None, out=None) -> Tensor\n\nComputes a matrix norm.\n\nIf :attr:`A` is complex valued, it computes the norm of :attr:`A`\\ `.abs()`\n\nSupport input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices: the norm will be computed over the\ndimensions specified by the 2-tuple :attr:`dim` and the other dimensions will\nbe treated as batch dimensions. The output will have the same batch dimensions.\n\n:attr:`ord` defines the matrix norm that is computed. The following norms are supported:\n\n======================   ========================================================\n:attr:`ord`              matrix norm\n======================   ========================================================\n`'fro'` (default)        Frobenius norm\n`'nuc'`                  nuclear norm\n`inf`                    `max(sum(abs(x), dim=1))`\n`-inf`                   `min(sum(abs(x), dim=1))`\n`1`                      `max(sum(abs(x), dim=0))`\n`-1`                     `min(sum(abs(x), dim=0))`\n`2`                      largest singular value\n`-2`                     smallest singular value\n======================   ========================================================\n\nwhere `inf` refers to `float('inf')`, NumPy's `inf` object, or any equivalent object.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor with two or more dimensions. By default its"
          },
          "shape": {
            "type": "",
            "description": "is interpreted as `(*, m, n)` where `*` is zero or more"
          },
          "batch": {
            "type": "",
            "description": "dimensions, but this behavior can be controlled using :attr:`dim`."
          },
          "ord": {
            "type": "int, inf, -inf, 'fro', 'nuc', optional",
            "description": "order of norm. Default: `'fro'`"
          },
          "dim": {
            "type": "Tuple[int, int], optional",
            "description": "dimensions over which to compute the norm. Default: `(-2, -1)`"
          },
          "keepdim": {
            "type": "bool, optional",
            "description": "If set to `True`, the reduced dimensions are retained"
          },
          "in": {
            "type": "",
            "description": "the result as dimensions with size one. Default: `False`"
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          },
          "dtype": {
            "type": ":class:`torch.dtype`, optional",
            "description": "If specified, the input tensor is cast to\n:attr:`dtype` before performing the operation, and the returned tensor's type"
          },
          "will": {
            "type": "",
            "description": "be :attr:`dtype`. Default: `None`"
          }
        },
        "returns": "A real-valued tensor, even when :attr:`A` is complex.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "matrix_power",
      "signature": "linalg_matrix_power(A, n, *, out=None)",
      "documentation": {
        "description": "matrix_power(A, n, *, out=None) -> Tensor\n\nComputes the `n`-th power of a square matrix for an integer `n`.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nIf :attr:`n`\\ `= 0`, it returns the identity matrix (or batch) of the same shape\nas :attr:`A`. If :attr:`n` is negative, it returns the inverse of each matrix\n(if invertible) raised to the power of `abs(n)`.\n\n.. note::\n    Consider using :func:`torch.linalg.solve` if possible for multiplying a matrix on the left by\n    a negative power as, if :attr:`n`\\ `> 0`::\n\n        torch.linalg.solve(matrix_power(A, n), B) == matrix_power(A, -n)  @ B\n\n    It is always preferred to use :func:`~solve` when possible, as it is faster and more\n    numerically stable than computing :math:`A^{-n}` explicitly.\n\n.. seealso::\n\n        :func:`torch.linalg.solve` computes :attr:`A`\\ `.inverse() @ \\ `:attr:`B` with a\n        numerically stable algorithm.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, m, m)` where `*` is zero or more batch dimensions."
          },
          "n": {
            "type": "int",
            "description": "the exponent."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "RuntimeError: if :attr:`n`\\ `< 0` and the matrix :attr:`A` or any matrix in the\n                  batch of matrices :attr:`A` is not invertible.",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "matrix_rank",
      "signature": "linalg_matrix_rank(A, tol)",
      "documentation": {
        "description": "linalg.matrix_rank(A, *, atol=None, rtol=None, hermitian=False, out=None) -> Tensor\n\nComputes the numerical rank of a matrix.\n\nThe matrix rank is computed as the number of singular values\n(or eigenvalues in absolute value when :attr:`hermitian`\\ `= True`)\nthat are greater than :math:`\\max(\\text{atol}, \\sigma_1 * \\text{rtol})` threshold,\nwhere :math:`\\sigma_1` is the largest singular value (or eigenvalue).\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nIf :attr:`hermitian`\\ `= True`, :attr:`A` is assumed to be Hermitian if complex or\nsymmetric if real, but this is not checked internally. Instead, just the lower\ntriangular part of the matrix is used in the computations.\n\nIf :attr:`rtol` is not specified and :attr:`A` is a matrix of dimensions `(m, n)`,\nthe relative tolerance is set to be :math:`\\text{rtol} = \\max(m, n) \\varepsilon`\nand :math:`\\varepsilon` is the epsilon value for the dtype of :attr:`A` (see :class:`.finfo`).\nIf :attr:`rtol` is not specified and :attr:`atol` is specified to be larger than zero then\n:attr:`rtol` is set to zero.\n\nIf :attr:`atol` or :attr:`rtol` is a :class:`torch.Tensor`, its shape must be broadcastable to that\nof the singular values of :attr:`A` as returned by :func:`torch.linalg.svdvals`.\n\n.. note::\n    This function has NumPy compatible variant `linalg.matrix_rank(A, tol, hermitian=False)`.\n    However, use of the positional argument :attr:`tol` is deprecated in favor of :attr:`atol` and :attr:`rtol`.\n\n\n.. note:: The matrix rank is computed using a singular value decomposition\n          :func:`torch.linalg.svdvals` if :attr:`hermitian`\\ `= False` (default) and the eigenvalue\n          decomposition :func:`torch.linalg.eigvalsh` when :attr:`hermitian`\\ `= True`.\n          When inputs are on a CUDA device, this function synchronizes that device with the CPU.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions."
          },
          "tol": {
            "type": "float, Tensor, optional",
            "description": "[NumPy Compat] Alias for :attr:`atol`. Default: `None`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "atol": {
            "type": "float, Tensor, optional",
            "description": "the absolute tolerance value. When `None` it's considered to be zero."
          },
          "Default": {
            "type": "",
            "description": "`None`."
          },
          "rtol": {
            "type": "float, Tensor, optional",
            "description": "the relative tolerance value. See above for the value it takes when `None`."
          },
          "hermitian": {
            "type": "bool",
            "description": "indicates whether :attr:`A` is Hermitian if complex"
          },
          "or": {
            "type": "",
            "description": "symmetric if real. Default: `False`."
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "multi_dot",
      "signature": "linalg_multi_dot(tensors, tensors)",
      "documentation": {
        "description": "linalg.multi_dot(tensors, *, out=None)\n\nEfficiently multiplies two or more matrices by reordering the multiplications so that\nthe fewest arithmetic operations are performed.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nThis function does not support batched inputs.\n\nEvery tensor in :attr:`tensors` must be 2D, except for the first and last which\nmay be 1D. If the first tensor is a 1D vector of shape `(n,)` it is treated as a row vector\nof shape `(1, n)`, similarly if the last tensor is a 1D vector of shape `(n,)` it is treated\nas a column vector of shape `(n, 1)`.\n\nIf the first and last tensors are matrices, the output will be a matrix.\nHowever, if either is a 1D vector, then the output will be a 1D vector.\n\nDifferences with `numpy.linalg.multi_dot`:\n\n- Unlike `numpy.linalg.multi_dot`, the first and last tensors must either be 1D or 2D\n  whereas NumPy allows them to be nD\n\n.. warning:: This function does not broadcast.\n\n.. note:: This function is implemented by chaining :func:`torch.mm` calls after\n          computing the optimal matrix multiplication order.\n\n.. note:: The cost of multiplying two matrices with shapes `(a, b)` and `(b, c)` is\n          `a * b * c`. Given matrices `A`, `B`, `C` with shapes `(10, 100)`,\n          `(100, 5)`, `(5, 50)` respectively, we can calculate the cost of different\n          multiplication orders as follows:\n\n          .. math::\n\n             \\begin{align*}\n             \\operatorname{cost}((AB)C) &= 10 \\times 100 \\times 5 + 10 \\times 5 \\times 50 = 7500 \\\\\n             \\operatorname{cost}(A(BC)) &= 10 \\times 100 \\times 50 + 100 \\times 5 \\times 50 = 75000\n             \\end{align*}\n\n          In this case, multiplying `A` and `B` first followed by `C` is 10 times faster.",
        "parameters": {
          "tensors": {
            "type": "",
            "description": "may be 1D or 2D. Every other tensor must be 2D."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "norm",
      "signature": "linalg_norm(A, ord, dim, the, Default, keepdim, in)",
      "documentation": {
        "description": "linalg.norm(A, ord=None, dim=None, keepdim=False, *, out=None, dtype=None) -> Tensor\n\nComputes a vector or matrix norm.\n\nSupports input of float, double, cfloat and cdouble dtypes.\n\nWhether this function computes a vector or matrix norm is determined as follows:\n\n- If :attr:`dim` is an `int`, the vector norm will be computed.\n- If :attr:`dim` is a `2`-`tuple`, the matrix norm will be computed.\n- If :attr:`dim`\\ `= None` and :attr:`ord`\\ `= None`,\n  :attr:`A` will be flattened to 1D and the `2`-norm of the resulting vector will be computed.\n- If :attr:`dim`\\ `= None` and :attr:`ord` `!= None`, :attr:`A` must be 1D or 2D.\n\n:attr:`ord` defines the norm that is computed. The following norms are supported:\n\n======================     =========================  ========================================================\n:attr:`ord`                norm for matrices          norm for vectors\n======================     =========================  ========================================================\n`None` (default)           Frobenius norm             `2`-norm (see below)\n`'fro'`                    Frobenius norm             -- not supported --\n`'nuc'`                    nuclear norm               -- not supported --\n`inf`                      `max(sum(abs(x), dim=1))`  `max(abs(x))`\n`-inf`                     `min(sum(abs(x), dim=1))`  `min(abs(x))`\n`0`                        -- not supported --        `sum(x != 0)`\n`1`                        `max(sum(abs(x), dim=0))`  as below\n`-1`                       `min(sum(abs(x), dim=0))`  as below\n`2`                        largest singular value     as below\n`-2`                       smallest singular value    as below\nother `int` or `float`     -- not supported --        `sum(abs(x)^{ord})^{(1 / ord)}`\n======================     =========================  ========================================================\n\nwhere `inf` refers to `float('inf')`, NumPy's `inf` object, or any equivalent object.\n\n.. seealso::\n\n        :func:`torch.linalg.vector_norm` computes a vector norm.\n\n        :func:`torch.linalg.matrix_norm` computes a matrix norm.\n\n        The above functions are often clearer and more flexible than using :func:`torch.linalg.norm`.\n        For example, `torch.linalg.norm(A, ord=1, dim=(0, 1))` always\n        computes a matrix norm, but with `torch.linalg.vector_norm(A, ord=1, dim=(0, 1))` it is possible\n        to compute a vector norm over the two dimensions.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n)` or `(*, m, n)` where `*` is zero or more batch dimensions"
          },
          "ord": {
            "type": "int, float, inf, -inf, 'fro', 'nuc', optional",
            "description": "order of norm. Default: `None`"
          },
          "dim": {
            "type": "int, Tuple[int], optional",
            "description": "dimensions over which to compute"
          },
          "the": {
            "type": "",
            "description": "vector or matrix norm. See above for the behavior when :attr:`dim`\\ `= None`."
          },
          "Default": {
            "type": "",
            "description": "`None`"
          },
          "keepdim": {
            "type": "bool, optional",
            "description": "If set to `True`, the reduced dimensions are retained"
          },
          "in": {
            "type": "",
            "description": "the result as dimensions with size one. Default: `False`"
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          },
          "dtype": {
            "type": ":class:`torch.dtype`, optional",
            "description": "If specified, the input tensor is cast to\n:attr:`dtype` before performing the operation, and the returned tensor's type"
          },
          "will": {
            "type": "",
            "description": "be :attr:`dtype`. Default: `None`"
          }
        },
        "returns": "A real-valued tensor, even when :attr:`A` is complex.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "pinv",
      "signature": "linalg_pinv(A, rcond)",
      "documentation": {
        "description": "linalg.pinv(A, *, atol=None, rtol=None, hermitian=False, out=None) -> Tensor\n\nComputes the pseudoinverse (Moore-Penrose inverse) of a matrix.\n\nThe pseudoinverse may be `defined algebraically`_\nbut it is more computationally convenient to understand it `through the SVD`_\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nIf :attr:`hermitian`\\ `= True`, :attr:`A` is assumed to be Hermitian if complex or\nsymmetric if real, but this is not checked internally. Instead, just the lower\ntriangular part of the matrix is used in the computations.\n\nThe singular values (or the norm of the eigenvalues when :attr:`hermitian`\\ `= True`)\nthat are below :math:`\\max(\\text{atol}, \\sigma_1 \\cdot \\text{rtol})` threshold are\ntreated as zero and discarded in the computation,\nwhere :math:`\\sigma_1` is the largest singular value (or eigenvalue).\n\nIf :attr:`rtol` is not specified and :attr:`A` is a matrix of dimensions `(m, n)`,\nthe relative tolerance is set to be :math:`\\text{rtol} = \\max(m, n) \\varepsilon`\nand :math:`\\varepsilon` is the epsilon value for the dtype of :attr:`A` (see :class:`.finfo`).\nIf :attr:`rtol` is not specified and :attr:`atol` is specified to be larger than zero then\n:attr:`rtol` is set to zero.\n\nIf :attr:`atol` or :attr:`rtol` is a :class:`torch.Tensor`, its shape must be broadcastable to that\nof the singular values of :attr:`A` as returned by :func:`torch.linalg.svd`.\n\n.. note:: This function uses :func:`torch.linalg.svd` if :attr:`hermitian`\\ `= False` and\n          :func:`torch.linalg.eigh` if :attr:`hermitian`\\ `= True`.\n          For CUDA inputs, this function synchronizes that device with the CPU.\n\n.. note::\n    Consider using :func:`torch.linalg.lstsq` if possible for multiplying a matrix on the left by\n    the pseudoinverse, as::\n\n        torch.linalg.lstsq(A, B).solution == A.pinv() @ B\n\n    It is always preferred to use :func:`~lstsq` when possible, as it is faster and more\n    numerically stable than computing the pseudoinverse explicitly.\n\n.. note::\n    This function has NumPy compatible variant `linalg.pinv(A, rcond, hermitian=False)`.\n    However, use of the positional argument :attr:`rcond` is deprecated in favor of :attr:`rtol`.\n\n.. warning::\n    This function uses internally :func:`torch.linalg.svd` (or :func:`torch.linalg.eigh`\n    when :attr:`hermitian`\\ `= True`), so its derivative has the same problems as those of these\n    functions. See the warnings in :func:`torch.linalg.svd` and :func:`torch.linalg.eigh` for\n    more details.\n\n.. seealso::\n\n        :func:`torch.linalg.inv` computes the inverse of a square matrix.\n\n        :func:`torch.linalg.lstsq` computes :attr:`A`\\ `.pinv() @ \\ `:attr:`B` with a\n        numerically stable algorithm.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions."
          },
          "rcond": {
            "type": "float, Tensor, optional",
            "description": "[NumPy Compat]. Alias for :attr:`rtol`. Default: `None`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "atol": {
            "type": "float, Tensor, optional",
            "description": "the absolute tolerance value. When `None` it's considered to be zero."
          },
          "Default": {
            "type": "",
            "description": "`None`."
          },
          "rtol": {
            "type": "float, Tensor, optional",
            "description": "the relative tolerance value. See above for the value it takes when `None`."
          },
          "hermitian": {
            "type": "bool, optional",
            "description": "indicates whether :attr:`A` is Hermitian if complex"
          },
          "or": {
            "type": "",
            "description": "symmetric if real. Default: `False`."
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "qr",
      "signature": "linalg_qr(A, mode='reduced', *, out=None)",
      "documentation": {
        "description": "qr(A, mode='reduced', *, out=None) -> (Tensor, Tensor)\n\nComputes the QR decomposition of a matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **full QR decomposition** of a matrix\n:math:`A \\in \\mathbb{K}^{m \\times n}` is defined as\n\n.. math::\n\n    A = QR\\mathrlap{\\qquad Q \\in \\mathbb{K}^{m \\times m}, R \\in \\mathbb{K}^{m \\times n}}\n\nwhere :math:`Q` is orthogonal in the real case and unitary in the complex case,\nand :math:`R` is upper triangular with real diagonal (even in the complex case).\n\nWhen `m > n` (tall matrix), as `R` is upper triangular, its last `m - n` rows are zero.\nIn this case, we can drop the last `m - n` columns of `Q` to form the\n**reduced QR decomposition**:\n\n.. math::\n\n    A = QR\\mathrlap{\\qquad Q \\in \\mathbb{K}^{m \\times n}, R \\in \\mathbb{K}^{n \\times n}}\n\nThe reduced QR decomposition agrees with the full QR decomposition when `n >= m` (wide matrix).\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nThe parameter :attr:`mode` chooses between the full and reduced QR decomposition.\nIf :attr:`A` has shape `(*, m, n)`, denoting `k = min(m, n)`\n\n- :attr:`mode`\\ `= 'reduced'` (default): Returns `(Q, R)` of shapes `(*, m, k)`, `(*, k, n)` respectively.\n  It is always differentiable.\n- :attr:`mode`\\ `= 'complete'`: Returns `(Q, R)` of shapes `(*, m, m)`, `(*, m, n)` respectively.\n  It is differentiable for `m <= n`.\n- :attr:`mode`\\ `= 'r'`: Computes only the reduced `R`. Returns `(Q, R)` with `Q` empty and `R` of shape `(*, k, n)`.\n  It is never differentiable.\n\nDifferences with `numpy.linalg.qr`:\n\n- :attr:`mode`\\ `= 'raw'` is not implemented.\n- Unlike `numpy.linalg.qr`, this function always returns a tuple of two tensors.\n  When :attr:`mode`\\ `= 'r'`, the `Q` tensor is an empty tensor.\n\n.. warning:: The elements in the diagonal of `R` are not necessarily positive.\n             As such, the returned QR decomposition is only unique up to the sign of the diagonal of `R`.\n             Therefore, different platforms, like NumPy, or inputs on different devices,\n             may produce different valid decompositions.\n\n.. warning:: The QR decomposition is only well-defined if the first `k = min(m, n)` columns\n             of every matrix in :attr:`A` are linearly independent.\n             If this condition is not met, no error will be thrown, but the QR produced\n             may be incorrect and its autodiff may fail or produce incorrect results.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions."
          },
          "mode": {
            "type": "str, optional",
            "description": "one of `'reduced'`, `'complete'`, `'r'`."
          },
          "Controls": {
            "type": "",
            "description": "the shape of the returned tensors. Default: `'reduced'`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "tuple, optional",
            "description": "output tuple of two tensors. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A named tuple `(Q, R)`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "slogdet",
      "signature": "linalg_slogdet(A)",
      "documentation": {
        "description": "linalg.slogdet(A, *, out=None) -> (Tensor, Tensor)\n\nComputes the sign and natural logarithm of the absolute value of the determinant of a square matrix.\n\nFor complex :attr:`A`, it returns the sign and the natural logarithm of the modulus of the\ndeterminant, that is, a logarithmic polar decomposition of the determinant.\n\nThe determinant can be recovered as `sign * exp(logabsdet)`.\nWhen a matrix has a determinant of zero, it returns `(0, -inf)`.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n.. seealso::\n\n        :func:`torch.linalg.det` computes the determinant of square matrices.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "tuple, optional",
            "description": "output tuple of two tensors. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A named tuple `(sign, logabsdet)`.\n\n    `sign` will have the same dtype as :attr:`A`.\n\n    `logabsdet` will always be real-valued, even when :attr:`A` is complex.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "solve",
      "signature": "linalg_solve(A, B, according)",
      "documentation": {
        "description": "linalg.solve(A, B, *, left=True, out=None) -> Tensor\n\nComputes the solution of a square system of linear equations with a unique solution.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthis function computes the solution :math:`X \\in \\mathbb{K}^{n \\times k}` of the **linear system** associated to\n:math:`A \\in \\mathbb{K}^{n \\times n}, B \\in \\mathbb{K}^{n \\times k}`, which is defined as\n\n.. math:: AX = B\n\nIf :attr:`left`\\ `= False`, this function returns the matrix :math:`X \\in \\mathbb{K}^{n \\times k}` that solves the system\n\n.. math::\n\n    XA = B\\mathrlap{\\qquad A \\in \\mathbb{K}^{k \\times k}, B \\in \\mathbb{K}^{n \\times k}.}\n\nThis system of linear equations has one solution if and only if :math:`A` is `invertible`_.\nThis function assumes that :math:`A` is invertible.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if the inputs are batches of matrices then\nthe output has the same batch dimensions.\n\nLetting `*` be zero or more batch dimensions,\n\n- If :attr:`A` has shape `(*, n, n)` and :attr:`B` has shape `(*, n)` (a batch of vectors) or shape\n  `(*, n, k)` (a batch of matrices or \"multiple right-hand sides\"), this function returns `X` of shape\n  `(*, n)` or `(*, n, k)` respectively.\n- Otherwise, if :attr:`A` has shape `(*, n, n)` and  :attr:`B` has shape `(n,)`  or `(n, k)`, :attr:`B`\n  is broadcasted to have shape `(*, n)` or `(*, n, k)` respectively.\n  This function then returns the solution of the resulting batch of systems of linear equations.\n\n.. note::\n    This function computes `X = \\ `:attr:`A`\\ `.inverse() @ \\ `:attr:`B` in a faster and\n    more numerically stable way than performing the computations separately.\n\n.. note::\n    It is possible to compute the solution of the system :math:`XA = B` by passing the inputs\n    :attr:`A` and :attr:`B` transposed and transposing the output returned by this function.\n\n.. note::\n    :attr:`A` is allowed to be a non-batched `torch.sparse_csr_tensor`, but only with `left=True`.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU. For a version of this function that does not synchronize, see :func:`torch.linalg.solve_ex`.\n\n\n.. seealso::\n\n        :func:`torch.linalg.solve_triangular` computes the solution of a triangular system of linear\n        equations with a unique solution.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions."
          },
          "B": {
            "type": "Tensor",
            "description": "right-hand side tensor of shape `(*, n)` or  `(*, n, k)` or `(n,)` or `(n, k)`"
          },
          "according": {
            "type": "",
            "description": "to the rules described above"
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "left": {
            "type": "bool, optional",
            "description": "whether to solve the system :math:`AX=B` or :math:`XA = B`. Default: `True`."
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "RuntimeError: if the :attr:`A` matrix is not invertible or any matrix in a batched :attr:`A`\n                  is not invertible.",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "solve_ex",
      "signature": "linalg_solve_ex(A)",
      "documentation": {
        "description": "linalg.solve_ex(A, B, *, left=True, check_errors=False, out=None) -> (Tensor, Tensor)\n\nA version of :func:`~solve` that does not perform error checks unless :attr:`check_errors`\\ `= True`.\nIt also returns the :attr:`info` tensor returned by `LAPACK's getrf`_.\n\n\n.. note:: When the inputs are on a CUDA device, this function synchronizes only when :attr:`check_errors`\\ `= True`.\n\n.. warning:: This function is \"experimental\" and it may change in a future PyTorch release.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "left": {
            "type": "bool, optional",
            "description": "whether to solve the system :math:`AX=B` or :math:`XA = B`. Default: `True`."
          },
          "check_errors": {
            "type": "bool, optional",
            "description": "controls whether to check the content of ``infos`` and raise"
          },
          "an": {
            "type": "",
            "description": "error if it is non-zero. Default: `False`."
          },
          "out": {
            "type": "tuple, optional",
            "description": "tuple of two tensors to write the output to. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A named tuple `(result, info)`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "solve_triangular",
      "signature": "linalg_solve_triangular(A, where, B)",
      "documentation": {
        "description": "linalg.solve_triangular(A, B, *, upper, left=True, unitriangular=False, out=None) -> Tensor\n\nComputes the solution of a triangular system of linear equations with a unique solution.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthis function computes the solution :math:`X \\in \\mathbb{K}^{n \\times k}` of the **linear system**\nassociated to the triangular matrix :math:`A \\in \\mathbb{K}^{n \\times n}` without zeros on the diagonal\n(that is, it is `invertible`_) and the rectangular matrix , :math:`B \\in \\mathbb{K}^{n \\times k}`,\nwhich is defined as\n\n.. math:: AX = B\n\nThe argument :attr:`upper` signals whether :math:`A` is upper or lower triangular.\n\nIf :attr:`left`\\ `= False`, this function returns the matrix :math:`X \\in \\mathbb{K}^{n \\times k}` that\nsolves the system\n\n.. math::\n\n    XA = B\\mathrlap{\\qquad A \\in \\mathbb{K}^{k \\times k}, B \\in \\mathbb{K}^{n \\times k}.}\n\nIf :attr:`upper`\\ `= True` (resp. `False`) just the upper (resp. lower) triangular half of :attr:`A`\nwill be accessed. The elements below the main diagonal will be considered to be zero and will not be accessed.\n\nIf :attr:`unitriangular`\\ `= True`, the diagonal of :attr:`A` is assumed to be ones and will not be accessed.\n\nThe result may contain `NaN` s if the diagonal of :attr:`A` contains zeros or elements that\nare very close to zero and :attr:`unitriangular`\\ `= False` (default) or if the input matrix\nhas very small eigenvalues.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if the inputs are batches of matrices then\nthe output has the same batch dimensions.\n\n.. seealso::\n\n        :func:`torch.linalg.solve` computes the solution of a general square system of linear\n        equations with a unique solution.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n, n)` (or `(*, k, k)` if :attr:`left`\\ `= False`)"
          },
          "where": {
            "type": "",
            "description": "`*` is zero or more batch dimensions."
          },
          "B": {
            "type": "Tensor",
            "description": "right-hand side tensor of shape `(*, n, k)`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "upper": {
            "type": "bool",
            "description": "whether :attr:`A` is an upper or lower triangular matrix."
          },
          "left": {
            "type": "bool, optional",
            "description": "whether to solve the system :math:`AX=B` or :math:`XA = B`. Default: `True`."
          },
          "unitriangular": {
            "type": "bool, optional",
            "description": "if `True`, the diagonal elements of :attr:`A` are assumed to be"
          },
          "all": {
            "type": "",
            "description": "equal to `1`. Default: `False`."
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. `B` may be passed as `out` and the result is computed in-place on `B`."
          },
          "Ignored": {
            "type": "",
            "description": "if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "svd",
      "signature": "linalg_svd(A, full_matrices, the)",
      "documentation": {
        "description": "linalg.svd(A, full_matrices=True, *, driver=None, out=None) -> (Tensor, Tensor, Tensor)\n\nComputes the singular value decomposition (SVD) of a matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **full SVD** of a matrix\n:math:`A \\in \\mathbb{K}^{m \\times n}`, if `k = min(m,n)`, is defined as\n\n.. math::\n\n    A = U \\operatorname{diag}(S) V^{\\text{H}}\n    \\mathrlap{\\qquad U \\in \\mathbb{K}^{m \\times m}, S \\in \\mathbb{R}^k, V \\in \\mathbb{K}^{n \\times n}}\n\nwhere :math:`\\operatorname{diag}(S) \\in \\mathbb{K}^{m \\times n}`,\n:math:`V^{\\text{H}}` is the conjugate transpose when :math:`V` is complex, and the transpose when :math:`V` is real-valued.\nThe matrices  :math:`U`, :math:`V` (and thus :math:`V^{\\text{H}}`) are orthogonal in the real case, and unitary in the complex case.\n\nWhen `m > n` (resp. `m < n`) we can drop the last `m - n` (resp. `n - m`) columns of `U` (resp. `V`) to form the **reduced SVD**:\n\n.. math::\n\n    A = U \\operatorname{diag}(S) V^{\\text{H}}\n    \\mathrlap{\\qquad U \\in \\mathbb{K}^{m \\times k}, S \\in \\mathbb{R}^k, V \\in \\mathbb{K}^{n \\times k}}\n\nwhere :math:`\\operatorname{diag}(S) \\in \\mathbb{K}^{k \\times k}`.\nIn this case, :math:`U` and :math:`V` also have orthonormal columns.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nThe returned decomposition is a named tuple `(U, S, Vh)`\nwhich corresponds to :math:`U`, :math:`S`, :math:`V^{\\text{H}}` above.\n\nThe singular values are returned in descending order.\n\nThe parameter :attr:`full_matrices` chooses between the full (default) and reduced SVD.\n\nThe :attr:`driver` kwarg may be used in CUDA with a cuSOLVER backend to choose the algorithm used to compute the SVD.\nThe choice of a driver is a trade-off between accuracy and speed.\n\n- If :attr:`A` is well-conditioned (its `condition number`_ is not too large), or you do not mind some precision loss.\n\n  - For a general matrix: `'gesvdj'` (Jacobi method)\n  - If :attr:`A` is tall or wide (`m >> n` or `m << n`): `'gesvda'` (Approximate method)\n\n- If :attr:`A` is not well-conditioned or precision is relevant: `'gesvd'` (QR based)\n\nBy default (:attr:`driver`\\ `= None`), we call `'gesvdj'` and, if it fails, we fallback to `'gesvd'`.\n\nDifferences with `numpy.linalg.svd`:\n\n- Unlike `numpy.linalg.svd`, this function always returns a tuple of three tensors\n  and it doesn't support `compute_uv` argument.\n  Please use :func:`torch.linalg.svdvals`, which computes only the singular values,\n  instead of `compute_uv=False`.\n\n.. note:: When :attr:`full_matrices`\\ `= True`, the gradients with respect to `U[..., :, min(m, n):]`\n          and `Vh[..., min(m, n):, :]` will be ignored, as those vectors can be arbitrary bases\n          of the corresponding subspaces.\n\n.. warning:: The returned tensors `U` and `V` are not unique, nor are they continuous with\n             respect to :attr:`A`.\n             Due to this lack of uniqueness, different hardware and software may compute\n             different singular vectors.\n\n             This non-uniqueness is caused by the fact that multiplying any pair of singular\n             vectors :math:`u_k, v_k` by `-1` in the real case or by\n             :math:`e^{i \\phi}, \\phi \\in \\mathbb{R}` in the complex case produces another two\n             valid singular vectors of the matrix.\n             For this reason, the loss function shall not depend on this :math:`e^{i \\phi}` quantity,\n             as it is not well-defined.\n             This is checked for complex inputs when computing the gradients of this function. As such,\n             when inputs are complex and are on a CUDA device, the computation of the gradients\n             of this function synchronizes that device with the CPU.\n\n.. warning:: Gradients computed using `U` or `Vh` will only be finite when\n             :attr:`A` does not have repeated singular values. If :attr:`A` is rectangular,\n             additionally, zero must also not be one of its singular values.\n             Furthermore, if the distance between any two singular values is close to zero,\n             the gradient will be numerically unstable, as it depends on the singular values\n             :math:`\\sigma_i` through the computation of\n             :math:`\\frac{1}{\\min_{i \\neq j} \\sigma_i^2 - \\sigma_j^2}`.\n             In the rectangular case, the gradient will also be numerically unstable when\n             :attr:`A` has small singular values, as it also depends on the computation of\n             :math:`\\frac{1}{\\sigma_i}`.\n\n.. seealso::\n\n        :func:`torch.linalg.svdvals` computes only the singular values.\n        Unlike :func:`torch.linalg.svd`, the gradients of :func:`~svdvals` are always\n        numerically stable.\n\n        :func:`torch.linalg.eig` for a function that computes another type of spectral\n        decomposition of a matrix. The eigendecomposition works just on square matrices.\n\n        :func:`torch.linalg.eigh` for a (faster) function that computes the eigenvalue decomposition\n        for Hermitian and symmetric matrices.\n\n        :func:`torch.linalg.qr` for another (much faster) decomposition that works on general\n        matrices.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions."
          },
          "full_matrices": {
            "type": "bool, optional",
            "description": "controls whether to compute the full or reduced"
          },
          "SVD": {
            "type": "",
            "description": ", and consequently,"
          },
          "the": {
            "type": "",
            "description": "shape of the returned tensors\n`U` and `Vh`. Default: `True`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "driver": {
            "type": "str, optional",
            "description": "name of the cuSOLVER method to be used. This keyword argument only works on CUDA inputs."
          },
          "Available": {
            "type": "",
            "description": "options are: `None`, `gesvd`, `gesvdj`, and `gesvda`."
          },
          "Default": {
            "type": "",
            "description": "`None`."
          },
          "out": {
            "type": "tuple, optional",
            "description": "output tuple of three tensors. Ignored if `None`."
          }
        },
        "returns": "A named tuple `(U, S, Vh)` which corresponds to :math:`U`, :math:`S`, :math:`V^{\\text{H}}` above.\n\n    `S` will always be real-valued, even when :attr:`A` is complex.\n    It will also be ordered in descending order.\n\n    `U` and `Vh` will have the same dtype as :attr:`A`. The left / right singular vectors will be given by\n    the columns of `U` and the rows of `Vh` respectively.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "svdvals",
      "signature": "linalg_svdvals(A)",
      "documentation": {
        "description": "linalg.svdvals(A, *, driver=None, out=None) -> Tensor\n\nComputes the singular values of a matrix.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nThe singular values are returned in descending order.\n\n.. note:: This function is equivalent to NumPy's `linalg.svd(A, compute_uv=False)`.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\n.. seealso::\n\n        :func:`torch.linalg.svd` computes the full singular value decomposition.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "driver": {
            "type": "str, optional",
            "description": "name of the cuSOLVER method to be used. This keyword argument only works on CUDA inputs."
          },
          "Available": {
            "type": "",
            "description": "options are: `None`, `gesvd`, `gesvdj`, and `gesvda`."
          },
          "Check": {
            "type": "",
            "description": "func:`torch.linalg.svd` for details."
          },
          "Default": {
            "type": "",
            "description": "`None`."
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "A real-valued tensor, even when :attr:`A` is complex.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "tensorinv",
      "signature": "linalg_tensorinv(A, ind)",
      "documentation": {
        "description": "linalg.tensorinv(A, ind=2, *, out=None) -> Tensor\n\nComputes the multiplicative inverse of :func:`torch.tensordot`.\n\nIf `m` is the product of the first :attr:`ind` dimensions of :attr:`A` and `n` is the product of\nthe rest of the dimensions, this function expects `m` and `n` to be equal.\nIf this is the case, it computes a tensor `X` such that\n`tensordot(\\ `:attr:`A`\\ `, X, \\ `:attr:`ind`\\ `)` is the identity matrix in dimension `m`.\n`X` will have the shape of :attr:`A` but with the first :attr:`ind` dimensions pushed back to the end\n\n.. code:: text\n\n    X.shape == A.shape[ind:] + A.shape[:ind]\n\nSupports input of float, double, cfloat and cdouble dtypes.\n\n.. note:: When :attr:`A` is a `2`-dimensional tensor and :attr:`ind`\\ `= 1`,\n          this function computes the (multiplicative) inverse of :attr:`A`\n          (see :func:`torch.linalg.inv`).\n\n.. note::\n    Consider using :func:`torch.linalg.tensorsolve` if possible for multiplying a tensor on the left\n    by the tensor inverse, as::\n\n        linalg.tensorsolve(A, B) == torch.tensordot(linalg.tensorinv(A), B)  # When B is a tensor with shape A.shape[:B.ndim]\n\n    It is always preferred to use :func:`~tensorsolve` when possible, as it is faster and more\n    numerically stable than computing the pseudoinverse explicitly.\n\n.. seealso::\n\n        :func:`torch.linalg.tensorsolve` computes\n        `torch.tensordot(tensorinv(\\ `:attr:`A`\\ `), \\ `:attr:`B`\\ `)`.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor to invert. Its shape must satisfy\n`prod(\\ `:attr:`A`\\ `.shape[:\\ `:attr:`ind`\\ `]) =="
          },
          "prod": {
            "type": "\\ `:attr:`A`\\ `.shape[\\ `:attr:`ind`\\ `:]",
            "description": "`."
          },
          "ind": {
            "type": "int",
            "description": "index at which to compute the inverse of :func:`torch.tensordot`. Default: `2`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "RuntimeError: if the reshaped :attr:`A` is not invertible or the product of the first\n                  :attr:`ind` dimensions is not equal to the product of the rest.",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "tensorsolve",
      "signature": "linalg_tensorsolve(A, B, dims, If)",
      "documentation": {
        "description": "linalg.tensorsolve(A, B, dims=None, *, out=None) -> Tensor\n\nComputes the solution `X` to the system `torch.tensordot(A, X) = B`.\n\nIf `m` is the product of the first :attr:`B`\\ `.ndim`  dimensions of :attr:`A` and\n`n` is the product of the rest of the dimensions, this function expects `m` and `n` to be equal.\n\nThe returned tensor `x` satisfies\n`tensordot(\\ `:attr:`A`\\ `, x, dims=x.ndim) == \\ `:attr:`B`.\n`x` has shape :attr:`A`\\ `[B.ndim:]`.\n\nIf :attr:`dims` is specified, :attr:`A` will be reshaped as\n\n.. code:: text\n\n    A = movedim(A, dims, range(len(dims) - A.ndim + 1, 0))\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\n\n.. seealso::\n\n        :func:`torch.linalg.tensorinv` computes the multiplicative inverse of\n        :func:`torch.tensordot`.",
        "parameters": {
          "A": {
            "type": "Tensor",
            "description": "tensor to solve for. Its shape must satisfy\n`prod(\\ `:attr:`A`\\ `.shape[:\\ `:attr:`B`\\ `.ndim]) =="
          },
          "prod": {
            "type": "\\ `:attr:`A`\\ `.shape[\\ `:attr:`B`\\ `.ndim:]",
            "description": "`."
          },
          "B": {
            "type": "Tensor",
            "description": "tensor of shape :attr:`A`\\ `.shape[:\\ `:attr:`B`\\ `.ndim]`."
          },
          "dims": {
            "type": "Tuple[int], optional",
            "description": "dimensions of :attr:`A` to be moved."
          },
          "If": {
            "type": "",
            "description": "`None`, no dimensions are moved. Default: `None`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "RuntimeError: if the reshaped :attr:`A`\\ `.view(m, m)` with `m` as above  is not\n                  invertible or the product of the first :attr:`ind` dimensions is not equal\n                  to the product of the rest of the dimensions.",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "vander",
      "signature": "linalg_vander(x, N=None)",
      "documentation": {
        "description": "vander(x, N=None) -> Tensor\n\nGenerates a Vandermonde matrix.\n\nReturns the Vandermonde matrix :math:`V`\n\n.. math::\n\n    V = \\begin{pmatrix}\n            1 & x_1 & x_1^2 & \\dots & x_1^{N-1}\\\\\n            1 & x_2 & x_2^2 & \\dots & x_2^{N-1}\\\\\n            1 & x_3 & x_3^2 & \\dots & x_3^{N-1}\\\\\n            \\vdots & \\vdots & \\vdots & \\ddots &\\vdots \\\\\n            1 & x_n & x_n^2 & \\dots & x_n^{N-1}\n        \\end{pmatrix}.\n\nfor `N > 1`.\nIf :attr:`N`\\ `= None`, then `N = x.size(-1)` so that the output is a square matrix.\n\nSupports inputs of float, double, cfloat, cdouble, and integral dtypes.\nAlso supports batches of vectors, and if :attr:`x` is a batch of vectors then\nthe output has the same batch dimensions.\n\nDifferences with `numpy.vander`:\n\n- Unlike `numpy.vander`, this function returns the powers of :attr:`x` in ascending order.\n  To get them in the reverse order call ``linalg.vander(x, N).flip(-1)``.",
        "parameters": {
          "x": {
            "type": "Tensor",
            "description": "tensor of shape `(*, n)` where `*` is zero or more batch dimensions"
          },
          "consisting": {
            "type": "",
            "description": "of vectors."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "N": {
            "type": "int, optional",
            "description": "Number of columns in the output. Default: `x.size(-1)`"
          },
          "Example": {
            "type": "",
            "description": ":\n>>> x = torch.tensor([1, 2, 3, 5])\n>>> linalg.vander(x)"
          },
          "tensor": {
            "type": "",
            "description": "([[ 1,  1,  1],\n[ 1,  2,  4],\n[ 1,  3,  9],\n[ 1,  5, 25]])"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "vecdot",
      "signature": "linalg_vecdot(x, y)",
      "documentation": {
        "description": "linalg.vecdot(x, y, *, dim=-1, out=None) -> Tensor\n\nComputes the dot product of two batches of vectors along a dimension.\n\nIn symbols, this function computes\n\n.. math::\n\n    \\sum_{i=1}^n \\overline{x_i}y_i.\n\nover the dimension :attr:`dim` where :math:`\\overline{x_i}` denotes the conjugate for complex\nvectors, and it is the identity for real vectors.\n\nSupports input of half, bfloat16, float, double, cfloat, cdouble and integral dtypes.\nIt also supports broadcasting.",
        "parameters": {
          "x": {
            "type": "Tensor",
            "description": "first batch of vectors of shape `(*, n)`."
          },
          "y": {
            "type": "Tensor",
            "description": "second batch of vectors of shape `(*, n)`."
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "dim": {
            "type": "int",
            "description": "Dimension along which to compute the dot product. Default: `-1`."
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "vector_norm",
      "signature": "linalg_vector_norm(x, controlled, ord, dim, the, Default, keepdim, in)",
      "documentation": {
        "description": "linalg.vector_norm(x, ord=2, dim=None, keepdim=False, *, dtype=None, out=None) -> Tensor\n\nComputes a vector norm.\n\nIf :attr:`x` is complex valued, it computes the norm of :attr:`x`\\ `.abs()`\n\nSupports input of float, double, cfloat and cdouble dtypes.\n\nThis function does not necessarily treat multidimensional :attr:`x` as a batch of\nvectors, instead:\n\n- If :attr:`dim`\\ `= None`, :attr:`x` will be flattened before the norm is computed.\n- If :attr:`dim` is an `int` or a `tuple`, the norm will be computed over these dimensions\n  and the other dimensions will be treated as batch dimensions.\n\nThis behavior is for consistency with :func:`torch.linalg.norm`.\n\n:attr:`ord` defines the vector norm that is computed. The following norms are supported:\n\n======================   ===============================\n:attr:`ord`              vector norm\n======================   ===============================\n`2` (default)            `2`-norm (see below)\n`inf`                    `max(abs(x))`\n`-inf`                   `min(abs(x))`\n`0`                      `sum(x != 0)`\nother `int` or `float`   `sum(abs(x)^{ord})^{(1 / ord)}`\n======================   ===============================\n\nwhere `inf` refers to `float('inf')`, NumPy's `inf` object, or any equivalent object.\n\n:attr:`dtype` may be used to perform the computation in a more precise dtype.\nIt is semantically equivalent to calling ``linalg.vector_norm(x.to(dtype))``\nbut it is faster in some cases.\n\n.. seealso::\n\n        :func:`torch.linalg.matrix_norm` computes a matrix norm.",
        "parameters": {
          "x": {
            "type": "Tensor",
            "description": "tensor, flattened by default, but this behavior can be"
          },
          "controlled": {
            "type": "",
            "description": "using :attr:`dim`.  (Note: the keyword argument\n`input` can also be used as an alias for `x`.)"
          },
          "ord": {
            "type": "int, float, inf, -inf, 'fro', 'nuc', optional",
            "description": "order of norm. Default: `2`"
          },
          "dim": {
            "type": "int, Tuple[int], optional",
            "description": "dimensions over which to compute"
          },
          "the": {
            "type": "",
            "description": "norm. See above for the behavior when :attr:`dim`\\ `= None`."
          },
          "Default": {
            "type": "",
            "description": "`None`"
          },
          "keepdim": {
            "type": "bool, optional",
            "description": "If set to `True`, the reduced dimensions are retained"
          },
          "in": {
            "type": "",
            "description": "the result as dimensions with size one. Default: `False`"
          },
          "Keyword": {
            "type": "",
            "description": "args:"
          },
          "out": {
            "type": "Tensor, optional",
            "description": "output tensor. Ignored if `None`. Default: `None`."
          },
          "dtype": {
            "type": ":class:`torch.dtype`, optional",
            "description": "type used to perform the accumulation and the return."
          },
          "If": {
            "type": "",
            "description": "specified, :attr:`x` is cast to :attr:`dtype` before performing the operation,"
          },
          "and": {
            "type": "",
            "description": "the returned tensor's type will be :attr:`dtype` if real and of its real counterpart if complex.\n:attr:`dtype` may be complex if :attr:`x` is complex, otherwise it must be real.\n:attr:`x` should be convertible without narrowing to :attr:`dtype`. Default: None"
          }
        },
        "returns": "A real-valued tensor, even when :attr:`x` is complex.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": [
    {
      "name": "LinAlgError",
      "documentation": {
        "description": "Error raised by torch.linalg function when the cause of error is a numerical inconsistency in the data.\n For example, you can the torch.linalg.inv function will raise torch.linalg.LinAlgError when it finds that a matrix is not invertible.\n \nExample:\n >>> # xdoctest: +REQUIRES(env:TORCH_DOCKTEST_LAPACK)\n >>> matrix = torch.eye(3, 3)\n >>> matrix[-1, -1] = 0\n >>> matrix\n     tensor([[1., 0., 0.],\n             [0., 1., 0.],\n             [0., 0., 0.]])\n >>> torch.linalg.inv(matrix)\n Traceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\n torch._C._LinAlgError: torch.linalg.inv: The diagonal element 3 is zero, the inversion\n could not be completed because the input matrix is singular.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> # xdoctest: +REQUIRES(env:TORCH_DOCKTEST_LAPACK)\n >>> matrix = torch.eye(3, 3)\n >>> matrix[-1, -1] = 0\n >>> matrix\n     tensor([[1., 0., 0.],\n             [0., 1., 0.],\n             [0., 0., 0.]])\n >>> torch.linalg.inv(matrix)\n Traceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\n torch._C._LinAlgError: torch.linalg.inv: The diagonal element 3 is zero, the inversion\n could not be completed because the input matrix is singular."
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "documentation": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "Tensor",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "abs",
          "signature": "abs()",
          "documentation": {
            "description": "abs() -> Tensor\n\nSee :func:`torch.abs`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "abs_",
          "signature": "abs_()",
          "documentation": {
            "description": "abs_() -> Tensor\n\nIn-place version of :meth:`~Tensor.abs`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "absolute",
          "signature": "absolute()",
          "documentation": {
            "description": "absolute() -> Tensor\n\nAlias for :func:`abs`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "absolute_",
          "signature": "absolute_()",
          "documentation": {
            "description": "absolute_() -> Tensor\n\nIn-place version of :meth:`~Tensor.absolute`\nAlias for :func:`abs_`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "acos",
          "signature": "acos()",
          "documentation": {
            "description": "acos() -> Tensor\n\nSee :func:`torch.acos`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "acos_",
          "signature": "acos_()",
          "documentation": {
            "description": "acos_() -> Tensor\n\nIn-place version of :meth:`~Tensor.acos`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "acosh",
          "signature": "acosh()",
          "documentation": {
            "description": "acosh() -> Tensor\n\nSee :func:`torch.acosh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "acosh_",
          "signature": "acosh_()",
          "documentation": {
            "description": "acosh_() -> Tensor\n\nIn-place version of :meth:`~Tensor.acosh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "add",
          "signature": "add(other, *, alpha=1)",
          "documentation": {
            "description": "add(other, *, alpha=1) -> Tensor\n\nAdd a scalar or tensor to :attr:`self` tensor. If both :attr:`alpha`\nand :attr:`other` are specified, each element of :attr:`other` is scaled by\n:attr:`alpha` before being used.\n\nWhen :attr:`other` is a tensor, the shape of :attr:`other` must be\n:ref:`broadcastable <broadcasting-semantics>` with the shape of the underlying\ntensor\n\nSee :func:`torch.add`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "add_",
          "signature": "add_(other, *, alpha=1)",
          "documentation": {
            "description": "add_(other, *, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.add`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "addbmm",
          "signature": "addbmm(batch1, batch2, *, beta=1, alpha=1)",
          "documentation": {
            "description": "addbmm(batch1, batch2, *, beta=1, alpha=1) -> Tensor\n\nSee :func:`torch.addbmm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "addbmm_",
          "signature": "addbmm_(batch1, batch2, *, beta=1, alpha=1)",
          "documentation": {
            "description": "addbmm_(batch1, batch2, *, beta=1, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.addbmm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "addcdiv",
          "signature": "addcdiv(tensor1, tensor2, *, value=1)",
          "documentation": {
            "description": "addcdiv(tensor1, tensor2, *, value=1) -> Tensor\n\nSee :func:`torch.addcdiv`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "addcdiv_",
          "signature": "addcdiv_(tensor1, tensor2, *, value=1)",
          "documentation": {
            "description": "addcdiv_(tensor1, tensor2, *, value=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.addcdiv`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "addcmul",
          "signature": "addcmul(tensor1, tensor2, *, value=1)",
          "documentation": {
            "description": "addcmul(tensor1, tensor2, *, value=1) -> Tensor\n\nSee :func:`torch.addcmul`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "addcmul_",
          "signature": "addcmul_(tensor1, tensor2, *, value=1)",
          "documentation": {
            "description": "addcmul_(tensor1, tensor2, *, value=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.addcmul`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "addmm",
          "signature": "addmm(mat1, mat2, *, beta=1, alpha=1)",
          "documentation": {
            "description": "addmm(mat1, mat2, *, beta=1, alpha=1) -> Tensor\n\nSee :func:`torch.addmm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "addmm_",
          "signature": "addmm_(mat1, mat2, *, beta=1, alpha=1)",
          "documentation": {
            "description": "addmm_(mat1, mat2, *, beta=1, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.addmm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "addmv",
          "signature": "addmv(mat, vec, *, beta=1, alpha=1)",
          "documentation": {
            "description": "addmv(mat, vec, *, beta=1, alpha=1) -> Tensor\n\nSee :func:`torch.addmv`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "addmv_",
          "signature": "addmv_(mat, vec, *, beta=1, alpha=1)",
          "documentation": {
            "description": "addmv_(mat, vec, *, beta=1, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.addmv`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "addr",
          "signature": "addr(vec1, vec2, *, beta=1, alpha=1)",
          "documentation": {
            "description": "addr(vec1, vec2, *, beta=1, alpha=1) -> Tensor\n\nSee :func:`torch.addr`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "addr_",
          "signature": "addr_(vec1, vec2, *, beta=1, alpha=1)",
          "documentation": {
            "description": "addr_(vec1, vec2, *, beta=1, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.addr`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "adjoint",
          "signature": "adjoint()",
          "documentation": {
            "description": "adjoint() -> Tensor\n\nAlias for :func:`adjoint`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "align_as",
          "signature": "align_as(other)",
          "documentation": {
            "description": "align_as(other) -> Tensor\n\nPermutes the dimensions of the :attr:`self` tensor to match the dimension order\nin the :attr:`other` tensor, adding size-one dims for any new names.\n\nThis operation is useful for explicit broadcasting by names (see examples).\n\nAll of the dims of :attr:`self` must be named in order to use this method.\nThe resulting tensor is a view on the original tensor.\n\nAll dimension names of :attr:`self` must be present in ``other.names``.\n:attr:`other` may contain named dimensions that are not in ``self.names``;\nthe output tensor has a size-one dimension for each of those new names.\n\nTo align a tensor to a specific order, use :meth:`~Tensor.align_to`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "align_to",
          "signature": "align_to(self, *names)",
          "documentation": {
            "description": "Permutes the dimensions of the :attr:`self` tensor to match the order\nspecified in :attr:`names`, adding size-one dims for any new names.\n\nAll of the dims of :attr:`self` must be named in order to use this method.\nThe resulting tensor is a view on the original tensor.\n\nAll dimension names of :attr:`self` must be present in :attr:`names`.\n:attr:`names` may contain additional names that are not in ``self.names``;\nthe output tensor has a size-one dimension for each of those new names.\n\n:attr:`names` may contain up to one Ellipsis (``...``).\nThe Ellipsis is expanded to be equal to all dimension names of :attr:`self`\nthat are not mentioned in :attr:`names`, in the order that they appear\nin :attr:`self`.\n\nPython 2 does not support Ellipsis but one may use a string literal\ninstead (``'...'``).",
            "parameters": {
              "names": {
                "type": "iterable of str",
                "description": "The desired dimension ordering of the"
              },
              "output": {
                "type": "",
                "description": "tensor. May contain up to one Ellipsis that is expanded"
              },
              "to": {
                "type": "",
                "description": "all unmentioned dim names of :attr:`self`."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "all",
          "signature": "all(dim=None, keepdim=False)",
          "documentation": {
            "description": "all(dim=None, keepdim=False) -> Tensor\n\nSee :func:`torch.all`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "allclose",
          "signature": "allclose(other, rtol=1e-05, atol=1e-08, equal_nan=False)",
          "documentation": {
            "description": "allclose(other, rtol=1e-05, atol=1e-08, equal_nan=False) -> Tensor\n\nSee :func:`torch.allclose`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "amax",
          "signature": "amax(dim=None, keepdim=False)",
          "documentation": {
            "description": "amax(dim=None, keepdim=False) -> Tensor\n\nSee :func:`torch.amax`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "amin",
          "signature": "amin(dim=None, keepdim=False)",
          "documentation": {
            "description": "amin(dim=None, keepdim=False) -> Tensor\n\nSee :func:`torch.amin`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "aminmax",
          "signature": "aminmax(*, dim=None, keepdim=False)",
          "documentation": {
            "description": "aminmax(*, dim=None, keepdim=False) -> (Tensor min, Tensor max)\n\nSee :func:`torch.aminmax`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "angle",
          "signature": "angle()",
          "documentation": {
            "description": "angle() -> Tensor\n\nSee :func:`torch.angle`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(dim=None, keepdim=False)",
          "documentation": {
            "description": "any(dim=None, keepdim=False) -> Tensor\n\nSee :func:`torch.any`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "apply_",
          "signature": "apply_(callable)",
          "documentation": {
            "description": "apply_(callable) -> Tensor\n\nApplies the function :attr:`callable` to each element in the tensor, replacing\neach element with the value returned by :attr:`callable`.\n\n.. note::\n\n    This function only works with CPU tensors and should not be used in code\n    sections that require high performance.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arccos",
          "signature": "arccos()",
          "documentation": {
            "description": "arccos() -> Tensor\n\nSee :func:`torch.arccos`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arccos_",
          "signature": "arccos_()",
          "documentation": {
            "description": "arccos_() -> Tensor\n\nIn-place version of :meth:`~Tensor.arccos`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arccosh",
          "signature": "arccosh()",
          "documentation": {
            "description": "acosh() -> Tensor\n\nSee :func:`torch.arccosh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arccosh_",
          "signature": "arccosh_()",
          "documentation": {
            "description": "acosh_() -> Tensor\n\nIn-place version of :meth:`~Tensor.arccosh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arcsin",
          "signature": "arcsin()",
          "documentation": {
            "description": "arcsin() -> Tensor\n\nSee :func:`torch.arcsin`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arcsin_",
          "signature": "arcsin_()",
          "documentation": {
            "description": "arcsin_() -> Tensor\n\nIn-place version of :meth:`~Tensor.arcsin`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arcsinh",
          "signature": "arcsinh()",
          "documentation": {
            "description": "arcsinh() -> Tensor\n\nSee :func:`torch.arcsinh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arcsinh_",
          "signature": "arcsinh_()",
          "documentation": {
            "description": "arcsinh_() -> Tensor\n\nIn-place version of :meth:`~Tensor.arcsinh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arctan",
          "signature": "arctan()",
          "documentation": {
            "description": "arctan() -> Tensor\n\nSee :func:`torch.arctan`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arctan2",
          "signature": "arctan2(other)",
          "documentation": {
            "description": "arctan2(other) -> Tensor\n\nSee :func:`torch.arctan2`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arctan2_",
          "signature": "arctan2_(other)",
          "documentation": {
            "description": "atan2_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.arctan2`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arctan_",
          "signature": "arctan_()",
          "documentation": {
            "description": "arctan_() -> Tensor\n\nIn-place version of :meth:`~Tensor.arctan`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arctanh",
          "signature": "arctanh()",
          "documentation": {
            "description": "arctanh() -> Tensor\n\nSee :func:`torch.arctanh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "arctanh_",
          "signature": "arctanh_(other)",
          "documentation": {
            "description": "arctanh_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.arctanh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(dim=None, keepdim=False)",
          "documentation": {
            "description": "argmax(dim=None, keepdim=False) -> LongTensor\n\nSee :func:`torch.argmax`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(dim=None, keepdim=False)",
          "documentation": {
            "description": "argmin(dim=None, keepdim=False) -> LongTensor\n\nSee :func:`torch.argmin`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(dim=-1, descending=False)",
          "documentation": {
            "description": "argsort(dim=-1, descending=False) -> LongTensor\n\nSee :func:`torch.argsort`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argwhere",
          "signature": "argwhere()",
          "documentation": {
            "description": "argwhere() -> Tensor\n\nSee :func:`torch.argwhere`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "as_strided",
          "signature": "as_strided(size, stride, storage_offset=None)",
          "documentation": {
            "description": "as_strided(size, stride, storage_offset=None) -> Tensor\n\nSee :func:`torch.as_strided`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "as_strided_",
          "signature": "as_strided_(size, stride, storage_offset=None)",
          "documentation": {
            "description": "as_strided_(size, stride, storage_offset=None) -> Tensor\n\nIn-place version of :meth:`~Tensor.as_strided`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "as_strided_scatter",
          "signature": "as_strided_scatter(src, size, stride, storage_offset=None)",
          "documentation": {
            "description": "as_strided_scatter(src, size, stride, storage_offset=None) -> Tensor\n\nSee :func:`torch.as_strided_scatter`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "as_subclass",
          "signature": "as_subclass(cls)",
          "documentation": {
            "description": "as_subclass(cls) -> Tensor\n\nMakes a ``cls`` instance with the same data pointer as ``self``. Changes\nin the output mirror changes in ``self``, and the output stays attached\nto the autograd graph. ``cls`` must be a subclass of ``Tensor``.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "asin",
          "signature": "asin()",
          "documentation": {
            "description": "asin() -> Tensor\n\nSee :func:`torch.asin`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "asin_",
          "signature": "asin_()",
          "documentation": {
            "description": "asin_() -> Tensor\n\nIn-place version of :meth:`~Tensor.asin`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "asinh",
          "signature": "asinh()",
          "documentation": {
            "description": "asinh() -> Tensor\n\nSee :func:`torch.asinh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "asinh_",
          "signature": "asinh_()",
          "documentation": {
            "description": "asinh_() -> Tensor\n\nIn-place version of :meth:`~Tensor.asinh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "atan",
          "signature": "atan()",
          "documentation": {
            "description": "atan() -> Tensor\n\nSee :func:`torch.atan`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "atan2",
          "signature": "atan2(other)",
          "documentation": {
            "description": "atan2(other) -> Tensor\n\nSee :func:`torch.atan2`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "atan2_",
          "signature": "atan2_(other)",
          "documentation": {
            "description": "atan2_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.atan2`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "atan_",
          "signature": "atan_()",
          "documentation": {
            "description": "atan_() -> Tensor\n\nIn-place version of :meth:`~Tensor.atan`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "atanh",
          "signature": "atanh()",
          "documentation": {
            "description": "atanh() -> Tensor\n\nSee :func:`torch.atanh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "atanh_",
          "signature": "atanh_(other)",
          "documentation": {
            "description": "atanh_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.atanh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "backward",
          "signature": "backward(self, gradient=None, retain_graph=None, create_graph=False, inputs=None)",
          "documentation": {
            "description": "Computes the gradient of current tensor wrt graph leaves.\n\nThe graph is differentiated using the chain rule. If the tensor is\nnon-scalar (i.e. its data has more than one element) and requires\ngradient, the function additionally requires specifying a ``gradient``.\nIt should be a tensor of matching type and shape, that represents\nthe gradient of the differentiated function w.r.t. ``self``.\n\nThis function accumulates gradients in the leaves - you might need to zero\n``.grad`` attributes or set them to ``None`` before calling it.\nSee :ref:`Default gradient layouts<default-grad-layouts>`\nfor details on the memory layout of accumulated gradients.\n\n.. note::\n\n    If you run any forward ops, create ``gradient``, and/or call ``backward``\n    in a user-specified CUDA stream context, see\n    :ref:`Stream semantics of backward passes<bwd-cuda-stream-semantics>`.\n\n.. note::\n\n    When ``inputs`` are provided and a given input is not a leaf,\n    the current implementation will call its grad_fn (though it is not strictly needed to get this gradients).\n    It is an implementation detail on which the user should not rely.\n    See https://github.com/pytorch/pytorch/pull/60521#issuecomment-867061780 for more details.",
            "parameters": {
              "gradient": {
                "type": "Tensor, optional",
                "description": "The gradient of the function"
              },
              "being": {
                "type": "",
                "description": "differentiated w.r.t. ``self``."
              },
              "This": {
                "type": "",
                "description": "argument can be omitted if ``self`` is a scalar."
              },
              "retain_graph": {
                "type": "bool, optional",
                "description": "If ``False``, the graph used to compute"
              },
              "the": {
                "type": "",
                "description": "grads will be freed. Note that in nearly all cases setting"
              },
              "this": {
                "type": "",
                "description": "option to True is not needed and often can be worked around"
              },
              "in": {
                "type": "",
                "description": "a much more efficient way. Defaults to the value of\n``create_graph``."
              },
              "create_graph": {
                "type": "bool, optional",
                "description": "If ``True``, graph of the derivative will"
              },
              "be": {
                "type": "",
                "description": "constructed, allowing to compute higher order derivative"
              },
              "products": {
                "type": "",
                "description": ". Defaults to ``False``."
              },
              "inputs": {
                "type": "sequence of Tensor, optional",
                "description": "Inputs w.r.t. which the gradient will be"
              },
              "accumulated": {
                "type": "",
                "description": "into ``.grad``. All other tensors will be ignored. If not"
              },
              "provided": {
                "type": "",
                "description": ", the gradient is accumulated into all the leaf Tensors that were"
              },
              "used": {
                "type": "",
                "description": "to compute the :attr:`tensors`."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "baddbmm",
          "signature": "baddbmm(batch1, batch2, *, beta=1, alpha=1)",
          "documentation": {
            "description": "baddbmm(batch1, batch2, *, beta=1, alpha=1) -> Tensor\n\nSee :func:`torch.baddbmm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "baddbmm_",
          "signature": "baddbmm_(batch1, batch2, *, beta=1, alpha=1)",
          "documentation": {
            "description": "baddbmm_(batch1, batch2, *, beta=1, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.baddbmm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bernoulli",
          "signature": "bernoulli(*, generator=None)",
          "documentation": {
            "description": "bernoulli(*, generator=None) -> Tensor\n\nReturns a result tensor where each :math:`\\texttt{result[i]}` is independently\nsampled from :math:`\\text{Bernoulli}(\\texttt{self[i]})`. :attr:`self` must have\nfloating point ``dtype``, and the result will have the same ``dtype``.\n\nSee :func:`torch.bernoulli`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bernoulli_",
          "signature": "bernoulli_(p=0.5, *, generator=None)",
          "documentation": {
            "description": "bernoulli_(p=0.5, *, generator=None) -> Tensor\n\nFills each location of :attr:`self` with an independent sample from\n:math:`\\text{Bernoulli}(\\texttt{p})`. :attr:`self` can have integral\n``dtype``.\n\n:attr:`p` should either be a scalar or tensor containing probabilities to be\nused for drawing the binary random number.\n\nIf it is a tensor, the :math:`\\text{i}^{th}` element of :attr:`self` tensor\nwill be set to a value sampled from\n:math:`\\text{Bernoulli}(\\texttt{p\\_tensor[i]})`. In this case `p` must have\nfloating point ``dtype``.\n\nSee also :meth:`~Tensor.bernoulli` and :func:`torch.bernoulli`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bfloat16",
          "signature": "bfloat16(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "bfloat16(memory_format=torch.preserve_format) -> Tensor\n``self.bfloat16()`` is equivalent to ``self.to(torch.bfloat16)``. See :func:`to`.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bincount",
          "signature": "bincount(weights=None, minlength=0)",
          "documentation": {
            "description": "bincount(weights=None, minlength=0) -> Tensor\n\nSee :func:`torch.bincount`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bitwise_and",
          "signature": "bitwise_and()",
          "documentation": {
            "description": "bitwise_and() -> Tensor\n\nSee :func:`torch.bitwise_and`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bitwise_and_",
          "signature": "bitwise_and_()",
          "documentation": {
            "description": "bitwise_and_() -> Tensor\n\nIn-place version of :meth:`~Tensor.bitwise_and`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bitwise_left_shift",
          "signature": "bitwise_left_shift(other)",
          "documentation": {
            "description": "bitwise_left_shift(other) -> Tensor\n\nSee :func:`torch.bitwise_left_shift`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bitwise_left_shift_",
          "signature": "bitwise_left_shift_(other)",
          "documentation": {
            "description": "bitwise_left_shift_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.bitwise_left_shift`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bitwise_not",
          "signature": "bitwise_not()",
          "documentation": {
            "description": "bitwise_not() -> Tensor\n\nSee :func:`torch.bitwise_not`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bitwise_not_",
          "signature": "bitwise_not_()",
          "documentation": {
            "description": "bitwise_not_() -> Tensor\n\nIn-place version of :meth:`~Tensor.bitwise_not`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bitwise_or",
          "signature": "bitwise_or()",
          "documentation": {
            "description": "bitwise_or() -> Tensor\n\nSee :func:`torch.bitwise_or`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bitwise_or_",
          "signature": "bitwise_or_()",
          "documentation": {
            "description": "bitwise_or_() -> Tensor\n\nIn-place version of :meth:`~Tensor.bitwise_or`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bitwise_right_shift",
          "signature": "bitwise_right_shift(other)",
          "documentation": {
            "description": "bitwise_right_shift(other) -> Tensor\n\nSee :func:`torch.bitwise_right_shift`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bitwise_right_shift_",
          "signature": "bitwise_right_shift_(other)",
          "documentation": {
            "description": "bitwise_right_shift_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.bitwise_right_shift`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bitwise_xor",
          "signature": "bitwise_xor()",
          "documentation": {
            "description": "bitwise_xor() -> Tensor\n\nSee :func:`torch.bitwise_xor`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bitwise_xor_",
          "signature": "bitwise_xor_()",
          "documentation": {
            "description": "bitwise_xor_() -> Tensor\n\nIn-place version of :meth:`~Tensor.bitwise_xor`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bmm",
          "signature": "bmm(batch2)",
          "documentation": {
            "description": "bmm(batch2) -> Tensor\n\nSee :func:`torch.bmm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bool",
          "signature": "bool(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "bool(memory_format=torch.preserve_format) -> Tensor\n\n``self.bool()`` is equivalent to ``self.to(torch.bool)``. See :func:`to`.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "broadcast_to",
          "signature": "broadcast_to(shape)",
          "documentation": {
            "description": "broadcast_to(shape) -> Tensor\n\nSee :func:`torch.broadcast_to`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byte",
          "signature": "byte(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "byte(memory_format=torch.preserve_format) -> Tensor\n\n``self.byte()`` is equivalent to ``self.to(torch.uint8)``. See :func:`to`.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cauchy_",
          "signature": "cauchy_(median=0, sigma=1, *, generator=None)",
          "documentation": {
            "description": "cauchy_(median=0, sigma=1, *, generator=None) -> Tensor\n\nFills the tensor with numbers drawn from the Cauchy distribution:\n\n.. math::\n\n    f(x) = \\dfrac{1}{\\pi} \\dfrac{\\sigma}{(x - \\text{median})^2 + \\sigma^2}\n\n.. note::\n  Sigma (:math:`\\sigma`) is used to denote the scale parameter in Cauchy distribution.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ccol_indices",
          "signature": "ccol_indices(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cdouble",
          "signature": "cdouble(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "cdouble(memory_format=torch.preserve_format) -> Tensor\n\n``self.cdouble()`` is equivalent to ``self.to(torch.complex128)``. See :func:`to`.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ceil",
          "signature": "ceil()",
          "documentation": {
            "description": "ceil() -> Tensor\n\nSee :func:`torch.ceil`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ceil_",
          "signature": "ceil_()",
          "documentation": {
            "description": "ceil_() -> Tensor\n\nIn-place version of :meth:`~Tensor.ceil`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cfloat",
          "signature": "cfloat(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "cfloat(memory_format=torch.preserve_format) -> Tensor\n\n``self.cfloat()`` is equivalent to ``self.to(torch.complex64)``. See :func:`to`.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "chalf",
          "signature": "chalf(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "chalf(memory_format=torch.preserve_format) -> Tensor\n\n``self.chalf()`` is equivalent to ``self.to(torch.complex32)``. See :func:`to`.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "char",
          "signature": "char(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "char(memory_format=torch.preserve_format) -> Tensor\n\n``self.char()`` is equivalent to ``self.to(torch.int8)``. See :func:`to`.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cholesky",
          "signature": "cholesky(upper=False)",
          "documentation": {
            "description": "cholesky(upper=False) -> Tensor\n\nSee :func:`torch.cholesky`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cholesky_inverse",
          "signature": "cholesky_inverse(upper=False)",
          "documentation": {
            "description": "cholesky_inverse(upper=False) -> Tensor\n\nSee :func:`torch.cholesky_inverse`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cholesky_solve",
          "signature": "cholesky_solve(input2, upper=False)",
          "documentation": {
            "description": "cholesky_solve(input2, upper=False) -> Tensor\n\nSee :func:`torch.cholesky_solve`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "chunk",
          "signature": "chunk(chunks, dim=0)",
          "documentation": {
            "description": "chunk(chunks, dim=0) -> List of Tensors\n\nSee :func:`torch.chunk`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clamp",
          "signature": "clamp(min=None, max=None)",
          "documentation": {
            "description": "clamp(min=None, max=None) -> Tensor\n\nSee :func:`torch.clamp`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clamp_",
          "signature": "clamp_(min=None, max=None)",
          "documentation": {
            "description": "clamp_(min=None, max=None) -> Tensor\n\nIn-place version of :meth:`~Tensor.clamp`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clamp_max",
          "signature": "clamp_max(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clamp_max_",
          "signature": "clamp_max_(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clamp_min",
          "signature": "clamp_min(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clamp_min_",
          "signature": "clamp_min_(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(min=None, max=None)",
          "documentation": {
            "description": "clip(min=None, max=None) -> Tensor\n\nAlias for :meth:`~Tensor.clamp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip_",
          "signature": "clip_(min=None, max=None)",
          "documentation": {
            "description": "clip_(min=None, max=None) -> Tensor\n\nAlias for :meth:`~Tensor.clamp_`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clone",
          "signature": "clone(*, memory_format=torch.preserve_format)",
          "documentation": {
            "description": "clone(*, memory_format=torch.preserve_format) -> Tensor\n\nSee :func:`torch.clone`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "coalesce",
          "signature": "coalesce()",
          "documentation": {
            "description": "coalesce() -> Tensor\n\nReturns a coalesced copy of :attr:`self` if :attr:`self` is an\n:ref:`uncoalesced tensor <sparse-uncoalesced-coo-docs>`.\n\nReturns :attr:`self` if :attr:`self` is a coalesced tensor.\n\n.. warning::\n  Throws an error if :attr:`self` is not a sparse COO tensor.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "col_indices",
          "signature": "col_indices()",
          "documentation": {
            "description": "col_indices() -> IntTensor\n\nReturns the tensor containing the column indices of the :attr:`self`\ntensor when :attr:`self` is a sparse CSR tensor of layout ``sparse_csr``.\nThe ``col_indices`` tensor is strictly of shape (:attr:`self`.nnz())\nand of type ``int32`` or ``int64``.  When using MKL routines such as sparse\nmatrix multiplication, it is necessary to use ``int32`` indexing in order\nto avoid downcasting and potentially losing information.\n\nExample::\n    >>> csr = torch.eye(5,5).to_sparse_csr()\n    >>> csr.col_indices()\n    tensor([0, 1, 2, 3, 4], dtype=torch.int32)",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj()",
          "documentation": {
            "description": "conj() -> Tensor\n\nSee :func:`torch.conj`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj_physical",
          "signature": "conj_physical()",
          "documentation": {
            "description": "conj_physical() -> Tensor\n\nSee :func:`torch.conj_physical`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj_physical_",
          "signature": "conj_physical_()",
          "documentation": {
            "description": "conj_physical_() -> Tensor\n\nIn-place version of :meth:`~Tensor.conj_physical`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "contiguous",
          "signature": "contiguous(memory_format=torch.contiguous_format)",
          "documentation": {
            "description": "contiguous(memory_format=torch.contiguous_format) -> Tensor\n\nReturns a contiguous in memory tensor containing the same data as :attr:`self` tensor. If\n:attr:`self` tensor is already in the specified memory format, this function returns the\n:attr:`self` tensor.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.contiguous_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy_",
          "signature": "copy_(src, non_blocking=False)",
          "documentation": {
            "description": "copy_(src, non_blocking=False) -> Tensor\n\nCopies the elements from :attr:`src` into :attr:`self` tensor and returns\n:attr:`self`.\n\nThe :attr:`src` tensor must be :ref:`broadcastable <broadcasting-semantics>`\nwith the :attr:`self` tensor. It may be of a different data type or reside on a\ndifferent device.",
            "parameters": {
              "src": {
                "type": "Tensor",
                "description": "the source tensor to copy from"
              },
              "non_blocking": {
                "type": "bool",
                "description": "if ``True`` and this copy is between CPU and GPU,"
              },
              "the": {
                "type": "",
                "description": "copy may occur asynchronously with respect to the host. For other"
              },
              "cases": {
                "type": "",
                "description": ", this argument has no effect."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copysign",
          "signature": "copysign(other)",
          "documentation": {
            "description": "copysign(other) -> Tensor\n\nSee :func:`torch.copysign`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copysign_",
          "signature": "copysign_(other)",
          "documentation": {
            "description": "copysign_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.copysign`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "corrcoef",
          "signature": "corrcoef()",
          "documentation": {
            "description": "corrcoef() -> Tensor\n\nSee :func:`torch.corrcoef`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cos",
          "signature": "cos()",
          "documentation": {
            "description": "cos() -> Tensor\n\nSee :func:`torch.cos`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cos_",
          "signature": "cos_()",
          "documentation": {
            "description": "cos_() -> Tensor\n\nIn-place version of :meth:`~Tensor.cos`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cosh",
          "signature": "cosh()",
          "documentation": {
            "description": "cosh() -> Tensor\n\nSee :func:`torch.cosh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cosh_",
          "signature": "cosh_()",
          "documentation": {
            "description": "cosh_() -> Tensor\n\nIn-place version of :meth:`~Tensor.cosh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "count_nonzero",
          "signature": "count_nonzero(dim=None)",
          "documentation": {
            "description": "count_nonzero(dim=None) -> Tensor\n\nSee :func:`torch.count_nonzero`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cov",
          "signature": "cov(*, correction=1, fweights=None, aweights=None)",
          "documentation": {
            "description": "cov(*, correction=1, fweights=None, aweights=None) -> Tensor\n\nSee :func:`torch.cov`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cpu",
          "signature": "cpu(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "cpu(memory_format=torch.preserve_format) -> Tensor\n\nReturns a copy of this object in CPU memory.\n\nIf this object is already in CPU memory and on the correct device,\nthen no copy is performed and the original object is returned.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cross",
          "signature": "cross(other, dim=None)",
          "documentation": {
            "description": "cross(other, dim=None) -> Tensor\n\nSee :func:`torch.cross`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "crow_indices",
          "signature": "crow_indices()",
          "documentation": {
            "description": "crow_indices() -> IntTensor\n\nReturns the tensor containing the compressed row indices of the :attr:`self`\ntensor when :attr:`self` is a sparse CSR tensor of layout ``sparse_csr``.\nThe ``crow_indices`` tensor is strictly of shape (:attr:`self`.size(0) + 1)\nand of type ``int32`` or ``int64``. When using MKL routines such as sparse\nmatrix multiplication, it is necessary to use ``int32`` indexing in order\nto avoid downcasting and potentially losing information.\n\nExample::\n    >>> csr = torch.eye(5,5).to_sparse_csr()\n    >>> csr.crow_indices()\n    tensor([0, 1, 2, 3, 4, 5], dtype=torch.int32)",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cuda",
          "signature": "cuda(device=None, non_blocking=False, memory_format=torch.preserve_format)",
          "documentation": {
            "description": "cuda(device=None, non_blocking=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a copy of this object in CUDA memory.\n\nIf this object is already in CUDA memory and on the correct device,\nthen no copy is performed and the original object is returned.",
            "parameters": {
              "device": {
                "type": ":class:`torch.device`",
                "description": "The destination GPU device."
              },
              "Defaults": {
                "type": "",
                "description": "to the current CUDA device."
              },
              "non_blocking": {
                "type": "bool",
                "description": "If ``True`` and the source is in pinned memory,"
              },
              "the": {
                "type": "",
                "description": "copy will be asynchronous with respect to the host."
              },
              "Otherwise": {
                "type": "",
                "description": ", the argument has no effect. Default: ``False``."
              },
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cummax",
          "signature": "cummax(dim)",
          "documentation": {
            "description": "cummax(dim) -> (Tensor, Tensor)\n\nSee :func:`torch.cummax`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cummin",
          "signature": "cummin(dim)",
          "documentation": {
            "description": "cummin(dim) -> (Tensor, Tensor)\n\nSee :func:`torch.cummin`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(dim, dtype=None)",
          "documentation": {
            "description": "cumprod(dim, dtype=None) -> Tensor\n\nSee :func:`torch.cumprod`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod_",
          "signature": "cumprod_(dim, dtype=None)",
          "documentation": {
            "description": "cumprod_(dim, dtype=None) -> Tensor\n\nIn-place version of :meth:`~Tensor.cumprod`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(dim, dtype=None)",
          "documentation": {
            "description": "cumsum(dim, dtype=None) -> Tensor\n\nSee :func:`torch.cumsum`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum_",
          "signature": "cumsum_(dim, dtype=None)",
          "documentation": {
            "description": "cumsum_(dim, dtype=None) -> Tensor\n\nIn-place version of :meth:`~Tensor.cumsum`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "data_ptr",
          "signature": "data_ptr()",
          "documentation": {
            "description": "data_ptr() -> int\n\nReturns the address of the first element of :attr:`self` tensor.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "deg2rad",
          "signature": "deg2rad()",
          "documentation": {
            "description": "deg2rad() -> Tensor\n\nSee :func:`torch.deg2rad`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "deg2rad_",
          "signature": "deg2rad_()",
          "documentation": {
            "description": "deg2rad_() -> Tensor\n\nIn-place version of :meth:`~Tensor.deg2rad`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dense_dim",
          "signature": "dense_dim()",
          "documentation": {
            "description": "dense_dim() -> int\n\nReturn the number of dense dimensions in a :ref:`sparse tensor <sparse-docs>` :attr:`self`.\n\n.. note::\n  Returns ``len(self.shape)`` if :attr:`self` is not a sparse tensor.\n\nSee also :meth:`Tensor.sparse_dim` and :ref:`hybrid tensors <sparse-hybrid-coo-docs>`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dequantize",
          "signature": "dequantize()",
          "documentation": {
            "description": "dequantize() -> Tensor\n\nGiven a quantized Tensor, dequantize it and return the dequantized float Tensor.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "det",
          "signature": "det()",
          "documentation": {
            "description": "det() -> Tensor\n\nSee :func:`torch.det`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "detach",
          "signature": "detach(...)",
          "documentation": {
            "description": "Returns a new Tensor, detached from the current graph.\n\nThe result will never require gradient.\n\nThis method also affects forward mode AD gradients and the result will never\nhave forward mode AD gradients.\n\n.. note::\n\n  Returned Tensor shares the same storage with the original one.\n  In-place modifications on either of them will be seen, and may trigger\n  errors in correctness checks.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "detach_",
          "signature": "detach_(...)",
          "documentation": {
            "description": "Detaches the Tensor from the graph that created it, making it a leaf.\nViews cannot be detached in-place.\n\nThis method also affects forward mode AD gradients and the result will never\nhave forward mode AD gradients.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diag",
          "signature": "diag(diagonal=0)",
          "documentation": {
            "description": "diag(diagonal=0) -> Tensor\n\nSee :func:`torch.diag`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diag_embed",
          "signature": "diag_embed(offset=0, dim1=-2, dim2=-1)",
          "documentation": {
            "description": "diag_embed(offset=0, dim1=-2, dim2=-1) -> Tensor\n\nSee :func:`torch.diag_embed`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagflat",
          "signature": "diagflat(offset=0)",
          "documentation": {
            "description": "diagflat(offset=0) -> Tensor\n\nSee :func:`torch.diagflat`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(offset=0, dim1=0, dim2=1)",
          "documentation": {
            "description": "diagonal(offset=0, dim1=0, dim2=1) -> Tensor\n\nSee :func:`torch.diagonal`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal_scatter",
          "signature": "diagonal_scatter(src, offset=0, dim1=0, dim2=1)",
          "documentation": {
            "description": "diagonal_scatter(src, offset=0, dim1=0, dim2=1) -> Tensor\n\nSee :func:`torch.diagonal_scatter`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diff",
          "signature": "diff(n=1, dim=-1, prepend=None, append=None)",
          "documentation": {
            "description": "diff(n=1, dim=-1, prepend=None, append=None) -> Tensor\n\nSee :func:`torch.diff`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "digamma",
          "signature": "digamma()",
          "documentation": {
            "description": "digamma() -> Tensor\n\nSee :func:`torch.digamma`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "digamma_",
          "signature": "digamma_()",
          "documentation": {
            "description": "digamma_() -> Tensor\n\nIn-place version of :meth:`~Tensor.digamma`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dim",
          "signature": "dim()",
          "documentation": {
            "description": "dim() -> int\n\nReturns the number of dimensions of :attr:`self` tensor.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dim_order",
          "signature": "dim_order(self, *, ambiguity_check: Union[bool, List[torch.memory_format]] = False)",
          "documentation": {
            "description": "dim_order(ambiguity_check=False) -> tuple\n\nReturns the uniquely determined tuple of int describing the dim order or\nphysical layout of :attr:`self`.\n\nThe dim order represents how dimensions are laid out in memory,\nstarting from the outermost to the innermost dimension.\n\nNote that the dim order may not always be uniquely determined.\nIf `ambiguity_check` is True, this function raises a RuntimeError when the dim order cannot be uniquely determined;\nIf `ambiguity_check` is a list of memory formats, this function raises a RuntimeError when tensor can not be interpreted\ninto exactly one of the given memory formats, or it cannot be uniquely determined.\nIf `ambiguity_check` is False, it will return one of legal dim order(s) without checking its uniqueness.\nOtherwise, it will raise TypeError.",
            "parameters": {
              "ambiguity_check": {
                "type": "bool or List[torch.memory_format]",
                "description": "The check method for ambiguity of dim order.\n>>> torch.empty((2, 3, 5, 7)).dim_order()\n(0, 1, 2, 3)\n>>> torch.empty((2, 3, 5, 7)).transpose(1, 2).dim_order()\n(0, 2, 1, 3)\n>>> torch.empty((2, 3, 5, 7), memory_format=torch.channels_last).dim_order()\n(0, 2, 3, 1)\n>>> torch.empty((1, 2, 3, 4)).dim_order()\n(0, 1, 2, 3)\n>>> try:\n...     torch.empty((1, 2, 3, 4)).dim_order(ambiguity_check=True)\n... except RuntimeError as e:\n...     print(e)"
              },
              "The": {
                "type": "",
                "description": "dim_order tensor API is experimental and subject to change."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dist",
          "signature": "dist(other, p=2)",
          "documentation": {
            "description": "dist(other, p=2) -> Tensor\n\nSee :func:`torch.dist`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "div",
          "signature": "div(value, *, rounding_mode=None)",
          "documentation": {
            "description": "div(value, *, rounding_mode=None) -> Tensor\n\nSee :func:`torch.div`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "div_",
          "signature": "div_(value, *, rounding_mode=None)",
          "documentation": {
            "description": "div_(value, *, rounding_mode=None) -> Tensor\n\nIn-place version of :meth:`~Tensor.div`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "divide",
          "signature": "divide(value, *, rounding_mode=None)",
          "documentation": {
            "description": "divide(value, *, rounding_mode=None) -> Tensor\n\nSee :func:`torch.divide`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "divide_",
          "signature": "divide_(value, *, rounding_mode=None)",
          "documentation": {
            "description": "divide_(value, *, rounding_mode=None) -> Tensor\n\nIn-place version of :meth:`~Tensor.divide`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dot",
          "signature": "dot(other)",
          "documentation": {
            "description": "dot(other) -> Tensor\n\nSee :func:`torch.dot`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "double",
          "signature": "double(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "double(memory_format=torch.preserve_format) -> Tensor\n\n``self.double()`` is equivalent to ``self.to(torch.float64)``. See :func:`to`.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dsplit",
          "signature": "dsplit(split_size_or_sections)",
          "documentation": {
            "description": "dsplit(split_size_or_sections) -> List of Tensors\n\nSee :func:`torch.dsplit`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "eig",
          "signature": "eig(self, eigenvectors=False)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "element_size",
          "signature": "element_size()",
          "documentation": {
            "description": "element_size() -> int\n\nReturns the size in bytes of an individual element.\n\nExample::\n\n    >>> torch.tensor([]).element_size()\n    4\n    >>> torch.tensor([], dtype=torch.uint8).element_size()\n    1",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "eq",
          "signature": "eq(other)",
          "documentation": {
            "description": "eq(other) -> Tensor\n\nSee :func:`torch.eq`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "eq_",
          "signature": "eq_(other)",
          "documentation": {
            "description": "eq_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.eq`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "equal",
          "signature": "equal(other)",
          "documentation": {
            "description": "equal(other) -> bool\n\nSee :func:`torch.equal`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "erf",
          "signature": "erf()",
          "documentation": {
            "description": "erf() -> Tensor\n\nSee :func:`torch.erf`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "erf_",
          "signature": "erf_()",
          "documentation": {
            "description": "erf_() -> Tensor\n\nIn-place version of :meth:`~Tensor.erf`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "erfc",
          "signature": "erfc()",
          "documentation": {
            "description": "erfc() -> Tensor\n\nSee :func:`torch.erfc`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "erfc_",
          "signature": "erfc_()",
          "documentation": {
            "description": "erfc_() -> Tensor\n\nIn-place version of :meth:`~Tensor.erfc`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "erfinv",
          "signature": "erfinv()",
          "documentation": {
            "description": "erfinv() -> Tensor\n\nSee :func:`torch.erfinv`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "erfinv_",
          "signature": "erfinv_()",
          "documentation": {
            "description": "erfinv_() -> Tensor\n\nIn-place version of :meth:`~Tensor.erfinv`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "exp",
          "signature": "exp()",
          "documentation": {
            "description": "exp() -> Tensor\n\nSee :func:`torch.exp`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "exp2",
          "signature": "exp2()",
          "documentation": {
            "description": "exp2() -> Tensor\n\nSee :func:`torch.exp2`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "exp2_",
          "signature": "exp2_()",
          "documentation": {
            "description": "exp2_() -> Tensor\n\nIn-place version of :meth:`~Tensor.exp2`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "exp_",
          "signature": "exp_()",
          "documentation": {
            "description": "exp_() -> Tensor\n\nIn-place version of :meth:`~Tensor.exp`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "expand",
          "signature": "expand(*sizes)",
          "documentation": {
            "description": "expand(*sizes) -> Tensor\n\nReturns a new view of the :attr:`self` tensor with singleton dimensions expanded\nto a larger size.\n\nPassing -1 as the size for a dimension means not changing the size of\nthat dimension.\n\nTensor can be also expanded to a larger number of dimensions, and the\nnew ones will be appended at the front. For the new dimensions, the\nsize cannot be set to -1.\n\nExpanding a tensor does not allocate new memory, but only creates a\nnew view on the existing tensor where a dimension of size one is\nexpanded to a larger size by setting the ``stride`` to 0. Any dimension\nof size 1 can be expanded to an arbitrary value without allocating new\nmemory.",
            "parameters": {
              "More": {
                "type": "",
                "description": "than one element of an expanded tensor may refer to a single"
              },
              "memory": {
                "type": "",
                "description": "location. As a result, in-place operations (especially ones that"
              },
              "are": {
                "type": "",
                "description": "vectorized) may result in incorrect behavior. If you need to write"
              },
              "to": {
                "type": "",
                "description": "the tensors, please clone them first."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> x = torch.tensor([[1], [2], [3]])\n>>> x.size()"
              },
              "torch": {
                "type": "",
                "description": ".Size([3, 1])\n>>> x.expand(3, 4)"
              },
              "tensor": {
                "type": "",
                "description": "([[ 1,  1,  1,  1],\n[ 2,  2,  2,  2],\n[ 3,  3,  3,  3]])"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "expand_as",
          "signature": "expand_as(other)",
          "documentation": {
            "description": "expand_as(other) -> Tensor\n\nExpand this tensor to the same size as :attr:`other`.\n``self.expand_as(other)`` is equivalent to ``self.expand(other.size())``.\n\nPlease see :meth:`~Tensor.expand` for more information about ``expand``.",
            "parameters": {
              "other": {
                "type": ":class:`torch.Tensor`",
                "description": "The result tensor has the same size"
              },
              "as": {
                "type": "",
                "description": "attr:`other`."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "expm1",
          "signature": "expm1()",
          "documentation": {
            "description": "expm1() -> Tensor\n\nSee :func:`torch.expm1`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "expm1_",
          "signature": "expm1_()",
          "documentation": {
            "description": "expm1_() -> Tensor\n\nIn-place version of :meth:`~Tensor.expm1`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "exponential_",
          "signature": "exponential_(lambd=1, *, generator=None)",
          "documentation": {
            "description": "exponential_(lambd=1, *, generator=None) -> Tensor\n\nFills :attr:`self` tensor with elements drawn from the PDF (probability density function):\n\n.. math::\n\n    f(x) = \\lambda e^{-\\lambda x}, x > 0\n\n.. note::\n  In probability theory, exponential distribution is supported on interval [0, :math:`\\inf`) (i.e., :math:`x >= 0`)\n  implying that zero can be sampled from the exponential distribution.\n  However, :func:`torch.Tensor.exponential_` does not sample zero,\n  which means that its actual support is the interval (0, :math:`\\inf`).\n\n  Note that :func:`torch.distributions.exponential.Exponential` is supported on the interval [0, :math:`\\inf`) and can sample zero.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill_",
          "signature": "fill_(value)",
          "documentation": {
            "description": "fill_(value) -> Tensor\n\nFills :attr:`self` tensor with the specified value.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill_diagonal_",
          "signature": "fill_diagonal_(fill_value, wrap=False)",
          "documentation": {
            "description": "fill_diagonal_(fill_value, wrap=False) -> Tensor\n\nFill the main diagonal of a tensor that has at least 2-dimensions.\nWhen dims>2, all dimensions of input must be of equal length.\nThis function modifies the input tensor in-place, and returns the input tensor.",
            "parameters": {
              "fill_value": {
                "type": "Scalar",
                "description": "the fill value"
              },
              "wrap": {
                "type": "bool",
                "description": "the diagonal 'wrapped' after N columns for tall matrices."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> a = torch.zeros(3, 3)\n>>> a.fill_diagonal_(5)"
              },
              "tensor": {
                "type": "",
                "description": "([[5., 0., 0.],\n[0., 5., 0.],\n[0., 0., 5.],\n[0., 0., 0.],\n[5., 0., 0.],\n[0., 5., 0.],\n[0., 0., 5.]])"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fix",
          "signature": "fix()",
          "documentation": {
            "description": "fix() -> Tensor\n\nSee :func:`torch.fix`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fix_",
          "signature": "fix_()",
          "documentation": {
            "description": "fix_() -> Tensor\n\nIn-place version of :meth:`~Tensor.fix`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(start_dim=0, end_dim=-1)",
          "documentation": {
            "description": "flatten(start_dim=0, end_dim=-1) -> Tensor\n\nSee :func:`torch.flatten`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flip",
          "signature": "flip(dims)",
          "documentation": {
            "description": "flip(dims) -> Tensor\n\nSee :func:`torch.flip`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fliplr",
          "signature": "fliplr()",
          "documentation": {
            "description": "fliplr() -> Tensor\n\nSee :func:`torch.fliplr`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flipud",
          "signature": "flipud()",
          "documentation": {
            "description": "flipud() -> Tensor\n\nSee :func:`torch.flipud`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "float",
          "signature": "float(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "float(memory_format=torch.preserve_format) -> Tensor\n\n``self.float()`` is equivalent to ``self.to(torch.float32)``. See :func:`to`.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "float_power",
          "signature": "float_power(exponent)",
          "documentation": {
            "description": "float_power(exponent) -> Tensor\n\nSee :func:`torch.float_power`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "float_power_",
          "signature": "float_power_(exponent)",
          "documentation": {
            "description": "float_power_(exponent) -> Tensor\n\nIn-place version of :meth:`~Tensor.float_power`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "floor",
          "signature": "floor()",
          "documentation": {
            "description": "floor() -> Tensor\n\nSee :func:`torch.floor`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "floor_",
          "signature": "floor_()",
          "documentation": {
            "description": "floor_() -> Tensor\n\nIn-place version of :meth:`~Tensor.floor`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "floor_divide",
          "signature": "floor_divide(value)",
          "documentation": {
            "description": "floor_divide(value) -> Tensor\n\nSee :func:`torch.floor_divide`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "floor_divide_",
          "signature": "floor_divide_(value)",
          "documentation": {
            "description": "floor_divide_(value) -> Tensor\n\nIn-place version of :meth:`~Tensor.floor_divide`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fmax",
          "signature": "fmax(other)",
          "documentation": {
            "description": "fmax(other) -> Tensor\n\nSee :func:`torch.fmax`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fmin",
          "signature": "fmin(other)",
          "documentation": {
            "description": "fmin(other) -> Tensor\n\nSee :func:`torch.fmin`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fmod",
          "signature": "fmod(divisor)",
          "documentation": {
            "description": "fmod(divisor) -> Tensor\n\nSee :func:`torch.fmod`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fmod_",
          "signature": "fmod_(divisor)",
          "documentation": {
            "description": "fmod_(divisor) -> Tensor\n\nIn-place version of :meth:`~Tensor.fmod`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "frac",
          "signature": "frac()",
          "documentation": {
            "description": "frac() -> Tensor\n\nSee :func:`torch.frac`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "frac_",
          "signature": "frac_()",
          "documentation": {
            "description": "frac_() -> Tensor\n\nIn-place version of :meth:`~Tensor.frac`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "frexp",
          "signature": "frexp(input)",
          "documentation": {
            "description": "frexp(input) -> (Tensor mantissa, Tensor exponent)\n\nSee :func:`torch.frexp`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "gather",
          "signature": "gather(dim, index)",
          "documentation": {
            "description": "gather(dim, index) -> Tensor\n\nSee :func:`torch.gather`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "gcd",
          "signature": "gcd(other)",
          "documentation": {
            "description": "gcd(other) -> Tensor\n\nSee :func:`torch.gcd`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "gcd_",
          "signature": "gcd_(other)",
          "documentation": {
            "description": "gcd_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.gcd`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ge",
          "signature": "ge(other)",
          "documentation": {
            "description": "ge(other) -> Tensor\n\nSee :func:`torch.ge`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ge_",
          "signature": "ge_(other)",
          "documentation": {
            "description": "ge_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.ge`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "geometric_",
          "signature": "geometric_(p, *, generator=None)",
          "documentation": {
            "description": "geometric_(p, *, generator=None) -> Tensor\n\nFills :attr:`self` tensor with elements drawn from the geometric distribution:\n\n.. math::\n\n    P(X=k) = (1 - p)^{k - 1} p, k = 1, 2, ...\n\n.. note::\n  :func:`torch.Tensor.geometric_` `k`-th trial is the first success hence draws samples in :math:`\\{1, 2, \\ldots\\}`, whereas\n  :func:`torch.distributions.geometric.Geometric` :math:`(k+1)`-th trial is the first success\n  hence draws samples in :math:`\\{0, 1, \\ldots\\}`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "geqrf",
          "signature": "geqrf()",
          "documentation": {
            "description": "geqrf() -> (Tensor, Tensor)\n\nSee :func:`torch.geqrf`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ger",
          "signature": "ger(vec2)",
          "documentation": {
            "description": "ger(vec2) -> Tensor\n\nSee :func:`torch.ger`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_device",
          "signature": "get_device()",
          "documentation": {
            "description": "get_device() -> Device ordinal (Integer)\n\nFor CUDA tensors, this function returns the device ordinal of the GPU on which the tensor resides.\nFor CPU tensors, this function returns `-1`.\n\nExample::\n\n    >>> x = torch.randn(3, 4, 5, device='cuda:0')\n    >>> x.get_device()\n    0\n    >>> x.cpu().get_device()\n    -1",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "greater",
          "signature": "greater(other)",
          "documentation": {
            "description": "greater(other) -> Tensor\n\nSee :func:`torch.greater`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "greater_",
          "signature": "greater_(other)",
          "documentation": {
            "description": "greater_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.greater`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "greater_equal",
          "signature": "greater_equal(other)",
          "documentation": {
            "description": "greater_equal(other) -> Tensor\n\nSee :func:`torch.greater_equal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "greater_equal_",
          "signature": "greater_equal_(other)",
          "documentation": {
            "description": "greater_equal_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.greater_equal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "gt",
          "signature": "gt(other)",
          "documentation": {
            "description": "gt(other) -> Tensor\n\nSee :func:`torch.gt`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "gt_",
          "signature": "gt_(other)",
          "documentation": {
            "description": "gt_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.gt`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "half",
          "signature": "half(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "half(memory_format=torch.preserve_format) -> Tensor\n\n``self.half()`` is equivalent to ``self.to(torch.float16)``. See :func:`to`.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "hardshrink",
          "signature": "hardshrink(lambd=0.5)",
          "documentation": {
            "description": "hardshrink(lambd=0.5) -> Tensor\n\nSee :func:`torch.nn.functional.hardshrink`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "has_names",
          "signature": "has_names(...)",
          "documentation": {
            "description": "Is ``True`` if any of this tensor's dimensions are named. Otherwise, is ``False``.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "heaviside",
          "signature": "heaviside(values)",
          "documentation": {
            "description": "heaviside(values) -> Tensor\n\nSee :func:`torch.heaviside`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "heaviside_",
          "signature": "heaviside_(values)",
          "documentation": {
            "description": "heaviside_(values) -> Tensor\n\nIn-place version of :meth:`~Tensor.heaviside`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "histc",
          "signature": "histc(bins=100, min=0, max=0)",
          "documentation": {
            "description": "histc(bins=100, min=0, max=0) -> Tensor\n\nSee :func:`torch.histc`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "histogram",
          "signature": "histogram(input, bins, *, range=None, weight=None, density=False)",
          "documentation": {
            "description": "histogram(input, bins, *, range=None, weight=None, density=False) -> (Tensor, Tensor)\n\nSee :func:`torch.histogram`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "hsplit",
          "signature": "hsplit(split_size_or_sections)",
          "documentation": {
            "description": "hsplit(split_size_or_sections) -> List of Tensors\n\nSee :func:`torch.hsplit`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "hypot",
          "signature": "hypot(other)",
          "documentation": {
            "description": "hypot(other) -> Tensor\n\nSee :func:`torch.hypot`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "hypot_",
          "signature": "hypot_(other)",
          "documentation": {
            "description": "hypot_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.hypot`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "i0",
          "signature": "i0()",
          "documentation": {
            "description": "i0() -> Tensor\n\nSee :func:`torch.i0`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "i0_",
          "signature": "i0_()",
          "documentation": {
            "description": "i0_() -> Tensor\n\nIn-place version of :meth:`~Tensor.i0`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "igamma",
          "signature": "igamma(other)",
          "documentation": {
            "description": "igamma(other) -> Tensor\n\nSee :func:`torch.igamma`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "igamma_",
          "signature": "igamma_(other)",
          "documentation": {
            "description": "igamma_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.igamma`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "igammac",
          "signature": "igammac(other)",
          "documentation": {
            "description": "igammac(other) -> Tensor\nSee :func:`torch.igammac`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "igammac_",
          "signature": "igammac_(other)",
          "documentation": {
            "description": "igammac_(other) -> Tensor\nIn-place version of :meth:`~Tensor.igammac`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "index_add",
          "signature": "index_add(dim, index, source, *, alpha=1)",
          "documentation": {
            "description": "index_add(dim, index, source, *, alpha=1) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.index_add_`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "index_add_",
          "signature": "index_add_(dim, index, source, *, alpha=1)",
          "documentation": {
            "description": "index_add_(dim, index, source, *, alpha=1) -> Tensor\n\nAccumulate the elements of :attr:`alpha` times ``source`` into the :attr:`self`\ntensor by adding to the indices in the order given in :attr:`index`. For example,\nif ``dim == 0``, ``index[i] == j``, and ``alpha=-1``, then the ``i``\\ th row of\n``source`` is subtracted from the ``j``\\ th row of :attr:`self`.\n\nThe :attr:`dim`\\ th dimension of ``source`` must have the same size as the\nlength of :attr:`index` (which must be a vector), and all other dimensions must\nmatch :attr:`self`, or an error will be raised.\n\nFor a 3-D tensor the output is given as::\n\n    self[index[i], :, :] += alpha * src[i, :, :]  # if dim == 0\n    self[:, index[i], :] += alpha * src[:, i, :]  # if dim == 1\n    self[:, :, index[i]] += alpha * src[:, :, i]  # if dim == 2",
            "parameters": {
              "dim": {
                "type": "int",
                "description": "dimension along which to index"
              },
              "index": {
                "type": "Tensor",
                "description": "indices of ``source`` to select from,"
              },
              "should": {
                "type": "",
                "description": "have dtype either `torch.int64` or `torch.int32`"
              },
              "source": {
                "type": "Tensor",
                "description": "the tensor containing values to add"
              },
              "Keyword": {
                "type": "",
                "description": "args:"
              },
              "alpha": {
                "type": "Number",
                "description": "the scalar multiplier for ``source``"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> x = torch.ones(5, 3)\n>>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)\n>>> index = torch.tensor([0, 4, 2])\n>>> x.index_add_(0, index, t)"
              },
              "tensor": {
                "type": "",
                "description": "([[  1.,   1.,   1.],\n[  1.,   1.,   1.],\n[  1.,   1.,   1.],\n[  1.,   1.,   1.],\n[  1.,   1.,   1.]])"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "This operation may behave nondeterministically when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.\n\nArgs:\n    dim (int): dimension along which to index\n    index (Tensor): indices of ``source`` to select from,\n            should have dtype either `torch.int64` or `torch.int32`\n    source (Tensor): the tensor containing values to add\n\nKeyword args:\n    alpha (Number): the scalar multiplier for ``source``",
            "examples": ""
          }
        },
        {
          "name": "index_copy",
          "signature": "index_copy(dim, index, tensor2)",
          "documentation": {
            "description": "index_copy(dim, index, tensor2) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.index_copy_`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "index_copy_",
          "signature": "index_copy_(dim, index, tensor)",
          "documentation": {
            "description": "index_copy_(dim, index, tensor) -> Tensor\n\nCopies the elements of :attr:`tensor` into the :attr:`self` tensor by selecting\nthe indices in the order given in :attr:`index`. For example, if ``dim == 0``\nand ``index[i] == j``, then the ``i``\\ th row of :attr:`tensor` is copied to the\n``j``\\ th row of :attr:`self`.\n\nThe :attr:`dim`\\ th dimension of :attr:`tensor` must have the same size as the\nlength of :attr:`index` (which must be a vector), and all other dimensions must\nmatch :attr:`self`, or an error will be raised.\n\n.. note::\n    If :attr:`index` contains duplicate entries, multiple elements from\n    :attr:`tensor` will be copied to the same index of :attr:`self`. The result\n    is nondeterministic since it depends on which copy occurs last.",
            "parameters": {
              "dim": {
                "type": "int",
                "description": "dimension along which to index"
              },
              "index": {
                "type": "LongTensor",
                "description": "indices of :attr:`tensor` to select from"
              },
              "tensor": {
                "type": "",
                "description": "([[ 1.,  2.,  3.],\n[ 0.,  0.,  0.],\n[ 7.,  8.,  9.],\n[ 0.,  0.,  0.],\n[ 4.,  5.,  6.]])"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> x = torch.zeros(5, 3)\n>>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)\n>>> index = torch.tensor([0, 4, 2])\n>>> x.index_copy_(0, index, t)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "index_fill",
          "signature": "index_fill(dim, index, value)",
          "documentation": {
            "description": "index_fill(dim, index, value) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.index_fill_`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "index_fill_",
          "signature": "index_fill_(dim, index, value)",
          "documentation": {
            "description": "index_fill_(dim, index, value) -> Tensor\n\nFills the elements of the :attr:`self` tensor with value :attr:`value` by\nselecting the indices in the order given in :attr:`index`.",
            "parameters": {
              "dim": {
                "type": "int",
                "description": "dimension along which to index"
              },
              "index": {
                "type": "LongTensor",
                "description": "indices of :attr:`self` tensor to fill in"
              },
              "value": {
                "type": "float",
                "description": "the value to fill with"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)\n>>> index = torch.tensor([0, 2])\n>>> x.index_fill_(1, index, -1)"
              },
              "tensor": {
                "type": "",
                "description": "([[-1.,  2., -1.],\n[-1.,  5., -1.],\n[-1.,  8., -1.]])"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "index_put",
          "signature": "index_put(indices, values, accumulate=False)",
          "documentation": {
            "description": "index_put(indices, values, accumulate=False) -> Tensor\n\nOut-place version of :meth:`~Tensor.index_put_`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "index_put_",
          "signature": "index_put_(indices, values, accumulate=False)",
          "documentation": {
            "description": "index_put_(indices, values, accumulate=False) -> Tensor\n\nPuts values from the tensor :attr:`values` into the tensor :attr:`self` using\nthe indices specified in :attr:`indices` (which is a tuple of Tensors). The\nexpression ``tensor.index_put_(indices, values)`` is equivalent to\n``tensor[indices] = values``. Returns :attr:`self`.\n\nIf :attr:`accumulate` is ``True``, the elements in :attr:`values` are added to\n:attr:`self`. If accumulate is ``False``, the behavior is undefined if indices\ncontain duplicate elements.",
            "parameters": {
              "indices": {
                "type": "tuple of LongTensor",
                "description": "tensors used to index into `self`."
              },
              "values": {
                "type": "Tensor",
                "description": "tensor of same dtype as `self`."
              },
              "accumulate": {
                "type": "bool",
                "description": "whether to accumulate into self"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "index_reduce",
          "signature": "index_reduce(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "index_reduce_",
          "signature": "index_reduce_(dim, index, source, reduce, *, include_self=True)",
          "documentation": {
            "description": "index_reduce_(dim, index, source, reduce, *, include_self=True) -> Tensor\n\nAccumulate the elements of ``source`` into the :attr:`self`\ntensor by accumulating to the indices in the order given in :attr:`index`\nusing the reduction given by the ``reduce`` argument. For example, if ``dim == 0``,\n``index[i] == j``, ``reduce == prod`` and ``include_self == True`` then the ``i``\\ th\nrow of ``source`` is multiplied by the ``j``\\ th row of :attr:`self`. If\n:obj:`include_self=\"True\"`, the values in the :attr:`self` tensor are included\nin the reduction, otherwise, rows in the :attr:`self` tensor that are accumulated\nto are treated as if they were filled with the reduction identites.\n\nThe :attr:`dim`\\ th dimension of ``source`` must have the same size as the\nlength of :attr:`index` (which must be a vector), and all other dimensions must\nmatch :attr:`self`, or an error will be raised.\n\nFor a 3-D tensor with :obj:`reduce=\"prod\"` and :obj:`include_self=True` the\noutput is given as::\n\n    self[index[i], :, :] *= src[i, :, :]  # if dim == 0\n    self[:, index[i], :] *= src[:, i, :]  # if dim == 1\n    self[:, :, index[i]] *= src[:, :, i]  # if dim == 2",
            "parameters": {
              "dim": {
                "type": "int",
                "description": "dimension along which to index"
              },
              "index": {
                "type": "Tensor",
                "description": "indices of ``source`` to select from,"
              },
              "should": {
                "type": "",
                "description": "have dtype either `torch.int64` or `torch.int32`"
              },
              "source": {
                "type": "FloatTensor",
                "description": "the tensor containing values to accumulate"
              },
              "reduce": {
                "type": "str",
                "description": "the reduction operation to apply\n(:obj:`\"prod\"`, :obj:`\"mean\"`, :obj:`\"amax\"`, :obj:`\"amin\"`)"
              },
              "Keyword": {
                "type": "",
                "description": "args:"
              },
              "include_self": {
                "type": "bool",
                "description": "whether the elements from the ``self`` tensor are"
              },
              "included": {
                "type": "",
                "description": "in the reduction"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> x = torch.empty(5, 3).fill_(2)\n>>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], dtype=torch.float)\n>>> index = torch.tensor([0, 4, 2, 0])\n>>> x.index_reduce_(0, index, t, 'prod')"
              },
              "tensor": {
                "type": "",
                "description": "([[10., 22., 36.],\n[ 2.,  2.,  2.],\n[ 7.,  8.,  9.],\n[ 2.,  2.,  2.],\n[ 4.,  5.,  6.]])"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "This operation may behave nondeterministically when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.\n\n.. note::\n\n    This function only supports floating point tensors.\n\n.. warning::\n\n    This function is in beta and may change in the near future.\n\nArgs:\n    dim (int): dimension along which to index\n    index (Tensor): indices of ``source`` to select from,\n        should have dtype either `torch.int64` or `torch.int32`\n    source (FloatTensor): the tensor containing values to accumulate\n    reduce (str): the reduction operation to apply\n        (:obj:`\"prod\"`, :obj:`\"mean\"`, :obj:`\"amax\"`, :obj:`\"amin\"`)\n\nKeyword args:\n    include_self (bool): whether the elements from the ``self`` tensor are\n        included in the reduction",
            "examples": ""
          }
        },
        {
          "name": "index_select",
          "signature": "index_select(dim, index)",
          "documentation": {
            "description": "index_select(dim, index) -> Tensor\n\nSee :func:`torch.index_select`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "indices",
          "signature": "indices()",
          "documentation": {
            "description": "indices() -> Tensor\n\nReturn the indices tensor of a :ref:`sparse COO tensor <sparse-coo-docs>`.\n\n.. warning::\n  Throws an error if :attr:`self` is not a sparse COO tensor.\n\nSee also :meth:`Tensor.values`.\n\n.. note::\n  This method can only be called on a coalesced sparse tensor. See\n  :meth:`Tensor.coalesce` for details.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inner",
          "signature": "inner(other)",
          "documentation": {
            "description": "inner(other) -> Tensor\n\nSee :func:`torch.inner`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "int",
          "signature": "int(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "int(memory_format=torch.preserve_format) -> Tensor\n\n``self.int()`` is equivalent to ``self.to(torch.int32)``. See :func:`to`.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "int_repr",
          "signature": "int_repr()",
          "documentation": {
            "description": "int_repr() -> Tensor\n\nGiven a quantized Tensor,\n``self.int_repr()`` returns a CPU Tensor with uint8_t as data type that stores the\nunderlying uint8_t values of the given Tensor.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse",
          "signature": "inverse()",
          "documentation": {
            "description": "inverse() -> Tensor\n\nSee :func:`torch.inverse`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ipu",
          "signature": "ipu(device=None, non_blocking=False, memory_format=torch.preserve_format)",
          "documentation": {
            "description": "ipu(device=None, non_blocking=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a copy of this object in IPU memory.\n\nIf this object is already in IPU memory and on the correct device,\nthen no copy is performed and the original object is returned.",
            "parameters": {
              "device": {
                "type": ":class:`torch.device`",
                "description": "The destination IPU device."
              },
              "Defaults": {
                "type": "",
                "description": "to the current IPU device."
              },
              "non_blocking": {
                "type": "bool",
                "description": "If ``True`` and the source is in pinned memory,"
              },
              "the": {
                "type": "",
                "description": "copy will be asynchronous with respect to the host."
              },
              "Otherwise": {
                "type": "",
                "description": ", the argument has no effect. Default: ``False``."
              },
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_coalesced",
          "signature": "is_coalesced()",
          "documentation": {
            "description": "is_coalesced() -> bool\n\nReturns ``True`` if :attr:`self` is a :ref:`sparse COO tensor\n<sparse-coo-docs>` that is coalesced, ``False`` otherwise.\n\n.. warning::\n  Throws an error if :attr:`self` is not a sparse COO tensor.\n\nSee :meth:`coalesce` and :ref:`uncoalesced tensors <sparse-uncoalesced-coo-docs>`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_complex",
          "signature": "is_complex()",
          "documentation": {
            "description": "is_complex() -> bool\n\nReturns True if the data type of :attr:`self` is a complex data type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_conj",
          "signature": "is_conj()",
          "documentation": {
            "description": "is_conj() -> bool\n\nReturns True if the conjugate bit of :attr:`self` is set to true.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_contiguous",
          "signature": "is_contiguous(memory_format=torch.contiguous_format)",
          "documentation": {
            "description": "is_contiguous(memory_format=torch.contiguous_format) -> bool\n\nReturns True if :attr:`self` tensor is contiguous in memory in the order specified\nby memory format.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "Specifies memory allocation"
              },
              "order": {
                "type": "",
                "description": ". Default: ``torch.contiguous_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_distributed",
          "signature": "is_distributed(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_floating_point",
          "signature": "is_floating_point()",
          "documentation": {
            "description": "is_floating_point() -> bool\n\nReturns True if the data type of :attr:`self` is a floating point data type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_inference",
          "signature": "is_inference()",
          "documentation": {
            "description": "is_inference() -> bool\n\nSee :func:`torch.is_inference`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_neg",
          "signature": "is_neg()",
          "documentation": {
            "description": "is_neg() -> bool\n\nReturns True if the negative bit of :attr:`self` is set to true.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_nonzero",
          "signature": "is_nonzero(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_pinned",
          "signature": "is_pinned(...)",
          "documentation": {
            "description": "Returns true if this tensor resides in pinned memory.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_same_size",
          "signature": "is_same_size(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_set_to",
          "signature": "is_set_to(tensor)",
          "documentation": {
            "description": "is_set_to(tensor) -> bool\n\nReturns True if both tensors are pointing to the exact same memory (same\nstorage, offset, size and stride).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_shared",
          "signature": "is_shared(self)",
          "documentation": {
            "description": "Checks if tensor is in shared memory.\n\nThis is always ``True`` for CUDA tensors.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_signed",
          "signature": "is_signed()",
          "documentation": {
            "description": "is_signed() -> bool\n\nReturns True if the data type of :attr:`self` is a signed data type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isclose",
          "signature": "isclose(other, rtol=1e-05, atol=1e-08, equal_nan=False)",
          "documentation": {
            "description": "isclose(other, rtol=1e-05, atol=1e-08, equal_nan=False) -> Tensor\n\nSee :func:`torch.isclose`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isfinite",
          "signature": "isfinite()",
          "documentation": {
            "description": "isfinite() -> Tensor\n\nSee :func:`torch.isfinite`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isinf",
          "signature": "isinf()",
          "documentation": {
            "description": "isinf() -> Tensor\n\nSee :func:`torch.isinf`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isnan",
          "signature": "isnan()",
          "documentation": {
            "description": "isnan() -> Tensor\n\nSee :func:`torch.isnan`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isneginf",
          "signature": "isneginf()",
          "documentation": {
            "description": "isneginf() -> Tensor\n\nSee :func:`torch.isneginf`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isposinf",
          "signature": "isposinf()",
          "documentation": {
            "description": "isposinf() -> Tensor\n\nSee :func:`torch.isposinf`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isreal",
          "signature": "isreal()",
          "documentation": {
            "description": "isreal() -> Tensor\n\nSee :func:`torch.isreal`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "istft",
          "signature": "istft(self, n_fft: int, hop_length: Optional[int] = None, win_length: Optional[int] = None, window: 'Optional[Tensor]' = None, center: bool = True, normalized: bool = False, onesided: Optional[bool] = None, length: Optional[int] = None, return_complex: bool = False)",
          "documentation": {
            "description": "See :func:`torch.istft`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item()",
          "documentation": {
            "description": "item() -> number\n\nReturns the value of this tensor as a standard Python number. This only works\nfor tensors with one element. For other cases, see :meth:`~Tensor.tolist`.\n\nThis operation is not differentiable.\n\nExample::\n\n    >>> x = torch.tensor([1.0])\n    >>> x.item()\n    1.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "kron",
          "signature": "kron(other)",
          "documentation": {
            "description": "kron(other) -> Tensor\n\nSee :func:`torch.kron`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "kthvalue",
          "signature": "kthvalue(k, dim=None, keepdim=False)",
          "documentation": {
            "description": "kthvalue(k, dim=None, keepdim=False) -> (Tensor, LongTensor)\n\nSee :func:`torch.kthvalue`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lcm",
          "signature": "lcm(other)",
          "documentation": {
            "description": "lcm(other) -> Tensor\n\nSee :func:`torch.lcm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lcm_",
          "signature": "lcm_(other)",
          "documentation": {
            "description": "lcm_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.lcm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ldexp",
          "signature": "ldexp(other)",
          "documentation": {
            "description": "ldexp(other) -> Tensor\n\nSee :func:`torch.ldexp`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ldexp_",
          "signature": "ldexp_(other)",
          "documentation": {
            "description": "ldexp_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.ldexp`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "le",
          "signature": "le(other)",
          "documentation": {
            "description": "le(other) -> Tensor\n\nSee :func:`torch.le`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "le_",
          "signature": "le_(other)",
          "documentation": {
            "description": "le_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.le`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lerp",
          "signature": "lerp(end, weight)",
          "documentation": {
            "description": "lerp(end, weight) -> Tensor\n\nSee :func:`torch.lerp`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lerp_",
          "signature": "lerp_(end, weight)",
          "documentation": {
            "description": "lerp_(end, weight) -> Tensor\n\nIn-place version of :meth:`~Tensor.lerp`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "less",
          "signature": "less(other)",
          "documentation": {
            "description": "lt(other) -> Tensor\n\nSee :func:`torch.less`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "less_",
          "signature": "less_(other)",
          "documentation": {
            "description": "less_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.less`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "less_equal",
          "signature": "less_equal(other)",
          "documentation": {
            "description": "less_equal(other) -> Tensor\n\nSee :func:`torch.less_equal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "less_equal_",
          "signature": "less_equal_(other)",
          "documentation": {
            "description": "less_equal_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.less_equal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lgamma",
          "signature": "lgamma()",
          "documentation": {
            "description": "lgamma() -> Tensor\n\nSee :func:`torch.lgamma`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lgamma_",
          "signature": "lgamma_()",
          "documentation": {
            "description": "lgamma_() -> Tensor\n\nIn-place version of :meth:`~Tensor.lgamma`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "log",
          "signature": "log()",
          "documentation": {
            "description": "log() -> Tensor\n\nSee :func:`torch.log`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "log10",
          "signature": "log10()",
          "documentation": {
            "description": "log10() -> Tensor\n\nSee :func:`torch.log10`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "log10_",
          "signature": "log10_()",
          "documentation": {
            "description": "log10_() -> Tensor\n\nIn-place version of :meth:`~Tensor.log10`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "log1p",
          "signature": "log1p()",
          "documentation": {
            "description": "log1p() -> Tensor\n\nSee :func:`torch.log1p`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "log1p_",
          "signature": "log1p_()",
          "documentation": {
            "description": "log1p_() -> Tensor\n\nIn-place version of :meth:`~Tensor.log1p`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "log2",
          "signature": "log2()",
          "documentation": {
            "description": "log2() -> Tensor\n\nSee :func:`torch.log2`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "log2_",
          "signature": "log2_()",
          "documentation": {
            "description": "log2_() -> Tensor\n\nIn-place version of :meth:`~Tensor.log2`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "log_",
          "signature": "log_()",
          "documentation": {
            "description": "log_() -> Tensor\n\nIn-place version of :meth:`~Tensor.log`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "log_normal_",
          "signature": "log_normal_(mean=1, std=2, *, generator=None)",
          "documentation": {
            "description": "log_normal_(mean=1, std=2, *, generator=None)\n\nFills :attr:`self` tensor with numbers samples from the log-normal distribution\nparameterized by the given mean :math:`\\mu` and standard deviation\n:math:`\\sigma`. Note that :attr:`mean` and :attr:`std` are the mean and\nstandard deviation of the underlying normal distribution, and not of the\nreturned distribution:\n\n.. math::\n\n    f(x) = \\dfrac{1}{x \\sigma \\sqrt{2\\pi}}\\ e^{-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}}",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "log_softmax",
          "signature": "log_softmax(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logaddexp",
          "signature": "logaddexp(other)",
          "documentation": {
            "description": "logaddexp(other) -> Tensor\n\nSee :func:`torch.logaddexp`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logaddexp2",
          "signature": "logaddexp2(other)",
          "documentation": {
            "description": "logaddexp2(other) -> Tensor\n\nSee :func:`torch.logaddexp2`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logcumsumexp",
          "signature": "logcumsumexp(dim)",
          "documentation": {
            "description": "logcumsumexp(dim) -> Tensor\n\nSee :func:`torch.logcumsumexp`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logdet",
          "signature": "logdet()",
          "documentation": {
            "description": "logdet() -> Tensor\n\nSee :func:`torch.logdet`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logical_and",
          "signature": "logical_and()",
          "documentation": {
            "description": "logical_and() -> Tensor\n\nSee :func:`torch.logical_and`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logical_and_",
          "signature": "logical_and_()",
          "documentation": {
            "description": "logical_and_() -> Tensor\n\nIn-place version of :meth:`~Tensor.logical_and`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logical_not",
          "signature": "logical_not()",
          "documentation": {
            "description": "logical_not() -> Tensor\n\nSee :func:`torch.logical_not`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logical_not_",
          "signature": "logical_not_()",
          "documentation": {
            "description": "logical_not_() -> Tensor\n\nIn-place version of :meth:`~Tensor.logical_not`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logical_or",
          "signature": "logical_or()",
          "documentation": {
            "description": "logical_or() -> Tensor\n\nSee :func:`torch.logical_or`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logical_or_",
          "signature": "logical_or_()",
          "documentation": {
            "description": "logical_or_() -> Tensor\n\nIn-place version of :meth:`~Tensor.logical_or`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logical_xor",
          "signature": "logical_xor()",
          "documentation": {
            "description": "logical_xor() -> Tensor\n\nSee :func:`torch.logical_xor`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logical_xor_",
          "signature": "logical_xor_()",
          "documentation": {
            "description": "logical_xor_() -> Tensor\n\nIn-place version of :meth:`~Tensor.logical_xor`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logit",
          "signature": "logit()",
          "documentation": {
            "description": "logit() -> Tensor\n\nSee :func:`torch.logit`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logit_",
          "signature": "logit_()",
          "documentation": {
            "description": "logit_() -> Tensor\n\nIn-place version of :meth:`~Tensor.logit`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logsumexp",
          "signature": "logsumexp(dim, keepdim=False)",
          "documentation": {
            "description": "logsumexp(dim, keepdim=False) -> Tensor\n\nSee :func:`torch.logsumexp`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "long",
          "signature": "long(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "long(memory_format=torch.preserve_format) -> Tensor\n\n``self.long()`` is equivalent to ``self.to(torch.int64)``. See :func:`to`.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lstsq",
          "signature": "lstsq(self, other)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lt",
          "signature": "lt(other)",
          "documentation": {
            "description": "lt(other) -> Tensor\n\nSee :func:`torch.lt`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lt_",
          "signature": "lt_(other)",
          "documentation": {
            "description": "lt_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.lt`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lu",
          "signature": "lu(self, pivot=True, get_infos=False)",
          "documentation": {
            "description": "See :func:`torch.lu`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lu_solve",
          "signature": "lu_solve(LU_data, LU_pivots)",
          "documentation": {
            "description": "lu_solve(LU_data, LU_pivots) -> Tensor\n\nSee :func:`torch.lu_solve`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "map2_",
          "signature": "map2_(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "map_",
          "signature": "map_(tensor, callable)",
          "documentation": {
            "description": "map_(tensor, callable)\n\nApplies :attr:`callable` for each element in :attr:`self` tensor and the given\n:attr:`tensor` and stores the results in :attr:`self` tensor. :attr:`self` tensor and\nthe given :attr:`tensor` must be :ref:`broadcastable <broadcasting-semantics>`.\n\nThe :attr:`callable` should have the signature::\n\n    def callable(a, b) -> number",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "masked_fill",
          "signature": "masked_fill(mask, value)",
          "documentation": {
            "description": "masked_fill(mask, value) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.masked_fill_`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "masked_fill_",
          "signature": "masked_fill_(mask, value)",
          "documentation": {
            "description": "masked_fill_(mask, value)\n\nFills elements of :attr:`self` tensor with :attr:`value` where :attr:`mask` is\nTrue. The shape of :attr:`mask` must be\n:ref:`broadcastable <broadcasting-semantics>` with the shape of the underlying\ntensor.",
            "parameters": {
              "mask": {
                "type": "BoolTensor",
                "description": "the boolean mask"
              },
              "value": {
                "type": "float",
                "description": "the value to fill in with"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "masked_scatter",
          "signature": "masked_scatter(mask, tensor)",
          "documentation": {
            "description": "masked_scatter(mask, tensor) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.masked_scatter_`\n\n.. note::\n\n    The inputs :attr:`self` and :attr:`mask`\n    :ref:`broadcast <broadcasting-semantics>`.\n\nExample:\n\n    >>> self = torch.tensor([0, 0, 0, 0, 0])\n    >>> mask = torch.tensor([[0, 0, 0, 1, 1], [1, 1, 0, 1, 1]], dtype=torch.bool)\n    >>> source = torch.tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n    >>> self.masked_scatter(mask, source)\n    tensor([[0, 0, 0, 0, 1],\n            [2, 3, 0, 4, 5]])",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> self = torch.tensor([0, 0, 0, 0, 0])\n    >>> mask = torch.tensor([[0, 0, 0, 1, 1], [1, 1, 0, 1, 1]], dtype=torch.bool)\n    >>> source = torch.tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n    >>> self.masked_scatter(mask, source)\n    tensor([[0, 0, 0, 0, 1],\n            [2, 3, 0, 4, 5]])"
          }
        },
        {
          "name": "masked_scatter_",
          "signature": "masked_scatter_(mask, source)",
          "documentation": {
            "description": "masked_scatter_(mask, source)\n\nCopies elements from :attr:`source` into :attr:`self` tensor at positions where\nthe :attr:`mask` is True. Elements from :attr:`source` are copied into :attr:`self`\nstarting at position 0 of :attr:`source` and continuing in order one-by-one for each\noccurrence of :attr:`mask` being True.\nThe shape of :attr:`mask` must be :ref:`broadcastable <broadcasting-semantics>`\nwith the shape of the underlying tensor. The :attr:`source` should have at least\nas many elements as the number of ones in :attr:`mask`.",
            "parameters": {
              "mask": {
                "type": "BoolTensor",
                "description": "the boolean mask"
              },
              "source": {
                "type": "Tensor",
                "description": "the tensor to copy from\n.. note::"
              },
              "The": {
                "type": "",
                "description": "attr:`mask` operates on the :attr:`self` tensor, not on the given\n:attr:`source` tensor."
              },
              "Example": {
                "type": "",
                "description": ">>> self = torch.tensor([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]])\n>>> mask = torch.tensor([[0, 0, 0, 1, 1], [1, 1, 0, 1, 1]], dtype=torch.bool)\n>>> source = torch.tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n>>> self.masked_scatter_(mask, source)"
              },
              "tensor": {
                "type": "",
                "description": "([[0, 0, 0, 0, 1],\n[2, 3, 0, 4, 5]])"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> self = torch.tensor([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]])\n    >>> mask = torch.tensor([[0, 0, 0, 1, 1], [1, 1, 0, 1, 1]], dtype=torch.bool)\n    >>> source = torch.tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])\n    >>> self.masked_scatter_(mask, source)\n    tensor([[0, 0, 0, 0, 1],\n            [2, 3, 0, 4, 5]])"
          }
        },
        {
          "name": "masked_select",
          "signature": "masked_select(mask)",
          "documentation": {
            "description": "masked_select(mask) -> Tensor\n\nSee :func:`torch.masked_select`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "matmul",
          "signature": "matmul(tensor2)",
          "documentation": {
            "description": "matmul(tensor2) -> Tensor\n\nSee :func:`torch.matmul`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "matrix_exp",
          "signature": "matrix_exp()",
          "documentation": {
            "description": "matrix_exp() -> Tensor\n\nSee :func:`torch.matrix_exp`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "matrix_power",
          "signature": "matrix_power(n)",
          "documentation": {
            "description": "matrix_power(n) -> Tensor\n\n.. note:: :meth:`~Tensor.matrix_power` is deprecated, use :func:`torch.linalg.matrix_power` instead.\n\nAlias for :func:`torch.linalg.matrix_power`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(dim=None, keepdim=False)",
          "documentation": {
            "description": "max(dim=None, keepdim=False) -> Tensor or (Tensor, Tensor)\n\nSee :func:`torch.max`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "maximum",
          "signature": "maximum(other)",
          "documentation": {
            "description": "maximum(other) -> Tensor\n\nSee :func:`torch.maximum`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(dim=None, keepdim=False, *, dtype=None)",
          "documentation": {
            "description": "mean(dim=None, keepdim=False, *, dtype=None) -> Tensor\n\nSee :func:`torch.mean`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "median",
          "signature": "median(dim=None, keepdim=False)",
          "documentation": {
            "description": "median(dim=None, keepdim=False) -> (Tensor, LongTensor)\n\nSee :func:`torch.median`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(dim=None, keepdim=False)",
          "documentation": {
            "description": "min(dim=None, keepdim=False) -> Tensor or (Tensor, Tensor)\n\nSee :func:`torch.min`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "minimum",
          "signature": "minimum(other)",
          "documentation": {
            "description": "minimum(other) -> Tensor\n\nSee :func:`torch.minimum`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mm",
          "signature": "mm(mat2)",
          "documentation": {
            "description": "mm(mat2) -> Tensor\n\nSee :func:`torch.mm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mode",
          "signature": "mode(dim=None, keepdim=False)",
          "documentation": {
            "description": "mode(dim=None, keepdim=False) -> (Tensor, LongTensor)\n\nSee :func:`torch.mode`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "module_load",
          "signature": "module_load(self, other, assign=False)",
          "documentation": {
            "description": "Defines how to transform ``other`` when loading it into ``self`` in :meth:`~nn.Module.load_state_dict`.\n\nUsed when :func:`~torch.__future__.get_swap_module_params_on_conversion` is ``True``.\n\nIt is expected that ``self`` is a parameter or buffer in an ``nn.Module`` and ``other`` is the\nvalue in the state dictionary with the corresponding key, this method defines\nhow ``other`` is remapped before being swapped with ``self`` via\n:func:`~torch.utils.swap_tensors` in :meth:`~nn.Module.load_state_dict`.\n\n.. note::\n    This method should always return a new object that is not ``self`` or ``other``.\n    For example, the default implementation returns ``self.copy_(other).detach()``\n    if ``assign`` is ``False`` or ``other.detach()`` if ``assign`` is ``True``.",
            "parameters": {
              "other": {
                "type": "Tensor",
                "description": "value in state dict with key corresponding to ``self``"
              },
              "assign": {
                "type": "bool",
                "description": "the assign argument passed to :meth:`nn.Module.load_state_dict`"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "moveaxis",
          "signature": "moveaxis(source, destination)",
          "documentation": {
            "description": "moveaxis(source, destination) -> Tensor\n\nSee :func:`torch.moveaxis`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "movedim",
          "signature": "movedim(source, destination)",
          "documentation": {
            "description": "movedim(source, destination) -> Tensor\n\nSee :func:`torch.movedim`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "msort",
          "signature": "msort()",
          "documentation": {
            "description": "msort() -> Tensor\n\nSee :func:`torch.msort`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mtia",
          "signature": "mtia(device=None, non_blocking=False, memory_format=torch.preserve_format)",
          "documentation": {
            "description": "mtia(device=None, non_blocking=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a copy of this object in MTIA memory.\n\nIf this object is already in MTIA memory and on the correct device,\nthen no copy is performed and the original object is returned.",
            "parameters": {
              "device": {
                "type": ":class:`torch.device`",
                "description": "The destination MTIA device."
              },
              "Defaults": {
                "type": "",
                "description": "to the current MTIA device."
              },
              "non_blocking": {
                "type": "bool",
                "description": "If ``True`` and the source is in pinned memory,"
              },
              "the": {
                "type": "",
                "description": "copy will be asynchronous with respect to the host."
              },
              "Otherwise": {
                "type": "",
                "description": ", the argument has no effect. Default: ``False``."
              },
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mul",
          "signature": "mul(value)",
          "documentation": {
            "description": "mul(value) -> Tensor\n\nSee :func:`torch.mul`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mul_",
          "signature": "mul_(value)",
          "documentation": {
            "description": "mul_(value) -> Tensor\n\nIn-place version of :meth:`~Tensor.mul`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "multinomial",
          "signature": "multinomial(num_samples, replacement=False, *, generator=None)",
          "documentation": {
            "description": "multinomial(num_samples, replacement=False, *, generator=None) -> Tensor\n\nSee :func:`torch.multinomial`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "multiply",
          "signature": "multiply(value)",
          "documentation": {
            "description": "multiply(value) -> Tensor\n\nSee :func:`torch.multiply`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "multiply_",
          "signature": "multiply_(value)",
          "documentation": {
            "description": "multiply_(value) -> Tensor\n\nIn-place version of :meth:`~Tensor.multiply`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mv",
          "signature": "mv(vec)",
          "documentation": {
            "description": "mv(vec) -> Tensor\n\nSee :func:`torch.mv`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mvlgamma",
          "signature": "mvlgamma(p)",
          "documentation": {
            "description": "mvlgamma(p) -> Tensor\n\nSee :func:`torch.mvlgamma`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mvlgamma_",
          "signature": "mvlgamma_(p)",
          "documentation": {
            "description": "mvlgamma_(p) -> Tensor\n\nIn-place version of :meth:`~Tensor.mvlgamma`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nan_to_num",
          "signature": "nan_to_num(nan=0.0, posinf=None, neginf=None)",
          "documentation": {
            "description": "nan_to_num(nan=0.0, posinf=None, neginf=None) -> Tensor\n\nSee :func:`torch.nan_to_num`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nan_to_num_",
          "signature": "nan_to_num_(nan=0.0, posinf=None, neginf=None)",
          "documentation": {
            "description": "nan_to_num_(nan=0.0, posinf=None, neginf=None) -> Tensor\n\nIn-place version of :meth:`~Tensor.nan_to_num`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nanmean",
          "signature": "nanmean(dim=None, keepdim=False, *, dtype=None)",
          "documentation": {
            "description": "nanmean(dim=None, keepdim=False, *, dtype=None) -> Tensor\n\nSee :func:`torch.nanmean`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nanmedian",
          "signature": "nanmedian(dim=None, keepdim=False)",
          "documentation": {
            "description": "nanmedian(dim=None, keepdim=False) -> (Tensor, LongTensor)\n\nSee :func:`torch.nanmedian`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nanquantile",
          "signature": "nanquantile(q, dim=None, keepdim=False, *, interpolation='linear')",
          "documentation": {
            "description": "nanquantile(q, dim=None, keepdim=False, *, interpolation='linear') -> Tensor\n\nSee :func:`torch.nanquantile`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nansum",
          "signature": "nansum(dim=None, keepdim=False, dtype=None)",
          "documentation": {
            "description": "nansum(dim=None, keepdim=False, dtype=None) -> Tensor\n\nSee :func:`torch.nansum`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "narrow",
          "signature": "narrow(dimension, start, length)",
          "documentation": {
            "description": "narrow(dimension, start, length) -> Tensor\n\nSee :func:`torch.narrow`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "narrow_copy",
          "signature": "narrow_copy(dimension, start, length)",
          "documentation": {
            "description": "narrow_copy(dimension, start, length) -> Tensor\n\nSee :func:`torch.narrow_copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ndimension",
          "signature": "ndimension()",
          "documentation": {
            "description": "ndimension() -> int\n\nAlias for :meth:`~Tensor.dim()`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ne",
          "signature": "ne(other)",
          "documentation": {
            "description": "ne(other) -> Tensor\n\nSee :func:`torch.ne`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ne_",
          "signature": "ne_(other)",
          "documentation": {
            "description": "ne_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.ne`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "neg",
          "signature": "neg()",
          "documentation": {
            "description": "neg() -> Tensor\n\nSee :func:`torch.neg`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "neg_",
          "signature": "neg_()",
          "documentation": {
            "description": "neg_() -> Tensor\n\nIn-place version of :meth:`~Tensor.neg`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "negative",
          "signature": "negative()",
          "documentation": {
            "description": "negative() -> Tensor\n\nSee :func:`torch.negative`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "negative_",
          "signature": "negative_()",
          "documentation": {
            "description": "negative_() -> Tensor\n\nIn-place version of :meth:`~Tensor.negative`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nelement",
          "signature": "nelement()",
          "documentation": {
            "description": "nelement() -> int\n\nAlias for :meth:`~Tensor.numel`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "new",
          "signature": "new(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "new_empty",
          "signature": "new_empty(size, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False)",
          "documentation": {
            "description": "new_empty(size, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor\n\n\nReturns a Tensor of size :attr:`size` filled with uninitialized data.\nBy default, the returned Tensor has the same :class:`torch.dtype` and\n:class:`torch.device` as this tensor.",
            "parameters": {
              "size": {
                "type": "int...",
                "description": "a list, tuple, or :class:`torch.Size` of integers defining the"
              },
              "shape": {
                "type": "",
                "description": "of the output tensor."
              },
              "Keyword": {
                "type": "",
                "description": "args:"
              },
              "dtype": {
                "type": ":class:`torch.dtype`, optional",
                "description": "the desired type of returned tensor."
              },
              "Default": {
                "type": "",
                "description": "``torch.strided``."
              },
              "device": {
                "type": ":class:`torch.device`, optional",
                "description": "the desired device of returned tensor."
              },
              "requires_grad": {
                "type": "bool, optional",
                "description": "If autograd should record operations on the"
              },
              "returned": {
                "type": "",
                "description": "tensor. Default: ``False``."
              },
              "layout": {
                "type": ":class:`torch.layout`, optional",
                "description": "the desired layout of returned Tensor."
              },
              "pin_memory": {
                "type": "bool, optional",
                "description": "If set, returned tensor would be allocated in"
              },
              "the": {
                "type": "",
                "description": "pinned memory. Works only for CPU tensors. Default: ``False``."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> tensor = torch.ones(())\n>>> tensor.new_empty((2, 3))"
              },
              "tensor": {
                "type": "",
                "description": "([[ 5.8182e-18,  4.5765e-41, -1.0545e+30],\n[ 3.0949e-41,  4.4842e-44,  0.0000e+00]])"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "new_empty_strided",
          "signature": "new_empty_strided(size, stride, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False)",
          "documentation": {
            "description": "new_empty_strided(size, stride, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor\n\n\nReturns a Tensor of size :attr:`size` and strides :attr:`stride` filled with\nuninitialized data. By default, the returned Tensor has the same\n:class:`torch.dtype` and :class:`torch.device` as this tensor.",
            "parameters": {
              "size": {
                "type": "int...",
                "description": "a list, tuple, or :class:`torch.Size` of integers defining the"
              },
              "shape": {
                "type": "",
                "description": "of the output tensor."
              },
              "Keyword": {
                "type": "",
                "description": "args:"
              },
              "dtype": {
                "type": ":class:`torch.dtype`, optional",
                "description": "the desired type of returned tensor."
              },
              "Default": {
                "type": "",
                "description": "``torch.strided``."
              },
              "device": {
                "type": ":class:`torch.device`, optional",
                "description": "the desired device of returned tensor."
              },
              "requires_grad": {
                "type": "bool, optional",
                "description": "If autograd should record operations on the"
              },
              "returned": {
                "type": "",
                "description": "tensor. Default: ``False``."
              },
              "layout": {
                "type": ":class:`torch.layout`, optional",
                "description": "the desired layout of returned Tensor."
              },
              "pin_memory": {
                "type": "bool, optional",
                "description": "If set, returned tensor would be allocated in"
              },
              "the": {
                "type": "",
                "description": "pinned memory. Works only for CPU tensors. Default: ``False``."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> tensor = torch.ones(())\n>>> tensor.new_empty_strided((2, 3), (3, 1))"
              },
              "tensor": {
                "type": "",
                "description": "([[ 5.8182e-18,  4.5765e-41, -1.0545e+30],\n[ 3.0949e-41,  4.4842e-44,  0.0000e+00]])"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "new_full",
          "signature": "new_full(size, fill_value, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False)",
          "documentation": {
            "description": "new_full(size, fill_value, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor\n\n\nReturns a Tensor of size :attr:`size` filled with :attr:`fill_value`.\nBy default, the returned Tensor has the same :class:`torch.dtype` and\n:class:`torch.device` as this tensor.",
            "parameters": {
              "fill_value": {
                "type": "scalar",
                "description": "the number to fill the output tensor with."
              },
              "Keyword": {
                "type": "",
                "description": "args:"
              },
              "dtype": {
                "type": ":class:`torch.dtype`, optional",
                "description": "the desired type of returned tensor."
              },
              "Default": {
                "type": "",
                "description": "``torch.strided``."
              },
              "device": {
                "type": ":class:`torch.device`, optional",
                "description": "the desired device of returned tensor."
              },
              "requires_grad": {
                "type": "bool, optional",
                "description": "If autograd should record operations on the"
              },
              "returned": {
                "type": "",
                "description": "tensor. Default: ``False``."
              },
              "layout": {
                "type": ":class:`torch.layout`, optional",
                "description": "the desired layout of returned Tensor."
              },
              "pin_memory": {
                "type": "bool, optional",
                "description": "If set, returned tensor would be allocated in"
              },
              "the": {
                "type": "",
                "description": "pinned memory. Works only for CPU tensors. Default: ``False``."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> tensor = torch.ones((2,), dtype=torch.float64)\n>>> tensor.new_full((3, 4), 3.141592)"
              },
              "tensor": {
                "type": "",
                "description": "([[ 3.1416,  3.1416,  3.1416,  3.1416],\n[ 3.1416,  3.1416,  3.1416,  3.1416],\n[ 3.1416,  3.1416,  3.1416,  3.1416]], dtype=torch.float64)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "new_ones",
          "signature": "new_ones(size, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False)",
          "documentation": {
            "description": "new_ones(size, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor\n\n\nReturns a Tensor of size :attr:`size` filled with ``1``.\nBy default, the returned Tensor has the same :class:`torch.dtype` and\n:class:`torch.device` as this tensor.",
            "parameters": {
              "size": {
                "type": "int...",
                "description": "a list, tuple, or :class:`torch.Size` of integers defining the"
              },
              "shape": {
                "type": "",
                "description": "of the output tensor."
              },
              "Keyword": {
                "type": "",
                "description": "args:"
              },
              "dtype": {
                "type": ":class:`torch.dtype`, optional",
                "description": "the desired type of returned tensor."
              },
              "Default": {
                "type": "",
                "description": "``torch.strided``."
              },
              "device": {
                "type": ":class:`torch.device`, optional",
                "description": "the desired device of returned tensor."
              },
              "requires_grad": {
                "type": "bool, optional",
                "description": "If autograd should record operations on the"
              },
              "returned": {
                "type": "",
                "description": "tensor. Default: ``False``."
              },
              "layout": {
                "type": ":class:`torch.layout`, optional",
                "description": "the desired layout of returned Tensor."
              },
              "pin_memory": {
                "type": "bool, optional",
                "description": "If set, returned tensor would be allocated in"
              },
              "the": {
                "type": "",
                "description": "pinned memory. Works only for CPU tensors. Default: ``False``."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> tensor = torch.tensor((), dtype=torch.int32)\n>>> tensor.new_ones((2, 3))"
              },
              "tensor": {
                "type": "",
                "description": "([[ 1,  1,  1],\n[ 1,  1,  1]], dtype=torch.int32)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "new_tensor",
          "signature": "new_tensor(data, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False)",
          "documentation": {
            "description": "new_tensor(data, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor\n\n\nReturns a new Tensor with :attr:`data` as the tensor data.\nBy default, the returned Tensor has the same :class:`torch.dtype` and\n:class:`torch.device` as this tensor.\n\n.. warning::\n\n    :func:`new_tensor` always copies :attr:`data`. If you have a Tensor\n    ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_`\n    or :func:`torch.Tensor.detach`.\n    If you have a numpy array and want to avoid a copy, use\n    :func:`torch.from_numpy`.\n\n.. warning::\n\n    When data is a tensor `x`, :func:`new_tensor()` reads out 'the data' from whatever it is passed,\n    and constructs a leaf variable. Therefore ``tensor.new_tensor(x)`` is equivalent to ``x.clone().detach()``\n    and ``tensor.new_tensor(x, requires_grad=True)`` is equivalent to ``x.clone().detach().requires_grad_(True)``.\n    The equivalents using ``clone()`` and ``detach()`` are recommended.",
            "parameters": {
              "data": {
                "type": "array_like",
                "description": "The returned Tensor copies :attr:`data`."
              },
              "Keyword": {
                "type": "",
                "description": "args:"
              },
              "dtype": {
                "type": ":class:`torch.dtype`, optional",
                "description": "the desired type of returned tensor."
              },
              "Default": {
                "type": "",
                "description": "``torch.strided``."
              },
              "device": {
                "type": ":class:`torch.device`, optional",
                "description": "the desired device of returned tensor."
              },
              "requires_grad": {
                "type": "bool, optional",
                "description": "If autograd should record operations on the"
              },
              "returned": {
                "type": "",
                "description": "tensor. Default: ``False``."
              },
              "layout": {
                "type": ":class:`torch.layout`, optional",
                "description": "the desired layout of returned Tensor."
              },
              "pin_memory": {
                "type": "bool, optional",
                "description": "If set, returned tensor would be allocated in"
              },
              "the": {
                "type": "",
                "description": "pinned memory. Works only for CPU tensors. Default: ``False``."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> tensor = torch.ones((2,), dtype=torch.int8)\n>>> data = [[0, 1], [2, 3]]\n>>> tensor.new_tensor(data)"
              },
              "tensor": {
                "type": "",
                "description": "([[ 0,  1],\n[ 2,  3]], dtype=torch.int8)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "new_zeros",
          "signature": "new_zeros(size, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False)",
          "documentation": {
            "description": "new_zeros(size, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor\n\n\nReturns a Tensor of size :attr:`size` filled with ``0``.\nBy default, the returned Tensor has the same :class:`torch.dtype` and\n:class:`torch.device` as this tensor.",
            "parameters": {
              "size": {
                "type": "int...",
                "description": "a list, tuple, or :class:`torch.Size` of integers defining the"
              },
              "shape": {
                "type": "",
                "description": "of the output tensor."
              },
              "Keyword": {
                "type": "",
                "description": "args:"
              },
              "dtype": {
                "type": ":class:`torch.dtype`, optional",
                "description": "the desired type of returned tensor."
              },
              "Default": {
                "type": "",
                "description": "``torch.strided``."
              },
              "device": {
                "type": ":class:`torch.device`, optional",
                "description": "the desired device of returned tensor."
              },
              "requires_grad": {
                "type": "bool, optional",
                "description": "If autograd should record operations on the"
              },
              "returned": {
                "type": "",
                "description": "tensor. Default: ``False``."
              },
              "layout": {
                "type": ":class:`torch.layout`, optional",
                "description": "the desired layout of returned Tensor."
              },
              "pin_memory": {
                "type": "bool, optional",
                "description": "If set, returned tensor would be allocated in"
              },
              "the": {
                "type": "",
                "description": "pinned memory. Works only for CPU tensors. Default: ``False``."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> tensor = torch.tensor((), dtype=torch.float64)\n>>> tensor.new_zeros((2, 3))"
              },
              "tensor": {
                "type": "",
                "description": "([[ 0.,  0.,  0.],\n[ 0.,  0.,  0.]], dtype=torch.float64)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nextafter",
          "signature": "nextafter(other)",
          "documentation": {
            "description": "nextafter(other) -> Tensor\nSee :func:`torch.nextafter`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nextafter_",
          "signature": "nextafter_(other)",
          "documentation": {
            "description": "nextafter_(other) -> Tensor\nIn-place version of :meth:`~Tensor.nextafter`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero()",
          "documentation": {
            "description": "nonzero() -> LongTensor\n\nSee :func:`torch.nonzero`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero_static",
          "signature": "nonzero_static(input, *, size, fill_value=-1)",
          "documentation": {
            "description": "nonzero_static(input, *, size, fill_value=-1) -> Tensor\n\nReturns a 2-D tensor where each row is the index for a non-zero value.\nThe returned Tensor has the same `torch.dtype` as `torch.nonzero()`.",
            "parameters": {
              "input": {
                "type": "Tensor",
                "description": "the input tensor to count non-zero elements."
              },
              "Keyword": {
                "type": "",
                "description": "args:"
              },
              "size": {
                "type": "int",
                "description": "the size of non-zero elements expected to be included in the out"
              },
              "tensor": {
                "type": "[], size=(2, 0",
                "description": ", dtype=torch.int64)"
              },
              "than": {
                "type": "",
                "description": "the total number of non-zero elements. Default is `-1` to represent"
              },
              "is": {
                "type": "",
                "description": "smaller. The size must be a non-negative integer."
              },
              "fill_value": {
                "type": "int",
                "description": "the value to fill the output tensor with when `size` is larger"
              },
              "invalid": {
                "type": "",
                "description": "index."
              },
              "Example": {
                "type": "",
                "description": "# Example 1: Padding\n>>> input_tensor = torch.tensor([[1, 0], [3, 2]])\n>>> static_size = 4\n>>> t = torch.nonzero_static(input_tensor, size = static_size)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "# Example 1: Padding\n    >>> input_tensor = torch.tensor([[1, 0], [3, 2]])\n    >>> static_size = 4\n    >>> t = torch.nonzero_static(input_tensor, size = static_size)\n    tensor([[  0,   0],\n            [  1,   0],\n            [  1,   1],\n            [  -1, -1]], dtype=torch.int64)\n\n    # Example 2: Truncating\n    >>> input_tensor = torch.tensor([[1, 0], [3, 2]])\n    >>> static_size = 2\n    >>> t = torch.nonzero_static(input_tensor, size = static_size)\n    tensor([[  0,   0],\n            [  1,   0]], dtype=torch.int64)\n\n    # Example 3: 0 size\n    >>> input_tensor = torch.tensor([10])\n    >>> static_size = 0\n    >>> t = torch.nonzero_static(input_tensor, size = static_size)\n    tensor([], size=(0, 1), dtype=torch.int64)\n\n    # Example 4: 0 rank input\n    >>> input_tensor = torch.tensor(10)\n    >>> static_size = 2\n    >>> t = torch.nonzero_static(input_tensor, size = static_size)\n    tensor([], size=(2, 0), dtype=torch.int64)"
          }
        },
        {
          "name": "norm",
          "signature": "norm(self, p: Union[float, str, NoneType] = 'fro', dim=None, keepdim=False, dtype=None)",
          "documentation": {
            "description": "See :func:`torch.norm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "normal_",
          "signature": "normal_(mean=0, std=1, *, generator=None)",
          "documentation": {
            "description": "normal_(mean=0, std=1, *, generator=None) -> Tensor\n\nFills :attr:`self` tensor with elements samples from the normal distribution\nparameterized by :attr:`mean` and :attr:`std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "not_equal",
          "signature": "not_equal(other)",
          "documentation": {
            "description": "not_equal(other) -> Tensor\n\nSee :func:`torch.not_equal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "not_equal_",
          "signature": "not_equal_(other)",
          "documentation": {
            "description": "not_equal_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.not_equal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "numel",
          "signature": "numel()",
          "documentation": {
            "description": "numel() -> int\n\nSee :func:`torch.numel`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "numpy",
          "signature": "numpy(*, force=False)",
          "documentation": {
            "description": "numpy(*, force=False) -> numpy.ndarray\n\nReturns the tensor as a NumPy :class:`ndarray`.\n\nIf :attr:`force` is ``False`` (the default), the conversion\nis performed only if the tensor is on the CPU, does not require grad,\ndoes not have its conjugate bit set, and is a dtype and layout that\nNumPy supports. The returned ndarray and the tensor will share their\nstorage, so changes to the tensor will be reflected in the ndarray\nand vice versa.\n\nIf :attr:`force` is ``True`` this is equivalent to\ncalling ``t.detach().cpu().resolve_conj().resolve_neg().numpy()``.\nIf the tensor isn't on the CPU or the conjugate or negative bit is set,\nthe tensor won't share its storage with the returned ndarray.\nSetting :attr:`force` to ``True`` can be a useful shorthand.",
            "parameters": {
              "force": {
                "type": "bool",
                "description": "if ``True``, the ndarray may be a copy of the tensor"
              },
              "instead": {
                "type": "",
                "description": "of always sharing memory, defaults to ``False``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "orgqr",
          "signature": "orgqr(input2)",
          "documentation": {
            "description": "orgqr(input2) -> Tensor\n\nSee :func:`torch.orgqr`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ormqr",
          "signature": "ormqr(input2, input3, left=True, transpose=False)",
          "documentation": {
            "description": "ormqr(input2, input3, left=True, transpose=False) -> Tensor\n\nSee :func:`torch.ormqr`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "outer",
          "signature": "outer(vec2)",
          "documentation": {
            "description": "outer(vec2) -> Tensor\n\nSee :func:`torch.outer`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "permute",
          "signature": "permute(*dims)",
          "documentation": {
            "description": "permute(*dims) -> Tensor\n\nSee :func:`torch.permute`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "pin_memory",
          "signature": "pin_memory()",
          "documentation": {
            "description": "pin_memory() -> Tensor\n\nCopies the tensor to pinned memory, if it's not already pinned.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "pinverse",
          "signature": "pinverse()",
          "documentation": {
            "description": "pinverse() -> Tensor\n\nSee :func:`torch.pinverse`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "polygamma",
          "signature": "polygamma(n)",
          "documentation": {
            "description": "polygamma(n) -> Tensor\n\nSee :func:`torch.polygamma`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "polygamma_",
          "signature": "polygamma_(n)",
          "documentation": {
            "description": "polygamma_(n) -> Tensor\n\nIn-place version of :meth:`~Tensor.polygamma`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "positive",
          "signature": "positive()",
          "documentation": {
            "description": "positive() -> Tensor\n\nSee :func:`torch.positive`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "pow",
          "signature": "pow(exponent)",
          "documentation": {
            "description": "pow(exponent) -> Tensor\n\nSee :func:`torch.pow`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "pow_",
          "signature": "pow_(exponent)",
          "documentation": {
            "description": "pow_(exponent) -> Tensor\n\nIn-place version of :meth:`~Tensor.pow`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prelu",
          "signature": "prelu(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(dim=None, keepdim=False, dtype=None)",
          "documentation": {
            "description": "prod(dim=None, keepdim=False, dtype=None) -> Tensor\n\nSee :func:`torch.prod`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(input, index, source, accumulate=False)",
          "documentation": {
            "description": "put(input, index, source, accumulate=False) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.put_`.\n`input` corresponds to `self` in :meth:`torch.Tensor.put_`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put_",
          "signature": "put_(index, source, accumulate=False)",
          "documentation": {
            "description": "put_(index, source, accumulate=False) -> Tensor\n\nCopies the elements from :attr:`source` into the positions specified by\n:attr:`index`. For the purpose of indexing, the :attr:`self` tensor is treated as if\nit were a 1-D tensor.\n\n:attr:`index` and :attr:`source` need to have the same number of elements, but not necessarily\nthe same shape.\n\nIf :attr:`accumulate` is ``True``, the elements in :attr:`source` are added to\n:attr:`self`. If accumulate is ``False``, the behavior is undefined if :attr:`index`\ncontain duplicate elements.",
            "parameters": {
              "index": {
                "type": "LongTensor",
                "description": "the indices into self"
              },
              "source": {
                "type": "Tensor",
                "description": "the tensor containing values to copy from"
              },
              "accumulate": {
                "type": "bool",
                "description": "whether to accumulate into self"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> src = torch.tensor([[4, 3, 5],\n...                     [6, 7, 8]])\n>>> src.put_(torch.tensor([1, 3]), torch.tensor([9, 10]))"
              },
              "tensor": {
                "type": "",
                "description": "([[  4,   9,   5],\n[ 10,   7,   8]])"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "q_per_channel_axis",
          "signature": "q_per_channel_axis()",
          "documentation": {
            "description": "q_per_channel_axis() -> int\n\nGiven a Tensor quantized by linear (affine) per-channel quantization,\nreturns the index of dimension on which per-channel quantization is applied.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "q_per_channel_scales",
          "signature": "q_per_channel_scales()",
          "documentation": {
            "description": "q_per_channel_scales() -> Tensor\n\nGiven a Tensor quantized by linear (affine) per-channel quantization,\nreturns a Tensor of scales of the underlying quantizer. It has the number of\nelements that matches the corresponding dimensions (from q_per_channel_axis) of\nthe tensor.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "q_per_channel_zero_points",
          "signature": "q_per_channel_zero_points()",
          "documentation": {
            "description": "q_per_channel_zero_points() -> Tensor\n\nGiven a Tensor quantized by linear (affine) per-channel quantization,\nreturns a tensor of zero_points of the underlying quantizer. It has the number of\nelements that matches the corresponding dimensions (from q_per_channel_axis) of\nthe tensor.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "q_scale",
          "signature": "q_scale()",
          "documentation": {
            "description": "q_scale() -> float\n\nGiven a Tensor quantized by linear(affine) quantization,\nreturns the scale of the underlying quantizer().",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "q_zero_point",
          "signature": "q_zero_point()",
          "documentation": {
            "description": "q_zero_point() -> int\n\nGiven a Tensor quantized by linear(affine) quantization,\nreturns the zero_point of the underlying quantizer().",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "qr",
          "signature": "qr(some=True)",
          "documentation": {
            "description": "qr(some=True) -> (Tensor, Tensor)\n\nSee :func:`torch.qr`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "qscheme",
          "signature": "qscheme()",
          "documentation": {
            "description": "qscheme() -> torch.qscheme\n\nReturns the quantization scheme of a given QTensor.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "quantile",
          "signature": "quantile(q, dim=None, keepdim=False, *, interpolation='linear')",
          "documentation": {
            "description": "quantile(q, dim=None, keepdim=False, *, interpolation='linear') -> Tensor\n\nSee :func:`torch.quantile`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rad2deg",
          "signature": "rad2deg()",
          "documentation": {
            "description": "rad2deg() -> Tensor\n\nSee :func:`torch.rad2deg`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rad2deg_",
          "signature": "rad2deg_()",
          "documentation": {
            "description": "rad2deg_() -> Tensor\n\nIn-place version of :meth:`~Tensor.rad2deg`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "random_",
          "signature": "random_(from=0, to=None, *, generator=None)",
          "documentation": {
            "description": "random_(from=0, to=None, *, generator=None) -> Tensor\n\nFills :attr:`self` tensor with numbers sampled from the discrete uniform\ndistribution over ``[from, to - 1]``. If not specified, the values are usually\nonly bounded by :attr:`self` tensor's data type. However, for floating point\ntypes, if unspecified, range will be ``[0, 2^mantissa]`` to ensure that every\nvalue is representable. For example, `torch.tensor(1, dtype=torch.double).random_()`\nwill be uniform in ``[0, 2^53]``.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel()",
          "documentation": {
            "description": "ravel() -> Tensor\n\nsee :func:`torch.ravel`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reciprocal",
          "signature": "reciprocal()",
          "documentation": {
            "description": "reciprocal() -> Tensor\n\nSee :func:`torch.reciprocal`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reciprocal_",
          "signature": "reciprocal_()",
          "documentation": {
            "description": "reciprocal_() -> Tensor\n\nIn-place version of :meth:`~Tensor.reciprocal`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "record_stream",
          "signature": "record_stream(stream)",
          "documentation": {
            "description": "record_stream(stream)\n\nMarks the tensor as having been used by this stream.  When the tensor\nis deallocated, ensure the tensor memory is not reused for another tensor\nuntil all work queued on :attr:`stream` at the time of deallocation is\ncomplete.\n\n.. note::\n\n    The caching allocator is aware of only the stream where a tensor was\n    allocated. Due to the awareness, it already correctly manages the life\n    cycle of tensors on only one stream. But if a tensor is used on a stream\n    different from the stream of origin, the allocator might reuse the memory\n    unexpectedly. Calling this method lets the allocator know which streams\n    have used the tensor.\n\n.. warning::\n\n    This method is most suitable for use cases where you are providing a\n    function that created a tensor on a side stream, and want users to be able\n    to make use of the tensor without having to think carefully about stream\n    safety when making use of them.  These safety guarantees come at some\n    performance and predictability cost (analogous to the tradeoff between GC\n    and manual memory management), so if you are in a situation where\n    you manage the full lifetime of your tensors, you may consider instead\n    manually managing CUDA events so that calling this method is not necessary.\n    In particular, when you call this method, on later allocations the\n    allocator will poll the recorded stream to see if all operations have\n    completed yet; you can potentially race with side stream computation and\n    non-deterministically reuse or fail to reuse memory for an allocation.\n\n    You can safely use tensors allocated on side streams without\n    :meth:`~Tensor.record_stream`; you must manually ensure that\n    any non-creation stream uses of a tensor are synced back to the creation\n    stream before you deallocate the tensor.  As the CUDA caching allocator\n    guarantees that the memory will only be reused with the same creation stream,\n    this is sufficient to ensure that writes to future reallocations of the\n    memory will be delayed until non-creation stream uses are done.\n    (Counterintuitively, you may observe that on the CPU side we have already\n    reallocated the tensor, even though CUDA kernels on the old tensor are\n    still in progress.  This is fine, because CUDA operations on the new\n    tensor will appropriately wait for the old operations to complete, as they\n    are all on the same stream.)\n\n    Concretely, this looks like this::\n\n        with torch.cuda.stream(s0):\n            x = torch.zeros(N)\n\n        s1.wait_stream(s0)\n        with torch.cuda.stream(s1):\n            y = some_comm_op(x)\n\n        ... some compute on s0 ...\n\n        # synchronize creation stream s0 to side stream s1\n        # before deallocating x\n        s0.wait_stream(s1)\n        del x\n\n    Note that some discretion is required when deciding when to perform\n    ``s0.wait_stream(s1)``.  In particular, if we were to wait immediately\n    after ``some_comm_op``, there wouldn't be any point in having the side\n    stream; it would be equivalent to have run ``some_comm_op`` on ``s0``.\n    Instead, the synchronization must be placed at some appropriate, later\n    point in time where you expect the side stream ``s1`` to have finished\n    work.  This location is typically identified via profiling, e.g., using\n    Chrome traces produced\n    :meth:`torch.autograd.profiler.profile.export_chrome_trace`.  If you\n    place the wait too early, work on s0 will block until ``s1`` has finished,\n    preventing further overlapping of communication and computation.  If you\n    place the wait too late, you will use more memory than is strictly\n    necessary (as you are keeping ``x`` live for longer.)  For a concrete\n    example of how this guidance can be applied in practice, see this post:\n    `FSDP and CUDACachingAllocator\n    <https://dev-discuss.pytorch.org/t/fsdp-cudacachingallocator-an-outsider-newb-perspective/1486>`_.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "refine_names",
          "signature": "refine_names(self, *names)",
          "documentation": {
            "description": "Refines the dimension names of :attr:`self` according to :attr:`names`.\n\nRefining is a special case of renaming that \"lifts\" unnamed dimensions.\nA ``None`` dim can be refined to have any name; a named dim can only be\nrefined to have the same name.\n\nBecause named tensors can coexist with unnamed tensors, refining names\ngives a nice way to write named-tensor-aware code that works with both\nnamed and unnamed tensors.\n\n:attr:`names` may contain up to one Ellipsis (``...``).\nThe Ellipsis is expanded greedily; it is expanded in-place to fill\n:attr:`names` to the same length as ``self.dim()`` using names from the\ncorresponding indices of ``self.names``.\n\nPython 2 does not support Ellipsis but one may use a string literal\ninstead (``'...'``).",
            "parameters": {
              "names": {
                "type": "iterable of str",
                "description": "The desired names of the output tensor. May"
              },
              "contain": {
                "type": "",
                "description": "up to one Ellipsis."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_hook",
          "signature": "register_hook(self, hook)",
          "documentation": {
            "description": "Registers a backward hook.\n\nThe hook will be called every time a gradient with respect to the\nTensor is computed. The hook should have the following signature::\n\n    hook(grad) -> Tensor or None\n\n\nThe hook should not modify its argument, but it can optionally return\na new gradient which will be used in place of :attr:`grad`.\n\nThis function returns a handle with a method ``handle.remove()``\nthat removes the hook from the module.\n\n.. note::\n    See :ref:`backward-hooks-execution` for more information on how when this hook\n    is executed, and how its execution is ordered relative to other hooks.\n\nExample::\n\n    >>> v = torch.tensor([0., 0., 0.], requires_grad=True)\n    >>> h = v.register_hook(lambda grad: grad * 2)  # double the gradient\n    >>> v.backward(torch.tensor([1., 2., 3.]))\n    >>> v.grad\n\n     2\n     4\n     6\n    [torch.FloatTensor of size (3,)]\n\n    >>> h.remove()  # removes the hook",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "register_post_accumulate_grad_hook",
          "signature": "register_post_accumulate_grad_hook(self, hook)",
          "documentation": {
            "description": "Registers a backward hook that runs after grad accumulation.\n\nThe hook will be called after all gradients for a tensor have been accumulated,\nmeaning that the .grad field has been updated on that tensor. The post\naccumulate grad hook is ONLY applicable for leaf tensors (tensors without a\n.grad_fn field). Registering this hook on a non-leaf tensor will error!\n\nThe hook should have the following signature::\n\n    hook(param: Tensor) -> None\n\nNote that, unlike other autograd hooks, this hook operates on the tensor\nthat requires grad and not the grad itself. The hook can in-place modify\nand access its Tensor argument, including its .grad field.\n\nThis function returns a handle with a method ``handle.remove()``\nthat removes the hook from the module.\n\n.. note::\n    See :ref:`backward-hooks-execution` for more information on how when this hook\n    is executed, and how its execution is ordered relative to other hooks. Since\n    this hook runs during the backward pass, it will run in no_grad mode (unless\n    create_graph is True). You can use torch.enable_grad() to re-enable autograd\n    within the hook if you need it.\n\nExample::\n\n    >>> v = torch.tensor([0., 0., 0.], requires_grad=True)\n    >>> lr = 0.01\n    >>> # simulate a simple SGD update\n    >>> h = v.register_post_accumulate_grad_hook(lambda p: p.add_(p.grad, alpha=-lr))\n    >>> v.backward(torch.tensor([1., 2., 3.]))\n    >>> v\n    tensor([-0.0100, -0.0200, -0.0300], requires_grad=True)\n\n    >>> h.remove()  # removes the hook",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reinforce",
          "signature": "reinforce(self, reward)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "relu",
          "signature": "relu(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "relu_",
          "signature": "relu_(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "remainder",
          "signature": "remainder(divisor)",
          "documentation": {
            "description": "remainder(divisor) -> Tensor\n\nSee :func:`torch.remainder`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "remainder_",
          "signature": "remainder_(divisor)",
          "documentation": {
            "description": "remainder_(divisor) -> Tensor\n\nIn-place version of :meth:`~Tensor.remainder`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rename",
          "signature": "rename(self, *names, **rename_map)",
          "documentation": {
            "description": "Renames dimension names of :attr:`self`.\n\nThere are two main usages:\n\n``self.rename(**rename_map)`` returns a view on tensor that has dims\nrenamed as specified in the mapping :attr:`rename_map`.\n\n``self.rename(*names)`` returns a view on tensor, renaming all\ndimensions positionally using :attr:`names`.\nUse ``self.rename(None)`` to drop names on a tensor.\n\nOne cannot specify both positional args :attr:`names` and keyword args\n:attr:`rename_map`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rename_",
          "signature": "rename_(self, *names, **rename_map)",
          "documentation": {
            "description": "In-place version of :meth:`~Tensor.rename`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "renorm",
          "signature": "renorm(p, dim, maxnorm)",
          "documentation": {
            "description": "renorm(p, dim, maxnorm) -> Tensor\n\nSee :func:`torch.renorm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "renorm_",
          "signature": "renorm_(p, dim, maxnorm)",
          "documentation": {
            "description": "renorm_(p, dim, maxnorm) -> Tensor\n\nIn-place version of :meth:`~Tensor.renorm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(*repeats)",
          "documentation": {
            "description": "repeat(*repeats) -> Tensor\n\nRepeats this tensor along the specified dimensions.\n\nUnlike :meth:`~Tensor.expand`, this function copies the tensor's data.\n\n.. warning::\n\n    :meth:`~Tensor.repeat` behaves differently from\n    `numpy.repeat <https://docs.scipy.org/doc/numpy/reference/generated/numpy.repeat.html>`_,\n    but is more similar to\n    `numpy.tile <https://docs.scipy.org/doc/numpy/reference/generated/numpy.tile.html>`_.\n    For the operator similar to `numpy.repeat`, see :func:`torch.repeat_interleave`.",
            "parameters": {
              "repeat": {
                "type": "torch.Size, int..., tuple of int or list of int",
                "description": "The number of times to repeat this tensor along each dimension"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> x = torch.tensor([1, 2, 3])\n>>> x.repeat(4, 2)"
              },
              "tensor": {
                "type": "",
                "description": "([[ 1,  2,  3,  1,  2,  3],\n[ 1,  2,  3,  1,  2,  3],\n[ 1,  2,  3,  1,  2,  3],\n[ 1,  2,  3,  1,  2,  3]])\n>>> x.repeat(4, 2, 1).size()"
              },
              "torch": {
                "type": "",
                "description": ".Size([4, 2, 3])"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat_interleave",
          "signature": "repeat_interleave(repeats, dim=None, *, output_size=None)",
          "documentation": {
            "description": "repeat_interleave(repeats, dim=None, *, output_size=None) -> Tensor\n\nSee :func:`torch.repeat_interleave`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "requires_grad_",
          "signature": "requires_grad_(requires_grad=True)",
          "documentation": {
            "description": "requires_grad_(requires_grad=True) -> Tensor\n\nChange if autograd should record operations on this tensor: sets this tensor's\n:attr:`requires_grad` attribute in-place. Returns this tensor.\n\n:func:`requires_grad_`'s main use case is to tell autograd to begin recording\noperations on a Tensor ``tensor``. If ``tensor`` has ``requires_grad=False``\n(because it was obtained through a DataLoader, or required preprocessing or\ninitialization), ``tensor.requires_grad_()`` makes it so that autograd will\nbegin to record operations on ``tensor``.",
            "parameters": {
              "requires_grad": {
                "type": "bool",
                "description": "If autograd should record operations on this tensor."
              },
              "Default": {
                "type": "",
                "description": "``True``."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> # Let's say we want to preprocess some saved weights and use\n>>> # the result as new weights.\n>>> saved_weights = [0.1, 0.2, 0.3, 0.25]\n>>> loaded_weights = torch.tensor(saved_weights)\n>>> weights = preprocess(loaded_weights)  # some function\n>>> weights"
              },
              "tensor": {
                "type": "[-1.1007,  0.9853, -4.2316, -1.6606]",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(*shape)",
          "documentation": {
            "description": "reshape(*shape) -> Tensor\n\nReturns a tensor with the same data and number of elements as :attr:`self`\nbut with the specified shape. This method returns a view if :attr:`shape` is\ncompatible with the current shape. See :meth:`torch.Tensor.view` on when it is\npossible to return a view.\n\nSee :func:`torch.reshape`",
            "parameters": {
              "shape": {
                "type": "tuple of ints or int...",
                "description": "the desired shape"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape_as",
          "signature": "reshape_as(other)",
          "documentation": {
            "description": "reshape_as(other) -> Tensor\n\nReturns this tensor as the same shape as :attr:`other`.\n``self.reshape_as(other)`` is equivalent to ``self.reshape(other.sizes())``.\nThis method returns a view if ``other.sizes()`` is compatible with the current\nshape. See :meth:`torch.Tensor.view` on when it is possible to return a view.\n\nPlease see :meth:`reshape` for more information about ``reshape``.",
            "parameters": {
              "other": {
                "type": ":class:`torch.Tensor`",
                "description": "The result tensor has the same shape"
              },
              "as": {
                "type": "",
                "description": "attr:`other`."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(self, *sizes)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize_",
          "signature": "resize_(*sizes, memory_format=torch.contiguous_format)",
          "documentation": {
            "description": "resize_(*sizes, memory_format=torch.contiguous_format) -> Tensor\n\nResizes :attr:`self` tensor to the specified size. If the number of elements is\nlarger than the current storage size, then the underlying storage is resized\nto fit the new number of elements. If the number of elements is smaller, the\nunderlying storage is not changed. Existing elements are preserved but any new\nmemory is uninitialized.\n\n.. warning::\n\n    This is a low-level method. The storage is reinterpreted as C-contiguous,\n    ignoring the current strides (unless the target size equals the current\n    size, in which case the tensor is left unchanged). For most purposes, you\n    will instead want to use :meth:`~Tensor.view()`, which checks for\n    contiguity, or :meth:`~Tensor.reshape()`, which copies data if needed. To\n    change the size in-place with custom strides, see :meth:`~Tensor.set_()`.\n\n.. note::\n\n    If :func:`torch.use_deterministic_algorithms()` and\n    :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to\n    ``True``, new elements are initialized to prevent nondeterministic behavior\n    from using the result as an input to an operation. Floating point and\n    complex values are set to NaN, and integer values are set to the maximum\n    value.",
            "parameters": {
              "sizes": {
                "type": "torch.Size or int...",
                "description": "the desired size"
              },
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "Tensor": {
                "type": "",
                "description": ". Default: ``torch.contiguous_format``. Note that memory format of\n:attr:`self` is going to be unaffected if ``self.size()`` matches ``sizes``."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> x = torch.tensor([[1, 2], [3, 4], [5, 6]])\n>>> x.resize_(2, 2)"
              },
              "tensor": {
                "type": "",
                "description": "([[ 1,  2],\n[ 3,  4]])"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize_as",
          "signature": "resize_as(self, tensor)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize_as_",
          "signature": "resize_as_(tensor, memory_format=torch.contiguous_format)",
          "documentation": {
            "description": "resize_as_(tensor, memory_format=torch.contiguous_format) -> Tensor\n\nResizes the :attr:`self` tensor to be the same size as the specified\n:attr:`tensor`. This is equivalent to ``self.resize_(tensor.size())``.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "Tensor": {
                "type": "",
                "description": ". Default: ``torch.contiguous_format``. Note that memory format of\n:attr:`self` is going to be unaffected if ``self.size()`` matches ``tensor.size()``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize_as_sparse_",
          "signature": "resize_as_sparse_(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resolve_conj",
          "signature": "resolve_conj()",
          "documentation": {
            "description": "resolve_conj() -> Tensor\n\nSee :func:`torch.resolve_conj`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resolve_neg",
          "signature": "resolve_neg()",
          "documentation": {
            "description": "resolve_neg() -> Tensor\n\nSee :func:`torch.resolve_neg`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "retain_grad",
          "signature": "retain_grad()",
          "documentation": {
            "description": "retain_grad() -> None\n\nEnables this Tensor to have their :attr:`grad` populated during\n:func:`backward`. This is a no-op for leaf tensors.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "roll",
          "signature": "roll(shifts, dims)",
          "documentation": {
            "description": "roll(shifts, dims) -> Tensor\n\nSee :func:`torch.roll`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rot90",
          "signature": "rot90(k, dims)",
          "documentation": {
            "description": "rot90(k, dims) -> Tensor\n\nSee :func:`torch.rot90`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(decimals=0)",
          "documentation": {
            "description": "round(decimals=0) -> Tensor\n\nSee :func:`torch.round`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round_",
          "signature": "round_(decimals=0)",
          "documentation": {
            "description": "round_(decimals=0) -> Tensor\n\nIn-place version of :meth:`~Tensor.round`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "row_indices",
          "signature": "row_indices(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rsqrt",
          "signature": "rsqrt()",
          "documentation": {
            "description": "rsqrt() -> Tensor\n\nSee :func:`torch.rsqrt`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rsqrt_",
          "signature": "rsqrt_()",
          "documentation": {
            "description": "rsqrt_() -> Tensor\n\nIn-place version of :meth:`~Tensor.rsqrt`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "scatter",
          "signature": "scatter(dim, index, src)",
          "documentation": {
            "description": "scatter(dim, index, src) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.scatter_`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "scatter_",
          "signature": "scatter_(dim, index, src, *, reduce=None)",
          "documentation": {
            "description": "scatter_(dim, index, src, *, reduce=None) -> Tensor\n\nWrites all values from the tensor :attr:`src` into :attr:`self` at the indices\nspecified in the :attr:`index` tensor. For each value in :attr:`src`, its output\nindex is specified by its index in :attr:`src` for ``dimension != dim`` and by\nthe corresponding value in :attr:`index` for ``dimension = dim``.\n\nFor a 3-D tensor, :attr:`self` is updated as::\n\n    self[index[i][j][k]][j][k] = src[i][j][k]  # if dim == 0\n    self[i][index[i][j][k]][k] = src[i][j][k]  # if dim == 1\n    self[i][j][index[i][j][k]] = src[i][j][k]  # if dim == 2\n\nThis is the reverse operation of the manner described in :meth:`~Tensor.gather`.\n\n:attr:`self`, :attr:`index` and :attr:`src` (if it is a Tensor) should all have\nthe same number of dimensions. It is also required that\n``index.size(d) <= src.size(d)`` for all dimensions ``d``, and that\n``index.size(d) <= self.size(d)`` for all dimensions ``d != dim``.\nNote that ``index`` and ``src`` do not broadcast.\n\nMoreover, as for :meth:`~Tensor.gather`, the values of :attr:`index` must be\nbetween ``0`` and ``self.size(dim) - 1`` inclusive.\n\n.. warning::\n\n    When indices are not unique, the behavior is non-deterministic (one of the\n    values from ``src`` will be picked arbitrarily) and the gradient will be\n    incorrect (it will be propagated to all locations in the source that\n    correspond to the same index)!\n\n.. note::\n\n    The backward pass is implemented only for ``src.shape == index.shape``.\n\nAdditionally accepts an optional :attr:`reduce` argument that allows\nspecification of an optional reduction operation, which is applied to all\nvalues in the tensor :attr:`src` into :attr:`self` at the indices\nspecified in the :attr:`index`. For each value in :attr:`src`, the reduction\noperation is applied to an index in :attr:`self` which is specified by\nits index in :attr:`src` for ``dimension != dim`` and by the corresponding\nvalue in :attr:`index` for ``dimension = dim``.\n\nGiven a 3-D tensor and reduction using the multiplication operation, :attr:`self`\nis updated as::\n\n    self[index[i][j][k]][j][k] *= src[i][j][k]  # if dim == 0\n    self[i][index[i][j][k]][k] *= src[i][j][k]  # if dim == 1\n    self[i][j][index[i][j][k]] *= src[i][j][k]  # if dim == 2\n\nReducing with the addition operation is the same as using\n:meth:`~torch.Tensor.scatter_add_`.\n\n.. warning::\n    The reduce argument with Tensor ``src`` is deprecated and will be removed in\n    a future PyTorch release. Please use :meth:`~torch.Tensor.scatter_reduce_`\n    instead for more reduction options.",
            "parameters": {
              "dim": {
                "type": "int",
                "description": "the axis along which to index"
              },
              "index": {
                "type": "LongTensor",
                "description": "the indices of elements to scatter, can be either empty"
              },
              "or": {
                "type": "",
                "description": "of the same dimensionality as ``src``. When empty, the operation"
              },
              "returns": {
                "type": "",
                "description": "``self`` unchanged."
              },
              "src": {
                "type": "Tensor",
                "description": "the source element(s) to scatter."
              },
              "Keyword": {
                "type": "",
                "description": "args:"
              },
              "reduce": {
                "type": "str, optional",
                "description": "reduction operation to apply, can be either\n``'add'`` or ``'multiply'``."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> index = torch.tensor([[0, 1]])\n>>> value = 2\n>>> torch.zeros(3, 5).scatter_(0, index, value)"
              },
              "tensor": {
                "type": "",
                "description": "([[2., 0., 0., 0., 0.],\n[0., 2., 0., 0., 0.],\n[0., 0., 0., 0., 0.]])"
              },
              "Writes": {
                "type": "",
                "description": "the value from :attr:`value` into :attr:`self` at the indices"
              },
              "specified": {
                "type": "",
                "description": "in the :attr:`index` tensor.  This operation is equivalent to the previous version,"
              },
              "with": {
                "type": "",
                "description": "the :attr:`src` tensor filled entirely with :attr:`value`."
              },
              "Args": {
                "type": "",
                "description": ""
              },
              "value": {
                "type": "Scalar",
                "description": "the value to scatter."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "scatter_add",
          "signature": "scatter_add(dim, index, src)",
          "documentation": {
            "description": "scatter_add(dim, index, src) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.scatter_add_`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "scatter_add_",
          "signature": "scatter_add_(dim, index, src)",
          "documentation": {
            "description": "scatter_add_(dim, index, src) -> Tensor\n\nAdds all values from the tensor :attr:`src` into :attr:`self` at the indices\nspecified in the :attr:`index` tensor in a similar fashion as\n:meth:`~torch.Tensor.scatter_`. For each value in :attr:`src`, it is added to\nan index in :attr:`self` which is specified by its index in :attr:`src`\nfor ``dimension != dim`` and by the corresponding value in :attr:`index` for\n``dimension = dim``.\n\nFor a 3-D tensor, :attr:`self` is updated as::\n\n    self[index[i][j][k]][j][k] += src[i][j][k]  # if dim == 0\n    self[i][index[i][j][k]][k] += src[i][j][k]  # if dim == 1\n    self[i][j][index[i][j][k]] += src[i][j][k]  # if dim == 2\n\n:attr:`self`, :attr:`index` and :attr:`src` should have same number of\ndimensions. It is also required that ``index.size(d) <= src.size(d)`` for all\ndimensions ``d``, and that ``index.size(d) <= self.size(d)`` for all dimensions\n``d != dim``. Note that ``index`` and ``src`` do not broadcast.",
            "parameters": {
              "dim": {
                "type": "int",
                "description": "the axis along which to index"
              },
              "index": {
                "type": "LongTensor",
                "description": "the indices of elements to scatter and add, can be"
              },
              "either": {
                "type": "",
                "description": "empty or of the same dimensionality as ``src``. When empty, the"
              },
              "operation": {
                "type": "",
                "description": "returns ``self`` unchanged."
              },
              "src": {
                "type": "Tensor",
                "description": "the source elements to scatter and add"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> src = torch.ones((2, 5))\n>>> index = torch.tensor([[0, 1, 2, 0, 0]])\n>>> torch.zeros(3, 5, dtype=src.dtype).scatter_add_(0, index, src)"
              },
              "tensor": {
                "type": "",
                "description": "([[2., 0., 0., 1., 1.],\n[0., 2., 0., 0., 0.],\n[0., 0., 2., 1., 1.]])"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "This operation may behave nondeterministically when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.\n\n.. note::\n\n    The backward pass is implemented only for ``src.shape == index.shape``.\n\nArgs:\n    dim (int): the axis along which to index\n    index (LongTensor): the indices of elements to scatter and add, can be\n        either empty or of the same dimensionality as ``src``. When empty, the\n        operation returns ``self`` unchanged.\n    src (Tensor): the source elements to scatter and add",
            "examples": ""
          }
        },
        {
          "name": "scatter_reduce",
          "signature": "scatter_reduce(dim, index, src, reduce, *, include_self=True)",
          "documentation": {
            "description": "scatter_reduce(dim, index, src, reduce, *, include_self=True) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.scatter_reduce_`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "scatter_reduce_",
          "signature": "scatter_reduce_(dim, index, src, reduce, *, include_self=True)",
          "documentation": {
            "description": "scatter_reduce_(dim, index, src, reduce, *, include_self=True) -> Tensor\n\nReduces all values from the :attr:`src` tensor to the indices specified in\nthe :attr:`index` tensor in the :attr:`self` tensor using the applied reduction\ndefined via the :attr:`reduce` argument (:obj:`\"sum\"`, :obj:`\"prod\"`, :obj:`\"mean\"`,\n:obj:`\"amax\"`, :obj:`\"amin\"`). For each value in :attr:`src`, it is reduced to an\nindex in :attr:`self` which is specified by its index in :attr:`src` for\n``dimension != dim`` and by the corresponding value in :attr:`index` for\n``dimension = dim``. If :obj:`include_self=\"True\"`, the values in the :attr:`self`\ntensor are included in the reduction.\n\n:attr:`self`, :attr:`index` and :attr:`src` should all have\nthe same number of dimensions. It is also required that\n``index.size(d) <= src.size(d)`` for all dimensions ``d``, and that\n``index.size(d) <= self.size(d)`` for all dimensions ``d != dim``.\nNote that ``index`` and ``src`` do not broadcast.\n\nFor a 3-D tensor with :obj:`reduce=\"sum\"` and :obj:`include_self=True` the\noutput is given as::\n\n    self[index[i][j][k]][j][k] += src[i][j][k]  # if dim == 0\n    self[i][index[i][j][k]][k] += src[i][j][k]  # if dim == 1\n    self[i][j][index[i][j][k]] += src[i][j][k]  # if dim == 2",
            "parameters": {
              "dim": {
                "type": "int",
                "description": "the axis along which to index"
              },
              "index": {
                "type": "LongTensor",
                "description": "the indices of elements to scatter and reduce."
              },
              "src": {
                "type": "Tensor",
                "description": "the source elements to scatter and reduce"
              },
              "reduce": {
                "type": "str",
                "description": "the reduction operation to apply for non-unique indices\n(:obj:`\"sum\"`, :obj:`\"prod\"`, :obj:`\"mean\"`, :obj:`\"amax\"`, :obj:`\"amin\"`)"
              },
              "include_self": {
                "type": "bool",
                "description": "whether elements from the :attr:`self` tensor are"
              },
              "included": {
                "type": "",
                "description": "in the reduction"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> src = torch.tensor([1., 2., 3., 4., 5., 6.])\n>>> index = torch.tensor([0, 1, 0, 1, 2, 1])\n>>> input = torch.tensor([1., 2., 3., 4.])\n>>> input.scatter_reduce(0, index, src, reduce=\"sum\")"
              },
              "tensor": {
                "type": "[3., 6., 5., 2.]",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "This operation may behave nondeterministically when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.\n\n.. note::\n\n    The backward pass is implemented only for ``src.shape == index.shape``.\n\n.. warning::\n\n    This function is in beta and may change in the near future.\n\nArgs:\n    dim (int): the axis along which to index\n    index (LongTensor): the indices of elements to scatter and reduce.\n    src (Tensor): the source elements to scatter and reduce\n    reduce (str): the reduction operation to apply for non-unique indices\n        (:obj:`\"sum\"`, :obj:`\"prod\"`, :obj:`\"mean\"`, :obj:`\"amax\"`, :obj:`\"amin\"`)\n    include_self (bool): whether elements from the :attr:`self` tensor are\n        included in the reduction",
            "examples": ""
          }
        },
        {
          "name": "select",
          "signature": "select(dim, index)",
          "documentation": {
            "description": "select(dim, index) -> Tensor\n\nSee :func:`torch.select`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "select_scatter",
          "signature": "select_scatter(src, dim, index)",
          "documentation": {
            "description": "select_scatter(src, dim, index) -> Tensor\n\nSee :func:`torch.select_scatter`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_",
          "signature": "set_(source=None, storage_offset=0, size=None, stride=None)",
          "documentation": {
            "description": "set_(source=None, storage_offset=0, size=None, stride=None) -> Tensor\n\nSets the underlying storage, size, and strides. If :attr:`source` is a tensor,\n:attr:`self` tensor will share the same storage and have the same size and\nstrides as :attr:`source`. Changes to elements in one tensor will be reflected\nin the other.\n\nIf :attr:`source` is a :class:`~torch.Storage`, the method sets the underlying\nstorage, offset, size, and stride.",
            "parameters": {
              "source": {
                "type": "Tensor or Storage",
                "description": "the tensor or storage to use"
              },
              "storage_offset": {
                "type": "int, optional",
                "description": "the offset in the storage"
              },
              "size": {
                "type": "torch.Size, optional",
                "description": "the desired size. Defaults to the size of the source."
              },
              "stride": {
                "type": "tuple, optional",
                "description": "the desired stride. Defaults to C-contiguous strides."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sgn",
          "signature": "sgn()",
          "documentation": {
            "description": "sgn() -> Tensor\n\nSee :func:`torch.sgn`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sgn_",
          "signature": "sgn_()",
          "documentation": {
            "description": "sgn_() -> Tensor\n\nIn-place version of :meth:`~Tensor.sgn`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "share_memory_",
          "signature": "share_memory_(self)",
          "documentation": {
            "description": "Moves the underlying storage to shared memory.\n\nThis is a no-op if the underlying storage is already in shared memory\nand for CUDA tensors. Tensors in shared memory cannot be resized.\n\nSee :meth:`torch.UntypedStorage.share_memory_` for more details.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "short",
          "signature": "short(memory_format=torch.preserve_format)",
          "documentation": {
            "description": "short(memory_format=torch.preserve_format) -> Tensor\n\n``self.short()`` is equivalent to ``self.to(torch.int16)``. See :func:`to`.",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sigmoid",
          "signature": "sigmoid()",
          "documentation": {
            "description": "sigmoid() -> Tensor\n\nSee :func:`torch.sigmoid`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sigmoid_",
          "signature": "sigmoid_()",
          "documentation": {
            "description": "sigmoid_() -> Tensor\n\nIn-place version of :meth:`~Tensor.sigmoid`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sign",
          "signature": "sign()",
          "documentation": {
            "description": "sign() -> Tensor\n\nSee :func:`torch.sign`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sign_",
          "signature": "sign_()",
          "documentation": {
            "description": "sign_() -> Tensor\n\nIn-place version of :meth:`~Tensor.sign`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "signbit",
          "signature": "signbit()",
          "documentation": {
            "description": "signbit() -> Tensor\n\nSee :func:`torch.signbit`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sin",
          "signature": "sin()",
          "documentation": {
            "description": "sin() -> Tensor\n\nSee :func:`torch.sin`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sin_",
          "signature": "sin_()",
          "documentation": {
            "description": "sin_() -> Tensor\n\nIn-place version of :meth:`~Tensor.sin`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sinc",
          "signature": "sinc()",
          "documentation": {
            "description": "sinc() -> Tensor\n\nSee :func:`torch.sinc`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sinc_",
          "signature": "sinc_()",
          "documentation": {
            "description": "sinc_() -> Tensor\n\nIn-place version of :meth:`~Tensor.sinc`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sinh",
          "signature": "sinh()",
          "documentation": {
            "description": "sinh() -> Tensor\n\nSee :func:`torch.sinh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sinh_",
          "signature": "sinh_()",
          "documentation": {
            "description": "sinh_() -> Tensor\n\nIn-place version of :meth:`~Tensor.sinh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "size",
          "signature": "size(dim=None)",
          "documentation": {
            "description": "size(dim=None) -> torch.Size or int\n\nReturns the size of the :attr:`self` tensor. If ``dim`` is not specified,\nthe returned value is a :class:`torch.Size`, a subclass of :class:`tuple`.\nIf ``dim`` is specified, returns an int holding the size of that dimension.",
            "parameters": {
              "dim": {
                "type": "int, optional",
                "description": "The dimension for which to retrieve the size."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> t = torch.empty(3, 4, 5)\n>>> t.size()"
              },
              "torch": {
                "type": "",
                "description": ".Size([3, 4, 5])\n>>> t.size(dim=1)"
              },
              "4": {
                "type": "",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "slice_inverse",
          "signature": "slice_inverse(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "slice_scatter",
          "signature": "slice_scatter(src, dim=0, start=None, end=None, step=1)",
          "documentation": {
            "description": "slice_scatter(src, dim=0, start=None, end=None, step=1) -> Tensor\n\nSee :func:`torch.slice_scatter`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "slogdet",
          "signature": "slogdet()",
          "documentation": {
            "description": "slogdet() -> (Tensor, Tensor)\n\nSee :func:`torch.slogdet`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "smm",
          "signature": "smm(mat)",
          "documentation": {
            "description": "smm(mat) -> Tensor\n\nSee :func:`torch.smm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "softmax",
          "signature": "softmax(dim)",
          "documentation": {
            "description": "softmax(dim) -> Tensor\n\nAlias for :func:`torch.nn.functional.softmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "solve",
          "signature": "solve(self, other)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(dim=-1, descending=False)",
          "documentation": {
            "description": "sort(dim=-1, descending=False) -> (Tensor, LongTensor)\n\nSee :func:`torch.sort`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sparse_dim",
          "signature": "sparse_dim()",
          "documentation": {
            "description": "sparse_dim() -> int\n\nReturn the number of sparse dimensions in a :ref:`sparse tensor <sparse-docs>` :attr:`self`.\n\n.. note::\n  Returns ``0`` if :attr:`self` is not a sparse tensor.\n\nSee also :meth:`Tensor.dense_dim` and :ref:`hybrid tensors <sparse-hybrid-coo-docs>`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sparse_mask",
          "signature": "sparse_mask(mask)",
          "documentation": {
            "description": "sparse_mask(mask) -> Tensor\n\nReturns a new :ref:`sparse tensor <sparse-docs>` with values from a\nstrided tensor :attr:`self` filtered by the indices of the sparse\ntensor :attr:`mask`. The values of :attr:`mask` sparse tensor are\nignored. :attr:`self` and :attr:`mask` tensors must have the same\nshape.\n\n.. note::\n\n  The returned sparse tensor might contain duplicate values if :attr:`mask`\n  is not coalesced. It is therefore advisable to pass ``mask.coalesce()``\n  if such behavior is not desired.\n\n.. note::\n\n  The returned sparse tensor has the same indices as the sparse tensor\n  :attr:`mask`, even when the corresponding values in :attr:`self` are\n  zeros.",
            "parameters": {
              "mask": {
                "type": "Tensor",
                "description": "a sparse tensor whose indices are used as a filter"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> nse = 5\n>>> dims = (5, 5, 2, 2)\n>>> I = torch.cat([torch.randint(0, dims[0], size=(nse,)),\n...                torch.randint(0, dims[1], size=(nse,))], 0).reshape(2, nse)\n>>> V = torch.randn(nse, dims[2], dims[3])\n>>> S = torch.sparse_coo_tensor(I, V, dims).coalesce()\n>>> D = torch.randn(dims)\n>>> D.sparse_mask(S)"
              },
              "tensor": {
                "type": "",
                "description": "(indices=tensor([[0, 0, 0, 2],\n[0, 1, 4, 3]]),"
              },
              "values": {
                "type": "",
                "description": "=tensor([[[ 1.6550,  0.2397],\n[-0.1611, -0.0779]],\n[[ 0.2326, -1.0558],\n[ 1.4711,  1.9678]],\n[[-0.5138, -0.0411],\n[ 1.9417,  0.5158]],\n[[ 0.0793,  0.0036],\n[-0.2569, -0.1055]]]),"
              },
              "size": {
                "type": "",
                "description": "=(5, 5, 2, 2), nnz=4, layout=torch.sparse_coo)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sparse_resize_",
          "signature": "sparse_resize_(size, sparse_dim, dense_dim)",
          "documentation": {
            "description": "sparse_resize_(size, sparse_dim, dense_dim) -> Tensor\n\nResizes :attr:`self` :ref:`sparse tensor <sparse-docs>` to the desired\nsize and the number of sparse and dense dimensions.\n\n.. note::\n  If the number of specified elements in :attr:`self` is zero, then\n  :attr:`size`, :attr:`sparse_dim`, and :attr:`dense_dim` can be any\n  size and positive integers such that ``len(size) == sparse_dim +\n  dense_dim``.\n\n  If :attr:`self` specifies one or more elements, however, then each\n  dimension in :attr:`size` must not be smaller than the corresponding\n  dimension of :attr:`self`, :attr:`sparse_dim` must equal the number\n  of sparse dimensions in :attr:`self`, and :attr:`dense_dim` must\n  equal the number of dense dimensions in :attr:`self`.\n\n.. warning::\n  Throws an error if :attr:`self` is not a sparse tensor.",
            "parameters": {
              "size": {
                "type": "torch.Size",
                "description": "the desired size. If :attr:`self` is non-empty"
              },
              "sparse": {
                "type": "",
                "description": "tensor, the desired size cannot be smaller than the"
              },
              "original": {
                "type": "",
                "description": "size."
              },
              "sparse_dim": {
                "type": "int",
                "description": "the number of sparse dimensions"
              },
              "dense_dim": {
                "type": "int",
                "description": "the number of dense dimensions"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sparse_resize_and_clear_",
          "signature": "sparse_resize_and_clear_(size, sparse_dim, dense_dim)",
          "documentation": {
            "description": "sparse_resize_and_clear_(size, sparse_dim, dense_dim) -> Tensor\n\nRemoves all specified elements from a :ref:`sparse tensor\n<sparse-docs>` :attr:`self` and resizes :attr:`self` to the desired\nsize and the number of sparse and dense dimensions.\n\n.. warning:\n  Throws an error if :attr:`self` is not a sparse tensor.",
            "parameters": {
              "size": {
                "type": "torch.Size",
                "description": "the desired size."
              },
              "sparse_dim": {
                "type": "int",
                "description": "the number of sparse dimensions"
              },
              "dense_dim": {
                "type": "int",
                "description": "the number of dense dimensions"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, split_size, dim=0)",
          "documentation": {
            "description": "See :func:`torch.split`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split_with_sizes",
          "signature": "split_with_sizes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sqrt",
          "signature": "sqrt()",
          "documentation": {
            "description": "sqrt() -> Tensor\n\nSee :func:`torch.sqrt`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sqrt_",
          "signature": "sqrt_()",
          "documentation": {
            "description": "sqrt_() -> Tensor\n\nIn-place version of :meth:`~Tensor.sqrt`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "square",
          "signature": "square()",
          "documentation": {
            "description": "square() -> Tensor\n\nSee :func:`torch.square`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "square_",
          "signature": "square_()",
          "documentation": {
            "description": "square_() -> Tensor\n\nIn-place version of :meth:`~Tensor.square`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(dim=None)",
          "documentation": {
            "description": "squeeze(dim=None) -> Tensor\n\nSee :func:`torch.squeeze`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze_",
          "signature": "squeeze_(dim=None)",
          "documentation": {
            "description": "squeeze_(dim=None) -> Tensor\n\nIn-place version of :meth:`~Tensor.squeeze`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sspaddmm",
          "signature": "sspaddmm(mat1, mat2, *, beta=1, alpha=1)",
          "documentation": {
            "description": "sspaddmm(mat1, mat2, *, beta=1, alpha=1) -> Tensor\n\nSee :func:`torch.sspaddmm`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(dim=None, *, correction=1, keepdim=False)",
          "documentation": {
            "description": "std(dim=None, *, correction=1, keepdim=False) -> Tensor\n\nSee :func:`torch.std`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "stft",
          "signature": "stft(self, n_fft: int, hop_length: Optional[int] = None, win_length: Optional[int] = None, window: 'Optional[Tensor]' = None, center: bool = True, pad_mode: str = 'reflect', normalized: bool = False, onesided: Optional[bool] = None, return_complex: Optional[bool] = None)",
          "documentation": {
            "description": "See :func:`torch.stft`\n\n.. warning::\n  This function changed signature at version 0.4.1. Calling with\n  the previous signature may cause error or return incorrect result.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "storage",
          "signature": "storage(self)",
          "documentation": {
            "description": "storage() -> torch.TypedStorage\n\nReturns the underlying :class:`TypedStorage`.\n\n.. warning::\n\n    :class:`TypedStorage` is deprecated. It will be removed in the future, and\n    :class:`UntypedStorage` will be the only storage class. To access the\n    :class:`UntypedStorage` directly, use :attr:`Tensor.untyped_storage()`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "storage_offset",
          "signature": "storage_offset()",
          "documentation": {
            "description": "storage_offset() -> int\n\nReturns :attr:`self` tensor's offset in the underlying storage in terms of\nnumber of storage elements (not bytes).\n\nExample::\n\n    >>> x = torch.tensor([1, 2, 3, 4, 5])\n    >>> x.storage_offset()\n    0\n    >>> x[3:].storage_offset()\n    3",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "storage_type",
          "signature": "storage_type(self)",
          "documentation": {
            "description": "storage_type() -> type\n\nReturns the type of the underlying storage.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "stride",
          "signature": "stride(dim)",
          "documentation": {
            "description": "stride(dim) -> tuple or int\n\nReturns the stride of :attr:`self` tensor.\n\nStride is the jump necessary to go from one element to the next one in the\nspecified dimension :attr:`dim`. A tuple of all strides is returned when no\nargument is passed in. Otherwise, an integer value is returned as the stride in\nthe particular dimension :attr:`dim`.",
            "parameters": {
              "dim": {
                "type": "int, optional",
                "description": "the desired dimension in which stride is required"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> x = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\n>>> x.stride()\n(5, 1)\n>>> x.stride(0)"
              },
              "5": {
                "type": "",
                "description": ">>> x.stride(-1)"
              },
              "1": {
                "type": "",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sub",
          "signature": "sub(other, *, alpha=1)",
          "documentation": {
            "description": "sub(other, *, alpha=1) -> Tensor\n\nSee :func:`torch.sub`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sub_",
          "signature": "sub_(other, *, alpha=1)",
          "documentation": {
            "description": "sub_(other, *, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.sub`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "subtract",
          "signature": "subtract(other, *, alpha=1)",
          "documentation": {
            "description": "subtract(other, *, alpha=1) -> Tensor\n\nSee :func:`torch.subtract`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "subtract_",
          "signature": "subtract_(other, *, alpha=1)",
          "documentation": {
            "description": "subtract_(other, *, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.subtract`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(dim=None, keepdim=False, dtype=None)",
          "documentation": {
            "description": "sum(dim=None, keepdim=False, dtype=None) -> Tensor\n\nSee :func:`torch.sum`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum_to_size",
          "signature": "sum_to_size(*size)",
          "documentation": {
            "description": "sum_to_size(*size) -> Tensor\n\nSum ``this`` tensor to :attr:`size`.\n:attr:`size` must be broadcastable to ``this`` tensor size.",
            "parameters": {
              "size": {
                "type": "int...",
                "description": "a sequence of integers defining the shape of the output tensor."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "svd",
          "signature": "svd(some=True, compute_uv=True)",
          "documentation": {
            "description": "svd(some=True, compute_uv=True) -> (Tensor, Tensor, Tensor)\n\nSee :func:`torch.svd`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(axis0, axis1)",
          "documentation": {
            "description": "swapaxes(axis0, axis1) -> Tensor\n\nSee :func:`torch.swapaxes`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes_",
          "signature": "swapaxes_(axis0, axis1)",
          "documentation": {
            "description": "swapaxes_(axis0, axis1) -> Tensor\n\nIn-place version of :meth:`~Tensor.swapaxes`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapdims",
          "signature": "swapdims(dim0, dim1)",
          "documentation": {
            "description": "swapdims(dim0, dim1) -> Tensor\n\nSee :func:`torch.swapdims`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapdims_",
          "signature": "swapdims_(dim0, dim1)",
          "documentation": {
            "description": "swapdims_(dim0, dim1) -> Tensor\n\nIn-place version of :meth:`~Tensor.swapdims`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "symeig",
          "signature": "symeig(self, eigenvectors=False)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "t",
          "signature": "t()",
          "documentation": {
            "description": "t() -> Tensor\n\nSee :func:`torch.t`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "t_",
          "signature": "t_()",
          "documentation": {
            "description": "t_() -> Tensor\n\nIn-place version of :meth:`~Tensor.t`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(indices)",
          "documentation": {
            "description": "take(indices) -> Tensor\n\nSee :func:`torch.take`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take_along_dim",
          "signature": "take_along_dim(indices, dim)",
          "documentation": {
            "description": "take_along_dim(indices, dim) -> Tensor\n\nSee :func:`torch.take_along_dim`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tan",
          "signature": "tan()",
          "documentation": {
            "description": "tan() -> Tensor\n\nSee :func:`torch.tan`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tan_",
          "signature": "tan_()",
          "documentation": {
            "description": "tan_() -> Tensor\n\nIn-place version of :meth:`~Tensor.tan`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tanh",
          "signature": "tanh()",
          "documentation": {
            "description": "tanh() -> Tensor\n\nSee :func:`torch.tanh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tanh_",
          "signature": "tanh_()",
          "documentation": {
            "description": "tanh_() -> Tensor\n\nIn-place version of :meth:`~Tensor.tanh`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tensor_split",
          "signature": "tensor_split(indices_or_sections, dim=0)",
          "documentation": {
            "description": "tensor_split(indices_or_sections, dim=0) -> List of Tensors\n\nSee :func:`torch.tensor_split`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tile",
          "signature": "tile(dims)",
          "documentation": {
            "description": "tile(dims) -> Tensor\n\nSee :func:`torch.tile`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to",
          "signature": "to(*args, **kwargs)",
          "documentation": {
            "description": "to(*args, **kwargs) -> Tensor\n\nPerforms Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are\ninferred from the arguments of ``self.to(*args, **kwargs)``.\n\n.. note::\n\n    If the ``self`` Tensor already\n    has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.\n    Otherwise, the returned tensor is a copy of ``self`` with the desired\n    :class:`torch.dtype` and :class:`torch.device`.\n\nHere are the ways to call ``to``:\n\n.. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor\n   :noindex:\n\n    Returns a Tensor with the specified :attr:`dtype`",
            "parameters": {
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``.\n.. method:: to(other, non_blocking=False, copy=False) -> Tensor\n:noindex:"
              },
              "Returns": {
                "type": "",
                "description": "a Tensor with same :class:`torch.dtype` and :class:`torch.device` as"
              },
              "When": {
                "type": "",
                "description": "attr:`copy` is set, a new Tensor is created even when the Tensor"
              },
              "the": {
                "type": "",
                "description": "Tensor :attr:`other`. When :attr:`non_blocking`, tries to convert"
              },
              "CUDA": {
                "type": "",
                "description": "Tensor."
              },
              "already": {
                "type": "",
                "description": "matches the desired conversion."
              },
              "Args": {
                "type": "",
                "description": ""
              },
              "asynchronously": {
                "type": "",
                "description": "with respect to the host if possible, e.g., converting a CPU"
              },
              "Tensor": {
                "type": "",
                "description": "with pinned memory to a CUDA Tensor."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu\n>>> tensor.to(torch.float64)"
              },
              "tensor": {
                "type": "",
                "description": "([[-0.5044,  0.0005],\n[ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to_dense",
          "signature": "to_dense(dtype=None, *, masked_grad=True)",
          "documentation": {
            "description": "to_dense(dtype=None, *, masked_grad=True) -> Tensor\n\nCreates a strided copy of :attr:`self` if :attr:`self` is not a strided tensor, otherwise returns :attr:`self`.\n\nKeyword args:\n    {dtype}\n    masked_grad (bool, optional): If set to ``True`` (default) and\n      :attr:`self` has a sparse layout then the backward of\n      :meth:`to_dense` returns ``grad.sparse_mask(self)``.\n\nExample::\n\n    >>> s = torch.sparse_coo_tensor(\n    ...        torch.tensor([[1, 1],\n    ...                      [0, 2]]),\n    ...        torch.tensor([9, 10]),\n    ...        size=(3, 3))\n    >>> s.to_dense()\n    tensor([[ 0,  0,  0],\n            [ 9,  0, 10],\n            [ 0,  0,  0]])",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to_mkldnn",
          "signature": "to_mkldnn()",
          "documentation": {
            "description": "to_mkldnn() -> Tensor\nReturns a copy of the tensor in ``torch.mkldnn`` layout.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to_padded_tensor",
          "signature": "to_padded_tensor(padding, output_size=None)",
          "documentation": {
            "description": "to_padded_tensor(padding, output_size=None) -> Tensor\nSee :func:`to_padded_tensor`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to_sparse",
          "signature": "to_sparse(sparseDims)",
          "documentation": {
            "description": "to_sparse(sparseDims) -> Tensor\n\nReturns a sparse copy of the tensor.  PyTorch supports sparse tensors in\n:ref:`coordinate format <sparse-coo-docs>`.",
            "parameters": {
              "sparseDims": {
                "type": "int, optional",
                "description": "the number of sparse dimensions to include in the new sparse tensor"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])\n>>> x.to_sparse(layout=torch.sparse_coo)"
              },
              "tensor": {
                "type": "crow_indices=tensor([0, 1, 1, 3]",
                "description": ","
              },
              "values": {
                "type": "",
                "description": "=tensor([[1],\n[2],\n[3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)"
              },
              "size": {
                "type": "",
                "description": "=(3, 2), nnz=3, layout=torch.sparse_coo)\n>>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))"
              },
              "Returns": {
                "type": "",
                "description": "a sparse tensor with the specified layout and blocksize.  If"
              },
              "the": {
                "type": "",
                "description": "attr:`self` is strided, the number of dense dimensions could be"
              },
              "specified": {
                "type": "",
                "description": ", and a hybrid sparse tensor will be created, with\n`dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch"
              },
              "dimension": {
                "type": "",
                "description": ".\n.. note:: If the :attr:`self` layout and blocksize parameters match"
              },
              "with": {
                "type": "",
                "description": "the specified layout and blocksize, return\n:attr:`self`. Otherwise, return a sparse tensor copy of\n:attr:`self`."
              },
              "Args": {
                "type": "",
                "description": ""
              },
              "layout": {
                "type": "",
                "description": ". One of ``torch.sparse_coo``, ``torch.sparse_csr``,\n``torch.sparse_csc``, ``torch.sparse_bsr``, or\n``torch.sparse_bsc``. Default: if ``None``,\n``torch.sparse_coo``."
              },
              "blocksize": {
                "type": "list, tuple, :class:`torch.Size`, optional",
                "description": "Block size"
              },
              "of": {
                "type": "",
                "description": "the resulting BSR or BSC tensor. For other layouts,"
              },
              "specifying": {
                "type": "",
                "description": "the block size that is not ``None`` will result in a"
              },
              "RuntimeError": {
                "type": "",
                "description": "to_sparse for Strided to SparseCsr conversion does not use specified blocksize\n>>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])\n>>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)"
              },
              "two": {
                "type": "",
                "description": "such that its items evenly divide the two sparse dimensions."
              },
              "dense_dim": {
                "type": "int, optional",
                "description": "Number of dense dimensions of the"
              },
              "resulting": {
                "type": "",
                "description": "CSR, CSC, BSR or BSC tensor.  This argument should be"
              },
              "used": {
                "type": "",
                "description": "only if :attr:`self` is a strided tensor, and must be a"
              },
              "value": {
                "type": "",
                "description": "between 0 and dimension of :attr:`self` tensor minus two."
              },
              "col_indices": {
                "type": "",
                "description": "=tensor([0, 0, 1]),"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to_sparse_bsc",
          "signature": "to_sparse_bsc(blocksize, dense_dim)",
          "documentation": {
            "description": "to_sparse_bsc(blocksize, dense_dim) -> Tensor\n\nConvert a tensor to a block sparse column (BSC) storage format of\ngiven blocksize.  If the :attr:`self` is strided, then the number of\ndense dimensions could be specified, and a hybrid BSC tensor will be\ncreated, with `dense_dim` dense dimensions and `self.dim() - 2 -\ndense_dim` batch dimension.",
            "parameters": {
              "blocksize": {
                "type": "list, tuple, :class:`torch.Size`, optional",
                "description": "Block size"
              },
              "of": {
                "type": "",
                "description": "the resulting BSC tensor. A block size must be a tuple of"
              },
              "length": {
                "type": "",
                "description": "two such that its items evenly divide the two sparse"
              },
              "dimensions": {
                "type": "",
                "description": "."
              },
              "dense_dim": {
                "type": "int, optional",
                "description": "Number of dense dimensions of the"
              },
              "resulting": {
                "type": "",
                "description": "BSC tensor.  This argument should be used only if\n:attr:`self` is a strided tensor, and must be a value between 0"
              },
              "and": {
                "type": "",
                "description": "dimension of :attr:`self` tensor minus two."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> dense = torch.randn(10, 10)\n>>> sparse = dense.to_sparse_csr()\n>>> sparse_bsc = sparse.to_sparse_bsc((5, 5))\n>>> sparse_bsc.row_indices()"
              },
              "tensor": {
                "type": "ccol_indices=tensor([0, 1, 2, 3]",
                "description": ","
              },
              "row_indices": {
                "type": "",
                "description": "=tensor([0, 1, 0]),"
              },
              "values": {
                "type": "",
                "description": "=tensor([[[[1.]],\n[[1.]]],\n[[[1.]],\n[[1.]]],\n[[[1.]],\n[[1.]]]]), size=(4, 3, 1), nnz=3,"
              },
              "layout": {
                "type": "",
                "description": "=torch.sparse_bsc)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to_sparse_bsr",
          "signature": "to_sparse_bsr(blocksize, dense_dim)",
          "documentation": {
            "description": "to_sparse_bsr(blocksize, dense_dim) -> Tensor\n\nConvert a tensor to a block sparse row (BSR) storage format of given\nblocksize.  If the :attr:`self` is strided, then the number of dense\ndimensions could be specified, and a hybrid BSR tensor will be\ncreated, with `dense_dim` dense dimensions and `self.dim() - 2 -\ndense_dim` batch dimension.",
            "parameters": {
              "blocksize": {
                "type": "list, tuple, :class:`torch.Size`, optional",
                "description": "Block size"
              },
              "of": {
                "type": "",
                "description": "the resulting BSR tensor. A block size must be a tuple of"
              },
              "length": {
                "type": "",
                "description": "two such that its items evenly divide the two sparse"
              },
              "dimensions": {
                "type": "",
                "description": "."
              },
              "dense_dim": {
                "type": "int, optional",
                "description": "Number of dense dimensions of the"
              },
              "resulting": {
                "type": "",
                "description": "BSR tensor.  This argument should be used only if\n:attr:`self` is a strided tensor, and must be a value between 0"
              },
              "and": {
                "type": "",
                "description": "dimension of :attr:`self` tensor minus two."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> dense = torch.randn(10, 10)\n>>> sparse = dense.to_sparse_csr()\n>>> sparse_bsr = sparse.to_sparse_bsr((5, 5))\n>>> sparse_bsr.col_indices()"
              },
              "tensor": {
                "type": "crow_indices=tensor([0, 2, 3]",
                "description": ","
              },
              "col_indices": {
                "type": "",
                "description": "=tensor([0, 2, 1]),"
              },
              "values": {
                "type": "",
                "description": "=tensor([[[[1.]],\n[[1.]]],\n[[[1.]],\n[[1.]]],\n[[[1.]],\n[[1.]]]]), size=(4, 3, 1), nnz=3,"
              },
              "layout": {
                "type": "",
                "description": "=torch.sparse_bsr)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to_sparse_coo",
          "signature": "to_sparse_coo(self)",
          "documentation": {
            "description": "Convert a tensor to :ref:`coordinate format <sparse-coo-docs>`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to_sparse_csc",
          "signature": "to_sparse_csc()",
          "documentation": {
            "description": "to_sparse_csc() -> Tensor\n\nConvert a tensor to compressed column storage (CSC) format.  Except\nfor strided tensors, only works with 2D tensors.  If the :attr:`self`\nis strided, then the number of dense dimensions could be specified,\nand a hybrid CSC tensor will be created, with `dense_dim` dense\ndimensions and `self.dim() - 2 - dense_dim` batch dimension.",
            "parameters": {
              "dense_dim": {
                "type": "int, optional",
                "description": "Number of dense dimensions of the"
              },
              "resulting": {
                "type": "",
                "description": "CSC tensor.  This argument should be used only if\n:attr:`self` is a strided tensor, and must be a value between 0"
              },
              "and": {
                "type": "",
                "description": "dimension of :attr:`self` tensor minus two."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> dense = torch.randn(5, 5)\n>>> sparse = dense.to_sparse_csc()\n>>> sparse._nnz()"
              },
              "25": {
                "type": "",
                "description": ">>> dense = torch.zeros(3, 3, 1, 1)\n>>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1\n>>> dense.to_sparse_csc(dense_dim=2)"
              },
              "tensor": {
                "type": "ccol_indices=tensor([0, 1, 2, 3]",
                "description": ","
              },
              "row_indices": {
                "type": "",
                "description": "=tensor([0, 2, 1]),"
              },
              "values": {
                "type": "",
                "description": "=tensor([[[1.]],\n[[1.]],\n[[1.]]]), size=(3, 3, 1, 1), nnz=3,"
              },
              "layout": {
                "type": "",
                "description": "=torch.sparse_csc)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to_sparse_csr",
          "signature": "to_sparse_csr(dense_dim=None)",
          "documentation": {
            "description": "to_sparse_csr(dense_dim=None) -> Tensor\n\nConvert a tensor to compressed row storage format (CSR).  Except for\nstrided tensors, only works with 2D tensors.  If the :attr:`self` is\nstrided, then the number of dense dimensions could be specified, and a\nhybrid CSR tensor will be created, with `dense_dim` dense dimensions\nand `self.dim() - 2 - dense_dim` batch dimension.",
            "parameters": {
              "dense_dim": {
                "type": "int, optional",
                "description": "Number of dense dimensions of the"
              },
              "resulting": {
                "type": "",
                "description": "CSR tensor.  This argument should be used only if\n:attr:`self` is a strided tensor, and must be a value between 0"
              },
              "and": {
                "type": "",
                "description": "dimension of :attr:`self` tensor minus two."
              },
              "Example": {
                "type": "",
                "description": ":\n>>> dense = torch.randn(5, 5)\n>>> sparse = dense.to_sparse_csr()\n>>> sparse._nnz()"
              },
              "25": {
                "type": "",
                "description": ">>> dense = torch.zeros(3, 3, 1, 1)\n>>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1\n>>> dense.to_sparse_csr(dense_dim=2)"
              },
              "tensor": {
                "type": "crow_indices=tensor([0, 1, 2, 3]",
                "description": ","
              },
              "col_indices": {
                "type": "",
                "description": "=tensor([0, 2, 1]),"
              },
              "values": {
                "type": "",
                "description": "=tensor([[[1.]],\n[[1.]],\n[[1.]]]), size=(3, 3, 1, 1), nnz=3,"
              },
              "layout": {
                "type": "",
                "description": "=torch.sparse_csr)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist()",
          "documentation": {
            "description": "tolist() -> list or number\n\nReturns the tensor as a (nested) list. For scalars, a standard\nPython number is returned, just like with :meth:`~Tensor.item`.\nTensors are automatically moved to the CPU first if necessary.\n\nThis operation is not differentiable.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "topk",
          "signature": "topk(k, dim=None, largest=True, sorted=True)",
          "documentation": {
            "description": "topk(k, dim=None, largest=True, sorted=True) -> (Tensor, LongTensor)\n\nSee :func:`torch.topk`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace()",
          "documentation": {
            "description": "trace() -> Tensor\n\nSee :func:`torch.trace`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(dim0, dim1)",
          "documentation": {
            "description": "transpose(dim0, dim1) -> Tensor\n\nSee :func:`torch.transpose`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose_",
          "signature": "transpose_(dim0, dim1)",
          "documentation": {
            "description": "transpose_(dim0, dim1) -> Tensor\n\nIn-place version of :meth:`~Tensor.transpose`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "triangular_solve",
          "signature": "triangular_solve(A, upper=True, transpose=False, unitriangular=False)",
          "documentation": {
            "description": "triangular_solve(A, upper=True, transpose=False, unitriangular=False) -> (Tensor, Tensor)\n\nSee :func:`torch.triangular_solve`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tril",
          "signature": "tril(diagonal=0)",
          "documentation": {
            "description": "tril(diagonal=0) -> Tensor\n\nSee :func:`torch.tril`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tril_",
          "signature": "tril_(diagonal=0)",
          "documentation": {
            "description": "tril_(diagonal=0) -> Tensor\n\nIn-place version of :meth:`~Tensor.tril`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "triu",
          "signature": "triu(diagonal=0)",
          "documentation": {
            "description": "triu(diagonal=0) -> Tensor\n\nSee :func:`torch.triu`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "triu_",
          "signature": "triu_(diagonal=0)",
          "documentation": {
            "description": "triu_(diagonal=0) -> Tensor\n\nIn-place version of :meth:`~Tensor.triu`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "true_divide",
          "signature": "true_divide(value)",
          "documentation": {
            "description": "true_divide(value) -> Tensor\n\nSee :func:`torch.true_divide`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "true_divide_",
          "signature": "true_divide_(value)",
          "documentation": {
            "description": "true_divide_(value) -> Tensor\n\nIn-place version of :meth:`~Tensor.true_divide_`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trunc",
          "signature": "trunc()",
          "documentation": {
            "description": "trunc() -> Tensor\n\nSee :func:`torch.trunc`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trunc_",
          "signature": "trunc_()",
          "documentation": {
            "description": "trunc_() -> Tensor\n\nIn-place version of :meth:`~Tensor.trunc`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "type",
          "signature": "type(dtype=None, non_blocking=False, **kwargs)",
          "documentation": {
            "description": "type(dtype=None, non_blocking=False, **kwargs) -> str or Tensor\nReturns the type if `dtype` is not provided, else casts this object to\nthe specified type.\n\nIf this is already of the correct type, no copy is performed and the\noriginal object is returned.",
            "parameters": {
              "dtype": {
                "type": "dtype or string",
                "description": "The desired type"
              },
              "non_blocking": {
                "type": "bool",
                "description": "If ``True``, and the source is in pinned memory"
              },
              "and": {
                "type": "",
                "description": "destination is on the GPU or vice versa, the copy is performed"
              },
              "asynchronously": {
                "type": "",
                "description": "with respect to the host. Otherwise, the argument"
              },
              "has": {
                "type": "",
                "description": "no effect.\n**kwargs: For compatibility, may contain the key ``async`` in place of"
              },
              "the": {
                "type": "",
                "description": "``non_blocking`` argument. The ``async`` arg is deprecated."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "type_as",
          "signature": "type_as(tensor)",
          "documentation": {
            "description": "type_as(tensor) -> Tensor\n\nReturns this tensor cast to the type of the given tensor.\n\nThis is a no-op if the tensor is already of the correct type. This is\nequivalent to ``self.type(tensor.type())``",
            "parameters": {
              "tensor": {
                "type": "Tensor",
                "description": "the tensor which has the desired type"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unbind",
          "signature": "unbind(dim=0)",
          "documentation": {
            "description": "unbind(dim=0) -> seq\n\nSee :func:`torch.unbind`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unflatten",
          "signature": "unflatten(self, dim, sizes)",
          "documentation": {
            "description": "unflatten(dim, sizes) -> Tensor\n\nSee :func:`torch.unflatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unfold",
          "signature": "unfold(dimension, size, step)",
          "documentation": {
            "description": "unfold(dimension, size, step) -> Tensor\n\nReturns a view of the original tensor which contains all slices of size :attr:`size` from\n:attr:`self` tensor in the dimension :attr:`dimension`.\n\nStep between two slices is given by :attr:`step`.\n\nIf `sizedim` is the size of dimension :attr:`dimension` for :attr:`self`, the size of\ndimension :attr:`dimension` in the returned tensor will be\n`(sizedim - size) / step + 1`.\n\nAn additional dimension of size :attr:`size` is appended in the returned tensor.",
            "parameters": {
              "dimension": {
                "type": "int",
                "description": "dimension in which unfolding happens"
              },
              "size": {
                "type": "int",
                "description": "the size of each slice that is unfolded"
              },
              "step": {
                "type": "int",
                "description": "the step between each slice"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> x = torch.arange(1., 8)\n>>> x"
              },
              "tensor": {
                "type": "",
                "description": "([[ 1.,  2.],\n[ 3.,  4.],\n[ 5.,  6.]])"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "uniform_",
          "signature": "uniform_(from=0, to=1, *, generator=None)",
          "documentation": {
            "description": "uniform_(from=0, to=1, *, generator=None) -> Tensor\n\nFills :attr:`self` tensor with numbers sampled from the continuous uniform\ndistribution:\n\n.. math::\n    f(x) = \\dfrac{1}{\\text{to} - \\text{from}}",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unique",
          "signature": "unique(self, sorted=True, return_inverse=False, return_counts=False, dim=None)",
          "documentation": {
            "description": "Returns the unique elements of the input tensor.\n\nSee :func:`torch.unique`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unique_consecutive",
          "signature": "unique_consecutive(self, return_inverse=False, return_counts=False, dim=None)",
          "documentation": {
            "description": "Eliminates all but the first element from every consecutive group of equivalent elements.\n\nSee :func:`torch.unique_consecutive`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unsafe_chunk",
          "signature": "unsafe_chunk(chunks, dim=0)",
          "documentation": {
            "description": "unsafe_chunk(chunks, dim=0) -> List of Tensors\n\nSee :func:`torch.unsafe_chunk`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unsafe_split",
          "signature": "unsafe_split(split_size, dim=0)",
          "documentation": {
            "description": "unsafe_split(split_size, dim=0) -> List of Tensors\n\nSee :func:`torch.unsafe_split`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unsafe_split_with_sizes",
          "signature": "unsafe_split_with_sizes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unsqueeze",
          "signature": "unsqueeze(dim)",
          "documentation": {
            "description": "unsqueeze(dim) -> Tensor\n\nSee :func:`torch.unsqueeze`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unsqueeze_",
          "signature": "unsqueeze_(dim)",
          "documentation": {
            "description": "unsqueeze_(dim) -> Tensor\n\nIn-place version of :meth:`~Tensor.unsqueeze`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "untyped_storage",
          "signature": "untyped_storage()",
          "documentation": {
            "description": "untyped_storage() -> torch.UntypedStorage\n\nReturns the underlying :class:`UntypedStorage`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "values",
          "signature": "values()",
          "documentation": {
            "description": "values() -> Tensor\n\nReturn the values tensor of a :ref:`sparse COO tensor <sparse-coo-docs>`.\n\n.. warning::\n  Throws an error if :attr:`self` is not a sparse COO tensor.\n\nSee also :meth:`Tensor.indices`.\n\n.. note::\n  This method can only be called on a coalesced sparse tensor. See\n  :meth:`Tensor.coalesce` for details.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(dim=None, *, correction=1, keepdim=False)",
          "documentation": {
            "description": "var(dim=None, *, correction=1, keepdim=False) -> Tensor\n\nSee :func:`torch.var`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "vdot",
          "signature": "vdot(other)",
          "documentation": {
            "description": "vdot(other) -> Tensor\n\nSee :func:`torch.vdot`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(*shape)",
          "documentation": {
            "description": "view(*shape) -> Tensor\n\nReturns a new tensor with the same data as the :attr:`self` tensor but of a\ndifferent :attr:`shape`.\n\nThe returned tensor shares the same data and must have the same number\nof elements, but may have a different size. For a tensor to be viewed, the new\nview size must be compatible with its original size and stride, i.e., each new\nview dimension must either be a subspace of an original dimension, or only span\nacross original dimensions :math:`d, d+1, \\dots, d+k` that satisfy the following\ncontiguity-like condition that :math:`\\forall i = d, \\dots, d+k-1`,\n\n.. math::\n\n  \\text{stride}[i] = \\text{stride}[i+1] \\times \\text{size}[i+1]\n\nOtherwise, it will not be possible to view :attr:`self` tensor as :attr:`shape`\nwithout copying it (e.g., via :meth:`contiguous`). When it is unclear whether a\n:meth:`view` can be performed, it is advisable to use :meth:`reshape`, which\nreturns a view if the shapes are compatible, and copies (equivalent to calling\n:meth:`contiguous`) otherwise.",
            "parameters": {
              "shape": {
                "type": "torch.Size or int...",
                "description": "the desired size"
              },
              "Example": {
                "type": "",
                "description": ":\n>>> x = torch.randn(4, 4)\n>>> x"
              },
              "torch": {
                "type": "",
                "description": ".Size([4, 16])"
              },
              "False": {
                "type": "",
                "description": ".. method:: view(dtype) -> Tensor\n:noindex:"
              },
              "Returns": {
                "type": "",
                "description": "a new tensor with the same data as the :attr:`self` tensor but of a"
              },
              "different": {
                "type": "",
                "description": "attr:`dtype`."
              },
              "If": {
                "type": "",
                "description": "any of the above conditions are not met, an error is thrown.\n.. warning::"
              },
              "then": {
                "type": "",
                "description": "the size of the last dimension of the output will be scaled"
              },
              "proportionally": {
                "type": "",
                "description": ".  For instance, if :attr:`dtype` element size is twice that of\n``self.dtype``, then each pair of elements in the last dimension of\n:attr:`self` will be combined, and the size of the last dimension of the output"
              },
              "will": {
                "type": "",
                "description": "be half that of :attr:`self`. If :attr:`dtype` element size is half that"
              },
              "of": {
                "type": "",
                "description": "``self.dtype``, then each element in the last dimension of :attr:`self` will"
              },
              "be": {
                "type": "",
                "description": "split in two, and the size of the last dimension of the output will be"
              },
              "double": {
                "type": "",
                "description": "that of :attr:`self`. For this to be possible, the following conditions"
              },
              "must": {
                "type": "",
                "description": "be true:\n* ``self.dim()`` must be greater than 0.\n* ``self.stride(-1)`` must be 1."
              },
              "Additionally": {
                "type": "",
                "description": ", if the element size of :attr:`dtype` is greater than that of\n``self.dtype``, the following conditions must be true as well:\n* ``self.size(-1)`` must be divisible by the ratio between the element"
              },
              "sizes": {
                "type": "",
                "description": "of the dtypes.\n* ``self.storage_offset()`` must be divisible by the ratio between the"
              },
              "element": {
                "type": "",
                "description": "sizes of the dtypes.\n* The strides of all dimensions, except the last dimension, must be"
              },
              "divisible": {
                "type": "",
                "description": "by the ratio between the element sizes of the dtypes."
              },
              "This": {
                "type": "",
                "description": "overload is not supported by TorchScript, and using it in a Torchscript"
              },
              "program": {
                "type": "",
                "description": "will cause undefined behavior."
              },
              "Args": {
                "type": "",
                "description": ""
              },
              "dtype": {
                "type": "",
                "description": "=torch.int32)\n>>> y[0, 0] = 1000000000\n>>> x"
              },
              "tensor": {
                "type": "",
                "description": "([[  0, 202, 154,  59, 182, 243, 253, 188, 185, 252, 191,  63, 240,  22,"
              },
              "8": {
                "type": "",
                "description": ", 191],\n[227, 165,  27, 190, 128,  72,  63,  63, 146, 203,  15,  63,  22, 106,"
              },
              "93": {
                "type": "",
                "description": ", 191],\n[205,  59,  30, 192, 112, 206,   8, 189,   7,  95, 152, 190,  12, 147,"
              },
              "89": {
                "type": "",
                "description": ", 191],\n[ 43, 246,  87, 190, 235, 226, 254,  63, 111, 240, 117, 191, 177, 191,"
              },
              "28": {
                "type": "",
                "description": ", 191]], dtype=torch.uint8)\n>>> x.view(torch.uint8).size()"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view_as",
          "signature": "view_as(other)",
          "documentation": {
            "description": "view_as(other) -> Tensor\n\nView this tensor as the same size as :attr:`other`.\n``self.view_as(other)`` is equivalent to ``self.view(other.size())``.\n\nPlease see :meth:`~Tensor.view` for more information about ``view``.",
            "parameters": {
              "other": {
                "type": ":class:`torch.Tensor`",
                "description": "The result tensor has the same size"
              },
              "as": {
                "type": "",
                "description": "attr:`other`."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "vsplit",
          "signature": "vsplit(split_size_or_sections)",
          "documentation": {
            "description": "vsplit(split_size_or_sections) -> List of Tensors\n\nSee :func:`torch.vsplit`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "where",
          "signature": "where(condition, y)",
          "documentation": {
            "description": "where(condition, y) -> Tensor\n\n``self.where(condition, y)`` is equivalent to ``torch.where(condition, self, y)``.\nSee :func:`torch.where`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "xlogy",
          "signature": "xlogy(other)",
          "documentation": {
            "description": "xlogy(other) -> Tensor\n\nSee :func:`torch.xlogy`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "xlogy_",
          "signature": "xlogy_(other)",
          "documentation": {
            "description": "xlogy_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.xlogy`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "xpu",
          "signature": "xpu(device=None, non_blocking=False, memory_format=torch.preserve_format)",
          "documentation": {
            "description": "xpu(device=None, non_blocking=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a copy of this object in XPU memory.\n\nIf this object is already in XPU memory and on the correct device,\nthen no copy is performed and the original object is returned.",
            "parameters": {
              "device": {
                "type": ":class:`torch.device`",
                "description": "The destination XPU device."
              },
              "Defaults": {
                "type": "",
                "description": "to the current XPU device."
              },
              "non_blocking": {
                "type": "bool",
                "description": "If ``True`` and the source is in pinned memory,"
              },
              "the": {
                "type": "",
                "description": "copy will be asynchronous with respect to the host."
              },
              "Otherwise": {
                "type": "",
                "description": ", the argument has no effect. Default: ``False``."
              },
              "memory_format": {
                "type": ":class:`torch.memory_format`, optional",
                "description": "the desired memory format of"
              },
              "returned": {
                "type": "",
                "description": "Tensor. Default: ``torch.preserve_format``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "zero_",
          "signature": "zero_()",
          "documentation": {
            "description": "zero_() -> Tensor\n\nFills :attr:`self` tensor with zeros.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    }
  ]
}