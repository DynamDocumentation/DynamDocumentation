{
  "description": "========================\nRandom Number Generation\n========================\n\nUse ``default_rng()`` to create a `Generator` and call its methods.\n\n=============== =========================================================\nGenerator\n--------------- ---------------------------------------------------------\nGenerator       Class implementing all of the random number distributions\ndefault_rng     Default constructor for ``Generator``\n=============== =========================================================\n\n============================================= ===\nBitGenerator Streams that work with Generator\n--------------------------------------------- ---\nMT19937\nPCG64\nPCG64DXSM\nPhilox\nSFC64\n============================================= ===\n\n============================================= ===\nGetting entropy to initialize a BitGenerator\n--------------------------------------------- ---\nSeedSequence\n============================================= ===\n\n\nLegacy\n------\n\nFor backwards compatibility with previous versions of numpy before 1.17, the\nvarious aliases to the global `RandomState` methods are left alone and do not\nuse the new `Generator` API.\n\n==================== =========================================================\nUtility functions\n-------------------- ---------------------------------------------------------\nrandom               Uniformly distributed floats over ``[0, 1)``\nbytes                Uniformly distributed random bytes.\npermutation          Randomly permute a sequence / generate a random sequence.\nshuffle              Randomly permute a sequence in place.\nchoice               Random sample from 1-D array.\n==================== =========================================================\n\n==================== =========================================================\nCompatibility\nfunctions - removed\nin the new API\n-------------------- ---------------------------------------------------------\nrand                 Uniformly distributed values.\nrandn                Normally distributed values.\nranf                 Uniformly distributed floating point numbers.\nrandom_integers      Uniformly distributed integers in a given range.\n                     (deprecated, use ``integers(..., closed=True)`` instead)\nrandom_sample        Alias for `random_sample`\nrandint              Uniformly distributed integers in a given range\nseed                 Seed the legacy random number generator.\n==================== =========================================================\n\n==================== =========================================================\nUnivariate\ndistributions\n-------------------- ---------------------------------------------------------\nbeta                 Beta distribution over ``[0, 1]``.\nbinomial             Binomial distribution.\nchisquare            :math:`\\chi^2` distribution.\nexponential          Exponential distribution.\nf                    F (Fisher-Snedecor) distribution.\ngamma                Gamma distribution.\ngeometric            Geometric distribution.\ngumbel               Gumbel distribution.\nhypergeometric       Hypergeometric distribution.\nlaplace              Laplace distribution.\nlogistic             Logistic distribution.\nlognormal            Log-normal distribution.\nlogseries            Logarithmic series distribution.\nnegative_binomial    Negative binomial distribution.\nnoncentral_chisquare Non-central chi-square distribution.\nnoncentral_f         Non-central F distribution.\nnormal               Normal / Gaussian distribution.\npareto               Pareto distribution.\npoisson              Poisson distribution.\npower                Power distribution.\nrayleigh             Rayleigh distribution.\ntriangular           Triangular distribution.\nuniform              Uniform distribution.\nvonmises             Von Mises circular distribution.\nwald                 Wald (inverse Gaussian) distribution.\nweibull              Weibull distribution.\nzipf                 Zipf's distribution over ranked data.\n==================== =========================================================\n\n==================== ==========================================================\nMultivariate\ndistributions\n-------------------- ----------------------------------------------------------\ndirichlet            Multivariate generalization of Beta distribution.\nmultinomial          Multivariate generalization of the binomial distribution.\nmultivariate_normal  Multivariate generalization of the normal distribution.\n==================== ==========================================================\n\n==================== =========================================================\nStandard\ndistributions\n-------------------- ---------------------------------------------------------\nstandard_cauchy      Standard Cauchy-Lorentz distribution.\nstandard_exponential Standard exponential distribution.\nstandard_gamma       Standard Gamma distribution.\nstandard_normal      Standard normal distribution.\nstandard_t           Standard Student's t-distribution.\n==================== =========================================================\n\n==================== =========================================================\nInternal functions\n-------------------- ---------------------------------------------------------\nget_state            Get tuple representing internal state of generator.\nset_state            Set state of generator.\n==================== =========================================================",
  "functions": [
    {
      "name": "beta",
      "signature": "beta(...)",
      "documentation": {
        "description": "beta(a, b, size=None)\n\n        Draw samples from a Beta distribution.\n\n        The Beta distribution is a special case of the Dirichlet distribution,\n        and is related to the Gamma distribution.  It has the probability\n        distribution function\n\n        .. math:: f(x; a,b) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1}\n                                                         (1 - x)^{\\beta - 1},\n\n        where the normalization, B, is the beta function,\n\n        .. math:: B(\\alpha, \\beta) = \\int_0^1 t^{\\alpha - 1}\n                                     (1 - t)^{\\beta - 1} dt.\n\n        It is often seen in Bayesian inference and order statistics.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.beta`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "b": {
            "type": "float or array_like of floats",
            "description": "Beta, positive (>0)."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` and ``b`` are both scalars.\n            Otherwise, ``np.broadcast(a, b).size`` samples are drawn."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "binomial",
      "signature": "binomial(...)",
      "documentation": {
        "description": "binomial(n, p, size=None)\n\n        Draw samples from a binomial distribution.\n\n        Samples are drawn from a binomial distribution with specified\n        parameters, n trials and p probability of success where\n        n an integer >= 0 and p is in the interval [0,1]. (n may be\n        input as a float, but it is truncated to an integer in use)\n\n        .. note::\n            New code should use the `~numpy.random.Generator.binomial`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "p": {
            "type": "float or array_like of floats",
            "description": "Parameter of the distribution, >= 0 and <=1."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``n`` and ``p`` are both scalars.\n            Otherwise, ``np.broadcast(n, p).size`` samples are drawn."
          },
          "where": {
            "type": "math:`n` is the number of trials",
            "description": ", :math:`p` is the probability\n        of success, and :math:`N` is the number of successes.\n\n        When estimating the standard error of a proportion in a population by\n        using a random sample, the normal distribution works well unless the\n        product p*n <=5, where p = population proportion estimate, and n =\n        number of samples, in which case the binomial distribution is used\n        instead. For example, a sample of 15 people shows 4 who are left\n        handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,\n        so the binomial distribution should be used in this case.\n\n        References\n        ----------\n        .. [1] Dalgaard, Peter, \"Introductory Statistics with R\",\n               Springer-Verlag, 2002.\n        .. [2] Glantz, Stanton A. \"Primer of Biostatistics.\", McGraw-Hill,\n               Fifth Edition, 2002.\n        .. [3] Lentner, Marvin, \"Elementary Applied Statistics\", Bogden\n               and Quigley, 1972.\n        .. [4] Weisstein, Eric W. \"Binomial Distribution.\" From MathWorld--A\n               Wolfram Web Resource."
          },
          "http": {
            "type": "//mathworld.wolfram.com/BinomialDistribution.html",
            "description": ".. [5] Wikipedia, \"Binomial distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Binomial_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "bytes",
      "signature": "bytes(...)",
      "documentation": {
        "description": "bytes(length)\n\n        Return random bytes.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.bytes`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "chisquare",
      "signature": "chisquare(...)",
      "documentation": {
        "description": "chisquare(df, size=None)\n\n        Draw samples from a chi-square distribution.\n\n        When `df` independent random variables, each with standard normal\n        distributions (mean 0, variance 1), are squared and summed, the\n        resulting distribution is chi-square (see Notes).  This distribution\n        is often used in hypothesis testing.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.chisquare`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``df`` is a scalar.  Otherwise,\n            ``np.array(df).size`` samples are drawn."
          },
          "where": {
            "type": "math:`\\Gamma` is the gamma function",
            "description": ",\n\n        .. math:: \\Gamma(x) = \\int_0^{-\\infty} t^{x - 1} e^{-t} dt.\n\n        References\n        ----------\n        .. [1] NIST \"Engineering Statistics Handbook\""
          },
          "https": {
            "type": "//www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "choice",
      "signature": "choice(...)",
      "documentation": {
        "description": "choice(a, size=None, replace=True, p=None)\n\n        Generates a random sample from a given 1-D array\n\n        .. versionadded:: 1.7.0\n\n        .. note::\n            New code should use the `~numpy.random.Generator.choice`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned."
          },
          "replace": {
            "type": "boolean",
            "description": "Whether the sample is with or without replacement. Default is True,\n            meaning that a value of ``a`` can be selected multiple times."
          },
          "p": {
            "type": "1-D array-like",
            "description": "The probabilities associated with each entry in a.\n            If not given, the sample assumes a uniform distribution over all\n            entries in ``a``."
          },
          "replacement": {
            "type": ">>> np.random.choice(5",
            "description": ", 3, replace=False)\n        array([3,1,0]) # random\n        >>> #This is equivalent to np.random.permutation(np.arange(5))[:3]\n\n        Generate a non-uniform random sample from np.arange(5) of size\n        3 without replacement:\n\n        >>> np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])\n        array([2, 3, 0]) # random\n\n        Any of the above can be repeated with an arbitrary array-like\n        instead of just integers. For instance:\n\n        >>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']\n        >>> np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])\n        array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random\n              dtype='<U11')"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "default_rng",
      "signature": "default_rng(seed=None)",
      "documentation": {
        "description": "default_rng(seed=None)\nConstruct a new Generator with the default BitGenerator (PCG64).",
        "parameters": {
          "See": {
            "type": "ref:`seeding_and_entropy` for more information about seeding.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "dirichlet",
      "signature": "dirichlet(...)",
      "documentation": {
        "description": "dirichlet(alpha, size=None)\n\n        Draw samples from the Dirichlet distribution.\n\n        Draw `size` samples of dimension k from a Dirichlet distribution. A\n        Dirichlet-distributed random variable can be seen as a multivariate\n        generalization of a Beta distribution. The Dirichlet distribution\n        is a conjugate prior of a multinomial distribution in Bayesian\n        inference.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.dirichlet`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            vector of length ``k`` is returned."
          },
          "where": {
            "type": "math:`\\alpha` is a vector containing the positive",
            "description": "concentration parameters.\n\n        The method uses the following property for computation: let :math:`Y`\n        be a random vector which has components that follow a standard gamma\n        distribution, then :math:`X = \\frac{1}{\\sum_{i=1}^k{Y_i}} Y`\n        is Dirichlet-distributed\n\n        References\n        ----------\n        .. [1] David McKay, \"Information Theory, Inference and Learning\n               Algorithms,\" chapter 23,"
          },
          "http": {
            "type": "//www.inference.org.uk/mackay/itila/",
            "description": ".. [2] Wikipedia, \"Dirichlet distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Dirichlet_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "exponential",
      "signature": "exponential(...)",
      "documentation": {
        "description": "exponential(scale=1.0, size=None)\n\n        Draw samples from an exponential distribution.\n\n        Its probability density function is\n\n        .. math:: f(x; \\frac{1}{\\beta}) = \\frac{1}{\\beta} \\exp(-\\frac{x}{\\beta}),\n\n        for ``x > 0`` and 0 elsewhere. :math:`\\beta` is the scale parameter,\n        which is the inverse of the rate parameter :math:`\\lambda = 1/\\beta`.\n        The rate parameter is an alternative, widely used parameterization\n        of the exponential distribution [3]_.\n\n        The exponential distribution is a continuous analogue of the\n        geometric distribution.  It describes many common situations, such as\n        the size of raindrops measured over many rainstorms [1]_, or the time\n        between page requests to Wikipedia [2]_.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.exponential`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``scale`` is a scalar.  Otherwise,\n            ``np.array(scale).size`` samples are drawn."
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Exponential_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "f",
      "signature": "f(...)",
      "documentation": {
        "description": "f(dfnum, dfden, size=None)\n\n        Draw samples from an F distribution.\n\n        Samples are drawn from an F distribution with specified parameters,\n        `dfnum` (degrees of freedom in numerator) and `dfden` (degrees of\n        freedom in denominator), where both parameters must be greater than\n        zero.\n\n        The random variate of the F distribution (also known as the\n        Fisher distribution) is a continuous probability distribution\n        that arises in ANOVA tests, and is the ratio of two chi-square\n        variates.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.f`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "dfden": {
            "type": "float or array_like of float",
            "description": "Degrees of freedom in denominator, must be > 0."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``dfnum`` and ``dfden`` are both scalars.\n            Otherwise, ``np.broadcast(dfnum, dfden).size`` samples are drawn."
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/F-distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "gamma",
      "signature": "gamma(...)",
      "documentation": {
        "description": "gamma(shape, scale=1.0, size=None)\n\n        Draw samples from a Gamma distribution.\n\n        Samples are drawn from a Gamma distribution with specified parameters,\n        `shape` (sometimes designated \"k\") and `scale` (sometimes designated\n        \"theta\"), where both parameters are > 0.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.gamma`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "scale": {
            "type": "float or array_like of floats",
            "description": "The scale of the gamma distribution. Must be non-negative.\n            Default is equal to 1."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``shape`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(shape, scale).size`` samples are drawn."
          },
          "where": {
            "type": "math:`k` is the shape and :math:`\\theta` the scale",
            "description": ","
          },
          "and": {
            "type": "math:`\\Gamma` is the Gamma function.",
            "description": "The Gamma distribution is often used to model the times to failure of\n        electronic components, and arises naturally in processes for which the\n        waiting times between Poisson distributed events are relevant.\n\n        References\n        ----------\n        .. [1] Weisstein, Eric W. \"Gamma Distribution.\" From MathWorld--A\n               Wolfram Web Resource."
          },
          "http": {
            "type": "//mathworld.wolfram.com/GammaDistribution.html",
            "description": ".. [2] Wikipedia, \"Gamma distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Gamma_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "geometric",
      "signature": "geometric(...)",
      "documentation": {
        "description": "geometric(p, size=None)\n\n        Draw samples from the geometric distribution.\n\n        Bernoulli trials are experiments with one of two outcomes:\n        success or failure (an example of such an experiment is flipping\n        a coin).  The geometric distribution models the number of trials\n        that must be run in order to achieve success.  It is therefore\n        supported on the positive integers, ``k = 1, 2, ...``.\n\n        The probability mass function of the geometric distribution is\n\n        .. math:: f(k) = (1 - p)^{k - 1} p\n\n        where `p` is the probability of success of an individual trial.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.geometric`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``p`` is a scalar.  Otherwise,\n            ``np.array(p).size`` samples are drawn."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "get_bit_generator",
      "signature": "get_bit_generator(...)",
      "documentation": {
        "description": "Returns the singleton RandomState's bit generator",
        "parameters": {},
        "returns": "set_bit_generator\n    numpy.random.Generator",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "get_state",
      "signature": "get_state(...)",
      "documentation": {
        "description": "get_state(legacy=True)\n\n        Return a tuple representing the internal state of the generator.\n\n        For more details, see `set_state`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "gumbel",
      "signature": "gumbel(...)",
      "documentation": {
        "description": "gumbel(loc=0.0, scale=1.0, size=None)\n\n        Draw samples from a Gumbel distribution.\n\n        Draw samples from a Gumbel distribution with specified location and\n        scale.  For more information on the Gumbel distribution, see\n        Notes and References below.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.gumbel`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "scale": {
            "type": "float or array_like of floats",
            "description": "The scale parameter of the distribution. Default is 1. Must be non-\n            negative."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``loc`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn."
          },
          "where": {
            "type": "math:`\\mu` is the mode",
            "description": ", a location parameter, and\n        :math:`\\beta` is the scale parameter.\n\n        The Gumbel (named for German mathematician Emil Julius Gumbel) was used\n        very early in the hydrology literature, for modeling the occurrence of\n        flood events. It is also used for modeling maximum wind speed and\n        rainfall rates.  It is a \"fat-tailed\" distribution - the probability of\n        an event in the tail of the distribution is larger than if one used a\n        Gaussian, hence the surprisingly frequent occurrence of 100-year\n        floods. Floods were initially modeled as a Gaussian process, which\n        underestimated the frequency of extreme events.\n\n        It is one of a class of extreme value distributions, the Generalized\n        Extreme Value (GEV) distributions, which also includes the Weibull and\n        Frechet.\n\n        The function has a mean of :math:`\\mu + 0.57721\\beta` and a variance"
          },
          "of": {
            "type": "math:`\\frac{\\pi^2}{6}\\beta^2`.",
            "description": "References\n        ----------\n        .. [1] Gumbel, E. J., \"Statistics of Extremes,\"\n               New York: Columbia University Press, 1958.\n        .. [2] Reiss, R.-D. and Thomas, M., \"Statistical Analysis of Extreme\n               Values from Insurance, Finance, Hydrology and Other Fields,\""
          },
          "Basel": {
            "type": "Birkhauser Verlag",
            "description": ", 2001."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "hypergeometric",
      "signature": "hypergeometric(...)",
      "documentation": {
        "description": "hypergeometric(ngood, nbad, nsample, size=None)\n\n        Draw samples from a Hypergeometric distribution.\n\n        Samples are drawn from a hypergeometric distribution with specified\n        parameters, `ngood` (ways to make a good selection), `nbad` (ways to make\n        a bad selection), and `nsample` (number of items sampled, which is less\n        than or equal to the sum ``ngood + nbad``).\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.hypergeometric`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "nbad": {
            "type": "int or array_like of ints",
            "description": "Number of ways to make a bad selection.  Must be nonnegative."
          },
          "nsample": {
            "type": "int or array_like of ints",
            "description": "Number of items sampled.  Must be at least 1 and at most\n            ``ngood + nbad``."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if `ngood`, `nbad`, and `nsample`\n            are all scalars.  Otherwise, ``np.broadcast(ngood, nbad, nsample).size``\n            samples are drawn."
          },
          "where": {
            "type": "math:`0 \\le x \\le n` and :math:`n-b \\le x \\le g`",
            "description": "for P(x) the probability of ``x`` good results in the drawn sample,\n        g = `ngood`, b = `nbad`, and n = `nsample`.\n\n        Consider an urn with black and white marbles in it, `ngood` of them\n        are black and `nbad` are white. If you draw `nsample` balls without\n        replacement, then the hypergeometric distribution describes the\n        distribution of black balls in the drawn sample.\n\n        Note that this distribution is very similar to the binomial\n        distribution, except that in this case, samples are drawn without\n        replacement, whereas in the Binomial case samples are drawn with\n        replacement (or the sample space is infinite). As the sample space\n        becomes large, this distribution approaches the binomial.\n\n        References\n        ----------\n        .. [1] Lentner, Marvin, \"Elementary Applied Statistics\", Bogden\n               and Quigley, 1972.\n        .. [2] Weisstein, Eric W. \"Hypergeometric Distribution.\" From\n               MathWorld--A Wolfram Web Resource."
          },
          "http": {
            "type": "//mathworld.wolfram.com/HypergeometricDistribution.html",
            "description": ".. [3] Wikipedia, \"Hypergeometric distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Hypergeometric_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "laplace",
      "signature": "laplace(...)",
      "documentation": {
        "description": "laplace(loc=0.0, scale=1.0, size=None)\n\n        Draw samples from the Laplace or double exponential distribution with\n        specified location (or mean) and scale (decay).\n\n        The Laplace distribution is similar to the Gaussian/normal distribution,\n        but is sharper at the peak and has fatter tails. It represents the\n        difference between two independent, identically distributed exponential\n        random variables.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.laplace`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "scale": {
            "type": "float or array_like of floats",
            "description": ":math:`\\lambda`, the exponential decay. Default is 1. Must be non-\n            negative."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``loc`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn."
          },
          "http": {
            "type": "//mathworld.wolfram.com/LaplaceDistribution.html",
            "description": ".. [4] Wikipedia, \"Laplace distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Laplace_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "logistic",
      "signature": "logistic(...)",
      "documentation": {
        "description": "logistic(loc=0.0, scale=1.0, size=None)\n\n        Draw samples from a logistic distribution.\n\n        Samples are drawn from a logistic distribution with specified\n        parameters, loc (location or mean, also median), and scale (>0).\n\n        .. note::\n            New code should use the `~numpy.random.Generator.logistic`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "scale": {
            "type": "float or array_like of floats",
            "description": "Parameter of the distribution. Must be non-negative.\n            Default is 1."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``loc`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn."
          },
          "where": {
            "type": "math:`\\mu` = location and :math:`s` = scale.",
            "description": "The Logistic distribution is used in Extreme Value problems where it\n        can act as a mixture of Gumbel distributions, in Epidemiology, and by\n        the World Chess Federation (FIDE) where it is used in the Elo ranking\n        system, assuming the performance of each player is a logistically\n        distributed random variable.\n\n        References\n        ----------\n        .. [1] Reiss, R.-D. and Thomas M. (2001), \"Statistical Analysis of\n               Extreme Values, from Insurance, Finance, Hydrology and Other\n               Fields,\" Birkhauser Verlag, Basel, pp 132-133.\n        .. [2] Weisstein, Eric W. \"Logistic Distribution.\" From\n               MathWorld--A Wolfram Web Resource."
          },
          "http": {
            "type": "//mathworld.wolfram.com/LogisticDistribution.html",
            "description": ".. [3] Wikipedia, \"Logistic-distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Logistic_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "lognormal",
      "signature": "lognormal(...)",
      "documentation": {
        "description": "lognormal(mean=0.0, sigma=1.0, size=None)\n\n        Draw samples from a log-normal distribution.\n\n        Draw samples from a log-normal distribution with specified mean,\n        standard deviation, and array shape.  Note that the mean and standard\n        deviation are not the values for the distribution itself, but of the\n        underlying normal distribution it is derived from.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.lognormal`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "sigma": {
            "type": "float or array_like of floats",
            "description": "Standard deviation of the underlying normal distribution. Must be\n            non-negative. Default is 1."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``mean`` and ``sigma`` are both scalars.\n            Otherwise, ``np.broadcast(mean, sigma).size`` samples are drawn."
          },
          "where": {
            "type": "math:`\\mu` is the mean and :math:`\\sigma` is the standard",
            "description": "deviation of the normally distributed logarithm of the variable.\n        A log-normal distribution results if a random variable is the *product*\n        of a large number of independent, identically-distributed variables in\n        the same way that a normal distribution results if the variable is the\n        *sum* of a large number of independent, identically-distributed\n        variables.\n\n        References\n        ----------\n        .. [1] Limpert, E., Stahel, W. A., and Abbt, M., \"Log-normal\n               Distributions across the Sciences: Keys and Clues,\"\n               BioScience, Vol. 51, No. 5, May, 2001."
          },
          "https": {
            "type": "//stat.ethz.ch/~stahel/lognormal/bioscience.pdf",
            "description": ".. [2] Reiss, R.D. and Thomas, M., \"Statistical Analysis of Extreme\n               Values,\" Basel: Birkhauser Verlag, 2001, pp. 31-32."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "logseries",
      "signature": "logseries(...)",
      "documentation": {
        "description": "logseries(p, size=None)\n\n        Draw samples from a logarithmic series distribution.\n\n        Samples are drawn from a log series distribution with specified\n        shape parameter, 0 <= ``p`` < 1.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.logseries`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``p`` is a scalar.  Otherwise,\n            ``np.array(p).size`` samples are drawn."
          },
          "occurrences": {
            "type": "BIODIVERSITY RESEARCH Diversity & Distributions",
            "description": ",\n               Volume 5, Number 5, September 1999 , pp. 187-195(9).\n        .. [2] Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The\n               relation between the number of species and the number of\n               individuals in a random sample of an animal population.\n               Journal of Animal Ecology, 12:42-58.\n        .. [3] D. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small\n               Data Sets, CRC Press, 1994.\n        .. [4] Wikipedia, \"Logarithmic distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Logarithmic_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "multinomial",
      "signature": "multinomial(...)",
      "documentation": {
        "description": "multinomial(n, pvals, size=None)\n\n        Draw samples from a multinomial distribution.\n\n        The multinomial distribution is a multivariate generalization of the\n        binomial distribution.  Take an experiment with one of ``p``\n        possible outcomes.  An example of such an experiment is throwing a dice,\n        where the outcome can be 1 through 6.  Each sample drawn from the\n        distribution represents `n` such experiments.  Its values,\n        ``X_i = [X_0, X_1, ..., X_p]``, represent the number of times the\n        outcome was ``i``.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.multinomial`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "pvals": {
            "type": "sequence of floats",
            "description": ", length p\n            Probabilities of each of the ``p`` different outcomes.  These\n            must sum to 1 (however, the last element is always assumed to\n            account for the remaining probability, as long as\n            ``sum(pvals[:-1]) <= 1)``."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned."
          },
          "ValueError": {
            "type": "pvals < 0",
            "description": ", pvals > 1 or pvals contains NaNs"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "multivariate_normal",
      "signature": "multivariate_normal(...)",
      "documentation": {
        "description": "multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)\n\n        Draw random samples from a multivariate normal distribution.\n\n        The multivariate normal, multinormal or Gaussian distribution is a\n        generalization of the one-dimensional normal distribution to higher\n        dimensions.  Such a distribution is specified by its mean and\n        covariance matrix.  These parameters are analogous to the mean\n        (average or \"center\") and variance (standard deviation, or \"width,\"\n        squared) of the one-dimensional normal distribution.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.multivariate_normal`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "cov": {
            "type": "2-D array_like",
            "description": ", of shape (N, N)\n            Covariance matrix of the distribution. It must be symmetric and\n            positive-semidefinite for proper sampling."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Given a shape of, for example, ``(m,n,k)``, ``m*n*k`` samples are\n            generated, and packed in an `m`-by-`n`-by-`k` arrangement.  Because\n            each sample is `N`-dimensional, the output shape is ``(m,n,k,N)``.\n            If no shape is specified, a single (`N`-D) sample is returned."
          },
          "check_valid": {
            "type": "{ 'warn'",
            "description": ", 'raise', 'ignore' }, optional\n            Behavior when the covariance matrix is not positive semidefinite."
          },
          "tol": {
            "type": "float",
            "description": "Tolerance when checking the singular values in covariance matrix.\n            cov is cast to double before the check."
          },
          "element": {
            "type": "math:`C_{ij}` is the covariance of :math:`x_i` and :math:`x_j`.",
            "description": "The element :math:`C_{ii}` is the variance of :math:`x_i` (i.e. its\n        \"spread\").\n\n        Instead of specifying the full covariance matrix, popular\n        approximations include:\n\n          - Spherical covariance (`cov` is a multiple of the identity matrix)\n          - Diagonal covariance (`cov` has non-negative elements, and only on\n            the diagonal)\n\n        This geometrical property can be seen in two dimensions by plotting\n        generated data-points:\n\n        >>> mean = [0, 0]\n        >>> cov = [[1, 0], [0, 100]]  # diagonal covariance\n\n        Diagonal covariance means that points are oriented along x or y-axis:\n\n        >>> import matplotlib.pyplot as plt\n        >>> x, y = np.random.multivariate_normal(mean, cov, 5000).T\n        >>> plt.plot(x, y, 'x')\n        >>> plt.axis('equal')\n        >>> plt.show()\n\n        Note that the covariance matrix must be positive semidefinite (a.k.a.\n        nonnegative-definite). Otherwise, the behavior of this method is\n        undefined and backwards compatibility is not guaranteed.\n\n        References\n        ----------\n        .. [1] Papoulis, A., \"Probability, Random Variables, and Stochastic\n               Processes,\" 3rd ed., New York: McGraw-Hill, 1991.\n        .. [2] Duda, R. O., Hart, P. E., and Stork, D. G., \"Pattern\n               Classification,\" 2nd ed., New York: Wiley, 2001."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "negative_binomial",
      "signature": "negative_binomial(...)",
      "documentation": {
        "description": "negative_binomial(n, p, size=None)\n\n        Draw samples from a negative binomial distribution.\n\n        Samples are drawn from a negative binomial distribution with specified\n        parameters, `n` successes and `p` probability of success where `n`\n        is > 0 and `p` is in the interval [0, 1].\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.negative_binomial`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "p": {
            "type": "float or array_like of floats",
            "description": "Parameter of the distribution, >= 0 and <=1."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``n`` and ``p`` are both scalars.\n            Otherwise, ``np.broadcast(n, p).size`` samples are drawn."
          },
          "where": {
            "type": "math:`n` is the number of successes",
            "description": ", :math:`p` is the\n        probability of success, :math:`N+n` is the number of trials, and\n        :math:`\\Gamma` is the gamma function. When :math:`n` is an integer,\n        :math:`\\frac{\\Gamma(N+n)}{N!\\Gamma(n)} = \\binom{N+n-1}{N}`, which is\n        the more common form of this term in the pmf. The negative\n        binomial distribution gives the probability of N failures given n\n        successes, with a success on the last trial.\n\n        If one throws a die repeatedly until the third time a \"1\" appears,\n        then the probability distribution of the number of non-\"1\"s that\n        appear before the third \"1\" is a negative binomial distribution.\n\n        References\n        ----------\n        .. [1] Weisstein, Eric W. \"Negative Binomial Distribution.\" From\n               MathWorld--A Wolfram Web Resource."
          },
          "http": {
            "type": "//mathworld.wolfram.com/NegativeBinomialDistribution.html",
            "description": ".. [2] Wikipedia, \"Negative binomial distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Negative_binomial_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "noncentral_chisquare",
      "signature": "noncentral_chisquare(...)",
      "documentation": {
        "description": "noncentral_chisquare(df, nonc, size=None)\n\n        Draw samples from a noncentral chi-square distribution.\n\n        The noncentral :math:`\\chi^2` distribution is a generalization of\n        the :math:`\\chi^2` distribution.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.noncentral_chisquare`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "nonc": {
            "type": "float or array_like of floats",
            "description": "Non-centrality, must be non-negative."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``df`` and ``nonc`` are both scalars.\n            Otherwise, ``np.broadcast(df, nonc).size`` samples are drawn."
          },
          "where": {
            "type": "math:`Y_{q}` is the Chi-square with q degrees of freedom.",
            "description": "References\n        ----------\n        .. [1] Wikipedia, \"Noncentral chi-squared distribution\""
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Noncentral_chi-squared_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "noncentral_f",
      "signature": "noncentral_f(...)",
      "documentation": {
        "description": "noncentral_f(dfnum, dfden, nonc, size=None)\n\n        Draw samples from the noncentral F distribution.\n\n        Samples are drawn from an F distribution with specified parameters,\n        `dfnum` (degrees of freedom in numerator) and `dfden` (degrees of\n        freedom in denominator), where both parameters > 1.\n        `nonc` is the non-centrality parameter.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.noncentral_f`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "dfden": {
            "type": "float or array_like of floats",
            "description": "Denominator degrees of freedom, must be > 0."
          },
          "nonc": {
            "type": "float or array_like of floats",
            "description": "Non-centrality parameter, the sum of the squares of the numerator\n            means, must be >= 0."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``dfnum``, ``dfden``, and ``nonc``\n            are all scalars.  Otherwise, ``np.broadcast(dfnum, dfden, nonc).size``\n            samples are drawn."
          },
          "http": {
            "type": "//mathworld.wolfram.com/NoncentralF-Distribution.html",
            "description": ".. [2] Wikipedia, \"Noncentral F-distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Noncentral_F-distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "normal",
      "signature": "normal(...)",
      "documentation": {
        "description": "normal(loc=0.0, scale=1.0, size=None)\n\n        Draw random samples from a normal (Gaussian) distribution.\n\n        The probability density function of the normal distribution, first\n        derived by De Moivre and 200 years later by both Gauss and Laplace\n        independently [2]_, is often called the bell curve because of\n        its characteristic shape (see the example below).\n\n        The normal distributions occurs often in nature.  For example, it\n        describes the commonly occurring distribution of samples influenced\n        by a large number of tiny, random disturbances, each with its own\n        unique distribution [2]_.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.normal`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "scale": {
            "type": "float or array_like of floats",
            "description": "Standard deviation (spread or \"width\") of the distribution. Must be\n            non-negative."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``loc`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn."
          },
          "where": {
            "type": "math:`\\mu` is the mean and :math:`\\sigma` the standard",
            "description": "deviation. The square of the standard deviation, :math:`\\sigma^2`,\n        is called the variance.\n\n        The function has its peak at the mean, and its \"spread\" increases with\n        the standard deviation (the function reaches 0.607 times its maximum at\n        :math:`x + \\sigma` and :math:`x - \\sigma` [2]_).  This implies that\n        normal is more likely to return samples lying close to the mean, rather\n        than those far away.\n\n        References\n        ----------\n        .. [1] Wikipedia, \"Normal distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Normal_distribution",
            "description": ".. [2] P. R. Peebles Jr., \"Central Limit Theorem\" in \"Probability,\n               Random Variables and Random Signal Principles\", 4th ed., 2001,\n               pp. 51, 51, 125."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "pareto",
      "signature": "pareto(...)",
      "documentation": {
        "description": "pareto(a, size=None)\n\n        Draw samples from a Pareto II or Lomax distribution with\n        specified shape.\n\n        The Lomax or Pareto II distribution is a shifted Pareto\n        distribution. The classical Pareto distribution can be\n        obtained from the Lomax distribution by adding 1 and\n        multiplying by the scale parameter ``m`` (see Notes).  The\n        smallest value of the Lomax distribution is zero while for the\n        classical Pareto distribution it is ``mu``, where the standard\n        Pareto distribution has location ``mu = 1``.  Lomax can also\n        be considered as a simplified version of the Generalized\n        Pareto distribution (available in SciPy), with the scale set\n        to one and the location set to zero.\n\n        The Pareto distribution must be greater than zero, and is\n        unbounded above.  It is also known as the \"80-20 rule\".  In\n        this distribution, 80 percent of the weights are in the lowest\n        20 percent of the range, while the other 20 percent fill the\n        remaining 80 percent of the range.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.pareto`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` is a scalar.  Otherwise,\n            ``np.array(a).size`` samples are drawn."
          },
          "where": {
            "type": "math:`a` is the shape and :math:`m` the scale.",
            "description": "The Pareto distribution, named after the Italian economist\n        Vilfredo Pareto, is a power law probability distribution\n        useful in many real world problems.  Outside the field of\n        economics it is generally referred to as the Bradford\n        distribution. Pareto developed the distribution to describe\n        the distribution of wealth in an economy.  It has also found\n        use in insurance, web page access statistics, oil field sizes,\n        and many other problems, including the download frequency for\n        projects in Sourceforge [1]_.  It is one of the so-called\n        \"fat-tailed\" distributions.\n\n        References\n        ----------\n        .. [1] Francis Hunt and Paul Johnson, On the Pareto Distribution of\n               Sourceforge projects.\n        .. [2] Pareto, V. (1896). Course of Political Economy. Lausanne.\n        .. [3] Reiss, R.D., Thomas, M.(2001), Statistical Analysis of Extreme\n               Values, Birkhauser Verlag, Basel, pp 23-30.\n        .. [4] Wikipedia, \"Pareto distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Pareto_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "permutation",
      "signature": "permutation(...)",
      "documentation": {
        "description": "permutation(x)\n\n        Randomly permute a sequence, or return a permuted range.\n\n        If `x` is a multi-dimensional array, it is only shuffled along its\n        first index.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.permutation`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "poisson",
      "signature": "poisson(...)",
      "documentation": {
        "description": "poisson(lam=1.0, size=None)\n\n        Draw samples from a Poisson distribution.\n\n        The Poisson distribution is the limit of the binomial distribution\n        for large N.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.poisson`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``lam`` is a scalar. Otherwise,\n            ``np.array(lam).size`` samples are drawn."
          },
          "distribution": {
            "type": "math:`f(k; \\lambda)` describes the probability of",
            "description": ":math:`k` events occurring within the observed"
          },
          "interval": {
            "type": "math:`\\lambda`.",
            "description": "Because the output is limited to the range of the C int64 type, a\n        ValueError is raised when `lam` is within 10 sigma of the maximum\n        representable value.\n\n        References\n        ----------\n        .. [1] Weisstein, Eric W. \"Poisson Distribution.\"\n               From MathWorld--A Wolfram Web Resource."
          },
          "http": {
            "type": "//mathworld.wolfram.com/PoissonDistribution.html",
            "description": ".. [2] Wikipedia, \"Poisson distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Poisson_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "power",
      "signature": "power(...)",
      "documentation": {
        "description": "power(a, size=None)\n\n        Draws samples in [0, 1] from a power distribution with positive\n        exponent a - 1.\n\n        Also known as the power function distribution.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.power`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` is a scalar.  Otherwise,\n            ``np.array(a).size`` samples are drawn."
          },
          "https": {
            "type": "//www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "rand",
      "signature": "rand(...)",
      "documentation": {
        "description": "rand(d0, d1, ..., dn)\n\n        Random values in a given shape.\n\n        .. note::\n            This is a convenience function for users porting code from Matlab,\n            and wraps `random_sample`. That function takes a\n            tuple to specify the size of the output, which is consistent with\n            other NumPy functions like `numpy.zeros` and `numpy.ones`.\n\n        Create an array of the given shape and populate it with\n        random samples from a uniform distribution\n        over ``[0, 1)``.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "randint",
      "signature": "randint(...)",
      "documentation": {
        "description": "randint(low, high=None, size=None, dtype=int)\n\n        Return random integers from `low` (inclusive) to `high` (exclusive).\n\n        Return random integers from the \"discrete uniform\" distribution of\n        the specified dtype in the \"half-open\" interval [`low`, `high`). If\n        `high` is None (the default), then results are from [0, `low`).\n\n        .. note::\n            New code should use the `~numpy.random.Generator.integers`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "high": {
            "type": "int or array-like of ints",
            "description": "If provided, one above the largest (signed) integer to be drawn\n            from the distribution (see above for behavior if ``high=None``).\n            If array-like, must contain integer values"
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned."
          },
          "dtype": {
            "type": "dtype",
            "description": "Desired dtype of the result. Byteorder must be native.\n            The default value is int.\n\n            .. versionadded:: 1.11.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "randn",
      "signature": "randn(...)",
      "documentation": {
        "description": "randn(d0, d1, ..., dn)\n\n        Return a sample (or samples) from the \"standard normal\" distribution.\n\n        .. note::\n            This is a convenience function for users porting code from Matlab,\n            and wraps `standard_normal`. That function takes a\n            tuple to specify the size of the output, which is consistent with\n            other NumPy functions like `numpy.zeros` and `numpy.ones`.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.standard_normal`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.\n\n        If positive int_like arguments are provided, `randn` generates an array\n        of shape ``(d0, d1, ..., dn)``, filled\n        with random floats sampled from a univariate \"normal\" (Gaussian)\n        distribution of mean 0 and variance 1. A single float randomly sampled\n        from the distribution is returned if no argument is provided.",
        "parameters": {
          "normal": {
            "type": "Also accepts mu and sigma arguments.",
            "description": "random.Generator.standard_normal: which should be used for new code."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "random",
      "signature": "random(...)",
      "documentation": {
        "description": "random(size=None)\n\n        Return random floats in the half-open interval [0.0, 1.0). Alias for\n        `random_sample` to ease forward-porting to the new random API.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "random_integers",
      "signature": "random_integers(...)",
      "documentation": {
        "description": "random_integers(low, high=None, size=None)\n\n        Random integers of type `np.int_` between `low` and `high`, inclusive.\n\n        Return random integers of type `np.int_` from the \"discrete uniform\"\n        distribution in the closed interval [`low`, `high`].  If `high` is\n        None (the default), then results are from [1, `low`]. The `np.int_`\n        type translates to the C long integer type and its precision\n        is platform dependent.\n\n        This function has been deprecated. Use randint instead.\n\n        .. deprecated:: 1.11.0",
        "parameters": {
          "high": {
            "type": "int",
            "description": "If provided, the largest (signed) integer to be drawn from the\n            distribution (see above for behavior if ``high=None``)."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned."
          },
          "use": {
            "type": ":",
            "description": "a + (b - a) * (np.random.random_integers(N) - 1) / (N - 1.)"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "random_sample",
      "signature": "random_sample(...)",
      "documentation": {
        "description": "random_sample(size=None)\n\n        Return random floats in the half-open interval [0.0, 1.0).\n\n        Results are from the \"continuous uniform\" distribution over the\n        stated interval.  To sample :math:`Unif[a, b), b > a` multiply\n        the output of `random_sample` by `(b-a)` and add `a`::\n\n          (b - a) * random_sample() + a\n\n        .. note::\n            New code should use the `~numpy.random.Generator.random`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ranf",
      "signature": "ranf(...)",
      "documentation": {
        "description": "This is an alias of `random_sample`. See `random_sample`  for the complete\n    documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "rayleigh",
      "signature": "rayleigh(...)",
      "documentation": {
        "description": "rayleigh(scale=1.0, size=None)\n\n        Draw samples from a Rayleigh distribution.\n\n        The :math:`\\chi` and Weibull distributions are generalizations of the\n        Rayleigh.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.rayleigh`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``scale`` is a scalar.  Otherwise,\n            ``np.array(scale).size`` samples are drawn."
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Rayleigh_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sample",
      "signature": "sample(...)",
      "documentation": {
        "description": "This is an alias of `random_sample`. See `random_sample`  for the complete\n    documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "seed",
      "signature": "seed(...)",
      "documentation": {
        "description": "seed(seed=None)\n\n    Reseed the singleton RandomState instance.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "numpy.random.Generator",
        "examples": ""
      }
    },
    {
      "name": "set_bit_generator",
      "signature": "set_bit_generator(...)",
      "documentation": {
        "description": "Sets the singleton RandomState's bit generator",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "set_state",
      "signature": "set_state(...)",
      "documentation": {
        "description": "set_state(state)\n\n        Set the internal state of the generator from a tuple.\n\n        For use if one has reason to manually (re-)set the internal state of\n        the bit generator used by the RandomState instance. By default,\n        RandomState uses the \"Mersenne Twister\"[1]_ pseudo-random number\n        generating algorithm.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "shuffle",
      "signature": "shuffle(...)",
      "documentation": {
        "description": "shuffle(x)\n\n        Modify a sequence in-place by shuffling its contents.\n\n        This function only shuffles the array along the first axis of a\n        multi-dimensional array. The order of sub-arrays is changed but\n        their contents remains the same.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.shuffle`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "standard_cauchy",
      "signature": "standard_cauchy(...)",
      "documentation": {
        "description": "standard_cauchy(size=None)\n\n        Draw samples from a standard Cauchy distribution with mode = 0.\n\n        Also known as the Lorentz distribution.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.standard_cauchy`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "https": {
            "type": "//en.wikipedia.org/wiki/Cauchy_distribution",
            "description": ""
          },
          "http": {
            "type": "//mathworld.wolfram.com/CauchyDistribution.html",
            "description": ".. [3] Wikipedia, \"Cauchy distribution\""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "standard_exponential",
      "signature": "standard_exponential(...)",
      "documentation": {
        "description": "standard_exponential(size=None)\n\n        Draw samples from the standard exponential distribution.\n\n        `standard_exponential` is identical to the exponential distribution\n        with a scale parameter of 1.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.standard_exponential`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "standard_gamma",
      "signature": "standard_gamma(...)",
      "documentation": {
        "description": "standard_gamma(shape, size=None)\n\n        Draw samples from a standard Gamma distribution.\n\n        Samples are drawn from a Gamma distribution with specified parameters,\n        shape (sometimes designated \"k\") and scale=1.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.standard_gamma`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``shape`` is a scalar.  Otherwise,\n            ``np.array(shape).size`` samples are drawn."
          },
          "where": {
            "type": "math:`k` is the shape and :math:`\\theta` the scale",
            "description": ","
          },
          "and": {
            "type": "math:`\\Gamma` is the Gamma function.",
            "description": "The Gamma distribution is often used to model the times to failure of\n        electronic components, and arises naturally in processes for which the\n        waiting times between Poisson distributed events are relevant.\n\n        References\n        ----------\n        .. [1] Weisstein, Eric W. \"Gamma Distribution.\" From MathWorld--A\n               Wolfram Web Resource."
          },
          "http": {
            "type": "//mathworld.wolfram.com/GammaDistribution.html",
            "description": ".. [2] Wikipedia, \"Gamma distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Gamma_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "standard_normal",
      "signature": "standard_normal(...)",
      "documentation": {
        "description": "standard_normal(size=None)\n\n        Draw samples from a standard Normal distribution (mean=0, stdev=1).\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.standard_normal`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "standard_t",
      "signature": "standard_t(...)",
      "documentation": {
        "description": "standard_t(df, size=None)\n\n        Draw samples from a standard Student's t distribution with `df` degrees\n        of freedom.\n\n        A special case of the hyperbolic distribution.  As `df` gets\n        large, the result resembles that of the standard normal\n        distribution (`standard_normal`).\n\n        .. note::\n            New code should use the `~numpy.random.Generator.standard_t`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``df`` is a scalar.  Otherwise,\n            ``np.array(df).size`` samples are drawn."
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Student's_t-distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "triangular",
      "signature": "triangular(...)",
      "documentation": {
        "description": "triangular(left, mode, right, size=None)\n\n        Draw samples from the triangular distribution over the\n        interval ``[left, right]``.\n\n        The triangular distribution is a continuous probability\n        distribution with lower limit left, peak at mode, and upper\n        limit right. Unlike the other distributions, these parameters\n        directly define the shape of the pdf.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.triangular`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "mode": {
            "type": "float or array_like of floats",
            "description": "The value where the peak of the distribution occurs.\n            The value must fulfill the condition ``left <= mode <= right``."
          },
          "right": {
            "type": "float or array_like of floats",
            "description": "Upper limit, must be larger than `left`."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``left``, ``mode``, and ``right``\n            are all scalars.  Otherwise, ``np.broadcast(left, mode, right).size``\n            samples are drawn."
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Triangular_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "uniform",
      "signature": "uniform(...)",
      "documentation": {
        "description": "uniform(low=0.0, high=1.0, size=None)\n\n        Draw samples from a uniform distribution.\n\n        Samples are uniformly distributed over the half-open interval\n        ``[low, high)`` (includes low, but excludes high).  In other words,\n        any value within the given interval is equally likely to be drawn\n        by `uniform`.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.uniform`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "high": {
            "type": "float or array_like of floats",
            "description": "Upper boundary of the output interval.  All values generated will be\n            less than or equal to high.  The high limit may be included in the \n            returned array of floats due to floating-point rounding in the \n            equation ``low + (high-low) * random_sample()``.  The default value \n            is 1.0."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``low`` and ``high`` are both scalars.\n            Otherwise, ``np.broadcast(low, high).size`` samples are drawn."
          },
          "random_integers": {
            "type": "Discrete uniform distribution over the closed",
            "description": "interval ``[low, high]``."
          },
          "random_sample": {
            "type": "Floats uniformly distributed over ``[0",
            "description": ", 1)``."
          },
          "random": {
            "type": "Alias for `random_sample`.",
            "description": ""
          },
          "rand": {
            "type": "Convenience function that accepts dimensions as input",
            "description": ", e.g.,\n               ``rand(2,2)`` would generate a 2-by-2 array of floats,\n               uniformly distributed over ``[0, 1)``.\n        random.Generator.uniform: which should be used for new code."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "vonmises",
      "signature": "vonmises(...)",
      "documentation": {
        "description": "vonmises(mu, kappa, size=None)\n\n        Draw samples from a von Mises distribution.\n\n        Samples are drawn from a von Mises distribution with specified mode\n        (mu) and dispersion (kappa), on the interval [-pi, pi].\n\n        The von Mises distribution (also known as the circular normal\n        distribution) is a continuous probability distribution on the unit\n        circle.  It may be thought of as the circular analogue of the normal\n        distribution.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.vonmises`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "kappa": {
            "type": "float or array_like of floats",
            "description": "Dispersion of the distribution, has to be >=0."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``mu`` and ``kappa`` are both scalars.\n            Otherwise, ``np.broadcast(mu, kappa).size`` samples are drawn."
          },
          "where": {
            "type": "math:`\\mu` is the mode and :math:`\\kappa` the dispersion",
            "description": ","
          },
          "and": {
            "type": "math:`I_0(\\kappa)` is the modified Bessel function of order 0.",
            "description": "The von Mises is named for Richard Edler von Mises, who was born in\n        Austria-Hungary, in what is now the Ukraine.  He fled to the United\n        States in 1939 and became a professor at Harvard.  He worked in\n        probability theory, aerodynamics, fluid mechanics, and philosophy of\n        science.\n\n        References\n        ----------\n        .. [1] Abramowitz, M. and Stegun, I. A. (Eds.). \"Handbook of\n               Mathematical Functions with Formulas, Graphs, and Mathematical\n               Tables, 9th printing,\" New York: Dover, 1972.\n        .. [2] von Mises, R., \"Mathematical Theory of Probability\n               and Statistics\", New York: Academic Press, 1964."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "wald",
      "signature": "wald(...)",
      "documentation": {
        "description": "wald(mean, scale, size=None)\n\n        Draw samples from a Wald, or inverse Gaussian, distribution.\n\n        As the scale approaches infinity, the distribution becomes more like a\n        Gaussian. Some references claim that the Wald is an inverse Gaussian\n        with mean equal to 1, but this is by no means universal.\n\n        The inverse Gaussian distribution was first studied in relationship to\n        Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian\n        because there is an inverse relationship between the time to cover a\n        unit distance and distance covered in unit time.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.wald`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "scale": {
            "type": "float or array_like of floats",
            "description": "Scale parameter, must be > 0."
          },
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``mean`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(mean, scale).size`` samples are drawn."
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Inverse_Gaussian_distribution",
            "description": ""
          },
          "Distribution": {
            "type": "Theory : Methodology",
            "description": ", and Applications\", CRC Press,\n               1988.\n        .. [3] Wikipedia, \"Inverse Gaussian distribution\""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "weibull",
      "signature": "weibull(...)",
      "documentation": {
        "description": "weibull(a, size=None)\n\n        Draw samples from a Weibull distribution.\n\n        Draw samples from a 1-parameter Weibull distribution with the given\n        shape parameter `a`.\n\n        .. math:: X = (-ln(U))^{1/a}\n\n        Here, U is drawn from the uniform distribution over (0,1].\n\n        The more common 2-parameter Weibull, including a scale parameter\n        :math:`\\lambda` is just :math:`X = \\lambda(-ln(U))^{1/a}`.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.weibull`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` is a scalar.  Otherwise,\n            ``np.array(a).size`` samples are drawn."
          },
          "where": {
            "type": "math:`a` is the shape and :math:`\\lambda` the scale.",
            "description": "The function has its peak (the mode) at\n        :math:`\\lambda(\\frac{a-1}{a})^{1/a}`.\n\n        When ``a = 1``, the Weibull distribution reduces to the exponential\n        distribution.\n\n        References\n        ----------\n        .. [1] Waloddi Weibull, Royal Technical University, Stockholm,\n               1939 \"A Statistical Theory Of The Strength Of Materials\",\n               Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939,\n               Generalstabens Litografiska Anstalts Forlag, Stockholm.\n        .. [2] Waloddi Weibull, \"A Statistical Distribution Function of\n               Wide Applicability\", Journal Of Applied Mechanics ASME Paper\n               1951.\n        .. [3] Wikipedia, \"Weibull distribution\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Weibull_distribution",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "zipf",
      "signature": "zipf(...)",
      "documentation": {
        "description": "zipf(a, size=None)\n\n        Draw samples from a Zipf distribution.\n\n        Samples are drawn from a Zipf distribution with specified parameter\n        `a` > 1.\n\n        The Zipf distribution (also known as the zeta distribution) is a\n        discrete probability distribution that satisfies Zipf's law: the\n        frequency of an item is inversely proportional to its rank in a\n        frequency table.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.zipf`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
        "parameters": {
          "size": {
            "type": "int or tuple of ints",
            "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` is a scalar. Otherwise,\n            ``np.array(a).size`` samples are drawn."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": [
    {
      "name": "BitGenerator",
      "documentation": {
        "description": "BitGenerator(seed=None)\n\n    Base Class for generic BitGenerators, which provide a stream\n    of random bits based on different algorithms. Must be overridden.",
        "parameters": {
          "lock": {
            "type": "threading.Lock",
            "description": "Lock instance that is shared so that the same BitGenerator can\n        be used in multiple Generators without corrupting the state. Code that\n        generates values from a bit generator should hold the bit generator's\n        lock."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "random_raw",
          "signature": "random_raw(...)",
          "documentation": {
            "description": "random_raw(self, size=None)\n\n        Return randoms as generated by the underlying BitGenerator",
            "parameters": {
              "output": {
                "type": "bool",
                "description": "Output values.  Used for performance testing since the generated\n            values are not returned."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "spawn",
          "signature": "spawn(...)",
          "documentation": {
            "description": "spawn(n_children)\n\n        Create new independent child bit generators.\n\n        See :ref:`seedsequence-spawn` for additional notes on spawning\n        children.  Some bit generators also implement ``jumped``\n        as a different approach for creating independent streams.\n\n        .. versionadded:: 1.25.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "Generator",
      "documentation": {
        "description": "Generator(bit_generator)\n\n    Container for the BitGenerators.\n\n    ``Generator`` exposes a number of methods for generating random\n    numbers drawn from a variety of probability distributions. In addition to\n    the distribution-specific arguments, each method takes a keyword argument\n    `size` that defaults to ``None``. If `size` is ``None``, then a single\n    value is generated and returned. If `size` is an integer, then a 1-D\n    array filled with generated values is returned. If `size` is a tuple,\n    then an array with that shape is filled and returned.\n\n    The function :func:`numpy.random.default_rng` will instantiate\n    a `Generator` with numpy's default `BitGenerator`.\n\n    **No Compatibility Guarantee**\n\n    ``Generator`` does not provide a version compatibility guarantee. In\n    particular, as better algorithms evolve the bit stream may change.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "beta",
          "signature": "beta(...)",
          "documentation": {
            "description": "beta(a, b, size=None)\n\n        Draw samples from a Beta distribution.\n\n        The Beta distribution is a special case of the Dirichlet distribution,\n        and is related to the Gamma distribution.  It has the probability\n        distribution function\n\n        .. math:: f(x; a,b) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1}\n                                                         (1 - x)^{\\beta - 1},\n\n        where the normalization, B, is the beta function,\n\n        .. math:: B(\\alpha, \\beta) = \\int_0^1 t^{\\alpha - 1}\n                                     (1 - t)^{\\beta - 1} dt.\n\n        It is often seen in Bayesian inference and order statistics.",
            "parameters": {
              "b": {
                "type": "float or array_like of floats",
                "description": "Beta, positive (>0)."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` and ``b`` are both scalars.\n            Otherwise, ``np.broadcast(a, b).size`` samples are drawn."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "binomial",
          "signature": "binomial(...)",
          "documentation": {
            "description": "binomial(n, p, size=None)\n\n        Draw samples from a binomial distribution.\n\n        Samples are drawn from a binomial distribution with specified\n        parameters, n trials and p probability of success where\n        n an integer >= 0 and p is in the interval [0,1]. (n may be\n        input as a float, but it is truncated to an integer in use)",
            "parameters": {
              "p": {
                "type": "float or array_like of floats",
                "description": "Parameter of the distribution, >= 0 and <=1."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``n`` and ``p`` are both scalars.\n            Otherwise, ``np.broadcast(n, p).size`` samples are drawn."
              },
              "where": {
                "type": "math:`n` is the number of trials",
                "description": ", :math:`p` is the probability\n        of success, and :math:`N` is the number of successes.\n\n        When estimating the standard error of a proportion in a population by\n        using a random sample, the normal distribution works well unless the\n        product p*n <=5, where p = population proportion estimate, and n =\n        number of samples, in which case the binomial distribution is used\n        instead. For example, a sample of 15 people shows 4 who are left\n        handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,\n        so the binomial distribution should be used in this case.\n\n        References\n        ----------\n        .. [1] Dalgaard, Peter, \"Introductory Statistics with R\",\n               Springer-Verlag, 2002.\n        .. [2] Glantz, Stanton A. \"Primer of Biostatistics.\", McGraw-Hill,\n               Fifth Edition, 2002.\n        .. [3] Lentner, Marvin, \"Elementary Applied Statistics\", Bogden\n               and Quigley, 1972.\n        .. [4] Weisstein, Eric W. \"Binomial Distribution.\" From MathWorld--A\n               Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/BinomialDistribution.html",
                "description": ".. [5] Wikipedia, \"Binomial distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Binomial_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bytes",
          "signature": "bytes(...)",
          "documentation": {
            "description": "bytes(length)\n\n        Return random bytes.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "chisquare",
          "signature": "chisquare(...)",
          "documentation": {
            "description": "chisquare(df, size=None)\n\n        Draw samples from a chi-square distribution.\n\n        When `df` independent random variables, each with standard normal\n        distributions (mean 0, variance 1), are squared and summed, the\n        resulting distribution is chi-square (see Notes).  This distribution\n        is often used in hypothesis testing.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``df`` is a scalar.  Otherwise,\n            ``np.array(df).size`` samples are drawn."
              },
              "where": {
                "type": "math:`\\Gamma` is the gamma function",
                "description": ",\n\n        .. math:: \\Gamma(x) = \\int_0^{-\\infty} t^{x - 1} e^{-t} dt.\n\n        References\n        ----------\n        .. [1] NIST \"Engineering Statistics Handbook\""
              },
              "https": {
                "type": "//www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choice",
          "signature": "choice(...)",
          "documentation": {
            "description": "choice(a, size=None, replace=True, p=None, axis=0, shuffle=True)\n\n        Generates a random sample from a given array",
            "parameters": {
              "size": {
                "type": "{int",
                "description": ", tuple[int]}, optional\n            Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn from the 1-d `a`. If `a` has more\n            than one dimension, the `size` shape will be inserted into the\n            `axis` dimension, so the output ``ndim`` will be ``a.ndim - 1 +\n            len(size)``. Default is None, in which case a single value is\n            returned."
              },
              "replace": {
                "type": "bool",
                "description": "Whether the sample is with or without replacement. Default is True,\n            meaning that a value of ``a`` can be selected multiple times."
              },
              "p": {
                "type": "1-D array_like",
                "description": "The probabilities associated with each entry in a.\n            If not given, the sample assumes a uniform distribution over all\n            entries in ``a``."
              },
              "axis": {
                "type": "int",
                "description": "The axis along which the selection is performed. The default, 0,\n            selects by row."
              },
              "shuffle": {
                "type": "bool",
                "description": "Whether the sample is shuffled when sampling without replacement.\n            Default is True, False provides a speedup."
              },
              "replacement": {
                "type": ">>> rng.choice(5",
                "description": ", 3, replace=False)\n        array([3,1,0]) # random\n        >>> #This is equivalent to rng.permutation(np.arange(5))[:3]\n\n        Generate a uniform random sample from a 2-D array along the first\n        axis (the default), without replacement:\n\n        >>> rng.choice([[0, 1, 2], [3, 4, 5], [6, 7, 8]], 2, replace=False)\n        array([[3, 4, 5], # random\n               [0, 1, 2]])\n\n        Generate a non-uniform random sample from np.arange(5) of size\n        3 without replacement:\n\n        >>> rng.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])\n        array([2, 3, 0]) # random\n\n        Any of the above can be repeated with an arbitrary array-like\n        instead of just integers. For instance:\n\n        >>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']\n        >>> rng.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])\n        array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random\n              dtype='<U11')"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dirichlet",
          "signature": "dirichlet(...)",
          "documentation": {
            "description": "dirichlet(alpha, size=None)\n\n        Draw samples from the Dirichlet distribution.\n\n        Draw `size` samples of dimension k from a Dirichlet distribution. A\n        Dirichlet-distributed random variable can be seen as a multivariate\n        generalization of a Beta distribution. The Dirichlet distribution\n        is a conjugate prior of a multinomial distribution in Bayesian\n        inference.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            vector of length ``k`` is returned."
              },
              "where": {
                "type": "math:`\\alpha` is a vector containing the positive",
                "description": "concentration parameters.\n\n        The method uses the following property for computation: let :math:`Y`\n        be a random vector which has components that follow a standard gamma\n        distribution, then :math:`X = \\frac{1}{\\sum_{i=1}^k{Y_i}} Y`\n        is Dirichlet-distributed\n\n        References\n        ----------\n        .. [1] David McKay, \"Information Theory, Inference and Learning\n               Algorithms,\" chapter 23,"
              },
              "http": {
                "type": "//www.inference.org.uk/mackay/itila/",
                "description": ".. [2] Wikipedia, \"Dirichlet distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Dirichlet_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "exponential",
          "signature": "exponential(...)",
          "documentation": {
            "description": "exponential(scale=1.0, size=None)\n\n        Draw samples from an exponential distribution.\n\n        Its probability density function is\n\n        .. math:: f(x; \\frac{1}{\\beta}) = \\frac{1}{\\beta} \\exp(-\\frac{x}{\\beta}),\n\n        for ``x > 0`` and 0 elsewhere. :math:`\\beta` is the scale parameter,\n        which is the inverse of the rate parameter :math:`\\lambda = 1/\\beta`.\n        The rate parameter is an alternative, widely used parameterization\n        of the exponential distribution [3]_.\n\n        The exponential distribution is a continuous analogue of the\n        geometric distribution.  It describes many common situations, such as\n        the size of raindrops measured over many rainstorms [1]_, or the time\n        between page requests to Wikipedia [2]_.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``scale`` is a scalar.  Otherwise,\n            ``np.array(scale).size`` samples are drawn."
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Exponential_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "f",
          "signature": "f(...)",
          "documentation": {
            "description": "f(dfnum, dfden, size=None)\n\n        Draw samples from an F distribution.\n\n        Samples are drawn from an F distribution with specified parameters,\n        `dfnum` (degrees of freedom in numerator) and `dfden` (degrees of\n        freedom in denominator), where both parameters must be greater than\n        zero.\n\n        The random variate of the F distribution (also known as the\n        Fisher distribution) is a continuous probability distribution\n        that arises in ANOVA tests, and is the ratio of two chi-square\n        variates.",
            "parameters": {
              "dfden": {
                "type": "float or array_like of float",
                "description": "Degrees of freedom in denominator, must be > 0."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``dfnum`` and ``dfden`` are both scalars.\n            Otherwise, ``np.broadcast(dfnum, dfden).size`` samples are drawn."
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/F-distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "gamma",
          "signature": "gamma(...)",
          "documentation": {
            "description": "gamma(shape, scale=1.0, size=None)\n\n        Draw samples from a Gamma distribution.\n\n        Samples are drawn from a Gamma distribution with specified parameters,\n        `shape` (sometimes designated \"k\") and `scale` (sometimes designated\n        \"theta\"), where both parameters are > 0.",
            "parameters": {
              "scale": {
                "type": "float or array_like of floats",
                "description": "The scale of the gamma distribution. Must be non-negative.\n            Default is equal to 1."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``shape`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(shape, scale).size`` samples are drawn."
              },
              "where": {
                "type": "math:`k` is the shape and :math:`\\theta` the scale",
                "description": ","
              },
              "and": {
                "type": "math:`\\Gamma` is the Gamma function.",
                "description": "The Gamma distribution is often used to model the times to failure of\n        electronic components, and arises naturally in processes for which the\n        waiting times between Poisson distributed events are relevant.\n\n        References\n        ----------\n        .. [1] Weisstein, Eric W. \"Gamma Distribution.\" From MathWorld--A\n               Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/GammaDistribution.html",
                "description": ".. [2] Wikipedia, \"Gamma distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Gamma_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "geometric",
          "signature": "geometric(...)",
          "documentation": {
            "description": "geometric(p, size=None)\n\n        Draw samples from the geometric distribution.\n\n        Bernoulli trials are experiments with one of two outcomes:\n        success or failure (an example of such an experiment is flipping\n        a coin).  The geometric distribution models the number of trials\n        that must be run in order to achieve success.  It is therefore\n        supported on the positive integers, ``k = 1, 2, ...``.\n\n        The probability mass function of the geometric distribution is\n\n        .. math:: f(k) = (1 - p)^{k - 1} p\n\n        where `p` is the probability of success of an individual trial.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``p`` is a scalar.  Otherwise,\n            ``np.array(p).size`` samples are drawn."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "gumbel",
          "signature": "gumbel(...)",
          "documentation": {
            "description": "gumbel(loc=0.0, scale=1.0, size=None)\n\n        Draw samples from a Gumbel distribution.\n\n        Draw samples from a Gumbel distribution with specified location and\n        scale.  For more information on the Gumbel distribution, see\n        Notes and References below.",
            "parameters": {
              "scale": {
                "type": "float or array_like of floats",
                "description": "The scale parameter of the distribution. Default is 1. Must be non-\n            negative."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``loc`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn."
              },
              "where": {
                "type": "math:`\\mu` is the mode",
                "description": ", a location parameter, and\n        :math:`\\beta` is the scale parameter.\n\n        The Gumbel (named for German mathematician Emil Julius Gumbel) was used\n        very early in the hydrology literature, for modeling the occurrence of\n        flood events. It is also used for modeling maximum wind speed and\n        rainfall rates.  It is a \"fat-tailed\" distribution - the probability of\n        an event in the tail of the distribution is larger than if one used a\n        Gaussian, hence the surprisingly frequent occurrence of 100-year\n        floods. Floods were initially modeled as a Gaussian process, which\n        underestimated the frequency of extreme events.\n\n        It is one of a class of extreme value distributions, the Generalized\n        Extreme Value (GEV) distributions, which also includes the Weibull and\n        Frechet.\n\n        The function has a mean of :math:`\\mu + 0.57721\\beta` and a variance"
              },
              "of": {
                "type": "math:`\\frac{\\pi^2}{6}\\beta^2`.",
                "description": "References\n        ----------\n        .. [1] Gumbel, E. J., \"Statistics of Extremes,\"\n               New York: Columbia University Press, 1958.\n        .. [2] Reiss, R.-D. and Thomas, M., \"Statistical Analysis of Extreme\n               Values from Insurance, Finance, Hydrology and Other Fields,\""
              },
              "Basel": {
                "type": "Birkhauser Verlag",
                "description": ", 2001."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "hypergeometric",
          "signature": "hypergeometric(...)",
          "documentation": {
            "description": "hypergeometric(ngood, nbad, nsample, size=None)\n\n        Draw samples from a Hypergeometric distribution.\n\n        Samples are drawn from a hypergeometric distribution with specified\n        parameters, `ngood` (ways to make a good selection), `nbad` (ways to make\n        a bad selection), and `nsample` (number of items sampled, which is less\n        than or equal to the sum ``ngood + nbad``).",
            "parameters": {
              "nbad": {
                "type": "int or array_like of ints",
                "description": "Number of ways to make a bad selection.  Must be nonnegative and\n            less than 10**9."
              },
              "nsample": {
                "type": "int or array_like of ints",
                "description": "Number of items sampled.  Must be nonnegative and less than\n            ``ngood + nbad``."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if `ngood`, `nbad`, and `nsample`\n            are all scalars.  Otherwise, ``np.broadcast(ngood, nbad, nsample).size``\n            samples are drawn."
              },
              "where": {
                "type": "math:`0 \\le x \\le n` and :math:`n-b \\le x \\le g`",
                "description": "for P(x) the probability of ``x`` good results in the drawn sample,\n        g = `ngood`, b = `nbad`, and n = `nsample`.\n\n        Consider an urn with black and white marbles in it, `ngood` of them\n        are black and `nbad` are white. If you draw `nsample` balls without\n        replacement, then the hypergeometric distribution describes the\n        distribution of black balls in the drawn sample.\n\n        Note that this distribution is very similar to the binomial\n        distribution, except that in this case, samples are drawn without\n        replacement, whereas in the Binomial case samples are drawn with\n        replacement (or the sample space is infinite). As the sample space\n        becomes large, this distribution approaches the binomial.\n\n        The arguments `ngood` and `nbad` each must be less than `10**9`. For\n        extremely large arguments, the algorithm that is used to compute the\n        samples [4]_ breaks down because of loss of precision in floating point\n        calculations.  For such large values, if `nsample` is not also large,\n        the distribution can be approximated with the binomial distribution,\n        `binomial(n=nsample, p=ngood/(ngood + nbad))`.\n\n        References\n        ----------\n        .. [1] Lentner, Marvin, \"Elementary Applied Statistics\", Bogden\n               and Quigley, 1972.\n        .. [2] Weisstein, Eric W. \"Hypergeometric Distribution.\" From\n               MathWorld--A Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/HypergeometricDistribution.html",
                "description": ".. [3] Wikipedia, \"Hypergeometric distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Hypergeometric_distribution",
                "description": ".. [4] Stadlober, Ernst, \"The ratio of uniforms approach for generating\n               discrete random variates\", Journal of Computational and Applied\n               Mathematics, 31, pp. 181-189 (1990)."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "integers",
          "signature": "integers(...)",
          "documentation": {
            "description": "integers(low, high=None, size=None, dtype=np.int64, endpoint=False)\n\n        Return random integers from `low` (inclusive) to `high` (exclusive), or\n        if endpoint=True, `low` (inclusive) to `high` (inclusive). Replaces\n        `RandomState.randint` (with endpoint=False) and\n        `RandomState.random_integers` (with endpoint=True)\n\n        Return random integers from the \"discrete uniform\" distribution of\n        the specified dtype. If `high` is None (the default), then results are\n        from 0 to `low`.",
            "parameters": {
              "high": {
                "type": "int or array-like of ints",
                "description": "If provided, one above the largest (signed) integer to be drawn\n            from the distribution (see above for behavior if ``high=None``).\n            If array-like, must contain integer values"
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned."
              },
              "dtype": {
                "type": "dtype",
                "description": "Desired dtype of the result. Byteorder must be native.\n            The default value is np.int64."
              },
              "endpoint": {
                "type": "bool",
                "description": "If true, sample from the interval [low, high] instead of the\n            default [low, high)\n            Defaults to False"
              },
              "http": {
                "type": "//arxiv.org/abs/1805.10941.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "laplace",
          "signature": "laplace(...)",
          "documentation": {
            "description": "laplace(loc=0.0, scale=1.0, size=None)\n\n        Draw samples from the Laplace or double exponential distribution with\n        specified location (or mean) and scale (decay).\n\n        The Laplace distribution is similar to the Gaussian/normal distribution,\n        but is sharper at the peak and has fatter tails. It represents the\n        difference between two independent, identically distributed exponential\n        random variables.",
            "parameters": {
              "scale": {
                "type": "float or array_like of floats",
                "description": ":math:`\\lambda`, the exponential decay. Default is 1. Must be non-\n            negative."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``loc`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn."
              },
              "http": {
                "type": "//mathworld.wolfram.com/LaplaceDistribution.html",
                "description": ".. [4] Wikipedia, \"Laplace distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Laplace_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logistic",
          "signature": "logistic(...)",
          "documentation": {
            "description": "logistic(loc=0.0, scale=1.0, size=None)\n\n        Draw samples from a logistic distribution.\n\n        Samples are drawn from a logistic distribution with specified\n        parameters, loc (location or mean, also median), and scale (>0).",
            "parameters": {
              "scale": {
                "type": "float or array_like of floats",
                "description": "Parameter of the distribution. Must be non-negative.\n            Default is 1."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``loc`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn."
              },
              "where": {
                "type": "math:`\\mu` = location and :math:`s` = scale.",
                "description": "The Logistic distribution is used in Extreme Value problems where it\n        can act as a mixture of Gumbel distributions, in Epidemiology, and by\n        the World Chess Federation (FIDE) where it is used in the Elo ranking\n        system, assuming the performance of each player is a logistically\n        distributed random variable.\n\n        References\n        ----------\n        .. [1] Reiss, R.-D. and Thomas M. (2001), \"Statistical Analysis of\n               Extreme Values, from Insurance, Finance, Hydrology and Other\n               Fields,\" Birkhauser Verlag, Basel, pp 132-133.\n        .. [2] Weisstein, Eric W. \"Logistic Distribution.\" From\n               MathWorld--A Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/LogisticDistribution.html",
                "description": ".. [3] Wikipedia, \"Logistic-distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Logistic_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lognormal",
          "signature": "lognormal(...)",
          "documentation": {
            "description": "lognormal(mean=0.0, sigma=1.0, size=None)\n\n        Draw samples from a log-normal distribution.\n\n        Draw samples from a log-normal distribution with specified mean,\n        standard deviation, and array shape.  Note that the mean and standard\n        deviation are not the values for the distribution itself, but of the\n        underlying normal distribution it is derived from.",
            "parameters": {
              "sigma": {
                "type": "float or array_like of floats",
                "description": "Standard deviation of the underlying normal distribution. Must be\n            non-negative. Default is 1."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``mean`` and ``sigma`` are both scalars.\n            Otherwise, ``np.broadcast(mean, sigma).size`` samples are drawn."
              },
              "where": {
                "type": "math:`\\mu` is the mean and :math:`\\sigma` is the standard",
                "description": "deviation of the normally distributed logarithm of the variable.\n        A log-normal distribution results if a random variable is the *product*\n        of a large number of independent, identically-distributed variables in\n        the same way that a normal distribution results if the variable is the\n        *sum* of a large number of independent, identically-distributed\n        variables.\n\n        References\n        ----------\n        .. [1] Limpert, E., Stahel, W. A., and Abbt, M., \"Log-normal\n               Distributions across the Sciences: Keys and Clues,\"\n               BioScience, Vol. 51, No. 5, May, 2001."
              },
              "https": {
                "type": "//stat.ethz.ch/~stahel/lognormal/bioscience.pdf",
                "description": ".. [2] Reiss, R.D. and Thomas, M., \"Statistical Analysis of Extreme\n               Values,\" Basel: Birkhauser Verlag, 2001, pp. 31-32."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logseries",
          "signature": "logseries(...)",
          "documentation": {
            "description": "logseries(p, size=None)\n\n        Draw samples from a logarithmic series distribution.\n\n        Samples are drawn from a log series distribution with specified\n        shape parameter, 0 <= ``p`` < 1.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``p`` is a scalar.  Otherwise,\n            ``np.array(p).size`` samples are drawn."
              },
              "occurrences": {
                "type": "BIODIVERSITY RESEARCH Diversity & Distributions",
                "description": ",\n               Volume 5, Number 5, September 1999 , pp. 187-195(9).\n        .. [2] Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The\n               relation between the number of species and the number of\n               individuals in a random sample of an animal population.\n               Journal of Animal Ecology, 12:42-58.\n        .. [3] D. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small\n               Data Sets, CRC Press, 1994.\n        .. [4] Wikipedia, \"Logarithmic distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Logarithmic_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "multinomial",
          "signature": "multinomial(...)",
          "documentation": {
            "description": "multinomial(n, pvals, size=None)\n\n        Draw samples from a multinomial distribution.\n\n        The multinomial distribution is a multivariate generalization of the\n        binomial distribution.  Take an experiment with one of ``p``\n        possible outcomes.  An example of such an experiment is throwing a dice,\n        where the outcome can be 1 through 6.  Each sample drawn from the\n        distribution represents `n` such experiments.  Its values,\n        ``X_i = [X_0, X_1, ..., X_p]``, represent the number of times the\n        outcome was ``i``.",
            "parameters": {
              "pvals": {
                "type": "array-like of floats",
                "description": "Probabilities of each of the ``p`` different outcomes with shape\n            ``(k0, k1, ..., kn, p)``. Each element ``pvals[i,j,...,:]`` must\n            sum to 1 (however, the last element is always assumed to account\n            for the remaining probability, as long as\n            ``sum(pvals[..., :-1], axis=-1) <= 1.0``. Must have at least 1\n            dimension where pvals.shape[-1] > 0."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn each with ``p`` elements. Default\n            is None where the output size is determined by the broadcast shape\n            of ``n`` and all by the final dimension of ``pvals``, which is\n            denoted as ``b=(b0, b1, ..., bq)``. If size is not None, then it\n            must be compatible with the broadcast shape ``b``. Specifically,\n            size must have ``q`` or more elements and size[-(q-j):] must equal\n            ``bj``."
              },
              "ValueError": {
                "type": "pvals < 0",
                "description": ", pvals > 1 or pvals contains NaNs"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "multivariate_hypergeometric",
          "signature": "multivariate_hypergeometric(...)",
          "documentation": {
            "description": "multivariate_hypergeometric(colors, nsample, size=None,\n                                    method='marginals')\n\n        Generate variates from a multivariate hypergeometric distribution.\n\n        The multivariate hypergeometric distribution is a generalization\n        of the hypergeometric distribution.\n\n        Choose ``nsample`` items at random without replacement from a\n        collection with ``N`` distinct types.  ``N`` is the length of\n        ``colors``, and the values in ``colors`` are the number of occurrences\n        of that type in the collection.  The total number of items in the\n        collection is ``sum(colors)``.  Each random variate generated by this\n        function is a vector of length ``N`` holding the counts of the\n        different types that occurred in the ``nsample`` items.\n\n        The name ``colors`` comes from a common description of the\n        distribution: it is the probability distribution of the number of\n        marbles of each color selected without replacement from an urn\n        containing marbles of different colors; ``colors[i]`` is the number\n        of marbles in the urn with color ``i``.",
            "parameters": {
              "nsample": {
                "type": "int",
                "description": "The number of items selected.  ``nsample`` must not be greater\n            than ``sum(colors)``."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "The number of variates to generate, either an integer or a tuple\n            holding the shape of the array of variates.  If the given size is,\n            e.g., ``(k, m)``, then ``k * m`` variates are drawn, where one\n            variate is a vector of length ``len(colors)``, and the return value\n            has shape ``(k, m, len(colors))``.  If `size` is an integer, the\n            output has shape ``(size, len(colors))``.  Default is None, in\n            which case a single variate is returned as an array with shape\n            ``(len(colors),)``."
              },
              "method": {
                "type": "string",
                "description": "Specify the algorithm that is used to generate the variates.\n            Must be 'count' or 'marginals' (the default).  See the Notes\n            for a description of the methods."
              },
              "code": {
                "type": ":",
                "description": "choices = np.repeat(np.arange(len(colors)), colors)\n            selection = np.random.choice(choices, nsample, replace=False)\n            variate = np.bincount(selection, minlength=len(colors))\n\n        The \"count\" algorithm uses a temporary array of integers with length\n        ``sum(colors)``.\n\n        The \"marginals\" algorithm generates a variate by using repeated\n        calls to the univariate hypergeometric sampler.  It is roughly\n        equivalent to::\n\n            variate = np.zeros(len(colors), dtype=np.int64)\n            # `remaining` is the cumulative sum of `colors` from the last\n            # element to the first; e.g. if `colors` is [3, 1, 5], then\n            # `remaining` is [9, 6, 5].\n            remaining = np.cumsum(colors[::-1])[::-1]\n            for i in range(len(colors)-1):\n                if nsample < 1:\n                    break\n                variate[i] = hypergeometric(colors[i], remaining[i+1],\n                                           nsample)\n                nsample -= variate[i]\n            variate[-1] = nsample\n\n        The default method is \"marginals\".  For some cases (e.g. when\n        `colors` contains relatively small integers), the \"count\" method\n        can be significantly faster than the \"marginals\" method.  If\n        performance of the algorithm is important, test the two methods\n        with typical inputs to decide which works best.\n\n        .. versionadded:: 1.18.0"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "multivariate_normal",
          "signature": "multivariate_normal(...)",
          "documentation": {
            "description": "multivariate_normal(mean, cov, size=None, check_valid='warn',\n                            tol=1e-8, *, method='svd')\n\n        Draw random samples from a multivariate normal distribution.\n\n        The multivariate normal, multinormal or Gaussian distribution is a\n        generalization of the one-dimensional normal distribution to higher\n        dimensions.  Such a distribution is specified by its mean and\n        covariance matrix.  These parameters are analogous to the mean\n        (average or \"center\") and variance (the squared standard deviation,\n        or \"width\") of the one-dimensional normal distribution.",
            "parameters": {
              "cov": {
                "type": "2-D array_like",
                "description": ", of shape (N, N)\n            Covariance matrix of the distribution. It must be symmetric and\n            positive-semidefinite for proper sampling."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Given a shape of, for example, ``(m,n,k)``, ``m*n*k`` samples are\n            generated, and packed in an `m`-by-`n`-by-`k` arrangement.  Because\n            each sample is `N`-dimensional, the output shape is ``(m,n,k,N)``.\n            If no shape is specified, a single (`N`-D) sample is returned."
              },
              "check_valid": {
                "type": "{ 'warn'",
                "description": ", 'raise', 'ignore' }, optional\n            Behavior when the covariance matrix is not positive semidefinite."
              },
              "tol": {
                "type": "float",
                "description": "Tolerance when checking the singular values in covariance matrix.\n            cov is cast to double before the check."
              },
              "method": {
                "type": "{ 'svd'",
                "description": ", 'eigh', 'cholesky'}, optional\n            The cov input is used to compute a factor matrix A such that\n            ``A @ A.T = cov``. This argument is used to select the method\n            used to compute the factor matrix A. The default method 'svd' is\n            the slowest, while 'cholesky' is the fastest but less robust than\n            the slowest method. The method `eigh` uses eigen decomposition to\n            compute A and is faster than svd but slower than cholesky.\n\n            .. versionadded:: 1.18.0"
              },
              "element": {
                "type": "math:`C_{ij}` is the covariance of :math:`x_i` and :math:`x_j`.",
                "description": "The element :math:`C_{ii}` is the variance of :math:`x_i` (i.e. its\n        \"spread\").\n\n        Instead of specifying the full covariance matrix, popular\n        approximations include:\n\n          - Spherical covariance (`cov` is a multiple of the identity matrix)\n          - Diagonal covariance (`cov` has non-negative elements, and only on\n            the diagonal)\n\n        This geometrical property can be seen in two dimensions by plotting\n        generated data-points:\n\n        >>> mean = [0, 0]\n        >>> cov = [[1, 0], [0, 100]]  # diagonal covariance\n\n        Diagonal covariance means that points are oriented along x or y-axis:\n\n        >>> import matplotlib.pyplot as plt\n        >>> x, y = np.random.default_rng().multivariate_normal(mean, cov, 5000).T\n        >>> plt.plot(x, y, 'x')\n        >>> plt.axis('equal')\n        >>> plt.show()\n\n        Note that the covariance matrix must be positive semidefinite (a.k.a.\n        nonnegative-definite). Otherwise, the behavior of this method is\n        undefined and backwards compatibility is not guaranteed.\n\n        This function internally uses linear algebra routines, and thus results\n        may not be identical (even up to precision) across architectures, OSes,\n        or even builds. For example, this is likely if ``cov`` has multiple equal\n        singular values and ``method`` is ``'svd'`` (default). In this case,\n        ``method='cholesky'`` may be more robust.\n\n        References\n        ----------\n        .. [1] Papoulis, A., \"Probability, Random Variables, and Stochastic\n               Processes,\" 3rd ed., New York: McGraw-Hill, 1991.\n        .. [2] Duda, R. O., Hart, P. E., and Stork, D. G., \"Pattern\n               Classification,\" 2nd ed., New York: Wiley, 2001."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "negative_binomial",
          "signature": "negative_binomial(...)",
          "documentation": {
            "description": "negative_binomial(n, p, size=None)\n\n        Draw samples from a negative binomial distribution.\n\n        Samples are drawn from a negative binomial distribution with specified\n        parameters, `n` successes and `p` probability of success where `n`\n        is > 0 and `p` is in the interval (0, 1].",
            "parameters": {
              "p": {
                "type": "float or array_like of floats",
                "description": "Parameter of the distribution. Must satisfy 0 < p <= 1."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``n`` and ``p`` are both scalars.\n            Otherwise, ``np.broadcast(n, p).size`` samples are drawn."
              },
              "where": {
                "type": "math:`n` is the number of successes",
                "description": ", :math:`p` is the\n        probability of success, :math:`N+n` is the number of trials, and\n        :math:`\\Gamma` is the gamma function. When :math:`n` is an integer,\n        :math:`\\frac{\\Gamma(N+n)}{N!\\Gamma(n)} = \\binom{N+n-1}{N}`, which is\n        the more common form of this term in the pmf. The negative\n        binomial distribution gives the probability of N failures given n\n        successes, with a success on the last trial.\n\n        If one throws a die repeatedly until the third time a \"1\" appears,\n        then the probability distribution of the number of non-\"1\"s that\n        appear before the third \"1\" is a negative binomial distribution.\n\n        Because this method internally calls ``Generator.poisson`` with an\n        intermediate random value, a ValueError is raised when the choice of \n        :math:`n` and :math:`p` would result in the mean + 10 sigma of the sampled\n        intermediate distribution exceeding the max acceptable value of the \n        ``Generator.poisson`` method. This happens when :math:`p` is too low \n        (a lot of failures happen for every success) and :math:`n` is too big (\n        a lot of successes are allowed).\n        Therefore, the :math:`n` and :math:`p` values must satisfy the constraint:\n\n        .. math:: n\\frac{1-p}{p}+10n\\sqrt{n}\\frac{1-p}{p}<2^{63}-1-10\\sqrt{2^{63}-1},\n\n        Where the left side of the equation is the derived mean + 10 sigma of\n        a sample from the gamma distribution internally used as the :math:`lam`\n        parameter of a poisson sample, and the right side of the equation is\n        the constraint for maximum value of :math:`lam` in ``Generator.poisson``.\n\n        References\n        ----------\n        .. [1] Weisstein, Eric W. \"Negative Binomial Distribution.\" From\n               MathWorld--A Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/NegativeBinomialDistribution.html",
                "description": ".. [2] Wikipedia, \"Negative binomial distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Negative_binomial_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "noncentral_chisquare",
          "signature": "noncentral_chisquare(...)",
          "documentation": {
            "description": "noncentral_chisquare(df, nonc, size=None)\n\n        Draw samples from a noncentral chi-square distribution.\n\n        The noncentral :math:`\\chi^2` distribution is a generalization of\n        the :math:`\\chi^2` distribution.",
            "parameters": {
              "nonc": {
                "type": "float or array_like of floats",
                "description": "Non-centrality, must be non-negative."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``df`` and ``nonc`` are both scalars.\n            Otherwise, ``np.broadcast(df, nonc).size`` samples are drawn."
              },
              "where": {
                "type": "math:`Y_{q}` is the Chi-square with q degrees of freedom.",
                "description": "References\n        ----------\n        .. [1] Wikipedia, \"Noncentral chi-squared distribution\""
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Noncentral_chi-squared_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "noncentral_f",
          "signature": "noncentral_f(...)",
          "documentation": {
            "description": "noncentral_f(dfnum, dfden, nonc, size=None)\n\n        Draw samples from the noncentral F distribution.\n\n        Samples are drawn from an F distribution with specified parameters,\n        `dfnum` (degrees of freedom in numerator) and `dfden` (degrees of\n        freedom in denominator), where both parameters > 1.\n        `nonc` is the non-centrality parameter.",
            "parameters": {
              "dfden": {
                "type": "float or array_like of floats",
                "description": "Denominator degrees of freedom, must be > 0."
              },
              "nonc": {
                "type": "float or array_like of floats",
                "description": "Non-centrality parameter, the sum of the squares of the numerator\n            means, must be >= 0."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``dfnum``, ``dfden``, and ``nonc``\n            are all scalars.  Otherwise, ``np.broadcast(dfnum, dfden, nonc).size``\n            samples are drawn."
              },
              "http": {
                "type": "//mathworld.wolfram.com/NoncentralF-Distribution.html",
                "description": ".. [2] Wikipedia, \"Noncentral F-distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Noncentral_F-distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "normal",
          "signature": "normal(...)",
          "documentation": {
            "description": "normal(loc=0.0, scale=1.0, size=None)\n\n        Draw random samples from a normal (Gaussian) distribution.\n\n        The probability density function of the normal distribution, first\n        derived by De Moivre and 200 years later by both Gauss and Laplace\n        independently [2]_, is often called the bell curve because of\n        its characteristic shape (see the example below).\n\n        The normal distributions occurs often in nature.  For example, it\n        describes the commonly occurring distribution of samples influenced\n        by a large number of tiny, random disturbances, each with its own\n        unique distribution [2]_.",
            "parameters": {
              "scale": {
                "type": "float or array_like of floats",
                "description": "Standard deviation (spread or \"width\") of the distribution. Must be\n            non-negative."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``loc`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn."
              },
              "where": {
                "type": "math:`\\mu` is the mean and :math:`\\sigma` the standard",
                "description": "deviation. The square of the standard deviation, :math:`\\sigma^2`,\n        is called the variance.\n\n        The function has its peak at the mean, and its \"spread\" increases with\n        the standard deviation (the function reaches 0.607 times its maximum at\n        :math:`x + \\sigma` and :math:`x - \\sigma` [2]_).  This implies that\n        :meth:`normal` is more likely to return samples lying close to the\n        mean, rather than those far away.\n\n        References\n        ----------\n        .. [1] Wikipedia, \"Normal distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Normal_distribution",
                "description": ".. [2] P. R. Peebles Jr., \"Central Limit Theorem\" in \"Probability,\n               Random Variables and Random Signal Principles\", 4th ed., 2001,\n               pp. 51, 51, 125."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "pareto",
          "signature": "pareto(...)",
          "documentation": {
            "description": "pareto(a, size=None)\n\n        Draw samples from a Pareto II or Lomax distribution with\n        specified shape.\n\n        The Lomax or Pareto II distribution is a shifted Pareto\n        distribution. The classical Pareto distribution can be\n        obtained from the Lomax distribution by adding 1 and\n        multiplying by the scale parameter ``m`` (see Notes).  The\n        smallest value of the Lomax distribution is zero while for the\n        classical Pareto distribution it is ``mu``, where the standard\n        Pareto distribution has location ``mu = 1``.  Lomax can also\n        be considered as a simplified version of the Generalized\n        Pareto distribution (available in SciPy), with the scale set\n        to one and the location set to zero.\n\n        The Pareto distribution must be greater than zero, and is\n        unbounded above.  It is also known as the \"80-20 rule\".  In\n        this distribution, 80 percent of the weights are in the lowest\n        20 percent of the range, while the other 20 percent fill the\n        remaining 80 percent of the range.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` is a scalar.  Otherwise,\n            ``np.array(a).size`` samples are drawn."
              },
              "where": {
                "type": "math:`a` is the shape and :math:`m` the scale.",
                "description": "The Pareto distribution, named after the Italian economist\n        Vilfredo Pareto, is a power law probability distribution\n        useful in many real world problems.  Outside the field of\n        economics it is generally referred to as the Bradford\n        distribution. Pareto developed the distribution to describe\n        the distribution of wealth in an economy.  It has also found\n        use in insurance, web page access statistics, oil field sizes,\n        and many other problems, including the download frequency for\n        projects in Sourceforge [1]_.  It is one of the so-called\n        \"fat-tailed\" distributions.\n\n\n        References\n        ----------\n        .. [1] Francis Hunt and Paul Johnson, On the Pareto Distribution of\n               Sourceforge projects.\n        .. [2] Pareto, V. (1896). Course of Political Economy. Lausanne.\n        .. [3] Reiss, R.D., Thomas, M.(2001), Statistical Analysis of Extreme\n               Values, Birkhauser Verlag, Basel, pp 23-30.\n        .. [4] Wikipedia, \"Pareto distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Pareto_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "permutation",
          "signature": "permutation(...)",
          "documentation": {
            "description": "permutation(x, axis=0)\n\n        Randomly permute a sequence, or return a permuted range.",
            "parameters": {
              "axis": {
                "type": "int",
                "description": "The axis which `x` is shuffled along. Default is 0."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "permuted",
          "signature": "permuted(...)",
          "documentation": {
            "description": "permuted(x, axis=None, out=None)\n\n        Randomly permute `x` along axis `axis`.\n\n        Unlike `shuffle`, each slice along the given axis is shuffled\n        independently of the others.",
            "parameters": {
              "axis": {
                "type": "int",
                "description": "Slices of `x` in this axis are shuffled. Each slice\n            is shuffled independently of the others.  If `axis` is\n            None, the flattened array is shuffled."
              },
              "out": {
                "type": "ndarray",
                "description": "If given, this is the destination of the shuffled array.\n            If `out` is None, a shuffled copy of the array is returned."
              },
              "parameter": {
                "type": ">>> y = rng.permuted(x",
                "description": ", axis=1, out=x)\n        >>> x\n        array([[ 3,  0,  4,  7,  1,  6,  2,  5],  # random\n               [ 8, 14, 13,  9, 12, 11, 15, 10],\n               [17, 18, 16, 22, 19, 23, 20, 21]])\n\n        Note that when the ``out`` parameter is given, the return\n        value is ``out``:\n\n        >>> y is x\n        True"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "poisson",
          "signature": "poisson(...)",
          "documentation": {
            "description": "poisson(lam=1.0, size=None)\n\n        Draw samples from a Poisson distribution.\n\n        The Poisson distribution is the limit of the binomial distribution\n        for large N.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``lam`` is a scalar. Otherwise,\n            ``np.array(lam).size`` samples are drawn."
              },
              "distribution": {
                "type": "math:`f(k; \\lambda)` describes the probability of",
                "description": ":math:`k` events occurring within the observed"
              },
              "interval": {
                "type": "math:`\\lambda`.",
                "description": "Because the output is limited to the range of the C int64 type, a\n        ValueError is raised when `lam` is within 10 sigma of the maximum\n        representable value.\n\n        References\n        ----------\n        .. [1] Weisstein, Eric W. \"Poisson Distribution.\"\n               From MathWorld--A Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/PoissonDistribution.html",
                "description": ".. [2] Wikipedia, \"Poisson distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Poisson_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "power",
          "signature": "power(...)",
          "documentation": {
            "description": "power(a, size=None)\n\n        Draws samples in [0, 1] from a power distribution with positive\n        exponent a - 1.\n\n        Also known as the power function distribution.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` is a scalar.  Otherwise,\n            ``np.array(a).size`` samples are drawn."
              },
              "https": {
                "type": "//www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "random",
          "signature": "random(...)",
          "documentation": {
            "description": "random(size=None, dtype=np.float64, out=None)\n\n        Return random floats in the half-open interval [0.0, 1.0).\n\n        Results are from the \"continuous uniform\" distribution over the\n        stated interval.  To sample :math:`Unif[a, b), b > a` use `uniform`\n        or multiply the output of `random` by ``(b - a)`` and add ``a``::\n\n            (b - a) * random() + a",
            "parameters": {
              "dtype": {
                "type": "dtype",
                "description": "Desired dtype of the result, only `float64` and `float32` are supported.\n            Byteorder must be native. The default value is np.float64."
              },
              "out": {
                "type": "ndarray",
                "description": "Alternative output array in which to place the result. If size is not None,\n            it must have the same shape as the provided size and must match the type of\n            the output values."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rayleigh",
          "signature": "rayleigh(...)",
          "documentation": {
            "description": "rayleigh(scale=1.0, size=None)\n\n        Draw samples from a Rayleigh distribution.\n\n        The :math:`\\chi` and Weibull distributions are generalizations of the\n        Rayleigh.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``scale`` is a scalar.  Otherwise,\n            ``np.array(scale).size`` samples are drawn."
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Rayleigh_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "shuffle",
          "signature": "shuffle(...)",
          "documentation": {
            "description": "shuffle(x, axis=0)\n\n        Modify an array or sequence in-place by shuffling its contents.\n\n        The order of sub-arrays is changed but their contents remains the same.",
            "parameters": {
              "axis": {
                "type": "int",
                "description": "The axis which `x` is shuffled along. Default is 0.\n            It is only supported on `ndarray` objects."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "spawn",
          "signature": "spawn(...)",
          "documentation": {
            "description": "spawn(n_children)\n\n        Create new independent child generators.\n\n        See :ref:`seedsequence-spawn` for additional notes on spawning\n        children.\n\n        .. versionadded:: 1.25.0",
            "parameters": {
              "bit_generator": {
                "type": "The bit generator instance used by the generator.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "standard_cauchy",
          "signature": "standard_cauchy(...)",
          "documentation": {
            "description": "standard_cauchy(size=None)\n\n        Draw samples from a standard Cauchy distribution with mode = 0.\n\n        Also known as the Lorentz distribution.",
            "parameters": {
              "https": {
                "type": "//en.wikipedia.org/wiki/Cauchy_distribution",
                "description": ""
              },
              "http": {
                "type": "//mathworld.wolfram.com/CauchyDistribution.html",
                "description": ".. [3] Wikipedia, \"Cauchy distribution\""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "standard_exponential",
          "signature": "standard_exponential(...)",
          "documentation": {
            "description": "standard_exponential(size=None, dtype=np.float64, method='zig', out=None)\n\n        Draw samples from the standard exponential distribution.\n\n        `standard_exponential` is identical to the exponential distribution\n        with a scale parameter of 1.",
            "parameters": {
              "dtype": {
                "type": "dtype",
                "description": "Desired dtype of the result, only `float64` and `float32` are supported.\n            Byteorder must be native. The default value is np.float64."
              },
              "method": {
                "type": "str",
                "description": "Either 'inv' or 'zig'. 'inv' uses the default inverse CDF method.\n            'zig' uses the much faster Ziggurat method of Marsaglia and Tsang."
              },
              "out": {
                "type": "ndarray",
                "description": "Alternative output array in which to place the result. If size is not None,\n            it must have the same shape as the provided size and must match the type of\n            the output values."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "standard_gamma",
          "signature": "standard_gamma(...)",
          "documentation": {
            "description": "standard_gamma(shape, size=None, dtype=np.float64, out=None)\n\n        Draw samples from a standard Gamma distribution.\n\n        Samples are drawn from a Gamma distribution with specified parameters,\n        shape (sometimes designated \"k\") and scale=1.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``shape`` is a scalar.  Otherwise,\n            ``np.array(shape).size`` samples are drawn."
              },
              "dtype": {
                "type": "dtype",
                "description": "Desired dtype of the result, only `float64` and `float32` are supported.\n            Byteorder must be native. The default value is np.float64."
              },
              "out": {
                "type": "ndarray",
                "description": "Alternative output array in which to place the result. If size is\n            not None, it must have the same shape as the provided size and\n            must match the type of the output values."
              },
              "where": {
                "type": "math:`k` is the shape and :math:`\\theta` the scale",
                "description": ","
              },
              "and": {
                "type": "math:`\\Gamma` is the Gamma function.",
                "description": "The Gamma distribution is often used to model the times to failure of\n        electronic components, and arises naturally in processes for which the\n        waiting times between Poisson distributed events are relevant.\n\n        References\n        ----------\n        .. [1] Weisstein, Eric W. \"Gamma Distribution.\" From MathWorld--A\n               Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/GammaDistribution.html",
                "description": ".. [2] Wikipedia, \"Gamma distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Gamma_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "standard_normal",
          "signature": "standard_normal(...)",
          "documentation": {
            "description": "standard_normal(size=None, dtype=np.float64, out=None)\n\n        Draw samples from a standard Normal distribution (mean=0, stdev=1).",
            "parameters": {
              "dtype": {
                "type": "dtype",
                "description": "Desired dtype of the result, only `float64` and `float32` are supported.\n            Byteorder must be native. The default value is np.float64."
              },
              "out": {
                "type": "ndarray",
                "description": "Alternative output array in which to place the result. If size is not None,\n            it must have the same shape as the provided size and must match the type of\n            the output values."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "standard_t",
          "signature": "standard_t(...)",
          "documentation": {
            "description": "standard_t(df, size=None)\n\n        Draw samples from a standard Student's t distribution with `df` degrees\n        of freedom.\n\n        A special case of the hyperbolic distribution.  As `df` gets\n        large, the result resembles that of the standard normal\n        distribution (`standard_normal`).",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``df`` is a scalar.  Otherwise,\n            ``np.array(df).size`` samples are drawn."
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Student's_t-distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "triangular",
          "signature": "triangular(...)",
          "documentation": {
            "description": "triangular(left, mode, right, size=None)\n\n        Draw samples from the triangular distribution over the\n        interval ``[left, right]``.\n\n        The triangular distribution is a continuous probability\n        distribution with lower limit left, peak at mode, and upper\n        limit right. Unlike the other distributions, these parameters\n        directly define the shape of the pdf.",
            "parameters": {
              "mode": {
                "type": "float or array_like of floats",
                "description": "The value where the peak of the distribution occurs.\n            The value must fulfill the condition ``left <= mode <= right``."
              },
              "right": {
                "type": "float or array_like of floats",
                "description": "Upper limit, must be larger than `left`."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``left``, ``mode``, and ``right``\n            are all scalars.  Otherwise, ``np.broadcast(left, mode, right).size``\n            samples are drawn."
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Triangular_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "uniform",
          "signature": "uniform(...)",
          "documentation": {
            "description": "uniform(low=0.0, high=1.0, size=None)\n\n        Draw samples from a uniform distribution.\n\n        Samples are uniformly distributed over the half-open interval\n        ``[low, high)`` (includes low, but excludes high).  In other words,\n        any value within the given interval is equally likely to be drawn\n        by `uniform`.",
            "parameters": {
              "high": {
                "type": "float or array_like of floats",
                "description": "Upper boundary of the output interval.  All values generated will be\n            less than high.  The high limit may be included in the returned array of \n            floats due to floating-point rounding in the equation \n            ``low + (high-low) * random_sample()``.  high - low must be \n            non-negative.  The default value is 1.0."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``low`` and ``high`` are both scalars.\n            Otherwise, ``np.broadcast(low, high).size`` samples are drawn."
              },
              "random": {
                "type": "Floats uniformly distributed over ``[0",
                "description": ", 1)``."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "vonmises",
          "signature": "vonmises(...)",
          "documentation": {
            "description": "vonmises(mu, kappa, size=None)\n\n        Draw samples from a von Mises distribution.\n\n        Samples are drawn from a von Mises distribution with specified mode\n        (mu) and dispersion (kappa), on the interval [-pi, pi].\n\n        The von Mises distribution (also known as the circular normal\n        distribution) is a continuous probability distribution on the unit\n        circle.  It may be thought of as the circular analogue of the normal\n        distribution.",
            "parameters": {
              "kappa": {
                "type": "float or array_like of floats",
                "description": "Dispersion of the distribution, has to be >=0."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``mu`` and ``kappa`` are both scalars.\n            Otherwise, ``np.broadcast(mu, kappa).size`` samples are drawn."
              },
              "where": {
                "type": "math:`\\mu` is the mode and :math:`\\kappa` the dispersion",
                "description": ","
              },
              "and": {
                "type": "math:`I_0(\\kappa)` is the modified Bessel function of order 0.",
                "description": "The von Mises is named for Richard Edler von Mises, who was born in\n        Austria-Hungary, in what is now the Ukraine.  He fled to the United\n        States in 1939 and became a professor at Harvard.  He worked in\n        probability theory, aerodynamics, fluid mechanics, and philosophy of\n        science.\n\n        References\n        ----------\n        .. [1] Abramowitz, M. and Stegun, I. A. (Eds.). \"Handbook of\n               Mathematical Functions with Formulas, Graphs, and Mathematical\n               Tables, 9th printing,\" New York: Dover, 1972.\n        .. [2] von Mises, R., \"Mathematical Theory of Probability\n               and Statistics\", New York: Academic Press, 1964."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "wald",
          "signature": "wald(...)",
          "documentation": {
            "description": "wald(mean, scale, size=None)\n\n        Draw samples from a Wald, or inverse Gaussian, distribution.\n\n        As the scale approaches infinity, the distribution becomes more like a\n        Gaussian. Some references claim that the Wald is an inverse Gaussian\n        with mean equal to 1, but this is by no means universal.\n\n        The inverse Gaussian distribution was first studied in relationship to\n        Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian\n        because there is an inverse relationship between the time to cover a\n        unit distance and distance covered in unit time.",
            "parameters": {
              "scale": {
                "type": "float or array_like of floats",
                "description": "Scale parameter, must be > 0."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``mean`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(mean, scale).size`` samples are drawn."
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Inverse_Gaussian_distribution",
                "description": ""
              },
              "Distribution": {
                "type": "Theory : Methodology",
                "description": ", and Applications\", CRC Press,\n               1988.\n        .. [3] Wikipedia, \"Inverse Gaussian distribution\""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "weibull",
          "signature": "weibull(...)",
          "documentation": {
            "description": "weibull(a, size=None)\n\n        Draw samples from a Weibull distribution.\n\n        Draw samples from a 1-parameter Weibull distribution with the given\n        shape parameter `a`.\n\n        .. math:: X = (-ln(U))^{1/a}\n\n        Here, U is drawn from the uniform distribution over (0,1].\n\n        The more common 2-parameter Weibull, including a scale parameter\n        :math:`\\lambda` is just :math:`X = \\lambda(-ln(U))^{1/a}`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` is a scalar.  Otherwise,\n            ``np.array(a).size`` samples are drawn."
              },
              "where": {
                "type": "math:`a` is the shape and :math:`\\lambda` the scale.",
                "description": "The function has its peak (the mode) at\n        :math:`\\lambda(\\frac{a-1}{a})^{1/a}`.\n\n        When ``a = 1``, the Weibull distribution reduces to the exponential\n        distribution.\n\n        References\n        ----------\n        .. [1] Waloddi Weibull, Royal Technical University, Stockholm,\n               1939 \"A Statistical Theory Of The Strength Of Materials\",\n               Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939,\n               Generalstabens Litografiska Anstalts Forlag, Stockholm.\n        .. [2] Waloddi Weibull, \"A Statistical Distribution Function of\n               Wide Applicability\", Journal Of Applied Mechanics ASME Paper\n               1951.\n        .. [3] Wikipedia, \"Weibull distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Weibull_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "zipf",
          "signature": "zipf(...)",
          "documentation": {
            "description": "zipf(a, size=None)\n\n        Draw samples from a Zipf distribution.\n\n        Samples are drawn from a Zipf distribution with specified parameter\n        `a` > 1.\n\n        The Zipf distribution (also known as the zeta distribution) is a\n        discrete probability distribution that satisfies Zipf's law: the\n        frequency of an item is inversely proportional to its rank in a\n        frequency table.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` is a scalar. Otherwise,\n            ``np.array(a).size`` samples are drawn."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "MT19937",
      "documentation": {
        "description": "MT19937(seed=None)\n\n    Container for the Mersenne Twister pseudo-random number generator.",
        "parameters": {
          "lock": {
            "type": "threading.Lock",
            "description": "Lock instance that is shared so that the same bit git generator can\n        be used in multiple Generators without corrupting the state. Code that\n        generates values from a bit generator should hold the bit generator's\n        lock."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "jumped",
          "signature": "jumped(...)",
          "documentation": {
            "description": "jumped(jumps=1)\n\n        Returns a new bit generator with the state jumped\n\n        The state of the returned bit generator is jumped as-if\n        2**(128 * jumps) random numbers have been generated.",
            "parameters": {
              "http": {
                "type": "//www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/JUMP/",
                "description": ".. [2] Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, François\n           Panneton, Pierre L'Ecuyer, \"Efficient Jump Ahead for F2-Linear\n           Random Number Generators\", INFORMS JOURNAL ON COMPUTING, Vol. 20,\n           No. 3, Summer 2008, pp. 385-390."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "random_raw",
          "signature": "random_raw(...)",
          "documentation": {
            "description": "random_raw(self, size=None)\n\n        Return randoms as generated by the underlying BitGenerator",
            "parameters": {
              "output": {
                "type": "bool",
                "description": "Output values.  Used for performance testing since the generated\n            values are not returned."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "spawn",
          "signature": "spawn(...)",
          "documentation": {
            "description": "spawn(n_children)\n\n        Create new independent child bit generators.\n\n        See :ref:`seedsequence-spawn` for additional notes on spawning\n        children.  Some bit generators also implement ``jumped``\n        as a different approach for creating independent streams.\n\n        .. versionadded:: 1.25.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "PCG64",
      "documentation": {
        "description": "PCG64(seed=None)\n\n    BitGenerator for the PCG-64 pseudo-random number generator.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "advance",
          "signature": "advance(...)",
          "documentation": {
            "description": "advance(delta)\n\n        Advance the underlying RNG as-if delta draws have occurred.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "jumped",
          "signature": "jumped(...)",
          "documentation": {
            "description": "jumped(jumps=1)\n\n        Returns a new bit generator with the state jumped.\n\n        Jumps the state as-if jumps * 210306068529402873165736369884012333109\n        random numbers have been generated.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "random_raw",
          "signature": "random_raw(...)",
          "documentation": {
            "description": "random_raw(self, size=None)\n\n        Return randoms as generated by the underlying BitGenerator",
            "parameters": {
              "output": {
                "type": "bool",
                "description": "Output values.  Used for performance testing since the generated\n            values are not returned."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "spawn",
          "signature": "spawn(...)",
          "documentation": {
            "description": "spawn(n_children)\n\n        Create new independent child bit generators.\n\n        See :ref:`seedsequence-spawn` for additional notes on spawning\n        children.  Some bit generators also implement ``jumped``\n        as a different approach for creating independent streams.\n\n        .. versionadded:: 1.25.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "PCG64DXSM",
      "documentation": {
        "description": "PCG64DXSM(seed=None)\n\n    BitGenerator for the PCG-64 DXSM pseudo-random number generator.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "advance",
          "signature": "advance(...)",
          "documentation": {
            "description": "advance(delta)\n\n        Advance the underlying RNG as-if delta draws have occurred.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "jumped",
          "signature": "jumped(...)",
          "documentation": {
            "description": "jumped(jumps=1)\n\n        Returns a new bit generator with the state jumped.\n\n        Jumps the state as-if jumps * 210306068529402873165736369884012333109\n        random numbers have been generated.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "random_raw",
          "signature": "random_raw(...)",
          "documentation": {
            "description": "random_raw(self, size=None)\n\n        Return randoms as generated by the underlying BitGenerator",
            "parameters": {
              "output": {
                "type": "bool",
                "description": "Output values.  Used for performance testing since the generated\n            values are not returned."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "spawn",
          "signature": "spawn(...)",
          "documentation": {
            "description": "spawn(n_children)\n\n        Create new independent child bit generators.\n\n        See :ref:`seedsequence-spawn` for additional notes on spawning\n        children.  Some bit generators also implement ``jumped``\n        as a different approach for creating independent streams.\n\n        .. versionadded:: 1.25.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "Philox",
      "documentation": {
        "description": "Philox(seed=None, counter=None, key=None)\n\n    Container for the Philox (4x64) pseudo-random number generator.",
        "parameters": {
          "counter": {
            "type": "{None",
            "description": ", int, array_like}, optional\n        Counter to use in the Philox state. Can be either\n        a Python int (long in 2.x) in [0, 2**256) or a 4-element uint64 array.\n        If not provided, the RNG is initialized at 0."
          },
          "key": {
            "type": "{None",
            "description": ", int, array_like}, optional\n        Key to use in the Philox state.  Unlike ``seed``, the value in key is\n        directly set. Can be either a Python int in [0, 2**128) or a 2-element\n        uint64 array. `key` and ``seed`` cannot both be used.\n\n    Attributes\n    ----------"
          },
          "lock": {
            "type": "threading.Lock",
            "description": "Lock instance that is shared so that the same bit git generator can\n        be used in multiple Generators without corrupting the state. Code that\n        generates values from a bit generator should hold the bit generator's\n        lock."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "advance",
          "signature": "advance(...)",
          "documentation": {
            "description": "advance(delta)\n\n        Advance the underlying RNG as-if delta draws have occurred.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "jumped",
          "signature": "jumped(...)",
          "documentation": {
            "description": "jumped(jumps=1)\n\n        Returns a new bit generator with the state jumped\n\n        The state of the returned bit generator is jumped as-if\n        (2**128) * jumps random numbers have been generated.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "random_raw",
          "signature": "random_raw(...)",
          "documentation": {
            "description": "random_raw(self, size=None)\n\n        Return randoms as generated by the underlying BitGenerator",
            "parameters": {
              "output": {
                "type": "bool",
                "description": "Output values.  Used for performance testing since the generated\n            values are not returned."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "spawn",
          "signature": "spawn(...)",
          "documentation": {
            "description": "spawn(n_children)\n\n        Create new independent child bit generators.\n\n        See :ref:`seedsequence-spawn` for additional notes on spawning\n        children.  Some bit generators also implement ``jumped``\n        as a different approach for creating independent streams.\n\n        .. versionadded:: 1.25.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "RandomState",
      "documentation": {
        "description": "RandomState(seed=None)\n\n    Container for the slow Mersenne Twister pseudo-random number generator.\n    Consider using a different BitGenerator with the Generator container\n    instead.\n\n    `RandomState` and `Generator` expose a number of methods for generating\n    random numbers drawn from a variety of probability distributions. In\n    addition to the distribution-specific arguments, each method takes a\n    keyword argument `size` that defaults to ``None``. If `size` is ``None``,\n    then a single value is generated and returned. If `size` is an integer,\n    then a 1-D array filled with generated values is returned. If `size` is a\n    tuple, then an array with that shape is filled and returned.\n\n    **Compatibility Guarantee**\n\n    A fixed bit generator using a fixed seed and a fixed series of calls to\n    'RandomState' methods using the same parameters will always produce the\n    same results up to roundoff error except when the values were incorrect.\n    `RandomState` is effectively frozen and will only receive updates that\n    are required by changes in the internals of Numpy. More substantial\n    changes, including algorithmic improvements, are reserved for\n    `Generator`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "beta",
          "signature": "beta(...)",
          "documentation": {
            "description": "beta(a, b, size=None)\n\n        Draw samples from a Beta distribution.\n\n        The Beta distribution is a special case of the Dirichlet distribution,\n        and is related to the Gamma distribution.  It has the probability\n        distribution function\n\n        .. math:: f(x; a,b) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1}\n                                                         (1 - x)^{\\beta - 1},\n\n        where the normalization, B, is the beta function,\n\n        .. math:: B(\\alpha, \\beta) = \\int_0^1 t^{\\alpha - 1}\n                                     (1 - t)^{\\beta - 1} dt.\n\n        It is often seen in Bayesian inference and order statistics.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.beta`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "b": {
                "type": "float or array_like of floats",
                "description": "Beta, positive (>0)."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` and ``b`` are both scalars.\n            Otherwise, ``np.broadcast(a, b).size`` samples are drawn."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "binomial",
          "signature": "binomial(...)",
          "documentation": {
            "description": "binomial(n, p, size=None)\n\n        Draw samples from a binomial distribution.\n\n        Samples are drawn from a binomial distribution with specified\n        parameters, n trials and p probability of success where\n        n an integer >= 0 and p is in the interval [0,1]. (n may be\n        input as a float, but it is truncated to an integer in use)\n\n        .. note::\n            New code should use the `~numpy.random.Generator.binomial`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "p": {
                "type": "float or array_like of floats",
                "description": "Parameter of the distribution, >= 0 and <=1."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``n`` and ``p`` are both scalars.\n            Otherwise, ``np.broadcast(n, p).size`` samples are drawn."
              },
              "where": {
                "type": "math:`n` is the number of trials",
                "description": ", :math:`p` is the probability\n        of success, and :math:`N` is the number of successes.\n\n        When estimating the standard error of a proportion in a population by\n        using a random sample, the normal distribution works well unless the\n        product p*n <=5, where p = population proportion estimate, and n =\n        number of samples, in which case the binomial distribution is used\n        instead. For example, a sample of 15 people shows 4 who are left\n        handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,\n        so the binomial distribution should be used in this case.\n\n        References\n        ----------\n        .. [1] Dalgaard, Peter, \"Introductory Statistics with R\",\n               Springer-Verlag, 2002.\n        .. [2] Glantz, Stanton A. \"Primer of Biostatistics.\", McGraw-Hill,\n               Fifth Edition, 2002.\n        .. [3] Lentner, Marvin, \"Elementary Applied Statistics\", Bogden\n               and Quigley, 1972.\n        .. [4] Weisstein, Eric W. \"Binomial Distribution.\" From MathWorld--A\n               Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/BinomialDistribution.html",
                "description": ".. [5] Wikipedia, \"Binomial distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Binomial_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bytes",
          "signature": "bytes(...)",
          "documentation": {
            "description": "bytes(length)\n\n        Return random bytes.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.bytes`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "chisquare",
          "signature": "chisquare(...)",
          "documentation": {
            "description": "chisquare(df, size=None)\n\n        Draw samples from a chi-square distribution.\n\n        When `df` independent random variables, each with standard normal\n        distributions (mean 0, variance 1), are squared and summed, the\n        resulting distribution is chi-square (see Notes).  This distribution\n        is often used in hypothesis testing.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.chisquare`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``df`` is a scalar.  Otherwise,\n            ``np.array(df).size`` samples are drawn."
              },
              "where": {
                "type": "math:`\\Gamma` is the gamma function",
                "description": ",\n\n        .. math:: \\Gamma(x) = \\int_0^{-\\infty} t^{x - 1} e^{-t} dt.\n\n        References\n        ----------\n        .. [1] NIST \"Engineering Statistics Handbook\""
              },
              "https": {
                "type": "//www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choice",
          "signature": "choice(...)",
          "documentation": {
            "description": "choice(a, size=None, replace=True, p=None)\n\n        Generates a random sample from a given 1-D array\n\n        .. versionadded:: 1.7.0\n\n        .. note::\n            New code should use the `~numpy.random.Generator.choice`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned."
              },
              "replace": {
                "type": "boolean",
                "description": "Whether the sample is with or without replacement. Default is True,\n            meaning that a value of ``a`` can be selected multiple times."
              },
              "p": {
                "type": "1-D array-like",
                "description": "The probabilities associated with each entry in a.\n            If not given, the sample assumes a uniform distribution over all\n            entries in ``a``."
              },
              "replacement": {
                "type": ">>> np.random.choice(5",
                "description": ", 3, replace=False)\n        array([3,1,0]) # random\n        >>> #This is equivalent to np.random.permutation(np.arange(5))[:3]\n\n        Generate a non-uniform random sample from np.arange(5) of size\n        3 without replacement:\n\n        >>> np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])\n        array([2, 3, 0]) # random\n\n        Any of the above can be repeated with an arbitrary array-like\n        instead of just integers. For instance:\n\n        >>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']\n        >>> np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])\n        array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random\n              dtype='<U11')"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dirichlet",
          "signature": "dirichlet(...)",
          "documentation": {
            "description": "dirichlet(alpha, size=None)\n\n        Draw samples from the Dirichlet distribution.\n\n        Draw `size` samples of dimension k from a Dirichlet distribution. A\n        Dirichlet-distributed random variable can be seen as a multivariate\n        generalization of a Beta distribution. The Dirichlet distribution\n        is a conjugate prior of a multinomial distribution in Bayesian\n        inference.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.dirichlet`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            vector of length ``k`` is returned."
              },
              "where": {
                "type": "math:`\\alpha` is a vector containing the positive",
                "description": "concentration parameters.\n\n        The method uses the following property for computation: let :math:`Y`\n        be a random vector which has components that follow a standard gamma\n        distribution, then :math:`X = \\frac{1}{\\sum_{i=1}^k{Y_i}} Y`\n        is Dirichlet-distributed\n\n        References\n        ----------\n        .. [1] David McKay, \"Information Theory, Inference and Learning\n               Algorithms,\" chapter 23,"
              },
              "http": {
                "type": "//www.inference.org.uk/mackay/itila/",
                "description": ".. [2] Wikipedia, \"Dirichlet distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Dirichlet_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "exponential",
          "signature": "exponential(...)",
          "documentation": {
            "description": "exponential(scale=1.0, size=None)\n\n        Draw samples from an exponential distribution.\n\n        Its probability density function is\n\n        .. math:: f(x; \\frac{1}{\\beta}) = \\frac{1}{\\beta} \\exp(-\\frac{x}{\\beta}),\n\n        for ``x > 0`` and 0 elsewhere. :math:`\\beta` is the scale parameter,\n        which is the inverse of the rate parameter :math:`\\lambda = 1/\\beta`.\n        The rate parameter is an alternative, widely used parameterization\n        of the exponential distribution [3]_.\n\n        The exponential distribution is a continuous analogue of the\n        geometric distribution.  It describes many common situations, such as\n        the size of raindrops measured over many rainstorms [1]_, or the time\n        between page requests to Wikipedia [2]_.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.exponential`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``scale`` is a scalar.  Otherwise,\n            ``np.array(scale).size`` samples are drawn."
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Exponential_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "f",
          "signature": "f(...)",
          "documentation": {
            "description": "f(dfnum, dfden, size=None)\n\n        Draw samples from an F distribution.\n\n        Samples are drawn from an F distribution with specified parameters,\n        `dfnum` (degrees of freedom in numerator) and `dfden` (degrees of\n        freedom in denominator), where both parameters must be greater than\n        zero.\n\n        The random variate of the F distribution (also known as the\n        Fisher distribution) is a continuous probability distribution\n        that arises in ANOVA tests, and is the ratio of two chi-square\n        variates.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.f`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "dfden": {
                "type": "float or array_like of float",
                "description": "Degrees of freedom in denominator, must be > 0."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``dfnum`` and ``dfden`` are both scalars.\n            Otherwise, ``np.broadcast(dfnum, dfden).size`` samples are drawn."
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/F-distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "gamma",
          "signature": "gamma(...)",
          "documentation": {
            "description": "gamma(shape, scale=1.0, size=None)\n\n        Draw samples from a Gamma distribution.\n\n        Samples are drawn from a Gamma distribution with specified parameters,\n        `shape` (sometimes designated \"k\") and `scale` (sometimes designated\n        \"theta\"), where both parameters are > 0.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.gamma`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "scale": {
                "type": "float or array_like of floats",
                "description": "The scale of the gamma distribution. Must be non-negative.\n            Default is equal to 1."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``shape`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(shape, scale).size`` samples are drawn."
              },
              "where": {
                "type": "math:`k` is the shape and :math:`\\theta` the scale",
                "description": ","
              },
              "and": {
                "type": "math:`\\Gamma` is the Gamma function.",
                "description": "The Gamma distribution is often used to model the times to failure of\n        electronic components, and arises naturally in processes for which the\n        waiting times between Poisson distributed events are relevant.\n\n        References\n        ----------\n        .. [1] Weisstein, Eric W. \"Gamma Distribution.\" From MathWorld--A\n               Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/GammaDistribution.html",
                "description": ".. [2] Wikipedia, \"Gamma distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Gamma_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "geometric",
          "signature": "geometric(...)",
          "documentation": {
            "description": "geometric(p, size=None)\n\n        Draw samples from the geometric distribution.\n\n        Bernoulli trials are experiments with one of two outcomes:\n        success or failure (an example of such an experiment is flipping\n        a coin).  The geometric distribution models the number of trials\n        that must be run in order to achieve success.  It is therefore\n        supported on the positive integers, ``k = 1, 2, ...``.\n\n        The probability mass function of the geometric distribution is\n\n        .. math:: f(k) = (1 - p)^{k - 1} p\n\n        where `p` is the probability of success of an individual trial.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.geometric`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``p`` is a scalar.  Otherwise,\n            ``np.array(p).size`` samples are drawn."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_state",
          "signature": "get_state(...)",
          "documentation": {
            "description": "get_state(legacy=True)\n\n        Return a tuple representing the internal state of the generator.\n\n        For more details, see `set_state`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "gumbel",
          "signature": "gumbel(...)",
          "documentation": {
            "description": "gumbel(loc=0.0, scale=1.0, size=None)\n\n        Draw samples from a Gumbel distribution.\n\n        Draw samples from a Gumbel distribution with specified location and\n        scale.  For more information on the Gumbel distribution, see\n        Notes and References below.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.gumbel`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "scale": {
                "type": "float or array_like of floats",
                "description": "The scale parameter of the distribution. Default is 1. Must be non-\n            negative."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``loc`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn."
              },
              "where": {
                "type": "math:`\\mu` is the mode",
                "description": ", a location parameter, and\n        :math:`\\beta` is the scale parameter.\n\n        The Gumbel (named for German mathematician Emil Julius Gumbel) was used\n        very early in the hydrology literature, for modeling the occurrence of\n        flood events. It is also used for modeling maximum wind speed and\n        rainfall rates.  It is a \"fat-tailed\" distribution - the probability of\n        an event in the tail of the distribution is larger than if one used a\n        Gaussian, hence the surprisingly frequent occurrence of 100-year\n        floods. Floods were initially modeled as a Gaussian process, which\n        underestimated the frequency of extreme events.\n\n        It is one of a class of extreme value distributions, the Generalized\n        Extreme Value (GEV) distributions, which also includes the Weibull and\n        Frechet.\n\n        The function has a mean of :math:`\\mu + 0.57721\\beta` and a variance"
              },
              "of": {
                "type": "math:`\\frac{\\pi^2}{6}\\beta^2`.",
                "description": "References\n        ----------\n        .. [1] Gumbel, E. J., \"Statistics of Extremes,\"\n               New York: Columbia University Press, 1958.\n        .. [2] Reiss, R.-D. and Thomas, M., \"Statistical Analysis of Extreme\n               Values from Insurance, Finance, Hydrology and Other Fields,\""
              },
              "Basel": {
                "type": "Birkhauser Verlag",
                "description": ", 2001."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "hypergeometric",
          "signature": "hypergeometric(...)",
          "documentation": {
            "description": "hypergeometric(ngood, nbad, nsample, size=None)\n\n        Draw samples from a Hypergeometric distribution.\n\n        Samples are drawn from a hypergeometric distribution with specified\n        parameters, `ngood` (ways to make a good selection), `nbad` (ways to make\n        a bad selection), and `nsample` (number of items sampled, which is less\n        than or equal to the sum ``ngood + nbad``).\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.hypergeometric`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "nbad": {
                "type": "int or array_like of ints",
                "description": "Number of ways to make a bad selection.  Must be nonnegative."
              },
              "nsample": {
                "type": "int or array_like of ints",
                "description": "Number of items sampled.  Must be at least 1 and at most\n            ``ngood + nbad``."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if `ngood`, `nbad`, and `nsample`\n            are all scalars.  Otherwise, ``np.broadcast(ngood, nbad, nsample).size``\n            samples are drawn."
              },
              "where": {
                "type": "math:`0 \\le x \\le n` and :math:`n-b \\le x \\le g`",
                "description": "for P(x) the probability of ``x`` good results in the drawn sample,\n        g = `ngood`, b = `nbad`, and n = `nsample`.\n\n        Consider an urn with black and white marbles in it, `ngood` of them\n        are black and `nbad` are white. If you draw `nsample` balls without\n        replacement, then the hypergeometric distribution describes the\n        distribution of black balls in the drawn sample.\n\n        Note that this distribution is very similar to the binomial\n        distribution, except that in this case, samples are drawn without\n        replacement, whereas in the Binomial case samples are drawn with\n        replacement (or the sample space is infinite). As the sample space\n        becomes large, this distribution approaches the binomial.\n\n        References\n        ----------\n        .. [1] Lentner, Marvin, \"Elementary Applied Statistics\", Bogden\n               and Quigley, 1972.\n        .. [2] Weisstein, Eric W. \"Hypergeometric Distribution.\" From\n               MathWorld--A Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/HypergeometricDistribution.html",
                "description": ".. [3] Wikipedia, \"Hypergeometric distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Hypergeometric_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "laplace",
          "signature": "laplace(...)",
          "documentation": {
            "description": "laplace(loc=0.0, scale=1.0, size=None)\n\n        Draw samples from the Laplace or double exponential distribution with\n        specified location (or mean) and scale (decay).\n\n        The Laplace distribution is similar to the Gaussian/normal distribution,\n        but is sharper at the peak and has fatter tails. It represents the\n        difference between two independent, identically distributed exponential\n        random variables.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.laplace`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "scale": {
                "type": "float or array_like of floats",
                "description": ":math:`\\lambda`, the exponential decay. Default is 1. Must be non-\n            negative."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``loc`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn."
              },
              "http": {
                "type": "//mathworld.wolfram.com/LaplaceDistribution.html",
                "description": ".. [4] Wikipedia, \"Laplace distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Laplace_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logistic",
          "signature": "logistic(...)",
          "documentation": {
            "description": "logistic(loc=0.0, scale=1.0, size=None)\n\n        Draw samples from a logistic distribution.\n\n        Samples are drawn from a logistic distribution with specified\n        parameters, loc (location or mean, also median), and scale (>0).\n\n        .. note::\n            New code should use the `~numpy.random.Generator.logistic`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "scale": {
                "type": "float or array_like of floats",
                "description": "Parameter of the distribution. Must be non-negative.\n            Default is 1."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``loc`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn."
              },
              "where": {
                "type": "math:`\\mu` = location and :math:`s` = scale.",
                "description": "The Logistic distribution is used in Extreme Value problems where it\n        can act as a mixture of Gumbel distributions, in Epidemiology, and by\n        the World Chess Federation (FIDE) where it is used in the Elo ranking\n        system, assuming the performance of each player is a logistically\n        distributed random variable.\n\n        References\n        ----------\n        .. [1] Reiss, R.-D. and Thomas M. (2001), \"Statistical Analysis of\n               Extreme Values, from Insurance, Finance, Hydrology and Other\n               Fields,\" Birkhauser Verlag, Basel, pp 132-133.\n        .. [2] Weisstein, Eric W. \"Logistic Distribution.\" From\n               MathWorld--A Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/LogisticDistribution.html",
                "description": ".. [3] Wikipedia, \"Logistic-distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Logistic_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lognormal",
          "signature": "lognormal(...)",
          "documentation": {
            "description": "lognormal(mean=0.0, sigma=1.0, size=None)\n\n        Draw samples from a log-normal distribution.\n\n        Draw samples from a log-normal distribution with specified mean,\n        standard deviation, and array shape.  Note that the mean and standard\n        deviation are not the values for the distribution itself, but of the\n        underlying normal distribution it is derived from.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.lognormal`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "sigma": {
                "type": "float or array_like of floats",
                "description": "Standard deviation of the underlying normal distribution. Must be\n            non-negative. Default is 1."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``mean`` and ``sigma`` are both scalars.\n            Otherwise, ``np.broadcast(mean, sigma).size`` samples are drawn."
              },
              "where": {
                "type": "math:`\\mu` is the mean and :math:`\\sigma` is the standard",
                "description": "deviation of the normally distributed logarithm of the variable.\n        A log-normal distribution results if a random variable is the *product*\n        of a large number of independent, identically-distributed variables in\n        the same way that a normal distribution results if the variable is the\n        *sum* of a large number of independent, identically-distributed\n        variables.\n\n        References\n        ----------\n        .. [1] Limpert, E., Stahel, W. A., and Abbt, M., \"Log-normal\n               Distributions across the Sciences: Keys and Clues,\"\n               BioScience, Vol. 51, No. 5, May, 2001."
              },
              "https": {
                "type": "//stat.ethz.ch/~stahel/lognormal/bioscience.pdf",
                "description": ".. [2] Reiss, R.D. and Thomas, M., \"Statistical Analysis of Extreme\n               Values,\" Basel: Birkhauser Verlag, 2001, pp. 31-32."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "logseries",
          "signature": "logseries(...)",
          "documentation": {
            "description": "logseries(p, size=None)\n\n        Draw samples from a logarithmic series distribution.\n\n        Samples are drawn from a log series distribution with specified\n        shape parameter, 0 <= ``p`` < 1.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.logseries`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``p`` is a scalar.  Otherwise,\n            ``np.array(p).size`` samples are drawn."
              },
              "occurrences": {
                "type": "BIODIVERSITY RESEARCH Diversity & Distributions",
                "description": ",\n               Volume 5, Number 5, September 1999 , pp. 187-195(9).\n        .. [2] Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The\n               relation between the number of species and the number of\n               individuals in a random sample of an animal population.\n               Journal of Animal Ecology, 12:42-58.\n        .. [3] D. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small\n               Data Sets, CRC Press, 1994.\n        .. [4] Wikipedia, \"Logarithmic distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Logarithmic_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "multinomial",
          "signature": "multinomial(...)",
          "documentation": {
            "description": "multinomial(n, pvals, size=None)\n\n        Draw samples from a multinomial distribution.\n\n        The multinomial distribution is a multivariate generalization of the\n        binomial distribution.  Take an experiment with one of ``p``\n        possible outcomes.  An example of such an experiment is throwing a dice,\n        where the outcome can be 1 through 6.  Each sample drawn from the\n        distribution represents `n` such experiments.  Its values,\n        ``X_i = [X_0, X_1, ..., X_p]``, represent the number of times the\n        outcome was ``i``.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.multinomial`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "pvals": {
                "type": "sequence of floats",
                "description": ", length p\n            Probabilities of each of the ``p`` different outcomes.  These\n            must sum to 1 (however, the last element is always assumed to\n            account for the remaining probability, as long as\n            ``sum(pvals[:-1]) <= 1)``."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned."
              },
              "ValueError": {
                "type": "pvals < 0",
                "description": ", pvals > 1 or pvals contains NaNs"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "multivariate_normal",
          "signature": "multivariate_normal(...)",
          "documentation": {
            "description": "multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)\n\n        Draw random samples from a multivariate normal distribution.\n\n        The multivariate normal, multinormal or Gaussian distribution is a\n        generalization of the one-dimensional normal distribution to higher\n        dimensions.  Such a distribution is specified by its mean and\n        covariance matrix.  These parameters are analogous to the mean\n        (average or \"center\") and variance (standard deviation, or \"width,\"\n        squared) of the one-dimensional normal distribution.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.multivariate_normal`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "cov": {
                "type": "2-D array_like",
                "description": ", of shape (N, N)\n            Covariance matrix of the distribution. It must be symmetric and\n            positive-semidefinite for proper sampling."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Given a shape of, for example, ``(m,n,k)``, ``m*n*k`` samples are\n            generated, and packed in an `m`-by-`n`-by-`k` arrangement.  Because\n            each sample is `N`-dimensional, the output shape is ``(m,n,k,N)``.\n            If no shape is specified, a single (`N`-D) sample is returned."
              },
              "check_valid": {
                "type": "{ 'warn'",
                "description": ", 'raise', 'ignore' }, optional\n            Behavior when the covariance matrix is not positive semidefinite."
              },
              "tol": {
                "type": "float",
                "description": "Tolerance when checking the singular values in covariance matrix.\n            cov is cast to double before the check."
              },
              "element": {
                "type": "math:`C_{ij}` is the covariance of :math:`x_i` and :math:`x_j`.",
                "description": "The element :math:`C_{ii}` is the variance of :math:`x_i` (i.e. its\n        \"spread\").\n\n        Instead of specifying the full covariance matrix, popular\n        approximations include:\n\n          - Spherical covariance (`cov` is a multiple of the identity matrix)\n          - Diagonal covariance (`cov` has non-negative elements, and only on\n            the diagonal)\n\n        This geometrical property can be seen in two dimensions by plotting\n        generated data-points:\n\n        >>> mean = [0, 0]\n        >>> cov = [[1, 0], [0, 100]]  # diagonal covariance\n\n        Diagonal covariance means that points are oriented along x or y-axis:\n\n        >>> import matplotlib.pyplot as plt\n        >>> x, y = np.random.multivariate_normal(mean, cov, 5000).T\n        >>> plt.plot(x, y, 'x')\n        >>> plt.axis('equal')\n        >>> plt.show()\n\n        Note that the covariance matrix must be positive semidefinite (a.k.a.\n        nonnegative-definite). Otherwise, the behavior of this method is\n        undefined and backwards compatibility is not guaranteed.\n\n        References\n        ----------\n        .. [1] Papoulis, A., \"Probability, Random Variables, and Stochastic\n               Processes,\" 3rd ed., New York: McGraw-Hill, 1991.\n        .. [2] Duda, R. O., Hart, P. E., and Stork, D. G., \"Pattern\n               Classification,\" 2nd ed., New York: Wiley, 2001."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "negative_binomial",
          "signature": "negative_binomial(...)",
          "documentation": {
            "description": "negative_binomial(n, p, size=None)\n\n        Draw samples from a negative binomial distribution.\n\n        Samples are drawn from a negative binomial distribution with specified\n        parameters, `n` successes and `p` probability of success where `n`\n        is > 0 and `p` is in the interval [0, 1].\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.negative_binomial`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "p": {
                "type": "float or array_like of floats",
                "description": "Parameter of the distribution, >= 0 and <=1."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``n`` and ``p`` are both scalars.\n            Otherwise, ``np.broadcast(n, p).size`` samples are drawn."
              },
              "where": {
                "type": "math:`n` is the number of successes",
                "description": ", :math:`p` is the\n        probability of success, :math:`N+n` is the number of trials, and\n        :math:`\\Gamma` is the gamma function. When :math:`n` is an integer,\n        :math:`\\frac{\\Gamma(N+n)}{N!\\Gamma(n)} = \\binom{N+n-1}{N}`, which is\n        the more common form of this term in the pmf. The negative\n        binomial distribution gives the probability of N failures given n\n        successes, with a success on the last trial.\n\n        If one throws a die repeatedly until the third time a \"1\" appears,\n        then the probability distribution of the number of non-\"1\"s that\n        appear before the third \"1\" is a negative binomial distribution.\n\n        References\n        ----------\n        .. [1] Weisstein, Eric W. \"Negative Binomial Distribution.\" From\n               MathWorld--A Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/NegativeBinomialDistribution.html",
                "description": ".. [2] Wikipedia, \"Negative binomial distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Negative_binomial_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "noncentral_chisquare",
          "signature": "noncentral_chisquare(...)",
          "documentation": {
            "description": "noncentral_chisquare(df, nonc, size=None)\n\n        Draw samples from a noncentral chi-square distribution.\n\n        The noncentral :math:`\\chi^2` distribution is a generalization of\n        the :math:`\\chi^2` distribution.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.noncentral_chisquare`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "nonc": {
                "type": "float or array_like of floats",
                "description": "Non-centrality, must be non-negative."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``df`` and ``nonc`` are both scalars.\n            Otherwise, ``np.broadcast(df, nonc).size`` samples are drawn."
              },
              "where": {
                "type": "math:`Y_{q}` is the Chi-square with q degrees of freedom.",
                "description": "References\n        ----------\n        .. [1] Wikipedia, \"Noncentral chi-squared distribution\""
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Noncentral_chi-squared_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "noncentral_f",
          "signature": "noncentral_f(...)",
          "documentation": {
            "description": "noncentral_f(dfnum, dfden, nonc, size=None)\n\n        Draw samples from the noncentral F distribution.\n\n        Samples are drawn from an F distribution with specified parameters,\n        `dfnum` (degrees of freedom in numerator) and `dfden` (degrees of\n        freedom in denominator), where both parameters > 1.\n        `nonc` is the non-centrality parameter.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.noncentral_f`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "dfden": {
                "type": "float or array_like of floats",
                "description": "Denominator degrees of freedom, must be > 0."
              },
              "nonc": {
                "type": "float or array_like of floats",
                "description": "Non-centrality parameter, the sum of the squares of the numerator\n            means, must be >= 0."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``dfnum``, ``dfden``, and ``nonc``\n            are all scalars.  Otherwise, ``np.broadcast(dfnum, dfden, nonc).size``\n            samples are drawn."
              },
              "http": {
                "type": "//mathworld.wolfram.com/NoncentralF-Distribution.html",
                "description": ".. [2] Wikipedia, \"Noncentral F-distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Noncentral_F-distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "normal",
          "signature": "normal(...)",
          "documentation": {
            "description": "normal(loc=0.0, scale=1.0, size=None)\n\n        Draw random samples from a normal (Gaussian) distribution.\n\n        The probability density function of the normal distribution, first\n        derived by De Moivre and 200 years later by both Gauss and Laplace\n        independently [2]_, is often called the bell curve because of\n        its characteristic shape (see the example below).\n\n        The normal distributions occurs often in nature.  For example, it\n        describes the commonly occurring distribution of samples influenced\n        by a large number of tiny, random disturbances, each with its own\n        unique distribution [2]_.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.normal`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "scale": {
                "type": "float or array_like of floats",
                "description": "Standard deviation (spread or \"width\") of the distribution. Must be\n            non-negative."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``loc`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn."
              },
              "where": {
                "type": "math:`\\mu` is the mean and :math:`\\sigma` the standard",
                "description": "deviation. The square of the standard deviation, :math:`\\sigma^2`,\n        is called the variance.\n\n        The function has its peak at the mean, and its \"spread\" increases with\n        the standard deviation (the function reaches 0.607 times its maximum at\n        :math:`x + \\sigma` and :math:`x - \\sigma` [2]_).  This implies that\n        normal is more likely to return samples lying close to the mean, rather\n        than those far away.\n\n        References\n        ----------\n        .. [1] Wikipedia, \"Normal distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Normal_distribution",
                "description": ".. [2] P. R. Peebles Jr., \"Central Limit Theorem\" in \"Probability,\n               Random Variables and Random Signal Principles\", 4th ed., 2001,\n               pp. 51, 51, 125."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "pareto",
          "signature": "pareto(...)",
          "documentation": {
            "description": "pareto(a, size=None)\n\n        Draw samples from a Pareto II or Lomax distribution with\n        specified shape.\n\n        The Lomax or Pareto II distribution is a shifted Pareto\n        distribution. The classical Pareto distribution can be\n        obtained from the Lomax distribution by adding 1 and\n        multiplying by the scale parameter ``m`` (see Notes).  The\n        smallest value of the Lomax distribution is zero while for the\n        classical Pareto distribution it is ``mu``, where the standard\n        Pareto distribution has location ``mu = 1``.  Lomax can also\n        be considered as a simplified version of the Generalized\n        Pareto distribution (available in SciPy), with the scale set\n        to one and the location set to zero.\n\n        The Pareto distribution must be greater than zero, and is\n        unbounded above.  It is also known as the \"80-20 rule\".  In\n        this distribution, 80 percent of the weights are in the lowest\n        20 percent of the range, while the other 20 percent fill the\n        remaining 80 percent of the range.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.pareto`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` is a scalar.  Otherwise,\n            ``np.array(a).size`` samples are drawn."
              },
              "where": {
                "type": "math:`a` is the shape and :math:`m` the scale.",
                "description": "The Pareto distribution, named after the Italian economist\n        Vilfredo Pareto, is a power law probability distribution\n        useful in many real world problems.  Outside the field of\n        economics it is generally referred to as the Bradford\n        distribution. Pareto developed the distribution to describe\n        the distribution of wealth in an economy.  It has also found\n        use in insurance, web page access statistics, oil field sizes,\n        and many other problems, including the download frequency for\n        projects in Sourceforge [1]_.  It is one of the so-called\n        \"fat-tailed\" distributions.\n\n        References\n        ----------\n        .. [1] Francis Hunt and Paul Johnson, On the Pareto Distribution of\n               Sourceforge projects.\n        .. [2] Pareto, V. (1896). Course of Political Economy. Lausanne.\n        .. [3] Reiss, R.D., Thomas, M.(2001), Statistical Analysis of Extreme\n               Values, Birkhauser Verlag, Basel, pp 23-30.\n        .. [4] Wikipedia, \"Pareto distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Pareto_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "permutation",
          "signature": "permutation(...)",
          "documentation": {
            "description": "permutation(x)\n\n        Randomly permute a sequence, or return a permuted range.\n\n        If `x` is a multi-dimensional array, it is only shuffled along its\n        first index.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.permutation`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "poisson",
          "signature": "poisson(...)",
          "documentation": {
            "description": "poisson(lam=1.0, size=None)\n\n        Draw samples from a Poisson distribution.\n\n        The Poisson distribution is the limit of the binomial distribution\n        for large N.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.poisson`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``lam`` is a scalar. Otherwise,\n            ``np.array(lam).size`` samples are drawn."
              },
              "distribution": {
                "type": "math:`f(k; \\lambda)` describes the probability of",
                "description": ":math:`k` events occurring within the observed"
              },
              "interval": {
                "type": "math:`\\lambda`.",
                "description": "Because the output is limited to the range of the C int64 type, a\n        ValueError is raised when `lam` is within 10 sigma of the maximum\n        representable value.\n\n        References\n        ----------\n        .. [1] Weisstein, Eric W. \"Poisson Distribution.\"\n               From MathWorld--A Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/PoissonDistribution.html",
                "description": ".. [2] Wikipedia, \"Poisson distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Poisson_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "power",
          "signature": "power(...)",
          "documentation": {
            "description": "power(a, size=None)\n\n        Draws samples in [0, 1] from a power distribution with positive\n        exponent a - 1.\n\n        Also known as the power function distribution.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.power`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` is a scalar.  Otherwise,\n            ``np.array(a).size`` samples are drawn."
              },
              "https": {
                "type": "//www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rand",
          "signature": "rand(...)",
          "documentation": {
            "description": "rand(d0, d1, ..., dn)\n\n        Random values in a given shape.\n\n        .. note::\n            This is a convenience function for users porting code from Matlab,\n            and wraps `random_sample`. That function takes a\n            tuple to specify the size of the output, which is consistent with\n            other NumPy functions like `numpy.zeros` and `numpy.ones`.\n\n        Create an array of the given shape and populate it with\n        random samples from a uniform distribution\n        over ``[0, 1)``.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "randint",
          "signature": "randint(...)",
          "documentation": {
            "description": "randint(low, high=None, size=None, dtype=int)\n\n        Return random integers from `low` (inclusive) to `high` (exclusive).\n\n        Return random integers from the \"discrete uniform\" distribution of\n        the specified dtype in the \"half-open\" interval [`low`, `high`). If\n        `high` is None (the default), then results are from [0, `low`).\n\n        .. note::\n            New code should use the `~numpy.random.Generator.integers`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "high": {
                "type": "int or array-like of ints",
                "description": "If provided, one above the largest (signed) integer to be drawn\n            from the distribution (see above for behavior if ``high=None``).\n            If array-like, must contain integer values"
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned."
              },
              "dtype": {
                "type": "dtype",
                "description": "Desired dtype of the result. Byteorder must be native.\n            The default value is int.\n\n            .. versionadded:: 1.11.0"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "randn",
          "signature": "randn(...)",
          "documentation": {
            "description": "randn(d0, d1, ..., dn)\n\n        Return a sample (or samples) from the \"standard normal\" distribution.\n\n        .. note::\n            This is a convenience function for users porting code from Matlab,\n            and wraps `standard_normal`. That function takes a\n            tuple to specify the size of the output, which is consistent with\n            other NumPy functions like `numpy.zeros` and `numpy.ones`.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.standard_normal`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.\n\n        If positive int_like arguments are provided, `randn` generates an array\n        of shape ``(d0, d1, ..., dn)``, filled\n        with random floats sampled from a univariate \"normal\" (Gaussian)\n        distribution of mean 0 and variance 1. A single float randomly sampled\n        from the distribution is returned if no argument is provided.",
            "parameters": {
              "normal": {
                "type": "Also accepts mu and sigma arguments.",
                "description": "random.Generator.standard_normal: which should be used for new code."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "random",
          "signature": "random(...)",
          "documentation": {
            "description": "random(size=None)\n\n        Return random floats in the half-open interval [0.0, 1.0). Alias for\n        `random_sample` to ease forward-porting to the new random API.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "random_integers",
          "signature": "random_integers(...)",
          "documentation": {
            "description": "random_integers(low, high=None, size=None)\n\n        Random integers of type `np.int_` between `low` and `high`, inclusive.\n\n        Return random integers of type `np.int_` from the \"discrete uniform\"\n        distribution in the closed interval [`low`, `high`].  If `high` is\n        None (the default), then results are from [1, `low`]. The `np.int_`\n        type translates to the C long integer type and its precision\n        is platform dependent.\n\n        This function has been deprecated. Use randint instead.\n\n        .. deprecated:: 1.11.0",
            "parameters": {
              "high": {
                "type": "int",
                "description": "If provided, the largest (signed) integer to be drawn from the\n            distribution (see above for behavior if ``high=None``)."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned."
              },
              "use": {
                "type": ":",
                "description": "a + (b - a) * (np.random.random_integers(N) - 1) / (N - 1.)"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "random_sample",
          "signature": "random_sample(...)",
          "documentation": {
            "description": "random_sample(size=None)\n\n        Return random floats in the half-open interval [0.0, 1.0).\n\n        Results are from the \"continuous uniform\" distribution over the\n        stated interval.  To sample :math:`Unif[a, b), b > a` multiply\n        the output of `random_sample` by `(b-a)` and add `a`::\n\n          (b - a) * random_sample() + a\n\n        .. note::\n            New code should use the `~numpy.random.Generator.random`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rayleigh",
          "signature": "rayleigh(...)",
          "documentation": {
            "description": "rayleigh(scale=1.0, size=None)\n\n        Draw samples from a Rayleigh distribution.\n\n        The :math:`\\chi` and Weibull distributions are generalizations of the\n        Rayleigh.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.rayleigh`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``scale`` is a scalar.  Otherwise,\n            ``np.array(scale).size`` samples are drawn."
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Rayleigh_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "seed",
          "signature": "seed(...)",
          "documentation": {
            "description": "seed(seed=None)\n\n        Reseed a legacy MT19937 BitGenerator",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "This is a convenience, legacy function.\n\n        The best practice is to **not** reseed a BitGenerator, rather to\n        recreate a new one. This method is here for legacy reasons.\n        This example demonstrates best practice.\n\n        >>> from numpy.random import MT19937\n        >>> from numpy.random import RandomState, SeedSequence\n        >>> rs = RandomState(MT19937(SeedSequence(123456789)))\n        # Later, you want to restart the stream\n        >>> rs = RandomState(MT19937(SeedSequence(987654321)))",
            "examples": ""
          }
        },
        {
          "name": "set_state",
          "signature": "set_state(...)",
          "documentation": {
            "description": "set_state(state)\n\n        Set the internal state of the generator from a tuple.\n\n        For use if one has reason to manually (re-)set the internal state of\n        the bit generator used by the RandomState instance. By default,\n        RandomState uses the \"Mersenne Twister\"[1]_ pseudo-random number\n        generating algorithm.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "shuffle",
          "signature": "shuffle(...)",
          "documentation": {
            "description": "shuffle(x)\n\n        Modify a sequence in-place by shuffling its contents.\n\n        This function only shuffles the array along the first axis of a\n        multi-dimensional array. The order of sub-arrays is changed but\n        their contents remains the same.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.shuffle`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "standard_cauchy",
          "signature": "standard_cauchy(...)",
          "documentation": {
            "description": "standard_cauchy(size=None)\n\n        Draw samples from a standard Cauchy distribution with mode = 0.\n\n        Also known as the Lorentz distribution.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.standard_cauchy`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "https": {
                "type": "//en.wikipedia.org/wiki/Cauchy_distribution",
                "description": ""
              },
              "http": {
                "type": "//mathworld.wolfram.com/CauchyDistribution.html",
                "description": ".. [3] Wikipedia, \"Cauchy distribution\""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "standard_exponential",
          "signature": "standard_exponential(...)",
          "documentation": {
            "description": "standard_exponential(size=None)\n\n        Draw samples from the standard exponential distribution.\n\n        `standard_exponential` is identical to the exponential distribution\n        with a scale parameter of 1.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.standard_exponential`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "standard_gamma",
          "signature": "standard_gamma(...)",
          "documentation": {
            "description": "standard_gamma(shape, size=None)\n\n        Draw samples from a standard Gamma distribution.\n\n        Samples are drawn from a Gamma distribution with specified parameters,\n        shape (sometimes designated \"k\") and scale=1.\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.standard_gamma`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``shape`` is a scalar.  Otherwise,\n            ``np.array(shape).size`` samples are drawn."
              },
              "where": {
                "type": "math:`k` is the shape and :math:`\\theta` the scale",
                "description": ","
              },
              "and": {
                "type": "math:`\\Gamma` is the Gamma function.",
                "description": "The Gamma distribution is often used to model the times to failure of\n        electronic components, and arises naturally in processes for which the\n        waiting times between Poisson distributed events are relevant.\n\n        References\n        ----------\n        .. [1] Weisstein, Eric W. \"Gamma Distribution.\" From MathWorld--A\n               Wolfram Web Resource."
              },
              "http": {
                "type": "//mathworld.wolfram.com/GammaDistribution.html",
                "description": ".. [2] Wikipedia, \"Gamma distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Gamma_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "standard_normal",
          "signature": "standard_normal(...)",
          "documentation": {
            "description": "standard_normal(size=None)\n\n        Draw samples from a standard Normal distribution (mean=0, stdev=1).\n\n        .. note::\n            New code should use the\n            `~numpy.random.Generator.standard_normal`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "standard_t",
          "signature": "standard_t(...)",
          "documentation": {
            "description": "standard_t(df, size=None)\n\n        Draw samples from a standard Student's t distribution with `df` degrees\n        of freedom.\n\n        A special case of the hyperbolic distribution.  As `df` gets\n        large, the result resembles that of the standard normal\n        distribution (`standard_normal`).\n\n        .. note::\n            New code should use the `~numpy.random.Generator.standard_t`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``df`` is a scalar.  Otherwise,\n            ``np.array(df).size`` samples are drawn."
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Student's_t-distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tomaxint",
          "signature": "tomaxint(...)",
          "documentation": {
            "description": "tomaxint(size=None)\n\n        Return a sample of uniformly distributed random integers in the interval\n        [0, ``np.iinfo(np.int_).max``]. The `np.int_` type translates to the C long\n        integer type and its precision is platform dependent.",
            "parameters": {
              "random_integers": {
                "type": "Uniform sampling over a given closed interval of",
                "description": "integers."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "triangular",
          "signature": "triangular(...)",
          "documentation": {
            "description": "triangular(left, mode, right, size=None)\n\n        Draw samples from the triangular distribution over the\n        interval ``[left, right]``.\n\n        The triangular distribution is a continuous probability\n        distribution with lower limit left, peak at mode, and upper\n        limit right. Unlike the other distributions, these parameters\n        directly define the shape of the pdf.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.triangular`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "mode": {
                "type": "float or array_like of floats",
                "description": "The value where the peak of the distribution occurs.\n            The value must fulfill the condition ``left <= mode <= right``."
              },
              "right": {
                "type": "float or array_like of floats",
                "description": "Upper limit, must be larger than `left`."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``left``, ``mode``, and ``right``\n            are all scalars.  Otherwise, ``np.broadcast(left, mode, right).size``\n            samples are drawn."
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Triangular_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "uniform",
          "signature": "uniform(...)",
          "documentation": {
            "description": "uniform(low=0.0, high=1.0, size=None)\n\n        Draw samples from a uniform distribution.\n\n        Samples are uniformly distributed over the half-open interval\n        ``[low, high)`` (includes low, but excludes high).  In other words,\n        any value within the given interval is equally likely to be drawn\n        by `uniform`.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.uniform`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "high": {
                "type": "float or array_like of floats",
                "description": "Upper boundary of the output interval.  All values generated will be\n            less than or equal to high.  The high limit may be included in the \n            returned array of floats due to floating-point rounding in the \n            equation ``low + (high-low) * random_sample()``.  The default value \n            is 1.0."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``low`` and ``high`` are both scalars.\n            Otherwise, ``np.broadcast(low, high).size`` samples are drawn."
              },
              "random_integers": {
                "type": "Discrete uniform distribution over the closed",
                "description": "interval ``[low, high]``."
              },
              "random_sample": {
                "type": "Floats uniformly distributed over ``[0",
                "description": ", 1)``."
              },
              "random": {
                "type": "Alias for `random_sample`.",
                "description": ""
              },
              "rand": {
                "type": "Convenience function that accepts dimensions as input",
                "description": ", e.g.,\n               ``rand(2,2)`` would generate a 2-by-2 array of floats,\n               uniformly distributed over ``[0, 1)``.\n        random.Generator.uniform: which should be used for new code."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "vonmises",
          "signature": "vonmises(...)",
          "documentation": {
            "description": "vonmises(mu, kappa, size=None)\n\n        Draw samples from a von Mises distribution.\n\n        Samples are drawn from a von Mises distribution with specified mode\n        (mu) and dispersion (kappa), on the interval [-pi, pi].\n\n        The von Mises distribution (also known as the circular normal\n        distribution) is a continuous probability distribution on the unit\n        circle.  It may be thought of as the circular analogue of the normal\n        distribution.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.vonmises`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "kappa": {
                "type": "float or array_like of floats",
                "description": "Dispersion of the distribution, has to be >=0."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``mu`` and ``kappa`` are both scalars.\n            Otherwise, ``np.broadcast(mu, kappa).size`` samples are drawn."
              },
              "where": {
                "type": "math:`\\mu` is the mode and :math:`\\kappa` the dispersion",
                "description": ","
              },
              "and": {
                "type": "math:`I_0(\\kappa)` is the modified Bessel function of order 0.",
                "description": "The von Mises is named for Richard Edler von Mises, who was born in\n        Austria-Hungary, in what is now the Ukraine.  He fled to the United\n        States in 1939 and became a professor at Harvard.  He worked in\n        probability theory, aerodynamics, fluid mechanics, and philosophy of\n        science.\n\n        References\n        ----------\n        .. [1] Abramowitz, M. and Stegun, I. A. (Eds.). \"Handbook of\n               Mathematical Functions with Formulas, Graphs, and Mathematical\n               Tables, 9th printing,\" New York: Dover, 1972.\n        .. [2] von Mises, R., \"Mathematical Theory of Probability\n               and Statistics\", New York: Academic Press, 1964."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "wald",
          "signature": "wald(...)",
          "documentation": {
            "description": "wald(mean, scale, size=None)\n\n        Draw samples from a Wald, or inverse Gaussian, distribution.\n\n        As the scale approaches infinity, the distribution becomes more like a\n        Gaussian. Some references claim that the Wald is an inverse Gaussian\n        with mean equal to 1, but this is by no means universal.\n\n        The inverse Gaussian distribution was first studied in relationship to\n        Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian\n        because there is an inverse relationship between the time to cover a\n        unit distance and distance covered in unit time.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.wald`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "scale": {
                "type": "float or array_like of floats",
                "description": "Scale parameter, must be > 0."
              },
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``mean`` and ``scale`` are both scalars.\n            Otherwise, ``np.broadcast(mean, scale).size`` samples are drawn."
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Inverse_Gaussian_distribution",
                "description": ""
              },
              "Distribution": {
                "type": "Theory : Methodology",
                "description": ", and Applications\", CRC Press,\n               1988.\n        .. [3] Wikipedia, \"Inverse Gaussian distribution\""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "weibull",
          "signature": "weibull(...)",
          "documentation": {
            "description": "weibull(a, size=None)\n\n        Draw samples from a Weibull distribution.\n\n        Draw samples from a 1-parameter Weibull distribution with the given\n        shape parameter `a`.\n\n        .. math:: X = (-ln(U))^{1/a}\n\n        Here, U is drawn from the uniform distribution over (0,1].\n\n        The more common 2-parameter Weibull, including a scale parameter\n        :math:`\\lambda` is just :math:`X = \\lambda(-ln(U))^{1/a}`.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.weibull`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` is a scalar.  Otherwise,\n            ``np.array(a).size`` samples are drawn."
              },
              "where": {
                "type": "math:`a` is the shape and :math:`\\lambda` the scale.",
                "description": "The function has its peak (the mode) at\n        :math:`\\lambda(\\frac{a-1}{a})^{1/a}`.\n\n        When ``a = 1``, the Weibull distribution reduces to the exponential\n        distribution.\n\n        References\n        ----------\n        .. [1] Waloddi Weibull, Royal Technical University, Stockholm,\n               1939 \"A Statistical Theory Of The Strength Of Materials\",\n               Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939,\n               Generalstabens Litografiska Anstalts Forlag, Stockholm.\n        .. [2] Waloddi Weibull, \"A Statistical Distribution Function of\n               Wide Applicability\", Journal Of Applied Mechanics ASME Paper\n               1951.\n        .. [3] Wikipedia, \"Weibull distribution\","
              },
              "https": {
                "type": "//en.wikipedia.org/wiki/Weibull_distribution",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "zipf",
          "signature": "zipf(...)",
          "documentation": {
            "description": "zipf(a, size=None)\n\n        Draw samples from a Zipf distribution.\n\n        Samples are drawn from a Zipf distribution with specified parameter\n        `a` > 1.\n\n        The Zipf distribution (also known as the zeta distribution) is a\n        discrete probability distribution that satisfies Zipf's law: the\n        frequency of an item is inversely proportional to its rank in a\n        frequency table.\n\n        .. note::\n            New code should use the `~numpy.random.Generator.zipf`\n            method of a `~numpy.random.Generator` instance instead;\n            please see the :ref:`random-quick-start`.",
            "parameters": {
              "size": {
                "type": "int or tuple of ints",
                "description": "Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  If size is ``None`` (default),\n            a single value is returned if ``a`` is a scalar. Otherwise,\n            ``np.array(a).size`` samples are drawn."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "SFC64",
      "documentation": {
        "description": "SFC64(seed=None)\n\n    BitGenerator for Chris Doty-Humphrey's Small Fast Chaotic PRNG.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "random_raw",
          "signature": "random_raw(...)",
          "documentation": {
            "description": "random_raw(self, size=None)\n\n        Return randoms as generated by the underlying BitGenerator",
            "parameters": {
              "output": {
                "type": "bool",
                "description": "Output values.  Used for performance testing since the generated\n            values are not returned."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "spawn",
          "signature": "spawn(...)",
          "documentation": {
            "description": "spawn(n_children)\n\n        Create new independent child bit generators.\n\n        See :ref:`seedsequence-spawn` for additional notes on spawning\n        children.  Some bit generators also implement ``jumped``\n        as a different approach for creating independent streams.\n\n        .. versionadded:: 1.25.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "SeedSequence",
      "documentation": {
        "description": "SeedSequence(entropy=None, *, spawn_key=(), pool_size=4)\n\n    SeedSequence mixes sources of entropy in a reproducible way to set the\n    initial state for independent and very probably non-overlapping\n    BitGenerators.\n\n    Once the SeedSequence is instantiated, you can call the `generate_state`\n    method to get an appropriately sized seed. Calling `spawn(n) <spawn>` will\n    create ``n`` SeedSequences that can be used to seed independent\n    BitGenerators, i.e. for different threads.",
        "parameters": {
          "spawn_key": {
            "type": "{()",
            "description": ", sequence[int]}, optional\n        An additional source of entropy based on the position of this\n        `SeedSequence` in the tree of such objects created with the\n        `SeedSequence.spawn` method. Typically, only `SeedSequence.spawn` will\n        set this, and users will not."
          },
          "pool_size": {
            "type": "{int}",
            "description": "Size of the pooled entropy to store. Default is 4 to give a 128-bit\n        entropy pool. 8 (for 256 bits) is another reasonable choice if working\n        with larger PRNGs, but there is very little to be gained by selecting\n        another value."
          },
          "n_children_spawned": {
            "type": "{int}",
            "description": "The number of children already spawned. Only pass this if\n        reconstructing a `SeedSequence` from a serialized form."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "generate_state",
          "signature": "generate_state(...)",
          "documentation": {
            "description": "generate_state(n_words, dtype=np.uint32)\n\n        Return the requested number of words for PRNG seeding.\n\n        A BitGenerator should call this method in its constructor with\n        an appropriate `n_words` parameter to properly seed itself.",
            "parameters": {
              "dtype": {
                "type": "np.uint32 or np.uint64",
                "description": "The size of each word. This should only be either `uint32` or\n            `uint64`. Strings (`'uint32'`, `'uint64'`) are fine. Note that\n            requesting `uint64` will draw twice as many bits as `uint32` for\n            the same `n_words`. This is a convenience for `BitGenerator`s that\n            express their states as `uint64` arrays."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "spawn",
          "signature": "spawn(...)",
          "documentation": {
            "description": "spawn(n_children)\n\n        Spawn a number of child `SeedSequence` s by extending the\n        `spawn_key`.\n\n        See :ref:`seedsequence-spawn` for additional notes on spawning\n        children.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    }
  ]
}