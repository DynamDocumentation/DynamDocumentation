{
  "description": "**Note:** almost all functions in the ``numpy.lib`` namespace\nare also present in the main ``numpy`` namespace.  Please use the\nfunctions as ``np.<funcname>`` where possible.\n\n``numpy.lib`` is mostly a space for implementing functions that don't\nbelong in core or in another NumPy submodule with a clear purpose\n(e.g. ``random``, ``fft``, ``linalg``, ``ma``).\n\nMost contains basic functions that are used by several submodules and are\nuseful to have in the main name-space.",
  "functions": [
    {
      "name": "add_docstring",
      "signature": "add_docstring(obj, docstring)",
      "documentation": {
        "description": "add_docstring(obj, docstring)\n\n    Add a docstring to a built-in obj if possible.\n    If the obj already has a docstring raise a RuntimeError\n    If this routine does not know how to add a docstring to the object\n    raise a TypeError",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "add_newdoc",
      "signature": "add_newdoc(place, obj, doc, warn_on_python=True)",
      "documentation": {
        "description": "Add documentation to an existing object, typically one defined in C\n\n    The purpose is to allow easier editing of the docstrings without requiring\n    a re-compile. This exists primarily for internal use within numpy itself.",
        "parameters": {
          "obj": {
            "type": "str",
            "description": "The name of the object to add documentation to, typically a class or\n        function name"
          },
          "doc": {
            "type": "{str",
            "description": ", Tuple[str, str], List[Tuple[str, str]]}\n        If a string, the documentation to apply to `obj`\n\n        If a tuple, then the first element is interpreted as an attribute of\n        `obj` and the second as the docstring to apply - ``(method, docstring)``\n\n        If a list, then each element of the list should be a tuple of length\n        two - ``[(method1, docstring1), (method2, docstring2), ...]``"
          },
          "warn_on_python": {
            "type": "bool",
            "description": "If True, the default, emit `UserWarning` if this is used to attach\n        documentation to a pure-python object."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "add_newdoc_ufunc",
      "signature": "_add_newdoc_ufunc(ufunc, new_docstring)",
      "documentation": {
        "description": "add_ufunc_docstring(ufunc, new_docstring)\n\n    Replace the docstring for a ufunc with new_docstring.\n    This method will only work if the current docstring for\n    the ufunc is NULL. (At the C level, i.e. when ufunc->doc is NULL.)",
        "parameters": {
          "new_docstring": {
            "type": "string",
            "description": "The new docstring for the ufunc."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "angle",
      "signature": "angle(z, deg=False)",
      "documentation": {
        "description": "Return the angle of the complex argument.",
        "parameters": {
          "deg": {
            "type": "bool",
            "description": "Return angle in degrees if True, radians if False (default)."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "append",
      "signature": "append(arr, values, axis=None)",
      "documentation": {
        "description": "Append values to the end of an array.",
        "parameters": {
          "values": {
            "type": "array_like",
            "description": "These values are appended to a copy of `arr`.  It must be of the\n        correct shape (the same shape as `arr`, excluding `axis`).  If\n        `axis` is not specified, `values` can be any shape and will be\n        flattened before use."
          },
          "axis": {
            "type": "int",
            "description": "The axis along which `values` are appended.  If `axis` is not\n        given, both `arr` and `values` are flattened before use."
          },
          "delete": {
            "type": "Delete elements from an array.",
            "description": ""
          },
          "ValueError": {
            "type": "all the input arrays must have same number of dimensions",
            "description": ", but\n    the array at index 0 has 2 dimension(s) and the array at index 1 has 1\n    dimension(s)"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "apply_along_axis",
      "signature": "apply_along_axis(func1d, axis, arr, *args, **kwargs)",
      "documentation": {
        "description": "Apply a function to 1-D slices along the given axis.\n\n    Execute `func1d(a, *args, **kwargs)` where `func1d` operates on 1-D arrays\n    and `a` is a 1-D slice of `arr` along `axis`.\n\n    This is equivalent to (but faster than) the following use of `ndindex` and\n    `s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices::\n\n        Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n        for ii in ndindex(Ni):\n            for kk in ndindex(Nk):\n                f = func1d(arr[ii + s_[:,] + kk])\n                Nj = f.shape\n                for jj in ndindex(Nj):\n                    out[ii + jj + kk] = f[jj]\n\n    Equivalently, eliminating the inner loop, this can be expressed as::\n\n        Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n        for ii in ndindex(Ni):\n            for kk in ndindex(Nk):\n                out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])",
        "parameters": {
          "axis": {
            "type": "integer",
            "description": "Axis along which `arr` is sliced."
          },
          "arr": {
            "type": "ndarray (Ni...",
            "description": ", M, Nk...)\n        Input array."
          },
          "args": {
            "type": "any",
            "description": "Additional arguments to `func1d`."
          },
          "kwargs": {
            "type": "any",
            "description": "Additional named arguments to `func1d`.\n\n        .. versionadded:: 1.9.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "apply_over_axes",
      "signature": "apply_over_axes(func, a, axes)",
      "documentation": {
        "description": "Apply a function repeatedly over multiple axes.\n\n    `func` is called as `res = func(a, axis)`, where `axis` is the first\n    element of `axes`.  The result `res` of the function call must have\n    either the same dimensions as `a` or one less dimension.  If `res`\n    has one less dimension than `a`, a dimension is inserted before\n    `axis`.  The call to `func` is then repeated for each axis in `axes`,\n    with `res` as the first argument.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array."
          },
          "axes": {
            "type": "array_like",
            "description": "Axes over which `func` is applied; the elements must be integers."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "array_split",
      "signature": "array_split(ary, indices_or_sections, axis=0)",
      "documentation": {
        "description": "Split an array into multiple sub-arrays.\n\n    Please refer to the ``split`` documentation.  The only difference\n    between these functions is that ``array_split`` allows\n    `indices_or_sections` to be an integer that does *not* equally\n    divide the axis. For an array of length l that should be split\n    into n sections, it returns l % n sub-arrays of size l//n + 1\n    and the rest of size l//n.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> x = np.arange(8.0)\n    >>> np.array_split(x, 3)\n    [array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])]\n\n    >>> x = np.arange(9)\n    >>> np.array_split(x, 4)\n    [array([0, 1, 2]), array([3, 4]), array([5, 6]), array([7, 8])]",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "asarray_chkfinite",
      "signature": "asarray_chkfinite(a, dtype=None, order=None)",
      "documentation": {
        "description": "Convert the input to an array, checking for NaNs or Infs.",
        "parameters": {
          "dtype": {
            "type": "data-type",
            "description": "By default, the data-type is inferred from the input data."
          },
          "order": {
            "type": "{'C'",
            "description": ", 'F', 'A', 'K'}, optional\n        Memory layout.  'A' and 'K' depend on the order of input array a.\n        'C' row-major (C-style),\n        'F' column-major (Fortran-style) memory representation.\n        'A' (any) means 'F' if `a` is Fortran contiguous, 'C' otherwise\n        'K' (keep) preserve input order\n        Defaults to 'C'."
          },
          "asanyarray": {
            "type": "Similar function which passes through subclasses.",
            "description": ""
          },
          "ascontiguousarray": {
            "type": "Convert input to a contiguous array.",
            "description": ""
          },
          "asfarray": {
            "type": "Convert input to a floating point ndarray.",
            "description": ""
          },
          "asfortranarray": {
            "type": "Convert input to an ndarray with column-major",
            "description": "memory order."
          },
          "fromiter": {
            "type": "Create an array from an iterator.",
            "description": ""
          },
          "fromfunction": {
            "type": "Construct an array by executing a function on grid",
            "description": "positions."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "asfarray",
      "signature": "asfarray(a, dtype=<class 'numpy.float64'>)",
      "documentation": {
        "description": "Return an array converted to a float type.",
        "parameters": {
          "dtype": {
            "type": "str or dtype object",
            "description": "Float type code to coerce input array `a`.  If `dtype` is one of the\n        'int' dtypes, it is replaced with float64."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "average",
      "signature": "average(a, axis=None, weights=None, returned=False, *, keepdims=<no value>)",
      "documentation": {
        "description": "Compute the weighted average along the specified axis.",
        "parameters": {
          "axis": {
            "type": "None or int or tuple of ints",
            "description": "Axis or axes along which to average `a`.  The default,\n        axis=None, will average over all of the elements of the input array.\n        If axis is negative it counts from the last to the first axis.\n\n        .. versionadded:: 1.7.0\n\n        If axis is a tuple of ints, averaging is performed on all of the axes\n        specified in the tuple instead of a single axis or all the axes as\n        before."
          },
          "weights": {
            "type": "array_like",
            "description": "An array of weights associated with the values in `a`. Each value in\n        `a` contributes to the average according to its associated weight.\n        The weights array can either be 1-D (in which case its length must be\n        the size of `a` along the given axis) or of the same shape as `a`.\n        If `weights=None`, then all data in `a` are assumed to have a\n        weight equal to one.  The 1-D calculation is::\n\n            avg = sum(a * weights) / sum(weights)\n\n        The only constraint on `weights` is that `sum(weights)` must not be 0."
          },
          "returned": {
            "type": "bool",
            "description": "Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)\n        is returned, otherwise only the average is returned.\n        If `weights=None`, `sum_of_weights` is equivalent to the number of\n        elements over which the average is taken."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n        *Note:* `keepdims` will not work with instances of `numpy.matrix`\n        or other classes whose methods do not support `keepdims`.\n\n        .. versionadded:: 1.23.0"
          },
          "TypeError": {
            "type": "Axis must be specified when shapes of a and weights differ.",
            "description": ">>> a = np.ones(5, dtype=np.float128)\n    >>> w = np.ones(5, dtype=np.complex64)\n    >>> avg = np.average(a, weights=w)\n    >>> print(avg.dtype)\n    complex256\n\n    With ``keepdims=True``, the following result has shape (3, 1).\n\n    >>> np.average(data, axis=1, keepdims=True)\n    array([[0.5],\n           [2.5],\n           [4.5]])"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "bartlett",
      "signature": "bartlett(M)",
      "documentation": {
        "description": "Return the Bartlett window.\n\n    The Bartlett window is very similar to a triangular window, except\n    that the end points are at zero.  It is often used in signal\n    processing for tapering a signal, without generating too much\n    ripple in the frequency domain.",
        "parameters": {
          "https": {
            "type": "//en.wikipedia.org/wiki/Window_function",
            "description": ".. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 429."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "bincount",
      "signature": "bincount(...)",
      "documentation": {
        "description": "bincount(x, /, weights=None, minlength=0)\n\n    Count number of occurrences of each value in array of non-negative ints.\n\n    The number of bins (of size 1) is one larger than the largest value in\n    `x`. If `minlength` is specified, there will be at least this number\n    of bins in the output array (though it will be longer if necessary,\n    depending on the contents of `x`).\n    Each bin gives the number of occurrences of its index value in `x`.\n    If `weights` is specified the input array is weighted by it, i.e. if a\n    value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead\n    of ``out[n] += 1``.",
        "parameters": {
          "weights": {
            "type": "array_like",
            "description": "Weights, array of the same shape as `x`."
          },
          "minlength": {
            "type": "int",
            "description": "A minimum number of bins for the output array.\n\n        .. versionadded:: 1.6.0"
          },
          "TypeError": {
            "type": "Cannot cast array data from dtype('float64') to dtype('int64')",
            "description": "according to the rule 'safe'\n\n    A possible use of ``bincount`` is to perform sums over\n    variable-size chunks of an array, using the ``weights`` keyword.\n\n    >>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights\n    >>> x = np.array([0, 1, 1, 2, 2, 2])\n    >>> np.bincount(x,  weights=w)\n    array([ 0.3,  0.7,  1.1])"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "blackman",
      "signature": "blackman(M)",
      "documentation": {
        "description": "Return the Blackman window.\n\n    The Blackman window is a taper formed by using the first three\n    terms of a summation of cosines. It was designed to have close to the\n    minimal leakage possible.  It is close to optimal, only slightly worse\n    than a Kaiser window.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "broadcast_arrays",
      "signature": "broadcast_arrays(*args, subok=False)",
      "documentation": {
        "description": "Broadcast any number of arrays against each other.",
        "parameters": {
          "subok": {
            "type": "bool",
            "description": "If True, then sub-classes will be passed-through, otherwise\n        the returned arrays will be forced to be a base-class array (default)."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "broadcast_shapes",
      "signature": "broadcast_shapes(*args)",
      "documentation": {
        "description": "Broadcast the input shapes into a single shape.\n\n    :ref:`Learn more about broadcasting here <basics.broadcasting>`.\n\n    .. versionadded:: 1.20.0",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "broadcast_to",
      "signature": "broadcast_to(array, shape, subok=False)",
      "documentation": {
        "description": "Broadcast an array to a new shape.",
        "parameters": {
          "shape": {
            "type": "tuple or int",
            "description": "The shape of the desired array. A single integer ``i`` is interpreted\n        as ``(i,)``."
          },
          "subok": {
            "type": "bool",
            "description": "If True, then sub-classes will be passed-through, otherwise\n        the returned array will be forced to be a base-class array (default)."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "byte_bounds",
      "signature": "byte_bounds(a)",
      "documentation": {
        "description": "Returns pointers to the end-points of an array.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "column_stack",
      "signature": "column_stack(tup)",
      "documentation": {
        "description": "Stack 1-D arrays as columns into a 2-D array.\n\n    Take a sequence of 1-D arrays and stack them as columns\n    to make a single 2-D array. 2-D arrays are stacked as-is,\n    just like with `hstack`.  1-D arrays are turned into 2-D columns\n    first.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "common_type",
      "signature": "common_type(*arrays)",
      "documentation": {
        "description": "Return a scalar type which is common to the input arrays.\n\n    The return type will always be an inexact (i.e. floating point) scalar\n    type, even if all the arrays are integer arrays. If one of the inputs is\n    an integer array, the minimum precision type that is returned is a\n    64-bit floating point dtype.\n\n    All input arrays except int64 and uint64 can be safely cast to the\n    returned dtype without loss of information.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "copy",
      "signature": "copy(a, order='K', subok=False)",
      "documentation": {
        "description": "Return an array copy of the given object.",
        "parameters": {
          "order": {
            "type": "{'C'",
            "description": ", 'F', 'A', 'K'}, optional\n        Controls the memory layout of the copy. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible. (Note that this function and :meth:`ndarray.copy` are very\n        similar, but have different default values for their order=\n        arguments.)"
          },
          "subok": {
            "type": "bool",
            "description": "If True, then sub-classes will be passed-through, otherwise the\n        returned array will be forced to be a base-class array (defaults to False).\n\n        .. versionadded:: 1.19.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "corrcoef",
      "signature": "corrcoef(x, y=None, rowvar=True, bias=<no value>, ddof=<no value>, *, dtype=None)",
      "documentation": {
        "description": "Return Pearson product-moment correlation coefficients.\n\n    Please refer to the documentation for `cov` for more detail.  The\n    relationship between the correlation coefficient matrix, `R`, and the\n    covariance matrix, `C`, is\n\n    .. math:: R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} C_{jj} } }\n\n    The values of `R` are between -1 and 1, inclusive.",
        "parameters": {
          "y": {
            "type": "array_like",
            "description": "An additional set of variables and observations. `y` has the same\n        shape as `x`."
          },
          "rowvar": {
            "type": "bool",
            "description": "If `rowvar` is True (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations."
          },
          "bias": {
            "type": "_NoValue",
            "description": "Has no effect, do not use.\n\n        .. deprecated:: 1.10.0"
          },
          "ddof": {
            "type": "_NoValue",
            "description": "Has no effect, do not use.\n\n        .. deprecated:: 1.10.0"
          },
          "dtype": {
            "type": "data-type",
            "description": "Data-type of the result. By default, the return data-type will have\n        at least `numpy.float64` precision.\n\n        .. versionadded:: 1.20"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cov",
      "signature": "cov(m, y=None, rowvar=True, bias=False, ddof=None, fweights=None, aweights=None, *, dtype=None)",
      "documentation": {
        "description": "Estimate a covariance matrix, given data and weights.\n\n    Covariance indicates the level to which two variables vary together.\n    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,\n    then the covariance matrix element :math:`C_{ij}` is the covariance of\n    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance\n    of :math:`x_i`.\n\n    See the notes for an outline of the algorithm.",
        "parameters": {
          "y": {
            "type": "array_like",
            "description": "An additional set of variables and observations. `y` has the same form\n        as that of `m`."
          },
          "rowvar": {
            "type": "bool",
            "description": "If `rowvar` is True (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations."
          },
          "bias": {
            "type": "bool",
            "description": "Default normalization (False) is by ``(N - 1)``, where ``N`` is the\n        number of observations given (unbiased estimate). If `bias` is True,\n        then normalization is by ``N``. These values can be overridden by using\n        the keyword ``ddof`` in numpy versions >= 1.5."
          },
          "ddof": {
            "type": "int",
            "description": "If not ``None`` the default value implied by `bias` is overridden.\n        Note that ``ddof=1`` will return the unbiased estimate, even if both\n        `fweights` and `aweights` are specified, and ``ddof=0`` will return\n        the simple average. See the notes for the details. The default value\n        is ``None``.\n\n        .. versionadded:: 1.5"
          },
          "fweights": {
            "type": "array_like",
            "description": ", int, optional\n        1-D array of integer frequency weights; the number of times each\n        observation vector should be repeated.\n\n        .. versionadded:: 1.10"
          },
          "aweights": {
            "type": "array_like",
            "description": "1-D array of observation vector weights. These relative weights are\n        typically large for observations considered \"important\" and smaller for\n        observations considered less \"important\". If ``ddof=0`` the array of\n        weights can be used to assign probabilities to observation vectors.\n\n        .. versionadded:: 1.10"
          },
          "dtype": {
            "type": "data-type",
            "description": "Data-type of the result. By default, the return data-type will have\n        at least `numpy.float64` precision.\n\n        .. versionadded:: 1.20"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "delete",
      "signature": "delete(arr, obj, axis=None)",
      "documentation": {
        "description": "Return a new array with sub-arrays along an axis deleted. For a one\n    dimensional array, this returns those entries not returned by\n    `arr[obj]`.",
        "parameters": {
          "obj": {
            "type": "slice",
            "description": ", int or array of ints\n        Indicate indices of sub-arrays to remove along the specified axis.\n\n        .. versionchanged:: 1.19.0\n            Boolean indices are now treated as a mask of elements to remove,\n            rather than being cast to the integers 0 and 1."
          },
          "axis": {
            "type": "int",
            "description": "The axis along which to delete the subarray defined by `obj`.\n        If `axis` is None, `obj` is applied to the flattened array."
          },
          "append": {
            "type": "Append elements at the end of an array.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "deprecate",
      "signature": "deprecate(*args, **kwargs)",
      "documentation": {
        "description": "Issues a DeprecationWarning, adds warning to `old_name`'s\n    docstring, rebinds ``old_name.__name__`` and returns the new\n    function object.\n\n    This function may also be used as a decorator.",
        "parameters": {
          "old_name": {
            "type": "str",
            "description": "The name of the function to be deprecated. Default is None, in\n        which case the name of `func` is used."
          },
          "new_name": {
            "type": "str",
            "description": "The new name for the function. Default is None, in which case the\n        deprecation message is that `old_name` is deprecated. If given, the\n        deprecation message is that `old_name` is deprecated and `new_name`\n        should be used instead."
          },
          "message": {
            "type": "str",
            "description": "Additional explanation of the deprecation.  Displayed in the\n        docstring after the warning."
          },
          "Warning": {
            "type": ">>> olduint = np.deprecate(np.uint)",
            "description": ""
          },
          "DeprecationWarning": {
            "type": "`uint64` is deprecated! # may vary",
            "description": ">>> olduint(6)\n    6"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "deprecate_with_doc",
      "signature": "deprecate_with_doc(msg)",
      "documentation": {
        "description": "Deprecates a function and includes the deprecation in its docstring.\n\n    This function is used as a decorator. It returns an object that can be\n    used to issue a DeprecationWarning, by passing the to-be decorated\n    function as argument, this adds warning to the to-be decorated function's\n    docstring and returns the new function object.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "obj : object",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "diag",
      "signature": "diag(v, k=0)",
      "documentation": {
        "description": "Extract a diagonal or construct a diagonal array.\n\n    See the more detailed documentation for ``numpy.diagonal`` if you use this\n    function to extract a diagonal and wish to write to the resulting array;\n    whether it returns a copy or a view depends on what version of numpy you\n    are using.",
        "parameters": {
          "k": {
            "type": "int",
            "description": "Diagonal in question. The default is 0. Use `k>0` for diagonals\n        above the main diagonal, and `k<0` for diagonals below the main\n        diagonal."
          },
          "diagflat": {
            "type": "Create a 2-D array with the flattened input as a diagonal.",
            "description": ""
          },
          "trace": {
            "type": "Sum along diagonals.",
            "description": ""
          },
          "triu": {
            "type": "Upper triangle of an array.",
            "description": ""
          },
          "tril": {
            "type": "Lower triangle of an array.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "diag_indices",
      "signature": "diag_indices(n, ndim=2)",
      "documentation": {
        "description": "Return the indices to access the main diagonal of an array.\n\n    This returns a tuple of indices that can be used to access the main\n    diagonal of an array `a` with ``a.ndim >= 2`` dimensions and shape\n    (n, n, ..., n). For ``a.ndim = 2`` this is the usual diagonal, for\n    ``a.ndim > 2`` this is the set of indices to access ``a[i, i, ..., i]``\n    for ``i = [0..n-1]``.",
        "parameters": {
          "ndim": {
            "type": "int",
            "description": "The number of dimensions."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "diag_indices_from",
      "signature": "diag_indices_from(arr)",
      "documentation": {
        "description": "Return the indices to access the main diagonal of an n-dimensional array.\n\n    See `diag_indices` for full details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "diagflat",
      "signature": "diagflat(v, k=0)",
      "documentation": {
        "description": "Create a two-dimensional array with the flattened input as a diagonal.",
        "parameters": {
          "k": {
            "type": "int",
            "description": "Diagonal to set; 0, the default, corresponds to the \"main\" diagonal,\n        a positive (negative) `k` giving the number of the diagonal above\n        (below) the main."
          },
          "diagonal": {
            "type": "Return specified diagonals.",
            "description": ""
          },
          "trace": {
            "type": "Sum along diagonals.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "diff",
      "signature": "diff(a, n=1, axis=-1, prepend=<no value>, append=<no value>)",
      "documentation": {
        "description": "Calculate the n-th discrete difference along the given axis.\n\n    The first difference is given by ``out[i] = a[i+1] - a[i]`` along\n    the given axis, higher differences are calculated by using `diff`\n    recursively.",
        "parameters": {
          "n": {
            "type": "int",
            "description": "The number of times values are differenced. If zero, the input\n        is returned as-is."
          },
          "axis": {
            "type": "int",
            "description": "The axis along which the difference is taken, default is the\n        last axis.\n    prepend, append : array_like, optional\n        Values to prepend or append to `a` along axis prior to\n        performing the difference.  Scalar values are expanded to\n        arrays with length 1 in the direction of axis and the shape\n        of the input array in along all other axes.  Otherwise the\n        dimension and shape must match `a` except along axis.\n\n        .. versionadded:: 1.16.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "digitize",
      "signature": "digitize(x, bins, right=False)",
      "documentation": {
        "description": "Return the indices of the bins to which each value in input array belongs.\n\n    =========  =============  ============================\n    `right`    order of bins  returned index `i` satisfies\n    =========  =============  ============================\n    ``False``  increasing     ``bins[i-1] <= x < bins[i]``\n    ``True``   increasing     ``bins[i-1] < x <= bins[i]``\n    ``False``  decreasing     ``bins[i-1] > x >= bins[i]``\n    ``True``   decreasing     ``bins[i-1] >= x > bins[i]``\n    =========  =============  ============================\n\n    If values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is\n    returned as appropriate.",
        "parameters": {
          "bins": {
            "type": "array_like",
            "description": "Array of bins. It has to be 1-dimensional and monotonic."
          },
          "right": {
            "type": "bool",
            "description": "Indicating whether the intervals include the right or the left bin\n        edge. Default behavior is (right==False) indicating that the interval\n        does not include the right edge. The left bin end is open in this\n        case, i.e., bins[i-1] <= x < bins[i] is the default behavior for\n        monotonically increasing bins."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "disp",
      "signature": "disp(mesg, device=None, linefeed=True)",
      "documentation": {
        "description": "Display a message on a device.",
        "parameters": {
          "device": {
            "type": "object",
            "description": "Device to write message. If None, defaults to ``sys.stdout`` which is\n        very similar to ``print``. `device` needs to have ``write()`` and\n        ``flush()`` methods."
          },
          "linefeed": {
            "type": "bool",
            "description": "Option whether to print a line feed or not. Defaults to True."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "dsplit",
      "signature": "dsplit(ary, indices_or_sections)",
      "documentation": {
        "description": "Split array into multiple sub-arrays along the 3rd axis (depth).\n\n    Please refer to the `split` documentation.  `dsplit` is equivalent\n    to `split` with ``axis=2``, the array is always split along the third\n    axis provided the array dimension is greater than or equal to 3.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> x = np.arange(16.0).reshape(2, 2, 4)\n    >>> x\n    array([[[ 0.,   1.,   2.,   3.],\n            [ 4.,   5.,   6.,   7.]],\n           [[ 8.,   9.,  10.,  11.],\n            [12.,  13.,  14.,  15.]]])\n    >>> np.dsplit(x, 2)\n    [array([[[ 0.,  1.],\n            [ 4.,  5.]],\n           [[ 8.,  9.],\n            [12., 13.]]]), array([[[ 2.,  3.],\n            [ 6.,  7.]],\n           [[10., 11.],\n            [14., 15.]]])]\n    >>> np.dsplit(x, np.array([3, 6]))\n    [array([[[ 0.,   1.,   2.],\n            [ 4.,   5.,   6.]],\n           [[ 8.,   9.,  10.],\n            [12.,  13.,  14.]]]),\n     array([[[ 3.],\n            [ 7.]],\n           [[11.],\n            [15.]]]),\n    array([], shape=(2, 2, 0), dtype=float64)]",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "dstack",
      "signature": "dstack(tup)",
      "documentation": {
        "description": "Stack arrays in sequence depth wise (along third axis).\n\n    This is equivalent to concatenation along the third axis after 2-D arrays\n    of shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape\n    `(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by\n    `dsplit`.\n\n    This function makes most sense for arrays with up to 3 dimensions. For\n    instance, for pixel-data with a height (first axis), width (second axis),\n    and r/g/b channels (third axis). The functions `concatenate`, `stack` and\n    `block` provide more general stacking and concatenation operations.",
        "parameters": {
          "stack": {
            "type": "Join a sequence of arrays along a new axis.",
            "description": ""
          },
          "block": {
            "type": "Assemble an nd-array from nested lists of blocks.",
            "description": ""
          },
          "vstack": {
            "type": "Stack arrays in sequence vertically (row wise).",
            "description": ""
          },
          "hstack": {
            "type": "Stack arrays in sequence horizontally (column wise).",
            "description": ""
          },
          "column_stack": {
            "type": "Stack 1-D arrays as columns into a 2-D array.",
            "description": ""
          },
          "dsplit": {
            "type": "Split array along third axis.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ediff1d",
      "signature": "ediff1d(ary, to_end=None, to_begin=None)",
      "documentation": {
        "description": "The differences between consecutive elements of an array.",
        "parameters": {
          "to_end": {
            "type": "array_like",
            "description": "Number(s) to append at the end of the returned differences."
          },
          "to_begin": {
            "type": "array_like",
            "description": "Number(s) to prepend at the beginning of the returned differences."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "expand_dims",
      "signature": "expand_dims(a, axis)",
      "documentation": {
        "description": "Expand the shape of an array.\n\n    Insert a new axis that will appear at the `axis` position in the expanded\n    array shape.",
        "parameters": {
          "axis": {
            "type": "int or tuple of ints",
            "description": "Position in the expanded axes where the new axis (or axes) is placed.\n\n        .. deprecated:: 1.13.0\n            Passing an axis where ``axis > a.ndim`` will be treated as\n            ``axis == a.ndim``, and passing ``axis < -a.ndim - 1`` will\n            be treated as ``axis == 0``. This behavior is deprecated.\n\n        .. versionchanged:: 1.18.0\n            A tuple of axes is now supported.  Out of range axes as\n            described above are now forbidden and raise an `AxisError`."
          },
          "reshape": {
            "type": "Insert",
            "description": ", remove, and combine dimensions, and resize existing ones\n    doc.indexing, atleast_1d, atleast_2d, atleast_3d"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "extract",
      "signature": "extract(condition, arr)",
      "documentation": {
        "description": "Return the elements of an array that satisfy some condition.\n\n    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If\n    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.\n\n    Note that `place` does the exact opposite of `extract`.",
        "parameters": {
          "arr": {
            "type": "array_like",
            "description": "Input array of the same size as `condition`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "eye",
      "signature": "eye(N, M=None, k=0, dtype=<class 'float'>, order='C', *, like=None)",
      "documentation": {
        "description": "Return a 2-D array with ones on the diagonal and zeros elsewhere.",
        "parameters": {
          "M": {
            "type": "int",
            "description": "Number of columns in the output. If None, defaults to `N`."
          },
          "k": {
            "type": "int",
            "description": "Index of the diagonal: 0 (the default) refers to the main diagonal,\n      a positive value refers to an upper diagonal, and a negative value\n      to a lower diagonal."
          },
          "dtype": {
            "type": "data-type",
            "description": "Data-type of the returned array."
          },
          "order": {
            "type": "{'C'",
            "description": ", 'F'}, optional\n        Whether the output should be stored in row-major (C-style) or\n        column-major (Fortran-style) order in memory.\n\n        .. versionadded:: 1.14.0"
          },
          "like": {
            "type": "array_like",
            "description": "Reference object to allow the creation of arrays which are not\n        NumPy arrays. If an array-like passed in as ``like`` supports\n        the ``__array_function__`` protocol, the result will be defined\n        by it. In this case, it ensures the creation of an array object\n        compatible with that passed in via this argument.\n\n        .. versionadded:: 1.20.0"
          },
          "diag": {
            "type": "diagonal 2-D array from a 1-D array specified by the user.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fill_diagonal",
      "signature": "fill_diagonal(a, val, wrap=False)",
      "documentation": {
        "description": "Fill the main diagonal of the given array of any dimensionality.\n\n    For an array `a` with ``a.ndim >= 2``, the diagonal is the list of\n    locations with indices ``a[i, ..., i]`` all identical. This function\n    modifies the input array in-place, it does not return a value.",
        "parameters": {
          "val": {
            "type": "scalar or array_like",
            "description": "Value(s) to write on the diagonal. If `val` is scalar, the value is\n      written along the diagonal. If array-like, the flattened `val` is\n      written along the diagonal, repeating if necessary to fill all\n      diagonal entries."
          },
          "wrap": {
            "type": "bool",
            "description": "For tall matrices in NumPy version up to 1.6.2, the\n      diagonal \"wrapped\" after N columns. You can have this behavior\n      with this option. This affects only tall matrices.\n\n    See also\n    --------\n    diag_indices, diag_indices_from"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fix",
      "signature": "fix(x, out=None)",
      "documentation": {
        "description": "Round to nearest integer towards zero.\n\n    Round an array of floats element-wise to nearest integer towards zero.\n    The rounded values are returned as floats.",
        "parameters": {
          "out": {
            "type": "ndarray",
            "description": "A location into which the result is stored. If provided, it must have\n        a shape that the input broadcasts to. If not provided or None, a\n        freshly-allocated array is returned."
          },
          "around": {
            "type": "Round to given number of decimals",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "flip",
      "signature": "flip(m, axis=None)",
      "documentation": {
        "description": "Reverse the order of elements in an array along the given axis.\n\n    The shape of the array is preserved, but the elements are reordered.\n\n    .. versionadded:: 1.12.0",
        "parameters": {
          "axis": {
            "type": "None or int or tuple of ints",
            "description": "Axis or axes along which to flip over. The default,\n         axis=None, will flip over all of the axes of the input array.\n         If axis is negative it counts from the last to the first axis.\n\n         If axis is a tuple of ints, flipping is performed on all of the axes\n         specified in the tuple.\n\n         .. versionchanged:: 1.15.0\n            None and tuples of axes are supported"
          },
          "fliplr": {
            "type": "Flip an array horizontally (axis=1).",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fliplr",
      "signature": "fliplr(m)",
      "documentation": {
        "description": "Reverse the order of elements along axis 1 (left/right).\n\n    For a 2-D array, this flips the entries in each row in the left/right\n    direction. Columns are preserved, but appear in a different order than\n    before.",
        "parameters": {
          "flip": {
            "type": "Flip array in one or more dimensions.",
            "description": ""
          },
          "rot90": {
            "type": "Rotate array counterclockwise.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "flipud",
      "signature": "flipud(m)",
      "documentation": {
        "description": "Reverse the order of elements along axis 0 (up/down).\n\n    For a 2-D array, this flips the entries in each column in the up/down\n    direction. Rows are preserved, but appear in a different order than before.",
        "parameters": {
          "flip": {
            "type": "Flip array in one or more dimensions.",
            "description": ""
          },
          "rot90": {
            "type": "Rotate array counterclockwise.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fromregex",
      "signature": "fromregex(file, regexp, dtype, encoding=None)",
      "documentation": {
        "description": "Construct an array from a text file, using regular expression parsing.\n\n    The returned array is always a structured array, and is constructed from\n    all matches of the regular expression in the file. Groups in the regular\n    expression are converted to fields of the structured array.",
        "parameters": {
          "regexp": {
            "type": "str or regexp",
            "description": "Regular expression used to parse the file.\n        Groups in the regular expression correspond to fields in the dtype."
          },
          "dtype": {
            "type": "dtype or list of dtypes",
            "description": "Dtype for the structured array; must be a structured datatype."
          },
          "encoding": {
            "type": "str",
            "description": "Encoding used to decode the inputfile. Does not apply to input streams.\n\n        .. versionadded:: 1.14.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "genfromtxt",
      "signature": "genfromtxt(fname, dtype=<class 'float'>, comments='#', delimiter=None, skip_header=0, skip_footer=0, converters=None, missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=\" !#$%&'()*+,-./:;<=>?@[\\\\]^{|}~\", replace_space='_', autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True, max_rows=None, encoding='bytes', *, ndmin=0, like=None)",
      "documentation": {
        "description": "Load data from a text file, with missing values handled as specified.\n\n    Each line past the first `skip_header` lines is split at the `delimiter`\n    character, and characters following the `comments` character are discarded.",
        "parameters": {
          "dtype": {
            "type": "dtype",
            "description": "Data type of the resulting array.\n        If None, the dtypes will be determined by the contents of each\n        column, individually."
          },
          "comments": {
            "type": "str",
            "description": "The character used to indicate the start of a comment.\n        All the characters occurring on a line after a comment are discarded."
          },
          "delimiter": {
            "type": "str",
            "description": ", int, or sequence, optional\n        The string used to separate values.  By default, any consecutive\n        whitespaces act as delimiter.  An integer or sequence of integers\n        can also be provided as width(s) of each field."
          },
          "skiprows": {
            "type": "int",
            "description": "`skiprows` was removed in numpy 1.10. Please use `skip_header` instead."
          },
          "skip_header": {
            "type": "int",
            "description": "The number of lines to skip at the beginning of the file."
          },
          "skip_footer": {
            "type": "int",
            "description": "The number of lines to skip at the end of the file."
          },
          "converters": {
            "type": "variable",
            "description": "The set of functions that convert the data of a column to a value.\n        The converters can also be used to provide a default value\n        for missing data: ``converters = {3: lambda s: float(s or 0)}``."
          },
          "missing": {
            "type": "variable",
            "description": "`missing` was removed in numpy 1.10. Please use `missing_values`\n        instead."
          },
          "missing_values": {
            "type": "variable",
            "description": "The set of strings corresponding to missing data."
          },
          "filling_values": {
            "type": "variable",
            "description": "The set of values to be used as default when the data are missing."
          },
          "usecols": {
            "type": "sequence",
            "description": "Which columns to read, with 0 being the first.  For example,\n        ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns."
          },
          "names": {
            "type": "{None",
            "description": ", True, str, sequence}, optional\n        If `names` is True, the field names are read from the first line after\n        the first `skip_header` lines. This line can optionally be preceded\n        by a comment delimiter. If `names` is a sequence or a single-string of\n        comma-separated names, the names will be used to define the field names\n        in a structured dtype. If `names` is None, the names of the dtype\n        fields will be used, if any."
          },
          "excludelist": {
            "type": "sequence",
            "description": "A list of names to exclude. This list is appended to the default list\n        ['return','file','print']. Excluded names are appended with an"
          },
          "underscore": {
            "type": "for example",
            "description": ", `file` would become `file_`."
          },
          "deletechars": {
            "type": "str",
            "description": "A string combining invalid characters that must be deleted from the\n        names."
          },
          "defaultfmt": {
            "type": "str",
            "description": "A format used to define default field names, such as \"f%i\" or \"f_%02i\"."
          },
          "autostrip": {
            "type": "bool",
            "description": "Whether to automatically strip white spaces from the variables."
          },
          "replace_space": {
            "type": "char",
            "description": "Character(s) used in replacement of white spaces in the variable\n        names. By default, use a '_'."
          },
          "case_sensitive": {
            "type": "{True",
            "description": ", False, 'upper', 'lower'}, optional\n        If True, field names are case sensitive.\n        If False or 'upper', field names are converted to upper case.\n        If 'lower', field names are converted to lower case."
          },
          "unpack": {
            "type": "bool",
            "description": "If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = genfromtxt(...)``.  When used with a\n        structured data-type, arrays are returned for each field.\n        Default is False."
          },
          "usemask": {
            "type": "bool",
            "description": "If True, return a masked array.\n        If False, return a regular array."
          },
          "loose": {
            "type": "bool",
            "description": "If True, do not raise errors for invalid values."
          },
          "invalid_raise": {
            "type": "bool",
            "description": "If True, an exception is raised if an inconsistency is detected in the\n        number of columns.\n        If False, a warning is emitted and the offending lines are skipped."
          },
          "max_rows": {
            "type": "int",
            "description": "The maximum number of rows to read. Must not be used with skip_footer\n        at the same time.  If given, the value must be at least 1. Default is\n        to read the entire file.\n\n        .. versionadded:: 1.10.0"
          },
          "encoding": {
            "type": "str",
            "description": "Encoding used to decode the inputfile. Does not apply when `fname` is\n        a file object.  The special value 'bytes' enables backward compatibility\n        workarounds that ensure that you receive byte arrays when possible\n        and passes latin1 encoded strings to converters. Override this value to\n        receive unicode arrays and pass strings as input to converters.  If set\n        to None the system default is used. The default value is 'bytes'.\n\n        .. versionadded:: 1.14.0"
          },
          "ndmin": {
            "type": "int",
            "description": "Same parameter as `loadtxt`\n\n        .. versionadded:: 1.23.0"
          },
          "like": {
            "type": "array_like",
            "description": "Reference object to allow the creation of arrays which are not\n        NumPy arrays. If an array-like passed in as ``like`` supports\n        the ``__array_function__`` protocol, the result will be defined\n        by it. In this case, it ensures the creation of an array object\n        compatible with that passed in via this argument.\n\n        .. versionadded:: 1.20.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "get_array_wrap",
      "signature": "get_array_wrap(*args)",
      "documentation": {
        "description": "Find the wrapper for the array with the highest priority.\n\n    In case of ties, leftmost wins. If no wrapper is found, return None",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "get_include",
      "signature": "get_include()",
      "documentation": {
        "description": "Return the directory that contains the NumPy \\*.h header files.\n\n    Extension modules that need to compile against NumPy should use this\n    function to locate the appropriate include directory.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "When using ``distutils``, for example in ``setup.py``::\n\n        import numpy as np\n        ...\n        Extension('extension_name', ...\n                include_dirs=[np.get_include()])\n        ...",
        "examples": ""
      }
    },
    {
      "name": "gradient",
      "signature": "gradient(f, *varargs, axis=None, edge_order=1)",
      "documentation": {
        "description": "Return the gradient of an N-dimensional array.\n\n    The gradient is computed using second order accurate central differences\n    in the interior points and either first or second order accurate one-sides\n    (forward or backwards) differences at the boundaries.\n    The returned gradient hence has the same shape as the input array.",
        "parameters": {
          "varargs": {
            "type": "list of scalar or array",
            "description": "Spacing between f values. Default unitary spacing for all dimensions.\n        Spacing can be specified using:\n\n        1. single scalar to specify a sample distance for all dimensions.\n        2. N scalars to specify a constant sample distance for each dimension.\n           i.e. `dx`, `dy`, `dz`, ...\n        3. N arrays to specify the coordinates of the values along each\n           dimension of F. The length of the array must match the size of\n           the corresponding dimension\n        4. Any combination of N scalars/arrays with the meaning of 2. and 3.\n\n        If `axis` is given, the number of varargs must equal the number of axes."
          },
          "Default": {
            "type": "1.",
            "description": ""
          },
          "edge_order": {
            "type": "{1",
            "description": ", 2}, optional\n        Gradient is calculated using N-th order accurate differences\n        at the boundaries. Default: 1.\n\n        .. versionadded:: 1.9.1"
          },
          "axis": {
            "type": "None or int or tuple of ints",
            "description": "Gradient is calculated only along the given axis or axes\n        The default (axis = None) is to calculate the gradient for all the axes\n        of the input array. axis may be negative, in which case it counts from\n        the last to the first axis.\n\n        .. versionadded:: 1.11.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "hamming",
      "signature": "hamming(M)",
      "documentation": {
        "description": "Return the Hamming window.\n\n    The Hamming window is a taper formed by using a weighted cosine.",
        "parameters": {
          "https": {
            "type": "//en.wikipedia.org/wiki/Window_function",
            "description": ".. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "hanning",
      "signature": "hanning(M)",
      "documentation": {
        "description": "Return the Hanning window.\n\n    The Hanning window is a taper formed by using a weighted cosine.",
        "parameters": {
          "https": {
            "type": "//en.wikipedia.org/wiki/Window_function",
            "description": ".. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "histogram",
      "signature": "histogram(a, bins=10, range=None, density=None, weights=None)",
      "documentation": {
        "description": "Compute the histogram of a dataset.",
        "parameters": {
          "bins": {
            "type": "int or sequence of scalars or str",
            "description": "If `bins` is an int, it defines the number of equal-width\n        bins in the given range (10, by default). If `bins` is a\n        sequence, it defines a monotonically increasing array of bin edges,\n        including the rightmost edge, allowing for non-uniform bin widths.\n\n        .. versionadded:: 1.11.0\n\n        If `bins` is a string, it defines the method used to calculate the\n        optimal bin width, as defined by `histogram_bin_edges`."
          },
          "range": {
            "type": "(float",
            "description": ", float), optional\n        The lower and upper range of the bins.  If not provided, range\n        is simply ``(a.min(), a.max())``.  Values outside the range are\n        ignored. The first element of the range must be less than or\n        equal to the second. `range` affects the automatic bin\n        computation as well. While bin width is computed to be optimal\n        based on the actual data within `range`, the bin count will fill\n        the entire range including portions containing no data."
          },
          "weights": {
            "type": "array_like",
            "description": "An array of weights, of the same shape as `a`.  Each value in\n        `a` only contributes its associated weight towards the bin count\n        (instead of 1). If `density` is True, the weights are\n        normalized, so that the integral of the density over the range\n        remains 1."
          },
          "density": {
            "type": "bool",
            "description": "If ``False``, the result will contain the number of samples in\n        each bin. If ``True``, the result is the value of the\n        probability *density* function at the bin, normalized such that\n        the *integral* over the range is 1. Note that the sum of the\n        histogram values will not be equal to 1 unless bins of unity\n        width are chosen; it is not a probability *mass* function."
          },
          "bin_edges": {
            "type": "array of dtype float",
            "description": "Return the bin edges ``(length(hist)+1)``."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "histogram2d",
      "signature": "histogram2d(x, y, bins=10, range=None, density=None, weights=None)",
      "documentation": {
        "description": "Compute the bi-dimensional histogram of two data samples.",
        "parameters": {
          "y": {
            "type": "array_like",
            "description": ", shape (N,)\n        An array containing the y coordinates of the points to be\n        histogrammed."
          },
          "bins": {
            "type": "int or array_like or [int",
            "description": ", int] or [array, array], optional\n        The bin specification:\n\n          * If int, the number of bins for the two dimensions (nx=ny=bins).\n          * If array_like, the bin edges for the two dimensions\n            (x_edges=y_edges=bins).\n          * If [int, int], the number of bins in each dimension\n            (nx, ny = bins).\n          * If [array, array], the bin edges in each dimension\n            (x_edges, y_edges = bins).\n          * A combination [int, array] or [array, int], where int\n            is the number of bins and array is the bin edges."
          },
          "range": {
            "type": "array_like",
            "description": ", shape(2,2), optional\n        The leftmost and rightmost edges of the bins along each dimension\n        (if not specified explicitly in the `bins` parameters):\n        ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range\n        will be considered outliers and not tallied in the histogram."
          },
          "density": {
            "type": "bool",
            "description": "If False, the default, returns the number of samples in each bin.\n        If True, returns the probability *density* function at the bin,\n        ``bin_count / sample_count / bin_area``."
          },
          "weights": {
            "type": "array_like",
            "description": ", shape(N,), optional\n        An array of values ``w_i`` weighing each sample ``(x_i, y_i)``.\n        Weights are normalized to 1 if `density` is True. If `density` is\n        False, the values of the returned histogram are equal to the sum of\n        the weights belonging to the samples falling into each bin."
          },
          "xedges": {
            "type": "ndarray",
            "description": ", shape(nx+1,)\n        The bin edges along the first dimension."
          },
          "yedges": {
            "type": "ndarray",
            "description": ", shape(ny+1,)\n        The bin edges along the second dimension."
          },
          "histogramdd": {
            "type": "Multidimensional histogram",
            "description": ""
          },
          "edges": {
            "type": ">>> # Generate non-symmetric test data",
            "description": ">>> n = 10000\n    >>> x = np.linspace(1, 100, n)\n    >>> y = 2*np.log(x) + np.random.rand(n) - 0.5\n    >>> # Compute 2d histogram. Note the order of x/y and xedges/yedges\n    >>> H, yedges, xedges = np.histogram2d(y, x, bins=20)\n\n    Now we can plot the histogram using\n    :func:`pcolormesh <matplotlib.pyplot.pcolormesh>`, and a\n    :func:`hexbin <matplotlib.pyplot.hexbin>` for comparison.\n\n    >>> # Plot histogram using pcolormesh\n    >>> fig, (ax1, ax2) = plt.subplots(ncols=2, sharey=True)\n    >>> ax1.pcolormesh(xedges, yedges, H, cmap='rainbow')\n    >>> ax1.plot(x, 2*np.log(x), 'k-')\n    >>> ax1.set_xlim(x.min(), x.max())\n    >>> ax1.set_ylim(y.min(), y.max())\n    >>> ax1.set_xlabel('x')\n    >>> ax1.set_ylabel('y')\n    >>> ax1.set_title('histogram2d')\n    >>> ax1.grid()\n\n    >>> # Create hexbin plot for comparison\n    >>> ax2.hexbin(x, y, gridsize=20, cmap='rainbow')\n    >>> ax2.plot(x, 2*np.log(x), 'k-')\n    >>> ax2.set_title('hexbin')\n    >>> ax2.set_xlim(x.min(), x.max())\n    >>> ax2.set_xlabel('x')\n    >>> ax2.grid()\n\n    >>> plt.show()"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "histogram_bin_edges",
      "signature": "histogram_bin_edges(a, bins=10, range=None, weights=None)",
      "documentation": {
        "description": "Function to calculate only the edges of the bins used by the `histogram`\n    function.",
        "parameters": {
          "bins": {
            "type": "int or sequence of scalars or str",
            "description": "If `bins` is an int, it defines the number of equal-width\n        bins in the given range (10, by default). If `bins` is a\n        sequence, it defines the bin edges, including the rightmost\n        edge, allowing for non-uniform bin widths.\n\n        If `bins` is a string from the list below, `histogram_bin_edges` will use\n        the method chosen to calculate the optimal bin width and\n        consequently the number of bins (see `Notes` for more detail on\n        the estimators) from the data that falls within the requested\n        range. While the bin width will be optimal for the actual data\n        in the range, the number of bins will be computed to fill the\n        entire range, including the empty portions. For visualisation,\n        using the 'auto' option is suggested. Weighted data is not\n        supported for automated bin size selection.\n\n        'auto'\n            Maximum of the 'sturges' and 'fd' estimators. Provides good\n            all around performance.\n\n        'fd' (Freedman Diaconis Estimator)\n            Robust (resilient to outliers) estimator that takes into\n            account data variability and data size.\n\n        'doane'\n            An improved version of Sturges' estimator that works better\n            with non-normal datasets.\n\n        'scott'\n            Less robust estimator that takes into account data variability\n            and data size.\n\n        'stone'\n            Estimator based on leave-one-out cross-validation estimate of\n            the integrated squared error. Can be regarded as a generalization\n            of Scott's rule.\n\n        'rice'\n            Estimator does not take variability into account, only data\n            size. Commonly overestimates number of bins required.\n\n        'sturges'\n            R's default method, only accounts for data size. Only\n            optimal for gaussian data and underestimates number of bins\n            for large non-gaussian datasets.\n\n        'sqrt'\n            Square root (of data size) estimator, used by Excel and\n            other programs for its speed and simplicity."
          },
          "range": {
            "type": "(float",
            "description": ", float), optional\n        The lower and upper range of the bins.  If not provided, range\n        is simply ``(a.min(), a.max())``.  Values outside the range are\n        ignored. The first element of the range must be less than or\n        equal to the second. `range` affects the automatic bin\n        computation as well. While bin width is computed to be optimal\n        based on the actual data within `range`, the bin count will fill\n        the entire range including portions containing no data."
          },
          "weights": {
            "type": "array_like",
            "description": "An array of weights, of the same shape as `a`.  Each value in\n        `a` only contributes its associated weight towards the bin count\n        (instead of 1). This is currently not used by any of the bin estimators,\n        but may be in the future."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "histogramdd",
      "signature": "histogramdd(sample, bins=10, range=None, density=None, weights=None)",
      "documentation": {
        "description": "Compute the multidimensional histogram of some data.",
        "parameters": {
          "bins": {
            "type": "sequence or int",
            "description": "The bin specification:\n\n        * A sequence of arrays describing the monotonically increasing bin\n          edges along each dimension.\n        * The number of bins for each dimension (nx, ny, ... =bins)\n        * The number of bins for all dimensions (nx=ny=...=bins)."
          },
          "range": {
            "type": "sequence",
            "description": "A sequence of length D, each an optional (lower, upper) tuple giving\n        the outer bin edges to be used if the edges are not given explicitly in\n        `bins`.\n        An entry of None in the sequence results in the minimum and maximum\n        values being used for the corresponding dimension.\n        The default, None, is equivalent to passing a tuple of D None values."
          },
          "density": {
            "type": "bool",
            "description": "If False, the default, returns the number of samples in each bin.\n        If True, returns the probability *density* function at the bin,\n        ``bin_count / sample_count / bin_volume``."
          },
          "weights": {
            "type": "(N",
            "description": ",) array_like, optional\n        An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.\n        Weights are normalized to 1 if density is True. If density is False,\n        the values of the returned histogram are equal to the sum of the\n        weights belonging to the samples falling into each bin."
          },
          "edges": {
            "type": "list",
            "description": "A list of D arrays describing the bin edges for each dimension."
          },
          "histogram2d": {
            "type": "2-D histogram",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "hsplit",
      "signature": "hsplit(ary, indices_or_sections)",
      "documentation": {
        "description": "Split an array into multiple sub-arrays horizontally (column-wise).\n\n    Please refer to the `split` documentation.  `hsplit` is equivalent\n    to `split` with ``axis=1``, the array is always split along the second\n    axis except for 1-D arrays, where it is split at ``axis=0``.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> x = np.arange(16.0).reshape(4, 4)\n    >>> x\n    array([[ 0.,   1.,   2.,   3.],\n           [ 4.,   5.,   6.,   7.],\n           [ 8.,   9.,  10.,  11.],\n           [12.,  13.,  14.,  15.]])\n    >>> np.hsplit(x, 2)\n    [array([[  0.,   1.],\n           [  4.,   5.],\n           [  8.,   9.],\n           [12.,  13.]]),\n     array([[  2.,   3.],\n           [  6.,   7.],\n           [10.,  11.],\n           [14.,  15.]])]\n    >>> np.hsplit(x, np.array([3, 6]))\n    [array([[ 0.,   1.,   2.],\n           [ 4.,   5.,   6.],\n           [ 8.,   9.,  10.],\n           [12.,  13.,  14.]]),\n     array([[ 3.],\n           [ 7.],\n           [11.],\n           [15.]]),\n     array([], shape=(4, 0), dtype=float64)]\n\n    With a higher dimensional array the split is still along the second axis.\n\n    >>> x = np.arange(8.0).reshape(2, 2, 2)\n    >>> x\n    array([[[0.,  1.],\n            [2.,  3.]],\n           [[4.,  5.],\n            [6.,  7.]]])\n    >>> np.hsplit(x, 2)\n    [array([[[0.,  1.]],\n           [[4.,  5.]]]),\n     array([[[2.,  3.]],\n           [[6.,  7.]]])]\n\n    With a 1-D array, the split is along axis 0.\n\n    >>> x = np.array([0, 1, 2, 3, 4, 5])\n    >>> np.hsplit(x, 2)\n    [array([0, 1, 2]), array([3, 4, 5])]",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "i0",
      "signature": "i0(x)",
      "documentation": {
        "description": "Modified Bessel function of the first kind, order 0.\n\n    Usually denoted :math:`I_0`.",
        "parameters": {
          "https": {
            "type": "//personal.math.ubc.ca/~cbm/aands/page_379.htm",
            "description": ".. [3] https://metacpan.org/pod/distribution/Math-Cephes/lib/Math/Cephes.pod#i0:-Modified-Bessel-function-of-order-zero"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "imag",
      "signature": "imag(val)",
      "documentation": {
        "description": "Return the imaginary part of the complex argument.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "in1d",
      "signature": "in1d(ar1, ar2, assume_unique=False, invert=False, *, kind=None)",
      "documentation": {
        "description": "Test whether each element of a 1-D array is also present in a second array.\n\n    Returns a boolean array the same length as `ar1` that is True\n    where an element of `ar1` is in `ar2` and False otherwise.\n\n    We recommend using :func:`isin` instead of `in1d` for new code.",
        "parameters": {
          "ar2": {
            "type": "array_like",
            "description": "The values against which to test each value of `ar1`."
          },
          "assume_unique": {
            "type": "bool",
            "description": "If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False."
          },
          "invert": {
            "type": "bool",
            "description": "If True, the values in the returned array are inverted (that is,\n        False where an element of `ar1` is in `ar2` and True otherwise).\n        Default is False. ``np.in1d(a, b, invert=True)`` is equivalent\n        to (but is faster than) ``np.invert(in1d(a, b))``."
          },
          "kind": {
            "type": "{None",
            "description": ", 'sort', 'table'}, optional\n        The algorithm to use. This will not affect the final result,\n        but will affect the speed and memory use. The default, None,\n        will select automatically based on memory considerations.\n\n        * If 'sort', will use a mergesort-based approach. This will have\n          a memory usage of roughly 6 times the sum of the sizes of\n          `ar1` and `ar2`, not accounting for size of dtypes.\n        * If 'table', will use a lookup table approach similar\n          to a counting sort. This is only available for boolean and\n          integer arrays. This will have a memory usage of the\n          size of `ar1` plus the max-min value of `ar2`. `assume_unique`\n          has no effect when the 'table' option is used.\n        * If None, will automatically choose 'table' if\n          the required memory allocation is less than or equal to\n          6 times the sum of the sizes of `ar1` and `ar2`,\n          otherwise will use 'sort'. This is done to not use\n          a large amount of memory by default, even though\n          'table' may be faster in most cases. If 'table' is chosen,\n          `assume_unique` will have no effect.\n\n        .. versionadded:: 1.8.0"
          },
          "container": {
            "type": "As ``ar2`` is converted to an array",
            "description": ", in those cases\n    ``asarray(ar2)`` is an object array rather than the expected array of\n    contained values.\n\n    Using ``kind='table'`` tends to be faster than `kind='sort'` if the\n    following relationship is true:\n    ``log10(len(ar2)) > (log10(max(ar2)-min(ar2)) - 2.27) / 0.927``,\n    but may use greater memory. The default value for `kind` will\n    be automatically selected based only on memory usage, so one may\n    manually set ``kind='table'`` if memory constraints can be relaxed.\n\n    .. versionadded:: 1.4.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "info",
      "signature": "info(object=None, maxwidth=76, output=None, toplevel='numpy')",
      "documentation": {
        "description": "Get help information for an array, function, class, or module.",
        "parameters": {
          "maxwidth": {
            "type": "int",
            "description": "Printing width."
          },
          "output": {
            "type": "file like object",
            "description": "File like object that the output is written to, default is\n        ``None``, in which case ``sys.stdout`` will be used.\n        The object has to be opened in 'w' or 'a' mode."
          },
          "toplevel": {
            "type": "str",
            "description": "Start search at this level."
          },
          "class": {
            "type": "ndarray",
            "description": ""
          },
          "shape": {
            "type": "(2",
            "description": ", 3)"
          },
          "strides": {
            "type": "(24",
            "description": ", 8)"
          },
          "itemsize": {
            "type": "8",
            "description": ""
          },
          "aligned": {
            "type": "True",
            "description": ""
          },
          "contiguous": {
            "type": "True",
            "description": ""
          },
          "fortran": {
            "type": "False",
            "description": "data pointer: 0x562b6e0d2860  # may vary"
          },
          "byteorder": {
            "type": "little",
            "description": ""
          },
          "byteswap": {
            "type": "False",
            "description": ""
          },
          "type": {
            "type": "complex64",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "insert",
      "signature": "insert(arr, obj, values, axis=None)",
      "documentation": {
        "description": "Insert values along the given axis before the given indices.",
        "parameters": {
          "obj": {
            "type": "int",
            "description": ", slice or sequence of ints\n        Object that defines the index or indices before which `values` is\n        inserted.\n\n        .. versionadded:: 1.8.0\n\n        Support for multiple insertions when `obj` is a single scalar or a\n        sequence with one element (similar to calling insert multiple\n        times)."
          },
          "values": {
            "type": "array_like",
            "description": "Values to insert into `arr`. If the type of `values` is different\n        from that of `arr`, `values` is converted to the type of `arr`.\n        `values` should be shaped so that ``arr[...,obj,...] = values``\n        is legal."
          },
          "axis": {
            "type": "int",
            "description": "Axis along which to insert `values`.  If `axis` is None then `arr`\n        is flattened first."
          },
          "concatenate": {
            "type": "Join a sequence of arrays along an existing axis.",
            "description": ""
          },
          "delete": {
            "type": "Delete elements from an array.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "interp",
      "signature": "interp(x, xp, fp, left=None, right=None, period=None)",
      "documentation": {
        "description": "One-dimensional linear interpolation for monotonically increasing sample points.\n\n    Returns the one-dimensional piecewise linear interpolant to a function\n    with given discrete data points (`xp`, `fp`), evaluated at `x`.",
        "parameters": {
          "xp": {
            "type": "1-D sequence of floats",
            "description": "The x-coordinates of the data points, must be increasing if argument\n        `period` is not specified. Otherwise, `xp` is internally sorted after\n        normalizing the periodic boundaries with ``xp = xp % period``."
          },
          "fp": {
            "type": "1-D sequence of float or complex",
            "description": "The y-coordinates of the data points, same length as `xp`."
          },
          "left": {
            "type": "optional float or complex corresponding to fp",
            "description": "Value to return for `x < xp[0]`, default is `fp[0]`."
          },
          "right": {
            "type": "optional float or complex corresponding to fp",
            "description": "Value to return for `x > xp[-1]`, default is `fp[-1]`."
          },
          "period": {
            "type": "None or float",
            "description": "A period for the x-coordinates. This parameter allows the proper\n        interpolation of angular x-coordinates. Parameters `left` and `right`\n        are ignored if `period` is specified.\n\n        .. versionadded:: 1.10.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "intersect1d",
      "signature": "intersect1d(ar1, ar2, assume_unique=False, return_indices=False)",
      "documentation": {
        "description": "Find the intersection of two arrays.\n\n    Return the sorted, unique values that are in both of the input arrays.",
        "parameters": {
          "assume_unique": {
            "type": "bool",
            "description": "If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  If True but ``ar1`` or ``ar2`` are not\n        unique, incorrect results and out-of-bounds indices could result.\n        Default is False."
          },
          "return_indices": {
            "type": "bool",
            "description": "If True, the indices which correspond to the intersection of the two\n        arrays are returned. The first instance of a value is used if there are\n        multiple. Default is False.\n\n        .. versionadded:: 1.15.0"
          },
          "comm1": {
            "type": "ndarray",
            "description": "The indices of the first occurrences of the common values in `ar1`.\n        Only provided if `return_indices` is True."
          },
          "comm2": {
            "type": "ndarray",
            "description": "The indices of the first occurrences of the common values in `ar2`.\n        Only provided if `return_indices` is True."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "iscomplex",
      "signature": "iscomplex(x)",
      "documentation": {
        "description": "Returns a bool array, where True if input element is complex.\n\n    What is tested is whether the input has a non-zero imaginary part, not if\n    the input type is complex.",
        "parameters": {
          "iscomplexobj": {
            "type": "Return True if x is a complex type or an array of complex",
            "description": "numbers."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "iscomplexobj",
      "signature": "iscomplexobj(x)",
      "documentation": {
        "description": "Check for a complex type or an array of complex numbers.\n\n    The type of the input is checked, not the value. Even if the input\n    has an imaginary part equal to zero, `iscomplexobj` evaluates to True.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "isin",
      "signature": "isin(element, test_elements, assume_unique=False, invert=False, *, kind=None)",
      "documentation": {
        "description": "Calculates ``element in test_elements``, broadcasting over `element` only.\n    Returns a boolean array of the same shape as `element` that is True\n    where an element of `element` is in `test_elements` and False otherwise.",
        "parameters": {
          "test_elements": {
            "type": "array_like",
            "description": "The values against which to test each value of `element`.\n        This argument is flattened if it is an array or array_like.\n        See notes for behavior with non-array-like parameters."
          },
          "assume_unique": {
            "type": "bool",
            "description": "If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False."
          },
          "invert": {
            "type": "bool",
            "description": "If True, the values in the returned array are inverted, as if\n        calculating `element not in test_elements`. Default is False.\n        ``np.isin(a, b, invert=True)`` is equivalent to (but faster\n        than) ``np.invert(np.isin(a, b))``."
          },
          "kind": {
            "type": "{None",
            "description": ", 'sort', 'table'}, optional\n        The algorithm to use. This will not affect the final result,\n        but will affect the speed and memory use. The default, None,\n        will select automatically based on memory considerations.\n\n        * If 'sort', will use a mergesort-based approach. This will have\n          a memory usage of roughly 6 times the sum of the sizes of\n          `ar1` and `ar2`, not accounting for size of dtypes.\n        * If 'table', will use a lookup table approach similar\n          to a counting sort. This is only available for boolean and\n          integer arrays. This will have a memory usage of the\n          size of `ar1` plus the max-min value of `ar2`. `assume_unique`\n          has no effect when the 'table' option is used.\n        * If None, will automatically choose 'table' if\n          the required memory allocation is less than or equal to\n          6 times the sum of the sizes of `ar1` and `ar2`,\n          otherwise will use 'sort'. This is done to not use\n          a large amount of memory by default, even though\n          'table' may be faster in most cases. If 'table' is chosen,\n          `assume_unique` will have no effect."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "isneginf",
      "signature": "isneginf(x, out=None)",
      "documentation": {
        "description": "Test element-wise for negative infinity, return result as bool array.",
        "parameters": {
          "out": {
            "type": "array_like",
            "description": "A location into which the result is stored. If provided, it must have a\n        shape that the input broadcasts to. If not provided or None, a\n        freshly-allocated boolean array is returned."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "isposinf",
      "signature": "isposinf(x, out=None)",
      "documentation": {
        "description": "Test element-wise for positive infinity, return result as bool array.",
        "parameters": {
          "out": {
            "type": "array_like",
            "description": "A location into which the result is stored. If provided, it must have a\n        shape that the input broadcasts to. If not provided or None, a\n        freshly-allocated boolean array is returned."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "isreal",
      "signature": "isreal(x)",
      "documentation": {
        "description": "Returns a bool array, where True if input element is real.\n\n    If element has complex type with zero complex part, the return value\n    for that element is True.",
        "parameters": {
          "isrealobj": {
            "type": "Return True if x is not a complex type.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "isrealobj",
      "signature": "isrealobj(x)",
      "documentation": {
        "description": "Return True if x is a not complex type or an array of complex numbers.\n\n    The type of the input is checked, not the value. So even if the input\n    has an imaginary part equal to zero, `isrealobj` evaluates to False\n    if the data type is complex.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "issubclass_",
      "signature": "issubclass_(arg1, arg2)",
      "documentation": {
        "description": "Determine if a class is a subclass of a second class.\n\n    `issubclass_` is equivalent to the Python built-in ``issubclass``,\n    except that it returns False instead of raising a TypeError if one\n    of the arguments is not a class.",
        "parameters": {
          "arg2": {
            "type": "class or tuple of classes.",
            "description": "Input class. If a tuple of classes, True is returned if `arg1` is a\n        subclass of any of the tuple elements."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "issubdtype",
      "signature": "issubdtype(arg1, arg2)",
      "documentation": {
        "description": "Returns True if first argument is a typecode lower/equal in type hierarchy.\n\n    This is like the builtin :func:`issubclass`, but for `dtype`\\ s.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "issubsctype",
      "signature": "issubsctype(arg1, arg2)",
      "documentation": {
        "description": "Determine if the first argument is a subclass of the second argument.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "iterable",
      "signature": "iterable(y)",
      "documentation": {
        "description": "Check whether or not an object can be iterated over.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ix_",
      "signature": "ix_(*args)",
      "documentation": {
        "description": "Construct an open mesh from multiple sequences.\n\n    This function takes N 1-D sequences and returns N outputs with N\n    dimensions each, such that the shape is 1 in all but one dimension\n    and the dimension with the non-unit shape value cycles through all\n    N dimensions.\n\n    Using `ix_` one can quickly construct index arrays that will index\n    the cross product. ``a[np.ix_([1,3],[2,5])]`` returns the array\n    ``[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]``.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "kaiser",
      "signature": "kaiser(M, beta)",
      "documentation": {
        "description": "Return the Kaiser window.\n\n    The Kaiser window is a taper formed by using a Bessel function.",
        "parameters": {
          "beta": {
            "type": "float",
            "description": "Shape parameter for window."
          },
          "where": {
            "type": "math:`I_0` is the modified zeroth-order Bessel function.",
            "description": "The Kaiser was named for Jim Kaiser, who discovered a simple\n    approximation to the DPSS window based on Bessel functions.  The Kaiser\n    window is a very good approximation to the Digital Prolate Spheroidal\n    Sequence, or Slepian window, which is the transform which maximizes the\n    energy in the main lobe of the window relative to total energy.\n\n    The Kaiser can approximate many other windows by varying the beta\n    parameter.\n\n    ====  =======================\n    beta  Window shape\n    ====  =======================\n    0     Rectangular\n    5     Similar to a Hamming\n    6     Similar to a Hanning\n    8.6   Similar to a Blackman\n    ====  =======================\n\n    A beta value of 14 is probably a good starting point. Note that as beta\n    gets large, the window narrows, and so the number of samples needs to be\n    large enough to sample the increasingly narrow spike, otherwise NaNs will\n    get returned.\n\n    Most references to the Kaiser window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] J. F. Kaiser, \"Digital Filters\" - Ch 7 in \"Systems analysis by\n           digital computer\", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.\n           John Wiley and Sons, New York, (1966).\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n           University of Alberta Press, 1975, pp. 177-178.\n    .. [3] Wikipedia, \"Window function\","
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Window_function",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "kron",
      "signature": "kron(a, b)",
      "documentation": {
        "description": "Kronecker product of two arrays.\n\n    Computes the Kronecker product, a composite array made of blocks of the\n    second array scaled by the first.",
        "parameters": {
          "where": {
            "type": ":",
            "description": "kt = it * st + jt,  t = 0,...,N\n\n    In the common 2-D case (N=1), the block structure can be visualized::\n\n        [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],\n         [  ...                              ...   ],\n         [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "load",
      "signature": "load(file, mmap_mode=None, allow_pickle=False, fix_imports=True, encoding='ASCII', *, max_header_size=10000)",
      "documentation": {
        "description": "Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.\n\n    .. warning:: Loading files that contain object arrays uses the ``pickle``\n                 module, which is not secure against erroneous or maliciously\n                 constructed data. Consider passing ``allow_pickle=False`` to\n                 load data that is known not to contain object arrays for the\n                 safer handling of untrusted sources.",
        "parameters": {
          "mmap_mode": {
            "type": "{None",
            "description": ", 'r+', 'r', 'w+', 'c'}, optional\n        If not None, then memory-map the file, using the given mode (see\n        `numpy.memmap` for a detailed description of the modes).  A\n        memory-mapped array is kept on disk. However, it can be accessed\n        and sliced like any ndarray.  Memory mapping is especially useful\n        for accessing small fragments of large files without reading the\n        entire file into memory."
          },
          "allow_pickle": {
            "type": "bool",
            "description": "Allow loading pickled object arrays stored in npy files. Reasons for\n        disallowing pickles include security, as loading pickled data can\n        execute arbitrary code. If pickles are disallowed, loading object\n        arrays will fail. Default: False\n\n        .. versionchanged:: 1.16.3\n            Made default False in response to CVE-2019-6446."
          },
          "fix_imports": {
            "type": "bool",
            "description": "Only useful when loading Python 2 generated pickled files on Python 3,\n        which includes npy/npz files containing object arrays. If `fix_imports`\n        is True, pickle will try to map the old Python 2 names to the new names\n        used in Python 3."
          },
          "encoding": {
            "type": "str",
            "description": "What encoding to use when reading Python 2 strings. Only useful when\n        loading Python 2 generated pickled files in Python 3, which includes\n        npy/npz files containing object arrays. Values other than 'latin1',\n        'ASCII', and 'bytes' are not allowed, as they can corrupt numerical\n        data. Default: 'ASCII'"
          },
          "max_header_size": {
            "type": "int",
            "description": "Maximum allowed size of the header.  Large headers may not be safe\n        to load securely and thus require explicitly passing a larger value."
          },
          "See": {
            "type": "py:func:`ast.literal_eval()` for details.",
            "description": "This option is ignored when `allow_pickle` is passed.  In that case\n        the file is by definition trusted and the limit is unnecessary."
          },
          "memmap": {
            "type": "Create a memory-map to an array stored in a file on disk.",
            "description": "lib.format.open_memmap : Create or load a memory-mapped ``.npy`` file."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "loadtxt",
      "signature": "loadtxt(fname, dtype=<class 'float'>, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding='bytes', max_rows=None, *, quotechar=None, like=None)",
      "documentation": {
        "description": "Load data from a text file.",
        "parameters": {
          "dtype": {
            "type": "data-type",
            "description": "Data-type of the resulting array; default: float.  If this is a\n        structured data-type, the resulting array will be 1-dimensional, and\n        each row will be interpreted as an element of the array.  In this\n        case, the number of columns used must match the number of fields in\n        the data-type."
          },
          "comments": {
            "type": "str or sequence of str or None",
            "description": "The characters or list of characters used to indicate the start of a\n        comment. None implies no comments. For backwards compatibility, byte\n        strings will be decoded as 'latin1'. The default is '#'."
          },
          "delimiter": {
            "type": "str",
            "description": "The character used to separate the values. For backwards compatibility,\n        byte strings will be decoded as 'latin1'. The default is whitespace.\n\n        .. versionchanged:: 1.23.0\n           Only single character delimiters are supported. Newline characters\n           cannot be used as the delimiter."
          },
          "converters": {
            "type": "dict or callable",
            "description": "Converter functions to customize value parsing. If `converters` is\n        callable, the function is applied to all columns, else it must be a\n        dict that maps column number to a parser function.\n        See examples for further details."
          },
          "Default": {
            "type": "None.",
            "description": ".. versionchanged:: 1.23.0\n           The ability to pass a single callable to be applied to all columns\n           was added."
          },
          "skiprows": {
            "type": "int",
            "description": "Skip the first `skiprows` lines, including comments; default: 0."
          },
          "usecols": {
            "type": "int or sequence",
            "description": "Which columns to read, with 0 being the first. For example,\n        ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.\n        The default, None, results in all columns being read.\n\n        .. versionchanged:: 1.11.0\n            When a single column has to be read it is possible to use\n            an integer instead of a tuple. E.g ``usecols = 3`` reads the\n            fourth column the same way as ``usecols = (3,)`` would."
          },
          "unpack": {
            "type": "bool",
            "description": "If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = loadtxt(...)``.  When used with a\n        structured data-type, arrays are returned for each field.\n        Default is False."
          },
          "ndmin": {
            "type": "int",
            "description": "The returned array will have at least `ndmin` dimensions.\n        Otherwise mono-dimensional axes will be squeezed.\n        Legal values: 0 (default), 1 or 2.\n\n        .. versionadded:: 1.6.0"
          },
          "encoding": {
            "type": "str",
            "description": "Encoding used to decode the inputfile. Does not apply to input streams.\n        The special value 'bytes' enables backward compatibility workarounds\n        that ensures you receive byte arrays as results if possible and passes\n        'latin1' encoded strings to converters. Override this value to receive\n        unicode arrays and pass strings as input to converters.  If set to None\n        the system default is used. The default value is 'bytes'.\n\n        .. versionadded:: 1.14.0"
          },
          "max_rows": {
            "type": "int",
            "description": "Read `max_rows` rows of content after `skiprows` lines. The default is\n        to read all the rows. Note that empty rows containing no data such as\n        empty lines and comment lines are not counted towards `max_rows`,\n        while such lines are counted in `skiprows`.\n\n        .. versionadded:: 1.16.0\n\n        .. versionchanged:: 1.23.0\n            Lines containing no data, including comment lines (e.g., lines\n            starting with '#' or as specified via `comments`) are not counted\n            towards `max_rows`."
          },
          "quotechar": {
            "type": "unicode character or None",
            "description": "The character used to denote the start and end of a quoted item.\n        Occurrences of the delimiter or comment characters are ignored within\n        a quoted item. The default value is ``quotechar=None``, which means\n        quoting support is disabled.\n\n        If two consecutive instances of `quotechar` are found within a quoted\n        field, the first is treated as an escape character. See examples.\n\n        .. versionadded:: 1.23.0"
          },
          "like": {
            "type": "array_like",
            "description": "Reference object to allow the creation of arrays which are not\n        NumPy arrays. If an array-like passed in as ``like`` supports\n        the ``__array_function__`` protocol, the result will be defined\n        by it. In this case, it ensures the creation of an array object\n        compatible with that passed in via this argument.\n\n        .. versionadded:: 1.20.0"
          },
          "genfromtxt": {
            "type": "Load data with missing values handled as specified.",
            "description": "scipy.io.loadmat : reads MATLAB data files"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "lookfor",
      "signature": "lookfor(what, module=None, import_modules=True, regenerate=False, output=None)",
      "documentation": {
        "description": "Do a keyword search on docstrings.\n\n    A list of objects that matched the search is displayed,\n    sorted by relevance. All given keywords need to be found in the\n    docstring for it to be returned as a result, but the order does\n    not matter.",
        "parameters": {
          "module": {
            "type": "str or list",
            "description": "Name of module(s) whose docstrings to go through."
          },
          "import_modules": {
            "type": "bool",
            "description": "Whether to import sub-modules in packages. Default is True."
          },
          "regenerate": {
            "type": "bool",
            "description": "Whether to re-generate the docstring cache. Default is False."
          },
          "output": {
            "type": "file-like",
            "description": "File-like object to write the output to. If omitted, use a pager."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "mask_indices",
      "signature": "mask_indices(n, mask_func, k=0)",
      "documentation": {
        "description": "Return the indices to access (n, n) arrays, given a masking function.\n\n    Assume `mask_func` is a function that, for a square array a of size\n    ``(n, n)`` with a possible offset argument `k`, when called as\n    ``mask_func(a, k)`` returns a new array with zeros in certain locations\n    (functions like `triu` or `tril` do precisely this). Then this function\n    returns the indices where the non-zero values would be located.",
        "parameters": {
          "mask_func": {
            "type": "callable",
            "description": "A function whose call signature is similar to that of `triu`, `tril`.\n        That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.\n        `k` is an optional argument to the function."
          },
          "k": {
            "type": "scalar",
            "description": "An optional argument which is passed through to `mask_func`. Functions\n        like `triu`, `tril` take a second argument that is interpreted as an\n        offset."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "median",
      "signature": "median(a, axis=None, out=None, overwrite_input=False, keepdims=False)",
      "documentation": {
        "description": "Compute the median along the specified axis.\n\n    Returns the median of the array elements.",
        "parameters": {
          "axis": {
            "type": "{int",
            "description": ", sequence of int, None}, optional\n        Axis or axes along which the medians are computed. The default\n        is to compute the median along a flattened version of the array.\n        A sequence of axes is supported since version 1.9.0."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary."
          },
          "overwrite_input": {
            "type": "bool",
            "description": "If True, then allow use of memory of input array `a` for\n       calculations. The input array will be modified by the call to\n       `median`. This will save memory when you do not need to preserve\n       the contents of the input array. Treat the input as undefined,\n       but it will probably be fully or partially sorted. Default is\n       False. If `overwrite_input` is ``True`` and `a` is not already an\n       `ndarray`, an error will be raised."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `arr`.\n\n        .. versionadded:: 1.9.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "meshgrid",
      "signature": "meshgrid(*xi, copy=True, sparse=False, indexing='xy')",
      "documentation": {
        "description": "Return a list of coordinate matrices from coordinate vectors.\n\n    Make N-D coordinate arrays for vectorized evaluations of\n    N-D scalar/vector fields over N-D grids, given\n    one-dimensional coordinate arrays x1, x2,..., xn.\n\n    .. versionchanged:: 1.9\n       1-D and 0-D cases are allowed.",
        "parameters": {
          "indexing": {
            "type": "{'xy'",
            "description": ", 'ij'}, optional\n        Cartesian ('xy', default) or matrix ('ij') indexing of output.\n        See Notes for more details.\n\n        .. versionadded:: 1.7.0"
          },
          "sparse": {
            "type": "bool",
            "description": "If True the shape of the returned coordinate array for dimension *i*\n        is reduced from ``(N1, ..., Ni, ... Nn)`` to\n        ``(1, ..., 1, Ni, 1, ..., 1)``.  These sparse coordinate grids are\n        intended to be use with :ref:`basics.broadcasting`.  When all\n        coordinates are used in an expression, broadcasting still leads to a\n        fully-dimensonal result array.\n\n        Default is False.\n\n        .. versionadded:: 1.7.0"
          },
          "copy": {
            "type": "bool",
            "description": "If False, a view into the original arrays are returned in order to\n        conserve memory.  Default is True.  Please note that\n        ``sparse=False, copy=False`` will likely return non-contiguous\n        arrays.  Furthermore, more than one element of a broadcast array\n        may refer to a single memory location.  If you need to write to the\n        arrays, make copies first.\n\n        .. versionadded:: 1.7.0"
          },
          "ogrid": {
            "type": "Construct an open multi-dimensional \"meshgrid\" using indexing",
            "description": "notation.\n    how-to-index"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "mintypecode",
      "signature": "mintypecode(typechars, typeset='GDFgdf', default='d')",
      "documentation": {
        "description": "Return the character for the minimum-size type to which given types can\n    be safely cast.\n\n    The returned type character must represent the smallest size dtype such\n    that an array of the returned type can handle the data from an array of\n    all types in `typechars` (or if `typechars` is an array, then its\n    dtype.char).",
        "parameters": {
          "typeset": {
            "type": "str or list of str",
            "description": "The set of characters that the returned character is chosen from.\n        The default set is 'GDFgdf'."
          },
          "default": {
            "type": "str",
            "description": "The default character, this is returned if none of the characters in\n        `typechars` matches a character in `typeset`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "msort",
      "signature": "msort(a)",
      "documentation": {
        "description": "Return a copy of an array sorted along the first axis.\n\n    .. deprecated:: 1.24\n\n       msort is deprecated, use ``np.sort(a, axis=0)`` instead.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nan_to_num",
      "signature": "nan_to_num(x, copy=True, nan=0.0, posinf=None, neginf=None)",
      "documentation": {
        "description": "Replace NaN with zero and infinity with large finite numbers (default\n    behaviour) or with the numbers defined by the user using the `nan`,\n    `posinf` and/or `neginf` keywords.\n\n    If `x` is inexact, NaN is replaced by zero or by the user defined value in\n    `nan` keyword, infinity is replaced by the largest finite floating point\n    values representable by ``x.dtype`` or by the user defined value in\n    `posinf` keyword and -infinity is replaced by the most negative finite\n    floating point values representable by ``x.dtype`` or by the user defined\n    value in `neginf` keyword.\n\n    For complex dtypes, the above is applied to each of the real and\n    imaginary components of `x` separately.\n\n    If `x` is not inexact, then no replacements are made.",
        "parameters": {
          "copy": {
            "type": "bool",
            "description": "Whether to create a copy of `x` (True) or to replace values\n        in-place (False). The in-place operation only occurs if\n        casting to an array does not require a copy.\n        Default is True.\n\n        .. versionadded:: 1.13"
          },
          "nan": {
            "type": "int",
            "description": ", float, optional\n        Value to be used to fill NaN values. If no value is passed\n        then NaN values will be replaced with 0.0.\n\n        .. versionadded:: 1.17"
          },
          "posinf": {
            "type": "int",
            "description": ", float, optional\n        Value to be used to fill positive infinity values. If no value is\n        passed then positive infinity values will be replaced with a very\n        large number.\n\n        .. versionadded:: 1.17"
          },
          "neginf": {
            "type": "int",
            "description": ", float, optional\n        Value to be used to fill negative infinity values. If no value is\n        passed then negative infinity values will be replaced with a very\n        small (or negative) number.\n\n        .. versionadded:: 1.17"
          },
          "isneginf": {
            "type": "Shows which elements are negative infinity.",
            "description": ""
          },
          "isposinf": {
            "type": "Shows which elements are positive infinity.",
            "description": ""
          },
          "isnan": {
            "type": "Shows which elements are Not a Number (NaN).",
            "description": ""
          },
          "isfinite": {
            "type": "Shows which elements are finite (not NaN",
            "description": ", not infinity)"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nanargmax",
      "signature": "nanargmax(a, axis=None, out=None, *, keepdims=<no value>)",
      "documentation": {
        "description": "Return the indices of the maximum values in the specified axis ignoring\n    NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the\n    results cannot be trusted if a slice contains only NaNs and -Infs.",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "Axis along which to operate.  By default flattened input is used."
          },
          "out": {
            "type": "array",
            "description": "If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n\n        .. versionadded:: 1.22.0"
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the array.\n\n        .. versionadded:: 1.22.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nanargmin",
      "signature": "nanargmin(a, axis=None, out=None, *, keepdims=<no value>)",
      "documentation": {
        "description": "Return the indices of the minimum values in the specified axis ignoring\n    NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results\n    cannot be trusted if a slice contains only NaNs and Infs.",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "Axis along which to operate.  By default flattened input is used."
          },
          "out": {
            "type": "array",
            "description": "If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n\n        .. versionadded:: 1.22.0"
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the array.\n\n        .. versionadded:: 1.22.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nancumprod",
      "signature": "nancumprod(a, axis=None, dtype=None, out=None)",
      "documentation": {
        "description": "Return the cumulative product of array elements over a given axis treating Not a\n    Numbers (NaNs) as one.  The cumulative product does not change when NaNs are\n    encountered and leading NaNs are replaced by ones.\n\n    Ones are returned for slices that are all-NaN or empty.\n\n    .. versionadded:: 1.12.0",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "Axis along which the cumulative product is computed.  By default\n        the input is flattened."
          },
          "dtype": {
            "type": "dtype",
            "description": "Type of the returned array, as well as of the accumulator in which\n        the elements are multiplied.  If *dtype* is not specified, it\n        defaults to the dtype of `a`, unless `a` has an integer dtype with\n        a precision less than that of the default platform integer.  In\n        that case, the default platform integer is used instead."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type of the resulting values will be cast if necessary."
          },
          "isnan": {
            "type": "Show which elements are NaN.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nancumsum",
      "signature": "nancumsum(a, axis=None, dtype=None, out=None)",
      "documentation": {
        "description": "Return the cumulative sum of array elements over a given axis treating Not a\n    Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are\n    encountered and leading NaNs are replaced by zeros.\n\n    Zeros are returned for slices that are all-NaN or empty.\n\n    .. versionadded:: 1.12.0",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "Axis along which the cumulative sum is computed. The default\n        (None) is to compute the cumsum over the flattened array."
          },
          "dtype": {
            "type": "dtype",
            "description": "Type of the returned array and of the accumulator in which the\n        elements are summed.  If `dtype` is not specified, it defaults\n        to the dtype of `a`, unless `a` has an integer dtype with a\n        precision less than that of the default platform integer.  In\n        that case, the default platform integer is used."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type will be cast if necessary. See :ref:`ufuncs-output-type` for\n        more details."
          },
          "isnan": {
            "type": "Show which elements are NaN.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nanmax",
      "signature": "nanmax(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)",
      "documentation": {
        "description": "Return the maximum of an array or maximum along an axis, ignoring any\n    NaNs.  When all-NaN slices are encountered a ``RuntimeWarning`` is\n    raised and NaN is returned for that slice.",
        "parameters": {
          "axis": {
            "type": "{int",
            "description": ", tuple of int, None}, optional\n        Axis or axes along which the maximum is computed. The default is to compute\n        the maximum of the flattened array."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary. See\n        :ref:`ufuncs-output-type` for more details.\n\n        .. versionadded:: 1.8.0"
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n\n        If the value is anything but the default, then\n        `keepdims` will be passed through to the `max` method\n        of sub-classes of `ndarray`.  If the sub-classes methods\n        does not implement `keepdims` any exceptions will be raised.\n\n        .. versionadded:: 1.8.0"
          },
          "initial": {
            "type": "scalar",
            "description": "The minimum value of an output element. Must be present to allow\n        computation on empty slice. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.22.0"
          },
          "where": {
            "type": "array_like of bool",
            "description": "Elements to compare for the maximum. See `~numpy.ufunc.reduce`\n        for details.\n\n        .. versionadded:: 1.22.0"
          },
          "amax": {
            "type": "The maximum value of an array along a given axis",
            "description": ", propagating any NaNs."
          },
          "fmax": {
            "type": "Element-wise maximum of two arrays",
            "description": ", ignoring any NaNs."
          },
          "maximum": {
            "type": "Element-wise maximum of two arrays",
            "description": ", propagating any NaNs."
          },
          "isnan": {
            "type": "Shows which elements are Not a Number (NaN).",
            "description": ""
          },
          "isfinite": {
            "type": "Shows which elements are neither NaN nor infinity.",
            "description": "amin, fmin, minimum"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nanmean",
      "signature": "nanmean(a, axis=None, dtype=None, out=None, keepdims=<no value>, *, where=<no value>)",
      "documentation": {
        "description": "Compute the arithmetic mean along the specified axis, ignoring NaNs.\n\n    Returns the average of the array elements.  The average is taken over\n    the flattened array by default, otherwise over the specified axis.\n    `float64` intermediate and return values are used for integer inputs.\n\n    For all-NaN slices, NaN is returned and a `RuntimeWarning` is raised.\n\n    .. versionadded:: 1.8.0",
        "parameters": {
          "axis": {
            "type": "{int",
            "description": ", tuple of int, None}, optional\n        Axis or axes along which the means are computed. The default is to compute\n        the mean of the flattened array."
          },
          "dtype": {
            "type": "data-type",
            "description": "Type to use in computing the mean.  For integer inputs, the default\n        is `float64`; for inexact inputs, it is the same as the input\n        dtype."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary. See\n        :ref:`ufuncs-output-type` for more details."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n\n        If the value is anything but the default, then\n        `keepdims` will be passed through to the `mean` or `sum` methods\n        of sub-classes of `ndarray`.  If the sub-classes methods\n        does not implement `keepdims` any exceptions will be raised."
          },
          "where": {
            "type": "array_like of bool",
            "description": "Elements to include in the mean. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.22.0"
          },
          "mean": {
            "type": "Arithmetic mean taken while not ignoring NaNs",
            "description": "var, nanvar"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nanmedian",
      "signature": "nanmedian(a, axis=None, out=None, overwrite_input=False, keepdims=<no value>)",
      "documentation": {
        "description": "Compute the median along the specified axis, while ignoring NaNs.\n\n    Returns the median of the array elements.\n\n    .. versionadded:: 1.9.0",
        "parameters": {
          "axis": {
            "type": "{int",
            "description": ", sequence of int, None}, optional\n        Axis or axes along which the medians are computed. The default\n        is to compute the median along a flattened version of the array.\n        A sequence of axes is supported since version 1.9.0."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary."
          },
          "overwrite_input": {
            "type": "bool",
            "description": "If True, then allow use of memory of input array `a` for\n       calculations. The input array will be modified by the call to\n       `median`. This will save memory when you do not need to preserve\n       the contents of the input array. Treat the input as undefined,\n       but it will probably be fully or partially sorted. Default is\n       False. If `overwrite_input` is ``True`` and `a` is not already an\n       `ndarray`, an error will be raised."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n\n        If this is anything but the default value it will be passed\n        through (in the special case of an empty array) to the\n        `mean` function of the underlying array.  If the array is\n        a sub-class and `mean` does not have the kwarg `keepdims` this\n        will raise a RuntimeError."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nanmin",
      "signature": "nanmin(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)",
      "documentation": {
        "description": "Return minimum of an array or minimum along an axis, ignoring any NaNs.\n    When all-NaN slices are encountered a ``RuntimeWarning`` is raised and\n    Nan is returned for that slice.",
        "parameters": {
          "axis": {
            "type": "{int",
            "description": ", tuple of int, None}, optional\n        Axis or axes along which the minimum is computed. The default is to compute\n        the minimum of the flattened array."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary. See\n        :ref:`ufuncs-output-type` for more details.\n\n        .. versionadded:: 1.8.0"
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n\n        If the value is anything but the default, then\n        `keepdims` will be passed through to the `min` method\n        of sub-classes of `ndarray`.  If the sub-classes methods\n        does not implement `keepdims` any exceptions will be raised.\n\n        .. versionadded:: 1.8.0"
          },
          "initial": {
            "type": "scalar",
            "description": "The maximum value of an output element. Must be present to allow\n        computation on empty slice. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.22.0"
          },
          "where": {
            "type": "array_like of bool",
            "description": "Elements to compare for the minimum. See `~numpy.ufunc.reduce`\n        for details.\n\n        .. versionadded:: 1.22.0"
          },
          "amin": {
            "type": "The minimum value of an array along a given axis",
            "description": ", propagating any NaNs."
          },
          "fmin": {
            "type": "Element-wise minimum of two arrays",
            "description": ", ignoring any NaNs."
          },
          "minimum": {
            "type": "Element-wise minimum of two arrays",
            "description": ", propagating any NaNs."
          },
          "isnan": {
            "type": "Shows which elements are Not a Number (NaN).",
            "description": ""
          },
          "isfinite": {
            "type": "Shows which elements are neither NaN nor infinity.",
            "description": "amax, fmax, maximum"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nanpercentile",
      "signature": "nanpercentile(a, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=<no value>, *, interpolation=None)",
      "documentation": {
        "description": "Compute the qth percentile of the data along the specified axis,\n    while ignoring nan values.\n\n    Returns the qth percentile(s) of the array elements.\n\n    .. versionadded:: 1.9.0",
        "parameters": {
          "q": {
            "type": "array_like of float",
            "description": "Percentile or sequence of percentiles to compute, which must be\n        between 0 and 100 inclusive."
          },
          "axis": {
            "type": "{int",
            "description": ", tuple of int, None}, optional\n        Axis or axes along which the percentiles are computed. The default\n        is to compute the percentile(s) along a flattened version of the\n        array."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternative output array in which to place the result. It must have\n        the same shape and buffer length as the expected output, but the\n        type (of the output) will be cast if necessary."
          },
          "overwrite_input": {
            "type": "bool",
            "description": "If True, then allow the input array `a` to be modified by\n        intermediate calculations, to save memory. In this case, the\n        contents of the input `a` after this function completes is\n        undefined."
          },
          "method": {
            "type": "str",
            "description": "This parameter specifies the method to use for estimating the\n        percentile.  There are many different methods, some unique to NumPy.\n        See the notes for explanation.  The options sorted by their R type\n        as summarized in the H&F paper [1]_ are:\n\n        1. 'inverted_cdf'\n        2. 'averaged_inverted_cdf'\n        3. 'closest_observation'\n        4. 'interpolated_inverted_cdf'\n        5. 'hazen'\n        6. 'weibull'\n        7. 'linear'  (default)\n        8. 'median_unbiased'\n        9. 'normal_unbiased'\n\n        The first three methods are discontinuous.  NumPy further defines the\n        following discontinuous variations of the default 'linear' (7.) option:\n\n        * 'lower'\n        * 'higher',\n        * 'midpoint'\n        * 'nearest'\n\n        .. versionchanged:: 1.22.0\n            This argument was previously called \"interpolation\" and only\n            offered the \"linear\" default and last four options."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left in\n        the result as dimensions with size one. With this option, the\n        result will broadcast correctly against the original array `a`.\n\n        If this is anything but the default value it will be passed\n        through (in the special case of an empty array) to the\n        `mean` function of the underlying array.  If the array is\n        a sub-class and `mean` does not have the kwarg `keepdims` this\n        will raise a RuntimeError."
          },
          "interpolation": {
            "type": "str",
            "description": "Deprecated name for the method keyword argument.\n\n        .. deprecated:: 1.22.0"
          },
          "nanmedian": {
            "type": "equivalent to ``nanpercentile(...",
            "description": ", 50)``\n    percentile, median, mean"
          },
          "nanquantile": {
            "type": "equivalent to nanpercentile",
            "description": ", except q in range [0, 1]."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nanprod",
      "signature": "nanprod(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)",
      "documentation": {
        "description": "Return the product of array elements over a given axis treating Not a\n    Numbers (NaNs) as ones.\n\n    One is returned for slices that are all-NaN or empty.\n\n    .. versionadded:: 1.10.0",
        "parameters": {
          "axis": {
            "type": "{int",
            "description": ", tuple of int, None}, optional\n        Axis or axes along which the product is computed. The default is to compute\n        the product of the flattened array."
          },
          "dtype": {
            "type": "data-type",
            "description": "The type of the returned array and of the accumulator in which the\n        elements are summed.  By default, the dtype of `a` is used.  An\n        exception is when `a` has an integer type with less precision than\n        the platform (u)intp. In that case, the default will be either\n        (u)int32 or (u)int64 depending on whether the platform is 32 or 64\n        bits. For inexact inputs, dtype must be inexact."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternate output array in which to place the result.  The default\n        is ``None``. If provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary. See\n        :ref:`ufuncs-output-type` for more details. The casting of NaN to integer\n        can yield unexpected results."
          },
          "keepdims": {
            "type": "bool",
            "description": "If True, the axes which are reduced are left in the result as\n        dimensions with size one. With this option, the result will\n        broadcast correctly against the original `arr`."
          },
          "initial": {
            "type": "scalar",
            "description": "The starting value for this product. See `~numpy.ufunc.reduce`\n        for details.\n\n        .. versionadded:: 1.22.0"
          },
          "where": {
            "type": "array_like of bool",
            "description": "Elements to include in the product. See `~numpy.ufunc.reduce`\n        for details.\n\n        .. versionadded:: 1.22.0"
          },
          "isnan": {
            "type": "Show which elements are NaN.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nanquantile",
      "signature": "nanquantile(a, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=<no value>, *, interpolation=None)",
      "documentation": {
        "description": "Compute the qth quantile of the data along the specified axis,\n    while ignoring nan values.\n    Returns the qth quantile(s) of the array elements.\n\n    .. versionadded:: 1.15.0",
        "parameters": {
          "q": {
            "type": "array_like of float",
            "description": "Probability or sequence of probabilities for the quantiles to compute.\n        Values must be between 0 and 1 inclusive."
          },
          "axis": {
            "type": "{int",
            "description": ", tuple of int, None}, optional\n        Axis or axes along which the quantiles are computed. The\n        default is to compute the quantile(s) along a flattened\n        version of the array."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary."
          },
          "overwrite_input": {
            "type": "bool",
            "description": "If True, then allow the input array `a` to be modified by intermediate\n        calculations, to save memory. In this case, the contents of the input\n        `a` after this function completes is undefined."
          },
          "method": {
            "type": "str",
            "description": "This parameter specifies the method to use for estimating the\n        quantile.  There are many different methods, some unique to NumPy.\n        See the notes for explanation.  The options sorted by their R type\n        as summarized in the H&F paper [1]_ are:\n\n        1. 'inverted_cdf'\n        2. 'averaged_inverted_cdf'\n        3. 'closest_observation'\n        4. 'interpolated_inverted_cdf'\n        5. 'hazen'\n        6. 'weibull'\n        7. 'linear'  (default)\n        8. 'median_unbiased'\n        9. 'normal_unbiased'\n\n        The first three methods are discontinuous.  NumPy further defines the\n        following discontinuous variations of the default 'linear' (7.) option:\n\n        * 'lower'\n        * 'higher',\n        * 'midpoint'\n        * 'nearest'\n\n        .. versionchanged:: 1.22.0\n            This argument was previously called \"interpolation\" and only\n            offered the \"linear\" default and last four options."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left in\n        the result as dimensions with size one. With this option, the\n        result will broadcast correctly against the original array `a`.\n\n        If this is anything but the default value it will be passed\n        through (in the special case of an empty array) to the\n        `mean` function of the underlying array.  If the array is\n        a sub-class and `mean` does not have the kwarg `keepdims` this\n        will raise a RuntimeError."
          },
          "interpolation": {
            "type": "str",
            "description": "Deprecated name for the method keyword argument.\n\n        .. deprecated:: 1.22.0"
          },
          "nanmedian": {
            "type": "equivalent to ``nanquantile(...",
            "description": ", 0.5)``"
          },
          "nanpercentile": {
            "type": "same as nanquantile",
            "description": ", but with q in the range [0, 100]."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nanstd",
      "signature": "nanstd(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>, *, where=<no value>)",
      "documentation": {
        "description": "Compute the standard deviation along the specified axis, while\n    ignoring NaNs.\n\n    Returns the standard deviation, a measure of the spread of a\n    distribution, of the non-NaN array elements. The standard deviation is\n    computed for the flattened array by default, otherwise over the\n    specified axis.\n\n    For all-NaN slices or slices with zero degrees of freedom, NaN is\n    returned and a `RuntimeWarning` is raised.\n\n    .. versionadded:: 1.8.0",
        "parameters": {
          "axis": {
            "type": "{int",
            "description": ", tuple of int, None}, optional\n        Axis or axes along which the standard deviation is computed. The default is\n        to compute the standard deviation of the flattened array."
          },
          "dtype": {
            "type": "dtype",
            "description": "Type to use in computing the standard deviation. For arrays of\n        integer type the default is float64, for arrays of float types it\n        is the same as the array type."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternative output array in which to place the result. It must have\n        the same shape as the expected output but the type (of the\n        calculated values) will be cast if necessary."
          },
          "ddof": {
            "type": "int",
            "description": "Means Delta Degrees of Freedom.  The divisor used in calculations\n        is ``N - ddof``, where ``N`` represents the number of non-NaN\n        elements.  By default `ddof` is zero."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n\n        If this value is anything but the default it is passed through\n        as-is to the relevant functions of the sub-classes.  If these\n        functions do not have a `keepdims` kwarg, a RuntimeError will\n        be raised."
          },
          "where": {
            "type": "array_like of bool",
            "description": "Elements to include in the standard deviation.\n        See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.22.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nansum",
      "signature": "nansum(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)",
      "documentation": {
        "description": "Return the sum of array elements over a given axis treating Not a\n    Numbers (NaNs) as zero.\n\n    In NumPy versions <= 1.9.0 Nan is returned for slices that are all-NaN or\n    empty. In later versions zero is returned.",
        "parameters": {
          "axis": {
            "type": "{int",
            "description": ", tuple of int, None}, optional\n        Axis or axes along which the sum is computed. The default is to compute the\n        sum of the flattened array."
          },
          "dtype": {
            "type": "data-type",
            "description": "The type of the returned array and of the accumulator in which the\n        elements are summed.  By default, the dtype of `a` is used.  An\n        exception is when `a` has an integer type with less precision than\n        the platform (u)intp. In that case, the default will be either\n        (u)int32 or (u)int64 depending on whether the platform is 32 or 64\n        bits. For inexact inputs, dtype must be inexact.\n\n        .. versionadded:: 1.8.0"
          },
          "out": {
            "type": "ndarray",
            "description": "Alternate output array in which to place the result.  The default\n        is ``None``. If provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary.  See\n        :ref:`ufuncs-output-type` for more details. The casting of NaN to integer\n        can yield unexpected results.\n\n        .. versionadded:: 1.8.0"
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n\n\n        If the value is anything but the default, then\n        `keepdims` will be passed through to the `mean` or `sum` methods\n        of sub-classes of `ndarray`.  If the sub-classes methods\n        does not implement `keepdims` any exceptions will be raised.\n\n        .. versionadded:: 1.8.0"
          },
          "initial": {
            "type": "scalar",
            "description": "Starting value for the sum. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.22.0"
          },
          "where": {
            "type": "array_like of bool",
            "description": "Elements to include in the sum. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.22.0"
          },
          "isnan": {
            "type": "Show which elements are NaN.",
            "description": ""
          },
          "isfinite": {
            "type": "Show which elements are not NaN or +/-inf.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nanvar",
      "signature": "nanvar(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>, *, where=<no value>)",
      "documentation": {
        "description": "Compute the variance along the specified axis, while ignoring NaNs.\n\n    Returns the variance of the array elements, a measure of the spread of\n    a distribution.  The variance is computed for the flattened array by\n    default, otherwise over the specified axis.\n\n    For all-NaN slices or slices with zero degrees of freedom, NaN is\n    returned and a `RuntimeWarning` is raised.\n\n    .. versionadded:: 1.8.0",
        "parameters": {
          "axis": {
            "type": "{int",
            "description": ", tuple of int, None}, optional\n        Axis or axes along which the variance is computed.  The default is to compute\n        the variance of the flattened array."
          },
          "dtype": {
            "type": "data-type",
            "description": "Type to use in computing the variance.  For arrays of integer type\n        the default is `float64`; for arrays of float types it is the same as\n        the array type."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternate output array in which to place the result.  It must have\n        the same shape as the expected output, but the type is cast if\n        necessary."
          },
          "ddof": {
            "type": "int",
            "description": "\"Delta Degrees of Freedom\": the divisor used in the calculation is\n        ``N - ddof``, where ``N`` represents the number of non-NaN\n        elements. By default `ddof` is zero."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`."
          },
          "where": {
            "type": "array_like of bool",
            "description": "Elements to include in the variance. See `~numpy.ufunc.reduce` for\n        details.\n\n        .. versionadded:: 1.22.0"
          },
          "mean": {
            "type": "Average",
            "description": ""
          },
          "var": {
            "type": "Variance while not ignoring NaNs",
            "description": "nanstd, nanmean\n    :ref:`ufuncs-output-type`"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "packbits",
      "signature": "packbits(...)",
      "documentation": {
        "description": "packbits(a, /, axis=None, bitorder='big')\n\n    Packs the elements of a binary-valued array into bits in a uint8 array.\n\n    The result is padded to full bytes by inserting zero bits at the end.",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "The dimension over which bit-packing is done.\n        ``None`` implies packing the flattened array."
          },
          "bitorder": {
            "type": "{'big'",
            "description": ", 'little'}, optional\n        The order of the input bits. 'big' will mimic bin(val),\n        ``[0, 0, 0, 0, 0, 0, 1, 1] => 3 = 0b00000011``, 'little' will\n        reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] => 3``.\n        Defaults to 'big'.\n\n        .. versionadded:: 1.17.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "pad",
      "signature": "pad(array, pad_width, mode='constant', **kwargs)",
      "documentation": {
        "description": "Pad an array.",
        "parameters": {
          "pad_width": {
            "type": "{sequence",
            "description": ", array_like, int}\n        Number of values padded to the edges of each axis.\n        ``((before_1, after_1), ... (before_N, after_N))`` unique pad widths\n        for each axis.\n        ``(before, after)`` or ``((before, after),)`` yields same before\n        and after pad for each axis.\n        ``(pad,)`` or ``int`` is a shortcut for before = after = pad width\n        for all axes."
          },
          "mode": {
            "type": "str or function",
            "description": "One of the following string values or a user supplied function.\n\n        'constant' (default)\n            Pads with a constant value.\n        'edge'\n            Pads with the edge values of array.\n        'linear_ramp'\n            Pads with the linear ramp between end_value and the\n            array edge value.\n        'maximum'\n            Pads with the maximum value of all or part of the\n            vector along each axis.\n        'mean'\n            Pads with the mean value of all or part of the\n            vector along each axis.\n        'median'\n            Pads with the median value of all or part of the\n            vector along each axis.\n        'minimum'\n            Pads with the minimum value of all or part of the\n            vector along each axis.\n        'reflect'\n            Pads with the reflection of the vector mirrored on\n            the first and last values of the vector along each\n            axis.\n        'symmetric'\n            Pads with the reflection of the vector mirrored\n            along the edge of the array.\n        'wrap'\n            Pads with the wrap of the vector along the axis.\n            The first values are used to pad the end and the\n            end values are used to pad the beginning.\n        'empty'\n            Pads with undefined values.\n\n            .. versionadded:: 1.17\n\n        <function>\n            Padding function, see Notes."
          },
          "stat_length": {
            "type": "sequence or int",
            "description": "Used in 'maximum', 'mean', 'median', and 'minimum'.  Number of\n        values at edge of each axis used to calculate the statistic value.\n\n        ``((before_1, after_1), ... (before_N, after_N))`` unique statistic\n        lengths for each axis.\n\n        ``(before, after)`` or ``((before, after),)`` yields same before\n        and after statistic lengths for each axis.\n\n        ``(stat_length,)`` or ``int`` is a shortcut for\n        ``before = after = statistic`` length for all axes.\n\n        Default is ``None``, to use the entire axis."
          },
          "constant_values": {
            "type": "sequence or scalar",
            "description": "Used in 'constant'.  The values to set the padded values for each\n        axis.\n\n        ``((before_1, after_1), ... (before_N, after_N))`` unique pad constants\n        for each axis.\n\n        ``(before, after)`` or ``((before, after),)`` yields same before\n        and after constants for each axis.\n\n        ``(constant,)`` or ``constant`` is a shortcut for\n        ``before = after = constant`` for all axes.\n\n        Default is 0."
          },
          "end_values": {
            "type": "sequence or scalar",
            "description": "Used in 'linear_ramp'.  The values used for the ending value of the\n        linear_ramp and that will form the edge of the padded array.\n\n        ``((before_1, after_1), ... (before_N, after_N))`` unique end values\n        for each axis.\n\n        ``(before, after)`` or ``((before, after),)`` yields same before\n        and after end values for each axis.\n\n        ``(constant,)`` or ``constant`` is a shortcut for\n        ``before = after = constant`` for all axes.\n\n        Default is 0."
          },
          "reflect_type": {
            "type": "{'even'",
            "description": ", 'odd'}, optional\n        Used in 'reflect', and 'symmetric'.  The 'even' style is the\n        default with an unaltered reflection around the edge value.  For\n        the 'odd' style, the extended part of the array is created by\n        subtracting the reflected values from two times the edge value."
          },
          "vector": {
            "type": "ndarray",
            "description": "A rank 1 array already padded with zeros.  Padded values are\n            vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:]."
          },
          "iaxis_pad_width": {
            "type": "tuple",
            "description": "A 2-tuple of ints, iaxis_pad_width[0] represents the number of\n            values padded at the beginning of vector where\n            iaxis_pad_width[1] represents the number of values padded at\n            the end of vector."
          },
          "iaxis": {
            "type": "int",
            "description": "The axis currently being calculated."
          },
          "kwargs": {
            "type": "dict",
            "description": "Any keyword arguments the function requires."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "percentile",
      "signature": "percentile(a, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=False, *, interpolation=None)",
      "documentation": {
        "description": "Compute the q-th percentile of the data along the specified axis.\n\n    Returns the q-th percentile(s) of the array elements.",
        "parameters": {
          "q": {
            "type": "array_like of float",
            "description": "Percentage or sequence of percentages for the percentiles to compute.\n        Values must be between 0 and 100 inclusive."
          },
          "axis": {
            "type": "{int",
            "description": ", tuple of int, None}, optional\n        Axis or axes along which the percentiles are computed. The\n        default is to compute the percentile(s) along a flattened\n        version of the array.\n\n        .. versionchanged:: 1.9.0\n            A tuple of axes is supported"
          },
          "out": {
            "type": "ndarray",
            "description": "Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary."
          },
          "overwrite_input": {
            "type": "bool",
            "description": "If True, then allow the input array `a` to be modified by intermediate\n        calculations, to save memory. In this case, the contents of the input\n        `a` after this function completes is undefined."
          },
          "method": {
            "type": "str",
            "description": "This parameter specifies the method to use for estimating the\n        percentile.  There are many different methods, some unique to NumPy.\n        See the notes for explanation.  The options sorted by their R type\n        as summarized in the H&F paper [1]_ are:\n\n        1. 'inverted_cdf'\n        2. 'averaged_inverted_cdf'\n        3. 'closest_observation'\n        4. 'interpolated_inverted_cdf'\n        5. 'hazen'\n        6. 'weibull'\n        7. 'linear'  (default)\n        8. 'median_unbiased'\n        9. 'normal_unbiased'\n\n        The first three methods are discontinuous.  NumPy further defines the\n        following discontinuous variations of the default 'linear' (7.) option:\n\n        * 'lower'\n        * 'higher',\n        * 'midpoint'\n        * 'nearest'\n\n        .. versionchanged:: 1.22.0\n            This argument was previously called \"interpolation\" and only\n            offered the \"linear\" default and last four options."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left in\n        the result as dimensions with size one. With this option, the\n        result will broadcast correctly against the original array `a`.\n\n        .. versionadded:: 1.9.0"
          },
          "interpolation": {
            "type": "str",
            "description": "Deprecated name for the method keyword argument.\n\n        .. deprecated:: 1.22.0"
          },
          "median": {
            "type": "equivalent to ``percentile(...",
            "description": ", 50)``\n    nanpercentile"
          },
          "quantile": {
            "type": "equivalent to percentile",
            "description": ", except q in the range [0, 1]."
          },
          "inverted_cdf": {
            "type": "method 1 of H&F [1]_.",
            "description": "This method gives discontinuous results:\n\n        * if g > 0 ; then take j\n        * if g = 0 ; then take i"
          },
          "averaged_inverted_cdf": {
            "type": "method 2 of H&F [1]_.",
            "description": "This method give discontinuous results:\n\n        * if g > 0 ; then take j\n        * if g = 0 ; then average between bounds"
          },
          "closest_observation": {
            "type": "method 3 of H&F [1]_.",
            "description": "This method give discontinuous results:\n\n        * if g > 0 ; then take j\n        * if g = 0 and index is odd ; then take j\n        * if g = 0 and index is even ; then take i"
          },
          "interpolated_inverted_cdf": {
            "type": "method 4 of H&F [1]_.",
            "description": "This method give continuous results using:\n\n        * alpha = 0\n        * beta = 1"
          },
          "hazen": {
            "type": "method 5 of H&F [1]_.",
            "description": "This method give continuous results using:\n\n        * alpha = 1/2\n        * beta = 1/2"
          },
          "weibull": {
            "type": "method 6 of H&F [1]_.",
            "description": "This method give continuous results using:\n\n        * alpha = 0\n        * beta = 0"
          },
          "linear": {
            "type": "method 7 of H&F [1]_.",
            "description": "This method give continuous results using:\n\n        * alpha = 1\n        * beta = 1"
          },
          "median_unbiased": {
            "type": "method 8 of H&F [1]_.",
            "description": "This method is probably the best method if the sample\n        distribution function is unknown (see reference).\n        This method give continuous results using:\n\n        * alpha = 1/3\n        * beta = 1/3"
          },
          "normal_unbiased": {
            "type": "method 9 of H&F [1]_.",
            "description": "This method is probably the best method if the sample\n        distribution function is known to be normal.\n        This method give continuous results using:\n\n        * alpha = 3/8\n        * beta = 3/8"
          },
          "lower": {
            "type": "NumPy method kept for backwards compatibility.",
            "description": "Takes ``i`` as the interpolation point."
          },
          "higher": {
            "type": "NumPy method kept for backwards compatibility.",
            "description": "Takes ``j`` as the interpolation point."
          },
          "nearest": {
            "type": "NumPy method kept for backwards compatibility.",
            "description": "Takes ``i`` or ``j``, whichever is nearest."
          },
          "midpoint": {
            "type": "NumPy method kept for backwards compatibility.",
            "description": "Uses ``(i + j) / 2``."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "piecewise",
      "signature": "piecewise(x, condlist, funclist, *args, **kw)",
      "documentation": {
        "description": "Evaluate a piecewise-defined function.\n\n    Given a set of conditions and corresponding functions, evaluate each\n    function on the input data wherever its condition is true.",
        "parameters": {
          "condlist": {
            "type": "list of bool arrays or bool scalars",
            "description": "Each boolean array corresponds to a function in `funclist`.  Wherever\n        `condlist[i]` is True, `funclist[i](x)` is used as the output value.\n\n        Each boolean array in `condlist` selects a piece of `x`,\n        and should therefore be of the same shape as `x`.\n\n        The length of `condlist` must correspond to that of `funclist`.\n        If one extra function is given, i.e. if\n        ``len(funclist) == len(condlist) + 1``, then that extra function\n        is the default value, used wherever all conditions are false."
          },
          "funclist": {
            "type": "list of callables",
            "description": ", f(x,*args,**kw), or scalars\n        Each function is evaluated over `x` wherever its corresponding\n        condition is True.  It should take a 1d array as input and give an 1d\n        array or a scalar value as output.  If, instead of a callable,\n        a scalar is provided then a constant function (``lambda x: scalar``) is\n        assumed."
          },
          "args": {
            "type": "tuple",
            "description": "Any further arguments given to `piecewise` are passed to the functions\n        upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then\n        each function is called as ``f(x, 1, 'a')``."
          },
          "kw": {
            "type": "dict",
            "description": "Keyword arguments used in calling `piecewise` are passed to the\n        functions upon execution, i.e., if called\n        ``piecewise(..., ..., alpha=1)``, then each function is called as\n        ``f(x, alpha=1)``."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "place",
      "signature": "place(arr, mask, vals)",
      "documentation": {
        "description": "Change elements of an array based on conditional and input values.\n\n    Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that\n    `place` uses the first N elements of `vals`, where N is the number of\n    True values in `mask`, while `copyto` uses the elements where `mask`\n    is True.\n\n    Note that `extract` does the exact opposite of `place`.",
        "parameters": {
          "mask": {
            "type": "array_like",
            "description": "Boolean mask array. Must have the same size as `a`."
          },
          "vals": {
            "type": "1-D sequence",
            "description": "Values to put into `a`. Only the first N elements are used, where\n        N is the number of True values in `mask`. If `vals` is smaller\n        than N, it will be repeated, and if elements of `a` are to be masked,\n        this sequence must be non-empty."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "poly",
      "signature": "poly(seq_of_zeros)",
      "documentation": {
        "description": "Find the coefficients of a polynomial with the given sequence of roots.\n\n    .. note::\n       This forms part of the old polynomial API. Since version 1.4, the\n       new polynomial API defined in `numpy.polynomial` is preferred.\n       A summary of the differences can be found in the\n       :doc:`transition guide </reference/routines.polynomials>`.\n\n    Returns the coefficients of the polynomial whose leading coefficient\n    is one for the given sequence of zeros (multiple roots must be included\n    in the sequence as many times as their multiplicity; see Examples).\n    A square matrix (or array, which will be treated as a matrix) can also\n    be given, in which case the coefficients of the characteristic polynomial\n    of the matrix are returned.",
        "parameters": {
          "roots": {
            "type": "Return the roots of a polynomial.",
            "description": ""
          },
          "polyfit": {
            "type": "Least squares polynomial fit.",
            "description": ""
          },
          "poly1d": {
            "type": "A one-dimensional polynomial class.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "polyadd",
      "signature": "polyadd(a1, a2)",
      "documentation": {
        "description": "Find the sum of two polynomials.\n\n    .. note::\n       This forms part of the old polynomial API. Since version 1.4, the\n       new polynomial API defined in `numpy.polynomial` is preferred.\n       A summary of the differences can be found in the\n       :doc:`transition guide </reference/routines.polynomials>`.\n\n    Returns the polynomial resulting from the sum of two input polynomials.\n    Each input must be either a poly1d object or a 1D sequence of polynomial\n    coefficients, from highest to lowest degree.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "polyder",
      "signature": "polyder(p, m=1)",
      "documentation": {
        "description": "Return the derivative of the specified order of a polynomial.\n\n    .. note::\n       This forms part of the old polynomial API. Since version 1.4, the\n       new polynomial API defined in `numpy.polynomial` is preferred.\n       A summary of the differences can be found in the\n       :doc:`transition guide </reference/routines.polynomials>`.",
        "parameters": {
          "m": {
            "type": "int",
            "description": "Order of differentiation (default: 1)"
          },
          "poly1d": {
            "type": "Class for one-dimensional polynomials.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "polydiv",
      "signature": "polydiv(u, v)",
      "documentation": {
        "description": "Returns the quotient and remainder of polynomial division.\n\n    .. note::\n       This forms part of the old polynomial API. Since version 1.4, the\n       new polynomial API defined in `numpy.polynomial` is preferred.\n       A summary of the differences can be found in the\n       :doc:`transition guide </reference/routines.polynomials>`.\n\n    The input arrays are the coefficients (including any coefficients\n    equal to zero) of the \"numerator\" (dividend) and \"denominator\"\n    (divisor) polynomials, respectively.",
        "parameters": {
          "v": {
            "type": "array_like or poly1d",
            "description": "Divisor polynomial's coefficients."
          },
          "r": {
            "type": "ndarray",
            "description": "Coefficients, including those equal to zero, of the remainder."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "polyfit",
      "signature": "polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False)",
      "documentation": {
        "description": "Least squares polynomial fit.\n\n    .. note::\n       This forms part of the old polynomial API. Since version 1.4, the\n       new polynomial API defined in `numpy.polynomial` is preferred.\n       A summary of the differences can be found in the\n       :doc:`transition guide </reference/routines.polynomials>`.\n\n    Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`\n    to points `(x, y)`. Returns a vector of coefficients `p` that minimises\n    the squared error in the order `deg`, `deg-1`, ... `0`.\n\n    The `Polynomial.fit <numpy.polynomial.polynomial.Polynomial.fit>` class\n    method is recommended for new code as it is more stable numerically. See\n    the documentation of the method for more information.",
        "parameters": {
          "y": {
            "type": "array_like",
            "description": ", shape (M,) or (M, K)\n        y-coordinates of the sample points. Several data sets of sample\n        points sharing the same x-coordinates can be fitted at once by\n        passing in a 2D-array that contains one dataset per column."
          },
          "deg": {
            "type": "int",
            "description": "Degree of the fitting polynomial"
          },
          "rcond": {
            "type": "float",
            "description": "Relative condition number of the fit. Singular values smaller than\n        this relative to the largest singular value will be ignored. The\n        default value is len(x)*eps, where eps is the relative precision of\n        the float type, about 2e-16 in most cases."
          },
          "full": {
            "type": "bool",
            "description": "Switch determining nature of return value. When it is False (the\n        default) just the coefficients are returned, when True diagnostic\n        information from the singular value decomposition is also returned."
          },
          "w": {
            "type": "array_like",
            "description": ", shape (M,), optional\n        Weights. If not None, the weight ``w[i]`` applies to the unsquared\n        residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are\n        chosen so that the errors of the products ``w[i]*y[i]`` all have the\n        same variance.  When using inverse-variance weighting, use\n        ``w[i] = 1/sigma(y[i])``.  The default value is None."
          },
          "cov": {
            "type": "bool or str",
            "description": "If given and not `False`, return not just the estimate but also its\n        covariance matrix. By default, the covariance are scaled by\n        chi2/dof, where dof = M - (deg + 1), i.e., the weights are presumed\n        to be unreliable except in a relative sense and everything is scaled\n        such that the reduced chi2 is unity. This scaling is omitted if\n        ``cov='unscaled'``, as is relevant for the case that the weights are\n        w = 1/sigma, with sigma known to be a reliable estimate of the\n        uncertainty."
          },
          "V": {
            "type": "ndarray",
            "description": ", shape (M,M) or (M,M,K)\n        Present only if ``full == False`` and ``cov == True``.  The covariance\n        matrix of the polynomial coefficient estimates.  The diagonal of\n        this matrix are the variance estimates for each coefficient.  If y\n        is a 2-D array, then the covariance matrix for the `k`-th data set\n        are in ``V[:,:,k]``\n\n\n    Warns\n    -----\n    RankWarning\n        The rank of the coefficient matrix in the least-squares fit is\n        deficient. The warning is only raised if ``full == False``.\n\n        The warnings can be turned off by\n\n        >>> import warnings\n        >>> warnings.simplefilter('ignore', np.RankWarning)"
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Polynomial_interpolation",
            "description": ""
          },
          "Illustration": {
            "type": ">>> import matplotlib.pyplot as plt",
            "description": ">>> xp = np.linspace(-2, 6, 100)\n    >>> _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n    >>> plt.ylim(-2,2)\n    (-2, 2)\n    >>> plt.show()"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "polyint",
      "signature": "polyint(p, m=1, k=None)",
      "documentation": {
        "description": "Return an antiderivative (indefinite integral) of a polynomial.\n\n    .. note::\n       This forms part of the old polynomial API. Since version 1.4, the\n       new polynomial API defined in `numpy.polynomial` is preferred.\n       A summary of the differences can be found in the\n       :doc:`transition guide </reference/routines.polynomials>`.\n\n    The returned order `m` antiderivative `P` of polynomial `p` satisfies\n    :math:`\\frac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1`\n    integration constants `k`. The constants determine the low-order\n    polynomial part\n\n    .. math:: \\frac{k_{m-1}}{0!} x^0 + \\ldots + \\frac{k_0}{(m-1)!}x^{m-1}\n\n    of `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`.",
        "parameters": {
          "m": {
            "type": "int",
            "description": "Order of the antiderivative. (Default: 1)"
          },
          "k": {
            "type": "list of `m` scalars or scalar",
            "description": "Integration constants. They are given in the order of integration:\n        those corresponding to highest-order terms come first.\n\n        If ``None`` (default), all constants are assumed to be zero.\n        If `m = 1`, a single scalar can be given instead of a list."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "polymul",
      "signature": "polymul(a1, a2)",
      "documentation": {
        "description": "Find the product of two polynomials.\n\n    .. note::\n       This forms part of the old polynomial API. Since version 1.4, the\n       new polynomial API defined in `numpy.polynomial` is preferred.\n       A summary of the differences can be found in the\n       :doc:`transition guide </reference/routines.polynomials>`.\n\n    Finds the polynomial resulting from the multiplication of the two input\n    polynomials. Each input must be either a poly1d object or a 1D sequence\n    of polynomial coefficients, from highest to lowest degree.",
        "parameters": {
          "convolve": {
            "type": "Array convolution. Same output as polymul",
            "description": ", but has parameter\n               for overlap mode."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "polysub",
      "signature": "polysub(a1, a2)",
      "documentation": {
        "description": "Difference (subtraction) of two polynomials.\n\n    .. note::\n       This forms part of the old polynomial API. Since version 1.4, the\n       new polynomial API defined in `numpy.polynomial` is preferred.\n       A summary of the differences can be found in the\n       :doc:`transition guide </reference/routines.polynomials>`.\n\n    Given two polynomials `a1` and `a2`, returns ``a1 - a2``.\n    `a1` and `a2` can be either array_like sequences of the polynomials'\n    coefficients (including coefficients equal to zero), or `poly1d` objects.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "polyval",
      "signature": "polyval(p, x)",
      "documentation": {
        "description": "Evaluate a polynomial at specific values.\n\n    .. note::\n       This forms part of the old polynomial API. Since version 1.4, the\n       new polynomial API defined in `numpy.polynomial` is preferred.\n       A summary of the differences can be found in the\n       :doc:`transition guide </reference/routines.polynomials>`.\n\n    If `p` is of length N, this function returns the value:\n\n        ``p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]``\n\n    If `x` is a sequence, then ``p(x)`` is returned for each element of ``x``.\n    If `x` is another polynomial then the composite polynomial ``p(x(t))``\n    is returned.",
        "parameters": {
          "x": {
            "type": "array_like or poly1d object",
            "description": "A number, an array of numbers, or an instance of poly1d, at\n       which to evaluate `p`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "put_along_axis",
      "signature": "put_along_axis(arr, indices, values, axis)",
      "documentation": {
        "description": "Put values into the destination array by matching 1d index and data slices.\n\n    This iterates over matching 1d slices oriented along the specified axis in\n    the index and data arrays, and uses the former to place values into the\n    latter. These slices can be different lengths.\n\n    Functions returning an index along an axis, like `argsort` and\n    `argpartition`, produce suitable indices for this function.\n\n    .. versionadded:: 1.15.0",
        "parameters": {
          "indices": {
            "type": "ndarray (Ni...",
            "description": ", J, Nk...)\n        Indices to change along each 1d slice of `arr`. This must match the\n        dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast\n        against `arr`."
          },
          "values": {
            "type": "array_like (Ni...",
            "description": ", J, Nk...)\n        values to insert at those indices. Its shape and dimension are\n        broadcast to match that of `indices`."
          },
          "axis": {
            "type": "int",
            "description": "The axis to take 1d slices along. If axis is None, the destination\n        array is treated as if a flattened 1d view had been created of it."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "quantile",
      "signature": "quantile(a, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=False, *, interpolation=None)",
      "documentation": {
        "description": "Compute the q-th quantile of the data along the specified axis.\n\n    .. versionadded:: 1.15.0",
        "parameters": {
          "q": {
            "type": "array_like of float",
            "description": "Probability or sequence of probabilities for the quantiles to compute.\n        Values must be between 0 and 1 inclusive."
          },
          "axis": {
            "type": "{int",
            "description": ", tuple of int, None}, optional\n        Axis or axes along which the quantiles are computed. The default is\n        to compute the quantile(s) along a flattened version of the array."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternative output array in which to place the result. It must have\n        the same shape and buffer length as the expected output, but the\n        type (of the output) will be cast if necessary."
          },
          "overwrite_input": {
            "type": "bool",
            "description": "If True, then allow the input array `a` to be modified by\n        intermediate calculations, to save memory. In this case, the\n        contents of the input `a` after this function completes is\n        undefined."
          },
          "method": {
            "type": "str",
            "description": "This parameter specifies the method to use for estimating the\n        quantile.  There are many different methods, some unique to NumPy.\n        See the notes for explanation.  The options sorted by their R type\n        as summarized in the H&F paper [1]_ are:\n\n        1. 'inverted_cdf'\n        2. 'averaged_inverted_cdf'\n        3. 'closest_observation'\n        4. 'interpolated_inverted_cdf'\n        5. 'hazen'\n        6. 'weibull'\n        7. 'linear'  (default)\n        8. 'median_unbiased'\n        9. 'normal_unbiased'\n\n        The first three methods are discontinuous.  NumPy further defines the\n        following discontinuous variations of the default 'linear' (7.) option:\n\n        * 'lower'\n        * 'higher',\n        * 'midpoint'\n        * 'nearest'\n\n        .. versionchanged:: 1.22.0\n            This argument was previously called \"interpolation\" and only\n            offered the \"linear\" default and last four options."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left in\n        the result as dimensions with size one. With this option, the\n        result will broadcast correctly against the original array `a`."
          },
          "interpolation": {
            "type": "str",
            "description": "Deprecated name for the method keyword argument.\n\n        .. deprecated:: 1.22.0"
          },
          "percentile": {
            "type": "equivalent to quantile",
            "description": ", but with q in the range [0, 100]."
          },
          "median": {
            "type": "equivalent to ``quantile(...",
            "description": ", 0.5)``\n    nanquantile"
          },
          "inverted_cdf": {
            "type": "method 1 of H&F [1]_.",
            "description": "This method gives discontinuous results:\n\n        * if g > 0 ; then take j\n        * if g = 0 ; then take i"
          },
          "averaged_inverted_cdf": {
            "type": "method 2 of H&F [1]_.",
            "description": "This method gives discontinuous results:\n\n        * if g > 0 ; then take j\n        * if g = 0 ; then average between bounds"
          },
          "closest_observation": {
            "type": "method 3 of H&F [1]_.",
            "description": "This method gives discontinuous results:\n\n        * if g > 0 ; then take j\n        * if g = 0 and index is odd ; then take j\n        * if g = 0 and index is even ; then take i"
          },
          "interpolated_inverted_cdf": {
            "type": "method 4 of H&F [1]_.",
            "description": "This method gives continuous results using:\n\n        * alpha = 0\n        * beta = 1"
          },
          "hazen": {
            "type": "method 5 of H&F [1]_.",
            "description": "This method gives continuous results using:\n\n        * alpha = 1/2\n        * beta = 1/2"
          },
          "weibull": {
            "type": "method 6 of H&F [1]_.",
            "description": "This method gives continuous results using:\n\n        * alpha = 0\n        * beta = 0"
          },
          "linear": {
            "type": "method 7 of H&F [1]_.",
            "description": "This method gives continuous results using:\n\n        * alpha = 1\n        * beta = 1"
          },
          "median_unbiased": {
            "type": "method 8 of H&F [1]_.",
            "description": "This method is probably the best method if the sample\n        distribution function is unknown (see reference).\n        This method gives continuous results using:\n\n        * alpha = 1/3\n        * beta = 1/3"
          },
          "normal_unbiased": {
            "type": "method 9 of H&F [1]_.",
            "description": "This method is probably the best method if the sample\n        distribution function is known to be normal.\n        This method gives continuous results using:\n\n        * alpha = 3/8\n        * beta = 3/8"
          },
          "lower": {
            "type": "NumPy method kept for backwards compatibility.",
            "description": "Takes ``i`` as the interpolation point."
          },
          "higher": {
            "type": "NumPy method kept for backwards compatibility.",
            "description": "Takes ``j`` as the interpolation point."
          },
          "nearest": {
            "type": "NumPy method kept for backwards compatibility.",
            "description": "Takes ``i`` or ``j``, whichever is nearest."
          },
          "midpoint": {
            "type": "NumPy method kept for backwards compatibility.",
            "description": "Uses ``(i + j) / 2``."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ravel_multi_index",
      "signature": "ravel_multi_index(...)",
      "documentation": {
        "description": "ravel_multi_index(multi_index, dims, mode='raise', order='C')\n\n    Converts a tuple of index arrays into an array of flat\n    indices, applying boundary modes to the multi-index.",
        "parameters": {
          "dims": {
            "type": "tuple of ints",
            "description": "The shape of array into which the indices from ``multi_index`` apply."
          },
          "mode": {
            "type": "{'raise'",
            "description": ", 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices are handled.  Can specify\n        either one mode or a tuple of modes, one mode per index.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        In 'clip' mode, a negative index which would normally\n        wrap will clip to 0 instead."
          },
          "order": {
            "type": "{'C'",
            "description": ", 'F'}, optional\n        Determines whether the multi-index should be viewed as\n        indexing in row-major (C-style) or column-major\n        (Fortran-style) order."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "real",
      "signature": "real(val)",
      "documentation": {
        "description": "Return the real part of the complex argument.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "real_if_close",
      "signature": "real_if_close(a, tol=100)",
      "documentation": {
        "description": "If input is complex with all imaginary parts close to zero, return\n    real parts.\n\n    \"Close to zero\" is defined as `tol` * (machine epsilon of the type for\n    `a`).",
        "parameters": {
          "tol": {
            "type": "float",
            "description": "Tolerance in machine epsilons for the complex part of the elements\n        in the array. If the tolerance is <=1, then the absolute tolerance\n        is used."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "recfromcsv",
      "signature": "recfromcsv(fname, **kwargs)",
      "documentation": {
        "description": "Load ASCII data stored in a comma-separated file.\n\n    The returned array is a record array (if ``usemask=False``, see\n    `recarray`) or a masked record array (if ``usemask=True``,\n    see `ma.mrecords.MaskedRecords`).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "recfromtxt",
      "signature": "recfromtxt(fname, **kwargs)",
      "documentation": {
        "description": "Load ASCII data from a file and return it in a record array.\n\n    If ``usemask=False`` a standard `recarray` is returned,\n    if ``usemask=True`` a MaskedRecords array is returned.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "roots",
      "signature": "roots(p)",
      "documentation": {
        "description": "Return the roots of a polynomial with coefficients given in p.\n\n    .. note::\n       This forms part of the old polynomial API. Since version 1.4, the\n       new polynomial API defined in `numpy.polynomial` is preferred.\n       A summary of the differences can be found in the\n       :doc:`transition guide </reference/routines.polynomials>`.\n\n    The values in the rank-1 array `p` are coefficients of a polynomial.\n    If the length of `p` is n+1 then the polynomial is described by::\n\n      p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]",
        "parameters": {
          "poly": {
            "type": "Find the coefficients of a polynomial with a given sequence",
            "description": "of roots."
          },
          "polyval": {
            "type": "Compute polynomial values.",
            "description": ""
          },
          "polyfit": {
            "type": "Least squares polynomial fit.",
            "description": ""
          },
          "poly1d": {
            "type": "A one-dimensional polynomial class.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "rot90",
      "signature": "rot90(m, k=1, axes=(0, 1))",
      "documentation": {
        "description": "Rotate an array by 90 degrees in the plane specified by axes.\n\n    Rotation direction is from the first towards the second axis.\n    This means for a 2D array with the default `k` and `axes`, the\n    rotation will be counterclockwise.",
        "parameters": {
          "k": {
            "type": "integer",
            "description": "Number of times the array is rotated by 90 degrees."
          },
          "axes": {
            "type": "(2",
            "description": ",) array_like\n        The array is rotated in the plane defined by the axes.\n        Axes must be different.\n\n        .. versionadded:: 1.12.0"
          },
          "fliplr": {
            "type": "Flip an array horizontally.",
            "description": ""
          },
          "flipud": {
            "type": "Flip an array vertically.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "row_stack",
      "signature": "vstack(tup, *, dtype=None, casting='same_kind')",
      "documentation": {
        "description": "Stack arrays in sequence vertically (row wise).\n\n    This is equivalent to concatenation along the first axis after 1-D arrays\n    of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by\n    `vsplit`.\n\n    This function makes most sense for arrays with up to 3 dimensions. For\n    instance, for pixel-data with a height (first axis), width (second axis),\n    and r/g/b channels (third axis). The functions `concatenate`, `stack` and\n    `block` provide more general stacking and concatenation operations.\n\n    ``np.row_stack`` is an alias for `vstack`. They are the same function.",
        "parameters": {
          "dtype": {
            "type": "str or dtype",
            "description": "If provided, the destination array will have this dtype. Cannot be\n        provided together with `out`.\n\n    .. versionadded:: 1.24"
          },
          "casting": {
            "type": "{'no'",
            "description": ", 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n    .. versionadded:: 1.24"
          },
          "stack": {
            "type": "Join a sequence of arrays along a new axis.",
            "description": ""
          },
          "block": {
            "type": "Assemble an nd-array from nested lists of blocks.",
            "description": ""
          },
          "hstack": {
            "type": "Stack arrays in sequence horizontally (column wise).",
            "description": ""
          },
          "dstack": {
            "type": "Stack arrays in sequence depth wise (along third axis).",
            "description": ""
          },
          "column_stack": {
            "type": "Stack 1-D arrays as columns into a 2-D array.",
            "description": ""
          },
          "vsplit": {
            "type": "Split an array into multiple sub-arrays vertically (row-wise).",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "safe_eval",
      "signature": "safe_eval(source)",
      "documentation": {
        "description": "Protected string evaluation.\n\n    Evaluate a string containing a Python literal expression without\n    allowing the execution of arbitrary non-literal code.\n\n    .. warning::\n\n        This function is identical to :py:meth:`ast.literal_eval` and\n        has the same security implications.  It may not always be safe\n        to evaluate large input strings.",
        "parameters": {
          "SyntaxError": {
            "type": "invalid syntax",
            "description": ">>> np.safe_eval('open(\"/home/user/.ssh/id_dsa\").read()')\n    Traceback (most recent call last):\n      ..."
          },
          "ValueError": {
            "type": "malformed node or string: <_ast.Call object at 0x...>",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "save",
      "signature": "save(file, arr, allow_pickle=True, fix_imports=True)",
      "documentation": {
        "description": "Save an array to a binary file in NumPy ``.npy`` format.",
        "parameters": {
          "arr": {
            "type": "array_like",
            "description": "Array data to be saved."
          },
          "allow_pickle": {
            "type": "bool",
            "description": "Allow saving object arrays using Python pickles. Reasons for disallowing\n        pickles include security (loading pickled data can execute arbitrary\n        code) and portability (pickled objects may not be loadable on different\n        Python installations, for example if the stored objects require libraries\n        that are not available, and not all pickled data is compatible between\n        Python 2 and Python 3)."
          },
          "Default": {
            "type": "True",
            "description": ""
          },
          "fix_imports": {
            "type": "bool",
            "description": "Only useful in forcing objects in object arrays on Python 3 to be\n        pickled in a Python 2 compatible way. If `fix_imports` is True, pickle\n        will try to map the new Python 3 names to the old module names used in\n        Python 2, so that the pickle data stream is readable with Python 2."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "savetxt",
      "signature": "savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\\n', header='', footer='', comments='# ', encoding=None)",
      "documentation": {
        "description": "Save an array to a text file.",
        "parameters": {
          "X": {
            "type": "1D or 2D array_like",
            "description": "Data to be saved to a text file."
          },
          "fmt": {
            "type": "str or sequence of strs",
            "description": "A single format (%10.5f), a sequence of formats, or a\n        multi-format string, e.g. 'Iteration %d -- %10.5f', in which\n        case `delimiter` is ignored. For complex `X`, the legal options\n        for `fmt` are:\n\n        * a single specifier, `fmt='%.4e'`, resulting in numbers formatted\n          like `' (%s+%sj)' % (fmt, fmt)`\n        * a full string specifying every real and imaginary part, e.g.\n          `' %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej'` for 3 columns\n        * a list of specifiers, one per column - in this case, the real\n          and imaginary part must have separate specifiers,\n          e.g. `['%.3e + %.3ej', '(%.15e%+.15ej)']` for 2 columns"
          },
          "delimiter": {
            "type": "str",
            "description": "String or character separating columns."
          },
          "newline": {
            "type": "str",
            "description": "String or character separating lines.\n\n        .. versionadded:: 1.5.0"
          },
          "header": {
            "type": "str",
            "description": "String that will be written at the beginning of the file.\n\n        .. versionadded:: 1.7.0"
          },
          "footer": {
            "type": "str",
            "description": "String that will be written at the end of the file.\n\n        .. versionadded:: 1.7.0"
          },
          "comments": {
            "type": "str",
            "description": "String that will be prepended to the ``header`` and ``footer`` strings,\n        to mark them as comments. Default: '# ',  as expected by e.g.\n        ``numpy.loadtxt``.\n\n        .. versionadded:: 1.7.0"
          },
          "encoding": {
            "type": "{None",
            "description": ", str}, optional\n        Encoding used to encode the outputfile. Does not apply to output\n        streams. If the encoding is something other than 'bytes' or 'latin1'\n        you will not be able to load the file in NumPy versions < 1.14. Default\n        is 'latin1'.\n\n        .. versionadded:: 1.14.0"
          },
          "savez": {
            "type": "Save several arrays into an uncompressed ``.npz`` archive",
            "description": ""
          },
          "savez_compressed": {
            "type": "Save several arrays into a compressed ``.npz`` archive",
            "description": ""
          },
          "flags": {
            "type": "``-`` : left justify",
            "description": "``+`` : Forces to precede result with + or -.\n\n        ``0`` : Left pad the number with zeros instead of space (see width)."
          },
          "width": {
            "type": "Minimum number of characters to be printed. The value is not truncated",
            "description": "if it has more characters."
          },
          "precision": {
            "type": "- For integer specifiers (eg. ``d",
            "description": ",i,o,x``), the minimum number of\n          digits.\n        - For ``e, E`` and ``f`` specifiers, the number of digits to print\n          after the decimal point.\n        - For ``g`` and ``G``, the maximum number of significant digits.\n        - For ``s``, the maximum number of characters."
          },
          "specifiers": {
            "type": "``c`` : character",
            "description": "``d`` or ``i`` : signed decimal integer\n\n        ``e`` or ``E`` : scientific notation with ``e`` or ``E``.\n\n        ``f`` : decimal floating point\n\n        ``g,G`` : use the shorter of ``e,E`` or ``f``\n\n        ``o`` : signed octal\n\n        ``s`` : string of characters\n\n        ``u`` : unsigned decimal integer\n\n        ``x,X`` : unsigned hexadecimal integer\n\n    This explanation of ``fmt`` is not complete, for an exhaustive\n    specification see [1]_.\n\n    References\n    ----------\n    .. [1] `Format Specification Mini-Language\n           <https://docs.python.org/library/string.html#format-specification-mini-language>`_,\n           Python Documentation."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "savez",
      "signature": "savez(file, *args, **kwds)",
      "documentation": {
        "description": "Save several arrays into a single file in uncompressed ``.npz`` format.\n\n    Provide arrays as keyword arguments to store them under the\n    corresponding name in the output file: ``savez(fn, x=x, y=y)``.\n\n    If arrays are specified as positional arguments, i.e., ``savez(fn,\n    x, y)``, their names will be `arr_0`, `arr_1`, etc.",
        "parameters": {
          "args": {
            "type": "Arguments",
            "description": "Arrays to save to the file. Please use keyword arguments (see\n        `kwds` below) to assign names to arrays.  Arrays specified as\n        args will be named \"arr_0\", \"arr_1\", and so on."
          },
          "kwds": {
            "type": "Keyword arguments",
            "description": "Arrays to save to the file. Each array will be saved to the\n        output file with its corresponding keyword name."
          },
          "savetxt": {
            "type": "Save an array to a file as plain text.",
            "description": ""
          },
          "savez_compressed": {
            "type": "Save several arrays into a compressed ``.npz`` archive",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "savez_compressed",
      "signature": "savez_compressed(file, *args, **kwds)",
      "documentation": {
        "description": "Save several arrays into a single file in compressed ``.npz`` format.\n\n    Provide arrays as keyword arguments to store them under the\n    corresponding name in the output file: ``savez(fn, x=x, y=y)``.\n\n    If arrays are specified as positional arguments, i.e., ``savez(fn,\n    x, y)``, their names will be `arr_0`, `arr_1`, etc.",
        "parameters": {
          "args": {
            "type": "Arguments",
            "description": "Arrays to save to the file. Please use keyword arguments (see\n        `kwds` below) to assign names to arrays.  Arrays specified as\n        args will be named \"arr_0\", \"arr_1\", and so on."
          },
          "kwds": {
            "type": "Keyword arguments",
            "description": "Arrays to save to the file. Each array will be saved to the\n        output file with its corresponding keyword name."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "select",
      "signature": "select(condlist, choicelist, default=0)",
      "documentation": {
        "description": "Return an array drawn from elements in choicelist, depending on conditions.",
        "parameters": {
          "choicelist": {
            "type": "list of ndarrays",
            "description": "The list of arrays from which the output elements are taken. It has\n        to be of the same length as `condlist`."
          },
          "default": {
            "type": "scalar",
            "description": "The element inserted in `output` when all conditions evaluate to False."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "setdiff1d",
      "signature": "setdiff1d(ar1, ar2, assume_unique=False)",
      "documentation": {
        "description": "Find the set difference of two arrays.\n\n    Return the unique values in `ar1` that are not in `ar2`.",
        "parameters": {
          "ar2": {
            "type": "array_like",
            "description": "Input comparison array."
          },
          "assume_unique": {
            "type": "bool",
            "description": "If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "setxor1d",
      "signature": "setxor1d(ar1, ar2, assume_unique=False)",
      "documentation": {
        "description": "Find the set exclusive-or of two arrays.\n\n    Return the sorted, unique values that are in only one (not both) of the\n    input arrays.",
        "parameters": {
          "assume_unique": {
            "type": "bool",
            "description": "If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "show_runtime",
      "signature": "show_runtime()",
      "documentation": {
        "description": "Print information about various resources in the system\n    including available intrinsic support and BLAS/LAPACK library\n    in use\n\n    .. versionadded:: 1.24.0",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "1. Information is derived with the help of `threadpoolctl <https://pypi.org/project/threadpoolctl/>`_\n       library if available.\n    2. SIMD related information is derived from ``__cpu_features__``,\n       ``__cpu_baseline__`` and ``__cpu_dispatch__``",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sinc",
      "signature": "sinc(x)",
      "documentation": {
        "description": "Return the normalized sinc function.\n\n    The sinc function is equal to :math:`\\sin(\\pi x)/(\\pi x)` for any argument\n    :math:`x\\ne 0`. ``sinc(0)`` takes the limit value 1, making ``sinc`` not\n    only everywhere continuous but also infinitely differentiable.\n\n    .. note::\n\n        Note the normalization factor of ``pi`` used in the definition.\n        This is the most commonly used definition in signal processing.\n        Use ``sinc(x / np.pi)`` to obtain the unnormalized sinc function\n        :math:`\\sin(x)/x` that is more common in mathematics.",
        "parameters": {
          "https": {
            "type": "//en.wikipedia.org/wiki/Sinc_function",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sort_complex",
      "signature": "sort_complex(a)",
      "documentation": {
        "description": "Sort a complex array using the real part first, then the imaginary part.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "source",
      "signature": "source(object, output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)",
      "documentation": {
        "description": "Print or write to a file the source code for a NumPy object.\n\n    The source code is only returned for objects written in Python. Many\n    functions and classes are defined in C and will therefore not return\n    useful information.",
        "parameters": {
          "output": {
            "type": "file object",
            "description": "If `output` not supplied then source code is printed to screen\n        (sys.stdout).  File object must be created with either write 'w' or\n        append 'a' modes."
          },
          "else": {
            "type": "return compiled_interp(x",
            "description": ", xp, fp, left, right)\n\n    The source code is only returned for objects written in Python.\n\n    >>> np.source(np.array)                         #doctest: +SKIP\n    Not available for this object."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "split",
      "signature": "split(ary, indices_or_sections, axis=0)",
      "documentation": {
        "description": "Split an array into multiple sub-arrays as views into `ary`.",
        "parameters": {
          "indices_or_sections": {
            "type": "int or 1-D array",
            "description": "If `indices_or_sections` is an integer, N, the array will be divided\n        into N equal arrays along `axis`.  If such a split is not possible,\n        an error is raised.\n\n        If `indices_or_sections` is a 1-D array of sorted integers, the entries\n        indicate where along `axis` the array is split.  For example,\n        ``[2, 3]`` would, for ``axis=0``, result in\n\n          - ary[:2]\n          - ary[2:3]\n          - ary[3:]\n\n        If an index exceeds the dimension of the array along `axis`,\n        an empty sub-array is returned correspondingly."
          },
          "axis": {
            "type": "int",
            "description": "The axis along which to split, default is 0."
          },
          "hsplit": {
            "type": "Split array into multiple sub-arrays horizontally (column-wise).",
            "description": ""
          },
          "vsplit": {
            "type": "Split array into multiple sub-arrays vertically (row wise).",
            "description": ""
          },
          "dsplit": {
            "type": "Split array into multiple sub-arrays along the 3rd axis (depth).",
            "description": ""
          },
          "concatenate": {
            "type": "Join a sequence of arrays along an existing axis.",
            "description": ""
          },
          "stack": {
            "type": "Join a sequence of arrays along a new axis.",
            "description": ""
          },
          "hstack": {
            "type": "Stack arrays in sequence horizontally (column wise).",
            "description": ""
          },
          "vstack": {
            "type": "Stack arrays in sequence vertically (row wise).",
            "description": ""
          },
          "dstack": {
            "type": "Stack arrays in sequence depth wise (along third dimension).",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "take_along_axis",
      "signature": "take_along_axis(arr, indices, axis)",
      "documentation": {
        "description": "Take values from the input array by matching 1d index and data slices.\n\n    This iterates over matching 1d slices oriented along the specified axis in\n    the index and data arrays, and uses the former to look up values in the\n    latter. These slices can be different lengths.\n\n    Functions returning an index along an axis, like `argsort` and\n    `argpartition`, produce suitable indices for this function.\n\n    .. versionadded:: 1.15.0",
        "parameters": {
          "indices": {
            "type": "ndarray (Ni...",
            "description": ", J, Nk...)\n        Indices to take along each 1d slice of `arr`. This must match the\n        dimension of arr, but dimensions Ni and Nj only need to broadcast\n        against `arr`."
          },
          "axis": {
            "type": "int",
            "description": "The axis to take 1d slices along. If axis is None, the input array is\n        treated as if it had first been flattened to 1d, for consistency with\n        `sort` and `argsort`."
          },
          "put_along_axis": {
            "type": "Put values into the destination array by matching 1d index and data slices",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "tile",
      "signature": "tile(A, reps)",
      "documentation": {
        "description": "Construct an array by repeating A the number of times given by reps.\n\n    If `reps` has length ``d``, the result will have dimension of\n    ``max(d, A.ndim)``.\n\n    If ``A.ndim < d``, `A` is promoted to be d-dimensional by prepending new\n    axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,\n    or shape (1, 1, 3) for 3-D replication. If this is not the desired\n    behavior, promote `A` to d-dimensions manually before calling this\n    function.\n\n    If ``A.ndim > d``, `reps` is promoted to `A`.ndim by pre-pending 1's to it.\n    Thus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as\n    (1, 1, 2, 2).\n\n    Note : Although tile may be used for broadcasting, it is strongly\n    recommended to use numpy's broadcasting operations and functions.",
        "parameters": {
          "reps": {
            "type": "array_like",
            "description": "The number of repetitions of `A` along each axis."
          },
          "broadcast_to": {
            "type": "Broadcast an array to a new shape",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "trapz",
      "signature": "trapz(y, x=None, dx=1.0, axis=-1)",
      "documentation": {
        "description": "Integrate along the given axis using the composite trapezoidal rule.\n\n    If `x` is provided, the integration happens in sequence along its\n    elements - they are not sorted.\n\n    Integrate `y` (`x`) along each 1d slice on the given axis, compute\n    :math:`\\int y(x) dx`.\n    When `x` is specified, this integrates along the parametric curve,\n    computing :math:`\\int_t y(t) dt =\n    \\int_t y(t) \\left.\\frac{dx}{dt}\\right|_{x=x(t)} dt`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "The sample points corresponding to the `y` values. If `x` is None,\n        the sample points are assumed to be evenly spaced `dx` apart. The\n        default is None."
          },
          "dx": {
            "type": "scalar",
            "description": "The spacing between sample points when `x` is None. The default is 1."
          },
          "axis": {
            "type": "int",
            "description": "The axis along which to integrate."
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "tri",
      "signature": "tri(N, M=None, k=0, dtype=<class 'float'>, *, like=None)",
      "documentation": {
        "description": "An array with ones at and below the given diagonal and zeros elsewhere.",
        "parameters": {
          "M": {
            "type": "int",
            "description": "Number of columns in the array.\n        By default, `M` is taken equal to `N`."
          },
          "k": {
            "type": "int",
            "description": "The sub-diagonal at and below which the array is filled.\n        `k` = 0 is the main diagonal, while `k` < 0 is below it,\n        and `k` > 0 is above.  The default is 0."
          },
          "dtype": {
            "type": "dtype",
            "description": "Data type of the returned array.  The default is float."
          },
          "like": {
            "type": "array_like",
            "description": "Reference object to allow the creation of arrays which are not\n        NumPy arrays. If an array-like passed in as ``like`` supports\n        the ``__array_function__`` protocol, the result will be defined\n        by it. In this case, it ensures the creation of an array object\n        compatible with that passed in via this argument.\n\n        .. versionadded:: 1.20.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "tril",
      "signature": "tril(m, k=0)",
      "documentation": {
        "description": "Lower triangle of an array.\n\n    Return a copy of an array with elements above the `k`-th diagonal zeroed.\n    For arrays with ``ndim`` exceeding 2, `tril` will apply to the final two\n    axes.",
        "parameters": {
          "k": {
            "type": "int",
            "description": "Diagonal above which to zero elements.  `k = 0` (the default) is the\n        main diagonal, `k < 0` is below it and `k > 0` is above."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "tril_indices",
      "signature": "tril_indices(n, k=0, m=None)",
      "documentation": {
        "description": "Return the indices for the lower-triangle of an (n, m) array.",
        "parameters": {
          "k": {
            "type": "int",
            "description": "Diagonal offset (see `tril` for details)."
          },
          "m": {
            "type": "int",
            "description": ".. versionadded:: 1.9.0\n\n        The column dimension of the arrays for which the returned\n        arrays will be valid.\n        By default `m` is taken equal to `n`."
          },
          "triu_indices": {
            "type": "similar function",
            "description": ", for upper-triangular."
          },
          "mask_indices": {
            "type": "generic function accepting an arbitrary mask function.",
            "description": "tril, triu"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "tril_indices_from",
      "signature": "tril_indices_from(arr, k=0)",
      "documentation": {
        "description": "Return the indices for the lower-triangle of arr.\n\n    See `tril_indices` for full details.",
        "parameters": {
          "k": {
            "type": "int",
            "description": "Diagonal offset (see `tril` for details)."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "trim_zeros",
      "signature": "trim_zeros(filt, trim='fb')",
      "documentation": {
        "description": "Trim the leading and/or trailing zeros from a 1-D array or sequence.",
        "parameters": {
          "trim": {
            "type": "str",
            "description": "A string with 'f' representing trim from front and 'b' to trim from\n        back. Default is 'fb', trim zeros from both front and back of the\n        array."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "triu",
      "signature": "triu(m, k=0)",
      "documentation": {
        "description": "Upper triangle of an array.\n\n    Return a copy of an array with the elements below the `k`-th diagonal\n    zeroed. For arrays with ``ndim`` exceeding 2, `triu` will apply to the\n    final two axes.\n\n    Please refer to the documentation for `tril` for further details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\n    array([[ 1,  2,  3],\n           [ 4,  5,  6],\n           [ 0,  8,  9],\n           [ 0,  0, 12]])\n\n    >>> np.triu(np.arange(3*4*5).reshape(3, 4, 5))\n    array([[[ 0,  1,  2,  3,  4],\n            [ 0,  6,  7,  8,  9],\n            [ 0,  0, 12, 13, 14],\n            [ 0,  0,  0, 18, 19]],\n           [[20, 21, 22, 23, 24],\n            [ 0, 26, 27, 28, 29],\n            [ 0,  0, 32, 33, 34],\n            [ 0,  0,  0, 38, 39]],\n           [[40, 41, 42, 43, 44],\n            [ 0, 46, 47, 48, 49],\n            [ 0,  0, 52, 53, 54],\n            [ 0,  0,  0, 58, 59]]])",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "triu_indices",
      "signature": "triu_indices(n, k=0, m=None)",
      "documentation": {
        "description": "Return the indices for the upper-triangle of an (n, m) array.",
        "parameters": {
          "k": {
            "type": "int",
            "description": "Diagonal offset (see `triu` for details)."
          },
          "m": {
            "type": "int",
            "description": ".. versionadded:: 1.9.0\n\n        The column dimension of the arrays for which the returned\n        arrays will be valid.\n        By default `m` is taken equal to `n`."
          },
          "tril_indices": {
            "type": "similar function",
            "description": ", for lower-triangular."
          },
          "mask_indices": {
            "type": "generic function accepting an arbitrary mask function.",
            "description": "triu, tril"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "triu_indices_from",
      "signature": "triu_indices_from(arr, k=0)",
      "documentation": {
        "description": "Return the indices for the upper-triangle of arr.\n\n    See `triu_indices` for full details.",
        "parameters": {
          "k": {
            "type": "int",
            "description": "Diagonal offset (see `triu` for details)."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "typename",
      "signature": "typename(char)",
      "documentation": {
        "description": "Return a description for the given data type code.",
        "parameters": {
          "S1": {
            "type": "character",
            "description": "?  :  bool"
          },
          "B": {
            "type": "unsigned char",
            "description": ""
          },
          "D": {
            "type": "complex double precision",
            "description": ""
          },
          "G": {
            "type": "complex long double precision",
            "description": ""
          },
          "F": {
            "type": "complex single precision",
            "description": ""
          },
          "I": {
            "type": "unsigned integer",
            "description": ""
          },
          "H": {
            "type": "unsigned short",
            "description": ""
          },
          "L": {
            "type": "unsigned long integer",
            "description": ""
          },
          "O": {
            "type": "object",
            "description": ""
          },
          "Q": {
            "type": "unsigned long long integer",
            "description": ""
          },
          "S": {
            "type": "string",
            "description": ""
          },
          "U": {
            "type": "unicode",
            "description": ""
          },
          "V": {
            "type": "void",
            "description": ""
          },
          "b": {
            "type": "signed char",
            "description": ""
          },
          "d": {
            "type": "double precision",
            "description": ""
          },
          "g": {
            "type": "long precision",
            "description": ""
          },
          "f": {
            "type": "single precision",
            "description": ""
          },
          "i": {
            "type": "integer",
            "description": ""
          },
          "h": {
            "type": "short",
            "description": ""
          },
          "l": {
            "type": "long integer",
            "description": ""
          },
          "q": {
            "type": "long long integer",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "union1d",
      "signature": "union1d(ar1, ar2)",
      "documentation": {
        "description": "Find the union of two arrays.\n\n    Return the unique, sorted array of values that are in either of the two\n    input arrays.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "unique",
      "signature": "unique(ar, return_index=False, return_inverse=False, return_counts=False, axis=None, *, equal_nan=True)",
      "documentation": {
        "description": "Find the unique elements of an array.\n\n    Returns the sorted unique elements of an array. There are three optional\n    outputs in addition to the unique elements:\n\n    * the indices of the input array that give the unique values\n    * the indices of the unique array that reconstruct the input array\n    * the number of times each unique value comes up in the input array",
        "parameters": {
          "return_index": {
            "type": "bool",
            "description": "If True, also return the indices of `ar` (along the specified axis,\n        if provided, or in the flattened array) that result in the unique array."
          },
          "return_inverse": {
            "type": "bool",
            "description": "If True, also return the indices of the unique array (for the specified\n        axis, if provided) that can be used to reconstruct `ar`."
          },
          "return_counts": {
            "type": "bool",
            "description": "If True, also return the number of times each unique item appears\n        in `ar`."
          },
          "axis": {
            "type": "int or None",
            "description": "The axis to operate on. If None, `ar` will be flattened. If an integer,\n        the subarrays indexed by the given axis will be flattened and treated\n        as the elements of a 1-D array with the dimension of the given axis,\n        see the notes for more details.  Object arrays or structured arrays\n        that contain objects are not supported if the `axis` kwarg is used. The\n        default is None.\n\n        .. versionadded:: 1.13.0"
          },
          "equal_nan": {
            "type": "bool",
            "description": "If True, collapses multiple NaN values in the return array into one.\n\n        .. versionadded:: 1.24"
          },
          "unique_indices": {
            "type": "ndarray",
            "description": "The indices of the first occurrences of the unique values in the\n        original array. Only provided if `return_index` is True."
          },
          "unique_inverse": {
            "type": "ndarray",
            "description": "The indices to reconstruct the original array from the\n        unique array. Only provided if `return_inverse` is True."
          },
          "unique_counts": {
            "type": "ndarray",
            "description": "The number of times each of the unique values comes up in the\n        original array. Only provided if `return_counts` is True.\n\n        .. versionadded:: 1.9.0"
          },
          "repeat": {
            "type": "Repeat elements of an array.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "unpackbits",
      "signature": "unpackbits(...)",
      "documentation": {
        "description": "unpackbits(a, /, axis=None, count=None, bitorder='big')\n\n    Unpacks elements of a uint8 array into a binary-valued output array.\n\n    Each element of `a` represents a bit-field that should be unpacked\n    into a binary-valued output array. The shape of the output array is\n    either 1-D (if `axis` is ``None``) or the same shape as the input\n    array with unpacking done along the axis specified.",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "The dimension over which bit-unpacking is done.\n        ``None`` implies unpacking the flattened array."
          },
          "count": {
            "type": "int or None",
            "description": "The number of elements to unpack along `axis`, provided as a way\n        of undoing the effect of packing a size that is not a multiple\n        of eight. A non-negative number means to only unpack `count`\n        bits. A negative number means to trim off that many bits from\n        the end. ``None`` means to unpack the entire array (the\n        default). Counts larger than the available number of bits will\n        add zero padding to the output. Negative counts must not\n        exceed the available number of bits.\n\n        .. versionadded:: 1.17.0"
          },
          "bitorder": {
            "type": "{'big'",
            "description": ", 'little'}, optional\n        The order of the returned bits. 'big' will mimic bin(val),\n        ``3 = 0b00000011 => [0, 0, 0, 0, 0, 0, 1, 1]``, 'little' will reverse\n        the order to ``[1, 1, 0, 0, 0, 0, 0, 0]``.\n        Defaults to 'big'.\n\n        .. versionadded:: 1.17.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "unravel_index",
      "signature": "unravel_index(...)",
      "documentation": {
        "description": "unravel_index(indices, shape, order='C')\n\n    Converts a flat index or array of flat indices into a tuple\n    of coordinate arrays.",
        "parameters": {
          "shape": {
            "type": "tuple of ints",
            "description": "The shape of the array to use for unraveling ``indices``.\n\n        .. versionchanged:: 1.16.0\n            Renamed from ``dims`` to ``shape``."
          },
          "order": {
            "type": "{'C'",
            "description": ", 'F'}, optional\n        Determines whether the indices should be viewed as indexing in\n        row-major (C-style) or column-major (Fortran-style) order.\n\n        .. versionadded:: 1.6.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "unwrap",
      "signature": "unwrap(p, discont=None, axis=-1, *, period=6.283185307179586)",
      "documentation": {
        "description": "Unwrap by taking the complement of large deltas with respect to the period.\n\n    This unwraps a signal `p` by changing elements which have an absolute\n    difference from their predecessor of more than ``max(discont, period/2)``\n    to their `period`-complementary values.\n\n    For the default case where `period` is :math:`2\\pi` and `discont` is\n    :math:`\\pi`, this unwraps a radian phase `p` such that adjacent differences\n    are never greater than :math:`\\pi` by adding :math:`2k\\pi` for some\n    integer :math:`k`.",
        "parameters": {
          "discont": {
            "type": "float",
            "description": "Maximum discontinuity between values, default is ``period/2``.\n        Values below ``period/2`` are treated as if they were ``period/2``.\n        To have an effect different from the default, `discont` should be\n        larger than ``period/2``."
          },
          "axis": {
            "type": "int",
            "description": "Axis along which unwrap will operate, default is the last axis."
          },
          "period": {
            "type": "float",
            "description": "Size of the range over which the input wraps. By default, it is\n        ``2 pi``.\n\n        .. versionadded:: 1.21.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "vander",
      "signature": "vander(x, N=None, increasing=False)",
      "documentation": {
        "description": "Generate a Vandermonde matrix.\n\n    The columns of the output matrix are powers of the input vector. The\n    order of the powers is determined by the `increasing` boolean argument.\n    Specifically, when `increasing` is False, the `i`-th output column is\n    the input vector raised element-wise to the power of ``N - i - 1``. Such\n    a matrix with a geometric progression in each row is named for Alexandre-\n    Theophile Vandermonde.",
        "parameters": {
          "N": {
            "type": "int",
            "description": "Number of columns in the output.  If `N` is not specified, a square\n        array is returned (``N = len(x)``)."
          },
          "increasing": {
            "type": "bool",
            "description": "Order of the powers of the columns.  If True, the powers increase\n        from left to right, if False (the default) they are reversed.\n\n        .. versionadded:: 1.9.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "vsplit",
      "signature": "vsplit(ary, indices_or_sections)",
      "documentation": {
        "description": "Split an array into multiple sub-arrays vertically (row-wise).\n\n    Please refer to the ``split`` documentation.  ``vsplit`` is equivalent\n    to ``split`` with `axis=0` (default), the array is always split along the\n    first axis regardless of the array dimension.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> x = np.arange(16.0).reshape(4, 4)\n    >>> x\n    array([[ 0.,   1.,   2.,   3.],\n           [ 4.,   5.,   6.,   7.],\n           [ 8.,   9.,  10.,  11.],\n           [12.,  13.,  14.,  15.]])\n    >>> np.vsplit(x, 2)\n    [array([[0., 1., 2., 3.],\n           [4., 5., 6., 7.]]), array([[ 8.,  9., 10., 11.],\n           [12., 13., 14., 15.]])]\n    >>> np.vsplit(x, np.array([3, 6]))\n    [array([[ 0.,  1.,  2.,  3.],\n           [ 4.,  5.,  6.,  7.],\n           [ 8.,  9., 10., 11.]]), array([[12., 13., 14., 15.]]), array([], shape=(0, 4), dtype=float64)]\n\n    With a higher dimensional array the split is still along the first axis.\n\n    >>> x = np.arange(8.0).reshape(2, 2, 2)\n    >>> x\n    array([[[0.,  1.],\n            [2.,  3.]],\n           [[4.,  5.],\n            [6.,  7.]]])\n    >>> np.vsplit(x, 2)\n    [array([[[0., 1.],\n            [2., 3.]]]), array([[[4., 5.],\n            [6., 7.]]])]",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "who",
      "signature": "who(vardict=None)",
      "documentation": {
        "description": "Print the NumPy arrays in the given dictionary.\n\n    If there is no dictionary passed in or `vardict` is None then returns\n    NumPy arrays in the globals() dictionary (all NumPy arrays in the\n    namespace).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": [
    {
      "name": "Arrayterator",
      "documentation": {
        "description": "Buffered iterator for big arrays.\n\n    `Arrayterator` creates a buffered iterator for reading big arrays in small\n    contiguous blocks. The class is useful for objects stored in the\n    file system. It allows iteration over the object *without* reading\n    everything in memory; instead, small blocks are read and iterated over.\n\n    `Arrayterator` can be used with any object that supports multidimensional\n    slices. This includes NumPy arrays, but also variables from\n    Scientific.IO.NetCDF or pynetcdf for example.",
        "parameters": {
          "buf_size": {
            "type": "int",
            "description": "The buffer size. If `buf_size` is supplied, the maximum amount of\n        data that will be read into memory is `buf_size` elements.\n        Default is None, which will read as many element as possible\n        into memory.\n\n    Attributes\n    ----------\n    var\n    buf_size\n    start\n    stop\n    step\n    shape\n    flat"
          },
          "flatiter": {
            "type": "Flat array iterator.",
            "description": ""
          },
          "memmap": {
            "type": "Create a memory-map to an array stored in a binary file on disk.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "DataSource",
      "documentation": {
        "description": "DataSource(destpath='.')\n\n    A generic data source file (file, http, ftp, ...).\n\n    DataSources can be local files or remote files/URLs.  The files may\n    also be compressed or uncompressed. DataSource hides some of the\n    low-level details of downloading the file, allowing you to simply pass\n    in a valid file path (or URL) and obtain a file object.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "abspath",
          "signature": "abspath(self, path)",
          "documentation": {
            "description": "Return absolute path of file in the DataSource directory.\n\n        If `path` is an URL, then `abspath` will return either the location\n        the file exists locally or the location it would exist when opened\n        using the `open` method.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "exists",
          "signature": "exists(self, path)",
          "documentation": {
            "description": "Test if path exists.\n\n        Test if `path` exists as (and in this order):\n\n        - a local file.\n        - a remote URL that has been downloaded and stored locally in the\n          `DataSource` directory.\n        - a remote URL that has not been downloaded, but is valid and\n          accessible.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "open",
          "signature": "open(self, path, mode='r', encoding=None, newline=None)",
          "documentation": {
            "description": "Open and return file-like object.\n\n        If `path` is an URL, it will be downloaded, stored in the\n        `DataSource` directory and opened from there.",
            "parameters": {
              "mode": {
                "type": "{'r'",
                "description": ", 'w', 'a'}, optional\n            Mode to open `path`.  Mode 'r' for reading, 'w' for writing,\n            'a' to append. Available modes depend on the type of object\n            specified by `path`. Default is 'r'."
              },
              "encoding": {
                "type": "{None",
                "description": ", str}, optional\n            Open text file with given encoding. The default encoding will be\n            what `io.open` uses."
              },
              "newline": {
                "type": "{None",
                "description": ", str}, optional\n            Newline to use when reading text file."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "NumpyVersion",
      "documentation": {
        "description": "Parse and compare numpy version strings.\n\n    NumPy has the following versioning scheme (numbers given are examples; they\n    can be > 9 in principle):\n\n    - Released version: '1.8.0', '1.8.1', etc.\n    - Alpha: '1.8.0a1', '1.8.0a2', etc.\n    - Beta: '1.8.0b1', '1.8.0b2', etc.\n    - Release candidates: '1.8.0rc1', '1.8.0rc2', etc.\n    - Development versions: '1.8.0.dev-f1234afa' (git commit hash appended)\n    - Development versions after a1: '1.8.0a1.dev-f1234afa',\n                                     '1.8.0b2.dev-f1234afa',\n                                     '1.8.1rc1.dev-f1234afa', etc.\n    - Development versions (no git hash available): '1.8.0.dev-Unknown'\n\n    Comparing needs to be done against a valid version string or other\n    `NumpyVersion` instance. Note that all development versions of the same\n    (pre-)release compare equal.\n\n    .. versionadded:: 1.9.0",
        "parameters": {
          "ValueError": {
            "type": "Not a valid numpy version string",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "RankWarning",
      "documentation": {
        "description": "Issued by `polyfit` when the Vandermonde matrix is rank deficient.\n\n    For more information, a way to suppress the warning, and an example of\n    `RankWarning` being issued, see `polyfit`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(note)",
          "documentation": {
            "description": "Exception.add_note(note) --\n    add a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(tb)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\n    set self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ndenumerate",
      "documentation": {
        "description": "Multidimensional index iterator.\n\n    Return an iterator yielding pairs of array coordinates and values.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "ndindex",
      "documentation": {
        "description": "An N-dimensional iterator object to index arrays.\n\n    Given the shape of an array, an `ndindex` instance iterates over\n    the N-dimensional index of the array. At each iteration a tuple\n    of indices is returned, the last dimension is iterated over first.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "ndincr",
          "signature": "ndincr(self)",
          "documentation": {
            "description": "Increment the multi-dimensional index by one.\n\n        This method is for backward compatibility only: do not use.\n\n        .. deprecated:: 1.20.0\n            This method has been advised against since numpy 1.8.0, but only\n            started emitting DeprecationWarning as of this version.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "poly1d",
      "documentation": {
        "description": "A one-dimensional polynomial class.\n\n    .. note::\n       This forms part of the old polynomial API. Since version 1.4, the\n       new polynomial API defined in `numpy.polynomial` is preferred.\n       A summary of the differences can be found in the\n       :doc:`transition guide </reference/routines.polynomials>`.\n\n    A convenience class, used to encapsulate \"natural\" operations on\n    polynomials so that said operations may take on their customary\n    form in code (see Examples).",
        "parameters": {
          "r": {
            "type": "bool",
            "description": "If True, `c_or_r` specifies the polynomial's roots; the default\n        is False."
          },
          "variable": {
            "type": "str",
            "description": "Changes the variable used when printing `p` from `x` to `variable`\n        (see Examples)."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "deriv",
          "signature": "deriv(self, m=1)",
          "documentation": {
            "description": "Return a derivative of this polynomial.\n\n        Refer to `polyder` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "polyder : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "integ",
          "signature": "integ(self, m=1, k=0)",
          "documentation": {
            "description": "Return an antiderivative (indefinite integral) of this polynomial.\n\n        Refer to `polyint` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "polyint : equivalent function",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "vectorize",
      "documentation": {
        "description": "vectorize(pyfunc=np._NoValue, otypes=None, doc=None, excluded=None,\n    cache=False, signature=None)\n\n    Returns an object that acts like pyfunc, but takes arrays as input.\n\n    Define a vectorized function which takes a nested sequence of objects or\n    numpy arrays as inputs and returns a single numpy array or a tuple of numpy\n    arrays. The vectorized function evaluates `pyfunc` over successive tuples\n    of the input arrays like the python map function, except it uses the\n    broadcasting rules of numpy.\n\n    The data type of the output of `vectorized` is determined by calling\n    the function with the first element of the input.  This can be avoided\n    by specifying the `otypes` argument.",
        "parameters": {
          "otypes": {
            "type": "str or list of dtypes",
            "description": "The output data type. It must be specified as either a string of\n        typecode characters or a list of data type specifiers. There should\n        be one data type specifier for each output."
          },
          "doc": {
            "type": "str",
            "description": "The docstring for the function. If None, the docstring will be the\n        ``pyfunc.__doc__``."
          },
          "excluded": {
            "type": "set",
            "description": "Set of strings or integers representing the positional or keyword\n        arguments for which the function will not be vectorized.  These will be\n        passed directly to `pyfunc` unmodified.\n\n        .. versionadded:: 1.7.0"
          },
          "cache": {
            "type": "bool",
            "description": "If `True`, then cache the first function call that determines the number\n        of outputs if `otypes` is not provided.\n\n        .. versionadded:: 1.7.0"
          },
          "signature": {
            "type": "string",
            "description": "Generalized universal function signature, e.g., ``(m,n),(n)->(m)`` for\n        vectorized matrix-vector multiplication. If provided, ``pyfunc`` will\n        be called with (and expected to return) arrays with shapes given by the\n        size of corresponding core dimensions. By default, ``pyfunc`` is\n        assumed to take scalars as input and output.\n\n        .. versionadded:: 1.12.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    }
  ]
}