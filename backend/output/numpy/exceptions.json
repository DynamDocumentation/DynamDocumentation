{
  "description": "Exceptions and Warnings (:mod:`numpy.exceptions`)\n=================================================\n\nGeneral exceptions used by NumPy.  Note that some exceptions may be module\nspecific, such as linear algebra errors.\n\n.. versionadded:: NumPy 1.25\n\n    The exceptions module is new in NumPy 1.25.  Older exceptions remain\n    available through the main NumPy namespace for compatibility.\n\n.. currentmodule:: numpy.exceptions\n\nWarnings\n--------\n.. autosummary::\n   :toctree: generated/\n\n   ComplexWarning             Given when converting complex to real.\n   VisibleDeprecationWarning  Same as a DeprecationWarning, but more visible.\n\nExceptions\n----------\n.. autosummary::\n   :toctree: generated/\n\n    AxisError          Given when an axis was invalid.\n    DTypePromotionError   Given when no common dtype could be found.\n    TooHardError       Error specific to `numpy.shares_memory`.",
  "functions": [],
  "classes": [
    {
      "name": "AxisError",
      "documentation": {
        "description": "Axis supplied was invalid.\n\n    This is raised whenever an ``axis`` parameter is specified that is larger\n    than the number of array dimensions.\n    For compatibility with code written against older numpy versions, which\n    raised a mixture of `ValueError` and `IndexError` for this situation, this\n    exception subclasses both to ensure that ``except ValueError`` and\n    ``except IndexError`` statements continue to catch `AxisError`.\n\n    .. versionadded:: 1.13",
        "parameters": {
          "ndim": {
            "type": "int",
            "description": "The number of array dimensions or ``None`` if a custom exception\n        message was provided.\n\n        .. versionadded:: 1.22"
          },
          "msg_prefix": {
            "type": "str",
            "description": "A prefix for the exception message.\n\n    Attributes\n    ----------"
          },
          "axis": {
            "type": "int",
            "description": "The out of bounds axis or ``None`` if a custom exception\n        message was provided. This should be the axis as passed by\n        the user, before any normalization to resolve negative indices.\n\n        .. versionadded:: 1.22"
          },
          "error": {
            "type": "axis 2 is out of bounds for array of dimension 1",
            "description": "Alternatively, a custom exception message can be passed:\n\n    >>> print(np.AxisError('Custom error message'))\n    Custom error message"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(note)",
          "documentation": {
            "description": "Exception.add_note(note) --\n    add a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(tb)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\n    set self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ComplexWarning",
      "documentation": {
        "description": "The warning raised when casting a complex dtype to a real dtype.\n\n    As implemented, casting a complex number to a real discards its imaginary\n    part, but this behavior may not be what the user actually wants.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(note)",
          "documentation": {
            "description": "Exception.add_note(note) --\n    add a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(tb)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\n    set self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "DTypePromotionError",
      "documentation": {
        "description": "Multiple DTypes could not be converted to a common one.\n\n    This exception derives from ``TypeError`` and is raised whenever dtypes\n    cannot be converted to a single common one.  This can be because they\n    are of a different category/class or incompatible instances of the same\n    one (see Examples).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "Datetimes and complex numbers are incompatible classes and cannot be\n    promoted:\n\n    >>> np.result_type(np.dtype(\"M8[s]\"), np.complex128)\n    DTypePromotionError: The DType <class 'numpy.dtype[datetime64]'> could not\n    be promoted by <class 'numpy.dtype[complex128]'>. This means that no common\n    DType exists for the given inputs. For example they cannot be stored in a\n    single array unless the dtype is `object`. The full list of DTypes is:\n    (<class 'numpy.dtype[datetime64]'>, <class 'numpy.dtype[complex128]'>)\n\n    For example for structured dtypes, the structure can mismatch and the\n    same ``DTypePromotionError`` is given when two structured dtypes with\n    a mismatch in their number of fields is given:\n\n    >>> dtype1 = np.dtype([(\"field1\", np.float64), (\"field2\", np.int64)])\n    >>> dtype2 = np.dtype([(\"field1\", np.float64)])\n    >>> np.promote_types(dtype1, dtype2)\n    DTypePromotionError: field names `('field1', 'field2')` and `('field1',)`\n    mismatch.",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(note)",
          "documentation": {
            "description": "Exception.add_note(note) --\n    add a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(tb)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\n    set self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ModuleDeprecationWarning",
      "documentation": {
        "description": "Module deprecation warning.\n\n    .. warning::\n\n        This warning should not be used, since nose testing is not relevant\n        anymore.\n\n    The nose tester turns ordinary Deprecation warnings into test failures.\n    That makes it hard to deprecate whole modules, because they get\n    imported by default. So this is a special Deprecation warning that the\n    nose tester will let pass without making tests fail.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(note)",
          "documentation": {
            "description": "Exception.add_note(note) --\n    add a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(tb)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\n    set self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "TooHardError",
      "documentation": {
        "description": "max_work was exceeded.\n\n    This is raised whenever the maximum number of candidate solutions\n    to consider specified by the ``max_work`` parameter is exceeded.\n    Assigning a finite number to max_work may have caused the operation\n    to fail.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(note)",
          "documentation": {
            "description": "Exception.add_note(note) --\n    add a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(tb)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\n    set self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "VisibleDeprecationWarning",
      "documentation": {
        "description": "Visible deprecation warning.\n\n    By default, python will not show deprecation warnings, so this class\n    can be used when a very visible warning is helpful, for example because\n    the usage is most likely a user bug.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(note)",
          "documentation": {
            "description": "Exception.add_note(note) --\n    add a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(tb)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\n    set self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    }
  ]
}