{
  "description": "============================\n``ctypes`` Utility Functions\n============================\n\nSee Also\n--------\nload_library : Load a C library.\nndpointer : Array restype/argtype with verification.\nas_ctypes : Create a ctypes array from an ndarray.\nas_array : Create an ndarray from a ctypes array.\n\nReferences\n----------\n.. [1] \"SciPy Cookbook: ctypes\", https://scipy-cookbook.readthedocs.io/items/Ctypes.html\n\nExamples\n--------\nLoad the C library:\n\n>>> _lib = np.ctypeslib.load_library('libmystuff', '.')     #doctest: +SKIP\n\nOur result type, an ndarray that must be of type double, be 1-dimensional\nand is C-contiguous in memory:\n\n>>> array_1d_double = np.ctypeslib.ndpointer(\n...                          dtype=np.double,\n...                          ndim=1, flags='CONTIGUOUS')    #doctest: +SKIP\n\nOur C-function typically takes an array and updates its values\nin-place.  For example::\n\n    void foo_func(double* x, int length)\n    {\n        int i;\n        for (i = 0; i < length; i++) {\n            x[i] = i*i;\n        }\n    }\n\nWe wrap it using:\n\n>>> _lib.foo_func.restype = None                      #doctest: +SKIP\n>>> _lib.foo_func.argtypes = [array_1d_double, c_int] #doctest: +SKIP\n\nThen, we're ready to call ``foo_func``:\n\n>>> out = np.empty(15, dtype=np.double)\n>>> _lib.foo_func(out, len(out))                #doctest: +SKIP",
  "functions": [
    {
      "name": "as_array",
      "signature": "as_array(obj, shape=None)",
      "documentation": {
        "description": "Create a numpy array from a ctypes array or POINTER.\nThe numpy array shares the memory with the ctypes object.\nThe shape parameter must be given if converting from a ctypes POINTER.\nThe shape parameter is ignored if converting from a ctypes array",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "as_ctypes",
      "signature": "as_ctypes(obj)",
      "documentation": {
        "description": "Create and return a ctypes object from a numpy array.  Actually\nanything that exposes the __array_interface__ is accepted.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "as_ctypes_type",
      "signature": "as_ctypes_type(dtype)",
      "documentation": {
        "description": "Convert a dtype into a ctypes type.",
        "parameters": {
          "dtype": {
            "type": "dtype",
            "description": "The dtype to convert"
          }
        },
        "returns": "-------\nctype\nA ctype scalar, union, array, or struct",
        "raises": "------\nNotImplementedError\nIf the conversion is not possible",
        "see_also": "",
        "notes": "-----\nThis function does not losslessly round-trip in either direction.\n``np.dtype(as_ctypes_type(dt))`` will:\n- insert padding fields\n- reorder fields to be sorted by offset\n- discard field titles\n``as_ctypes_type(np.dtype(ctype))`` will:\n- discard the class names of `ctypes.Structure`\\ s and\n`ctypes.Union`\\ s\n- convert single-element `ctypes.Union`\\ s into single-element\n`ctypes.Structure`\\ s\n- insert padding fields",
        "examples": ""
      }
    },
    {
      "name": "asarray",
      "signature": "asarray(a, dtype=None, order=None, *, like=None)",
      "documentation": {
        "description": "asarray(a, dtype=None, order=None, *, like=None)\nConvert the input to an array.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input data, in any form that can be converted to an array.  This\nincludes lists, lists of tuples, tuples, tuples of tuples, tuples\nof lists and ndarrays."
          },
          "dtype": {
            "type": "data-type, optional",
            "description": "By default, the data-type is inferred from the input data."
          },
          "order": {
            "type": "{'C', 'F', 'A', 'K'}, optional",
            "description": "Memory layout.  'A' and 'K' depend on the order of input array a.\n'C' row-major (C-style),\n'F' column-major (Fortran-style) memory representation.\n'A' (any) means 'F' if `a` is Fortran contiguous, 'C' otherwise\n'K' (keep) preserve input order\nDefaults to 'K'."
          },
          "like": {
            "type": "array_like, optional",
            "description": "Reference object to allow the creation of arrays which are not\nNumPy arrays. If an array-like passed in as ``like`` supports\nthe ``__array_function__`` protocol, the result will be defined\nby it. In this case, it ensures the creation of an array object\ncompatible with that passed in via this argument.\n.. versionadded:: 1.20.0"
          }
        },
        "returns": "-------\nout : ndarray\nArray interpretation of `a`.  No copy is performed if the input\nis already an ndarray with matching dtype and order.  If `a` is a\nsubclass of ndarray, a base class ndarray is returned.",
        "raises": "",
        "see_also": "--------\nasanyarray : Similar function which passes through subclasses.\nascontiguousarray : Convert input to a contiguous array.\nasfarray : Convert input to a floating point ndarray.\nasfortranarray : Convert input to an ndarray with column-major\nmemory order.\nasarray_chkfinite : Similar function which checks input for NaNs and Infs.\nfromiter : Create an array from an iterator.\nfromfunction : Construct an array by executing a function on grid\npositions.",
        "notes": "",
        "examples": "--------\nConvert a list into an array:\n>>> a = [1, 2]\n>>> np.asarray(a)\narray([1, 2])\nExisting arrays are not copied:\n>>> a = np.array([1, 2])\n>>> np.asarray(a) is a\nTrue\nIf `dtype` is set, array is copied only if dtype does not match:\n>>> a = np.array([1, 2], dtype=np.float32)\n>>> np.asarray(a, dtype=np.float32) is a\nTrue\n>>> np.asarray(a, dtype=np.float64) is a\nFalse\nContrary to `asanyarray`, ndarray subclasses are not passed through:\n>>> issubclass(np.recarray, np.ndarray)\nTrue\n>>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)\n>>> np.asarray(a) is a\nFalse\n>>> np.asanyarray(a) is a\nTrue"
      }
    },
    {
      "name": "frombuffer",
      "signature": "frombuffer(buffer, dtype=float, count=-1, offset=0, *, like=None)",
      "documentation": {
        "description": "frombuffer(buffer, dtype=float, count=-1, offset=0, *, like=None)\nInterpret a buffer as a 1-dimensional array.",
        "parameters": {
          "buffer": {
            "type": "buffer_like",
            "description": "An object that exposes the buffer interface."
          },
          "dtype": {
            "type": "data-type, optional",
            "description": "Data-type of the returned array; default: float."
          },
          "count": {
            "type": "int, optional",
            "description": "Number of items to read. ``-1`` means all data in the buffer."
          },
          "offset": {
            "type": "int, optional",
            "description": "Start reading the buffer from this offset (in bytes); default: 0."
          },
          "like": {
            "type": "array_like, optional",
            "description": "Reference object to allow the creation of arrays which are not\nNumPy arrays. If an array-like passed in as ``like`` supports\nthe ``__array_function__`` protocol, the result will be defined\nby it. In this case, it ensures the creation of an array object\ncompatible with that passed in via this argument.\n.. versionadded:: 1.20.0"
          }
        },
        "returns": "-------\nout : ndarray\nSee also\n--------\nndarray.tobytes\nInverse of this operation, construct Python bytes from the raw data\nbytes in the array.",
        "raises": "",
        "see_also": "",
        "notes": "-----\nIf the buffer has data that is not in machine byte-order, this should\nbe specified as part of the data-type, e.g.::\n>>> dt = np.dtype(int)\n>>> dt = dt.newbyteorder('>')\n>>> np.frombuffer(buf, dtype=dt) # doctest: +SKIP\nThe data of the resulting array will not be byteswapped, but will be\ninterpreted correctly.\nThis function creates a view into the original object.  This should be safe\nin general, but it may make sense to copy the result when the original\nobject is mutable or untrusted.",
        "examples": "--------\n>>> s = b'hello world'\n>>> np.frombuffer(s, dtype='S1', count=5, offset=6)\narray([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')\n>>> np.frombuffer(b'\\x01\\x02', dtype=np.uint8)\narray([1, 2], dtype=uint8)\n>>> np.frombuffer(b'\\x01\\x02\\x03\\x04\\x05', dtype=np.uint8, count=3)\narray([1, 2, 3], dtype=uint8)"
      }
    },
    {
      "name": "load_library",
      "signature": "load_library(libname, loader_path)",
      "documentation": {
        "description": "It is possible to load a library using\n>>> lib = ctypes.cdll[<full_path_name>] # doctest: +SKIP\nBut there are cross-platform considerations, such as library file extensions,\nplus the fact Windows will just load the first library it finds with that name.\nNumPy supplies the load_library function as a convenience.\n.. versionchanged:: 1.20.0\nAllow libname and loader_path to take any\n:term:`python:path-like object`.",
        "parameters": {
          "libname": {
            "type": "path-like",
            "description": "Name of the library, which can have 'lib' as a prefix,\nbut without an extension."
          },
          "loader_path": {
            "type": "path-like",
            "description": "Where the library can be found."
          }
        },
        "returns": "-------\nctypes.cdll[libpath] : library object\nA ctypes library object",
        "raises": "------\nOSError\nIf there is no library with the expected extension, or the\nlibrary is defective and cannot be loaded.",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ndpointer",
      "signature": "ndpointer(dtype=None, ndim=None, shape=None, flags=None)",
      "documentation": {
        "description": "Array-checking restype/argtypes.\nAn ndpointer instance is used to describe an ndarray in restypes\nand argtypes specifications.  This approach is more flexible than\nusing, for example, ``POINTER(c_double)``, since several restrictions\ncan be specified, which are verified upon calling the ctypes function.\nThese include data type, number of dimensions, shape and flags.  If a\ngiven array does not satisfy the specified restrictions,\na ``TypeError`` is raised.",
        "parameters": {
          "dtype": {
            "type": "data-type, optional",
            "description": "Array data-type."
          },
          "ndim": {
            "type": "int, optional",
            "description": "Number of array dimensions."
          },
          "shape": {
            "type": "tuple of ints, optional",
            "description": "Array shape."
          },
          "flags": {
            "type": "str or tuple of str",
            "description": "Array flags; may be one or more of:\n- C_CONTIGUOUS / C / CONTIGUOUS\n- F_CONTIGUOUS / F / FORTRAN\n- OWNDATA / O\n- WRITEABLE / W\n- ALIGNED / A\n- WRITEBACKIFCOPY / X"
          }
        },
        "returns": "-------\nklass : ndpointer type object\nA type object, which is an ``_ndtpr`` instance containing\ndtype, ndim, shape and flags information.",
        "raises": "------\nTypeError\nIf a given array does not satisfy the specified restrictions.",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> clib.somefunc.argtypes = [np.ctypeslib.ndpointer(dtype=np.float64,\n...                                                  ndim=1,\n...                                                  flags='C_CONTIGUOUS')]\n... #doctest: +SKIP\n>>> clib.somefunc(np.array([1, 2, 3], dtype=np.float64))\n... #doctest: +SKIP"
      }
    }
  ],
  "classes": [
    {
      "name": "c_intp",
      "documentation": {
        "description": "XXX to be provided",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "flagsobj",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "integer",
      "documentation": {
        "description": "Abstract base class of all integer scalar types.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_integer",
          "signature": "is_integer(...)",
          "documentation": {
            "description": "integer.is_integer() -> bool\nReturn ``True`` if the number is finite with integral value.\n.. versionadded:: 1.22",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> np.int64(-2).is_integer()\nTrue\n>>> np.uint32(5).is_integer()\nTrue"
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ndarray",
      "documentation": {
        "description": "ndarray(shape, dtype=float, buffer=None, offset=0,\nstrides=None, order=None)\nAn array object represents a multidimensional, homogeneous array\nof fixed-size items.  An associated data-type object describes the\nformat of each element in the array (its byte-order, how many bytes it\noccupies in memory, whether it is an integer, a floating point number,\nor something else, etc.)\nArrays should be constructed using `array`, `zeros` or `empty` (refer\nto the See Also section below).  The parameters given here refer to\na low-level method (`ndarray(...)`) for instantiating an array.\nFor more information, refer to the `numpy` module and examine the\nmethods and attributes of an array.",
        "parameters": {
          "shape": {
            "type": "tuple of ints",
            "description": "Shape of the array."
          },
          "dtype": {
            "type": "dtype object",
            "description": "Describes the format of the elements in the array."
          },
          "buffer": {
            "type": "object exposing buffer interface, optional",
            "description": "Used to fill the array with data."
          },
          "offset": {
            "type": "int, optional",
            "description": "Offset of array data in buffer."
          },
          "strides": {
            "type": "tuple of ints",
            "description": "The step-size required to move from one element to the next in\nmemory. For example, a contiguous ``(3, 4)`` array of type\n``int16`` in C-order has strides ``(8, 2)``.  This implies that\nto move from element to element in memory requires jumps of 2 bytes.\nTo move from row-to-row, one needs to jump 8 bytes at a time\n(``2 * 4``)."
          },
          "order": {
            "type": "{'C', 'F'}, optional",
            "description": "Row-major (C-style) or column-major (Fortran-style) order.\nAttributes\n----------"
          },
          "T": {
            "type": "ndarray",
            "description": "Transpose of the array."
          },
          "data": {
            "type": "buffer",
            "description": "The array's elements, in memory."
          },
          "flags": {
            "type": "dict",
            "description": "Dictionary containing information related to memory use, e.g.,\n'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc."
          },
          "flat": {
            "type": "numpy.flatiter object",
            "description": "Flattened version of the array as an iterator.  The iterator\nallows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for\nassignment examples; TODO)."
          },
          "imag": {
            "type": "ndarray",
            "description": "Imaginary part of the array."
          },
          "real": {
            "type": "ndarray",
            "description": "Real part of the array."
          },
          "size": {
            "type": "int",
            "description": "Number of elements in the array."
          },
          "itemsize": {
            "type": "int",
            "description": "The memory use of each array element in bytes."
          },
          "nbytes": {
            "type": "int",
            "description": "The total number of bytes required to store the array data,\ni.e., ``itemsize * size``."
          },
          "ndim": {
            "type": "int",
            "description": "The array's number of dimensions."
          },
          "ctypes": {
            "type": "ctypes object",
            "description": "Class containing properties of the array needed for interaction\nwith ctypes."
          },
          "base": {
            "type": "ndarray",
            "description": "If the array is a view into another array, that array is its `base`\n(unless that array is also a view).  The `base` array is where the\narray data is actually stored."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\narray : Construct an array.\nzeros : Create an array, each element of which is zero.\nempty : Create an array, but leave its allocated memory unchanged (i.e.,\nit contains \"garbage\").\ndtype : Create a data-type.\nnumpy.typing.NDArray : An ndarray alias :term:`generic <generic type>`\nw.r.t. its `dtype.type <numpy.dtype.type>`.",
        "notes": "-----\nThere are two modes of creating an array using ``__new__``:\n1. If `buffer` is None, then only `shape`, `dtype`, and `order`\nare used.\n2. If `buffer` is an object exposing the buffer interface, then\nall keywords are interpreted.\nNo ``__init__`` method is needed because the array is fully initialized\nafter the ``__new__`` method.",
        "examples": "--------\nThese examples illustrate the low-level `ndarray` constructor.  Refer\nto the `See Also` section above for easier ways of constructing an\nndarray.\nFirst mode, `buffer` is None:\n>>> np.ndarray(shape=(2,2), dtype=float, order='F')\narray([[0.0e+000, 0.0e+000], # random\n[     nan, 2.5e-323]])\nSecond mode:\n>>> np.ndarray((2,), buffer=np.array([1,2,3]),\n...            offset=np.int_().itemsize,\n...            dtype=int) # offset = 1*itemsize, i.e. skip first element\narray([2, 3])"
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "a.all(axis=None, out=None, keepdims=False, *, where=True)",
            "parameters": {},
            "returns": "Refer to `numpy.all` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.all : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "a.any(axis=None, out=None, keepdims=False, *, where=True)",
            "parameters": {},
            "returns": "Refer to `numpy.any` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.any : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "a.argmax(axis=None, out=None, *, keepdims=False)\nReturn indices of the maximum values along the given axis.\nRefer to `numpy.argmax` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.argmax : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "a.argmin(axis=None, out=None, *, keepdims=False)\nReturn indices of the minimum values along the given axis.\nRefer to `numpy.argmin` for detailed documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.argmin : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argpartition",
          "signature": "argpartition(...)",
          "documentation": {
            "description": "a.argpartition(kth, axis=-1, kind='introselect', order=None)",
            "parameters": {},
            "returns": "Refer to `numpy.argpartition` for full documentation.\n.. versionadded:: 1.8.0",
            "raises": "",
            "see_also": "--------\nnumpy.argpartition : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "a.argsort(axis=-1, kind=None, order=None)",
            "parameters": {},
            "returns": "Refer to `numpy.argsort` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.argsort : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\nCopy of the array, cast to a specified type.",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "Typecode or data-type to which the array is cast."
              },
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout order of the result.\n'C' means C order, 'F' means Fortran order, 'A'\nmeans 'F' order if all the arrays are Fortran contiguous,\n'C' order otherwise, and 'K' means as close to the\norder the array elements appear in memory as possible.\nDefault is 'K'."
              },
              "casting": {
                "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
                "description": "Controls what kind of data casting may occur. Defaults to 'unsafe'\nfor backwards compatibility.\n* 'no' means the data types should not be cast at all.\n* 'equiv' means only byte-order changes are allowed.\n* 'safe' means only casts which can preserve values are allowed.\n* 'same_kind' means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n* 'unsafe' means any data conversions may be done."
              },
              "subok": {
                "type": "bool, optional",
                "description": "If True, then sub-classes will be passed-through (default), otherwise\nthe returned array will be forced to be a base-class array."
              },
              "copy": {
                "type": "bool, optional",
                "description": "By default, astype always returns a newly allocated array. If this\nis set to false, and the `dtype`, `order`, and `subok`\nrequirements are satisfied, the input array is returned instead\nof a copy."
              }
            },
            "returns": "-------\narr_t : ndarray\nUnless `copy` is False and the other conditions for returning the input\narray are satisfied (see description for `copy` input parameter), `arr_t`\nis a new array of the same shape as the input array, with dtype, order\ngiven by `dtype`, `order`.",
            "raises": "------\nComplexWarning\nWhen casting from complex to float or int. To avoid this,\none should use ``a.real.astype(t)``.",
            "see_also": "",
            "notes": "-----\n.. versionchanged:: 1.17.0\nCasting between a simple data type and a structured one is possible only\nfor \"unsafe\" casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n.. versionchanged:: 1.9.0\nCasting from numeric to string types in 'safe' casting mode requires\nthat the string dtype length is long enough to store the max\ninteger/float value converted.",
            "examples": "--------\n>>> x = np.array([1, 2, 2.5])\n>>> x\narray([1. ,  2. ,  2.5])\n>>> x.astype(int)\narray([1, 2, 2])"
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "a.byteswap(inplace=False)\nSwap the bytes of the array elements\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.",
            "parameters": {
              "inplace": {
                "type": "bool, optional",
                "description": "If ``True``, swap bytes in-place, default is ``False``."
              }
            },
            "returns": "-------\nout : ndarray\nThe byteswapped array. If `inplace` is ``True``, this is\na view to self.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> list(map(hex, A))\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n>>> list(map(hex, A))\n['0x100', '0x1', '0x3322']\nArrays of byte-strings are not swapped\n>>> A = np.array([b'ceg', b'fac'])\n>>> A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n``A.newbyteorder().byteswap()`` produces an array with the same values\nbut different representation in memory\n>>> A = np.array([1, 2, 3])\n>>> A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n0, 0], dtype=uint8)\n>>> A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n>>> A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n0, 3], dtype=uint8)"
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "a.choose(choices, out=None, mode='raise')\nUse an index array to construct a new array from a set of choices.\nRefer to `numpy.choose` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.choose : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "a.clip(min=None, max=None, out=None, **kwargs)\nReturn an array whose values are limited to ``[min, max]``.\nOne of max or min must be given.\nRefer to `numpy.clip` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.clip : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "a.compress(condition, axis=None, out=None)\nReturn selected slices of this array along given axis.\nRefer to `numpy.compress` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.compress : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "a.conj()\nComplex-conjugate all elements.\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "a.conjugate()\nReturn the complex conjugate, element-wise.\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "a.copy(order='C')\nReturn a copy of the array.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout of the copy. 'C' means C-order,\n'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n'C' otherwise. 'K' means match the layout of `a` as closely\nas possible. (Note that this function and :func:`numpy.copy` are very\nsimilar but have different default values for their order=\narguments, and this function always passes sub-classes through.)\nSee also\n--------"
              },
              "numpy.copy": {
                "type": "Similar function with different default behavior",
                "description": "numpy.copyto"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\nThis function is the preferred method for creating an array copy.  The\nfunction :func:`numpy.copy` is similar, but it defaults to using order 'K',\nand will not pass sub-classes through by default.",
            "examples": "--------\n>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n>>> y = x.copy()\n>>> x.fill(0)\n>>> x\narray([[0, 0, 0],\n[0, 0, 0]])\n>>> y\narray([[1, 2, 3],\n[4, 5, 6]])\n>>> y.flags['C_CONTIGUOUS']\nTrue"
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "a.cumprod(axis=None, dtype=None, out=None)\nReturn the cumulative product of the elements along the given axis.\nRefer to `numpy.cumprod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.cumprod : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "a.cumsum(axis=None, dtype=None, out=None)\nReturn the cumulative sum of the elements along the given axis.\nRefer to `numpy.cumsum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.cumsum : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "a.diagonal(offset=0, axis1=0, axis2=1)\nReturn specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\nRefer to :func:`numpy.diagonal` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.diagonal : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dot",
          "signature": "dot(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "a.dump(file)\nDump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.",
            "parameters": {
              "file": {
                "type": "str or Path",
                "description": "A string naming the dump file.\n.. versionchanged:: 1.17.0\n`pathlib.Path` objects are now accepted."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "a.dumps()",
            "parameters": {},
            "returns": "pickle.loads will convert the string back to an array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "a.fill(value)\nFill the array with a scalar value.",
            "parameters": {
              "value": {
                "type": "scalar",
                "description": "All elements of `a` will be assigned this value."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([1.,  1.])\nFill expects a scalar value and always behaves the same as assigning\nto a single array element.  The following is a rare example where this\ndistinction is important:\n>>> a = np.array([None, None], dtype=object)\n>>> a[0] = np.array(3)\n>>> a\narray([array(3), None], dtype=object)\n>>> a.fill(np.array(3))\n>>> a\narray([array(3), array(3)], dtype=object)\nWhere other forms of assignments will unpack the array being assigned:\n>>> a[...] = np.array(3)\n>>> a\narray([3, 3], dtype=object)"
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "a.flatten(order='C')\nReturn a copy of the array collapsed into one dimension.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "'C' means to flatten in row-major (C-style) order.\n'F' means to flatten in column-major (Fortran-\nstyle) order. 'A' means to flatten in column-major\norder if `a` is Fortran *contiguous* in memory,\nrow-major order otherwise. 'K' means to flatten\n`a` in the order the elements occur in memory.\nThe default is 'C'."
              }
            },
            "returns": "-------\ny : ndarray\nA copy of the input array, flattened to one dimension.",
            "raises": "",
            "see_also": "--------\nravel : Return a flattened array.\nflat : A 1-D flat iterator over the array.",
            "notes": "",
            "examples": "--------\n>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])"
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "a.getfield(dtype, offset=0)",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "The data type of the view. The dtype size of the view can not be larger\nthan that of the array itself."
              },
              "offset": {
                "type": "int",
                "description": "Number of bytes to skip before beginning the element view."
              }
            },
            "returns": "A field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[1.+1.j,  0.+0.j],\n[0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[1.,  0.],\n[0.,  2.]])\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n>>> x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n[0.,  4.]])"
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "a.item(*args)\nCopy an element of an array to a standard Python scalar and return it.",
            "parameters": {},
            "returns": "-------\nz : Standard Python scalar object\nA copy of the specified element of the array as a suitable\nPython scalar",
            "raises": "",
            "see_also": "",
            "notes": "-----\nWhen the data type of `a` is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\n`item` is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python's optimized math.",
            "examples": "--------\n>>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n[1, 3, 6],\n[1, 0, 1]])\n>>> x.item(3)\n1\n>>> x.item(7)\n0\n>>> x.item((0, 1))\n2\n>>> x.item((2, 2))\n1"
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "a.itemset(*args)\nInsert scalar into an array (scalar is cast to array's dtype, if possible)\nThere must be at least 1 argument, and define the last argument\nas *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster\nthan ``a[args] = item``.  The item should be a scalar value and `args`\nmust select a single item in the array `a`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\nCompared to indexing syntax, `itemset` provides some speed increase\nfor placing a scalar into a particular location in an `ndarray`,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using `itemset` (and `item`) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.",
            "examples": "--------\n>>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n[1, 3, 6],\n[1, 0, 1]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[2, 2, 6],\n[1, 0, 6],\n[1, 0, 9]])"
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "a.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True)\nReturn the maximum along a given axis.\nRefer to `numpy.amax` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.amax : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "a.mean(axis=None, dtype=None, out=None, keepdims=False, *, where=True)",
            "parameters": {},
            "returns": "Refer to `numpy.mean` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.mean : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "a.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True)\nReturn the minimum along a given axis.\nRefer to `numpy.amin` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.amin : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(...)",
          "documentation": {
            "description": "arr.newbyteorder(new_order='S', /)\nReturn the array with the same data viewed with a different byte order.\nEquivalent to::\narr.view(arr.dtype.newbytorder(new_order))\nChanges are also made in all fields and sub-arrays of the array data\ntype.",
            "parameters": {
              "new_order": {
                "type": "string, optional",
                "description": "Byte order to force; a value from the byte order specifications\nbelow. `new_order` codes can be any of:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order, equivalent to `sys.byteorder`\n* {'|', 'I'} - ignore (no change to byte order)\nThe default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_arr : array\nNew array object with the dtype reflecting given change to the\nbyte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "a.nonzero()\nReturn the indices of the elements that are non-zero.\nRefer to `numpy.nonzero` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.nonzero : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "partition",
          "signature": "partition(...)",
          "documentation": {
            "description": "a.partition(kth, axis=-1, kind='introselect', order=None)\nRearranges the elements in the array in such a way that the value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.\n.. versionadded:: 1.8.0",
            "parameters": {
              "kth": {
                "type": "int or sequence of ints",
                "description": "Element index to partition by. The kth element value will be in its\nfinal sorted position and all smaller elements will be moved before it\nand all equal or greater elements behind it.\nThe order of all elements in the partitions is undefined.\nIf provided with a sequence of kth it will partition all elements\nindexed by kth of them into their sorted position at once.\n.. deprecated:: 1.22.0\nPassing booleans as index is deprecated."
              },
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. Default is -1, which means sort along the\nlast axis."
              },
              "kind": {
                "type": "{'introselect'}, optional",
                "description": "Selection algorithm. Default is 'introselect'."
              },
              "order": {
                "type": "str or list of str, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc. A single field can\nbe specified as a string, and not all fields need to be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.partition : Return a partitioned copy of an array.\nargpartition : Indirect partition.\nsort : Full sort.",
            "notes": "-----\nSee ``np.partition`` for notes on the different algorithms.",
            "examples": "--------\n>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])\n>>> a.partition((1, 3))\n>>> a\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "a.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True)\nReturn the product of the array elements over the given axis\nRefer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.prod : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "a.ptp(axis=None, out=None, keepdims=False)\nPeak to peak (maximum - minimum) value along a given axis.\nRefer to `numpy.ptp` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ptp : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "a.put(indices, values, mode='raise')\nSet ``a.flat[n] = values[n]`` for all `n` in indices.\nRefer to `numpy.put` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.put : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "a.ravel([order])\nReturn a flattened array.\nRefer to `numpy.ravel` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ravel : equivalent function\nndarray.flat : a flat iterator on the array.",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "a.repeat(repeats, axis=None)\nRepeat elements of an array.\nRefer to `numpy.repeat` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.repeat : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "a.reshape(shape, order='C')",
            "parameters": {},
            "returns": "Refer to `numpy.reshape` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.reshape : equivalent function",
            "notes": "-----\nUnlike the free function `numpy.reshape`, this method on `ndarray` allows\nthe elements of the shape parameter to be passed in as separate arguments.\nFor example, ``a.reshape(10, 11)`` is equivalent to\n``a.reshape((10, 11))``.",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "a.resize(new_shape, refcheck=True)\nChange shape and size of array in-place.",
            "parameters": {
              "new_shape": {
                "type": "tuple of ints, or `n` ints",
                "description": "Shape of resized array."
              },
              "refcheck": {
                "type": "bool, optional",
                "description": "If False, reference count will not be checked. Default is True."
              }
            },
            "returns": "-------\nNone",
            "raises": "------\nValueError\nIf `a` does not own its own data or references or views to it exist,\nand the data memory must be changed.\nPyPy only: will always raise if the data memory must be changed, since\nthere is no reliable way to determine if references or views to it\nexist.\nSystemError\nIf the `order` keyword argument is specified. This behaviour is a\nbug in NumPy.",
            "see_also": "--------\nresize : Return a new array with the specified shape.",
            "notes": "-----\nThis reallocates space for the data area if necessary.\nOnly contiguous arrays (data elements consecutive in memory) can be\nresized.\nThe purpose of the reference count check is to make sure you\ndo not use this array as a buffer for another Python object and then\nreallocate the memory. However, reference counts can increase in\nother ways so if you are sure that you have not shared the memory\nfor this array with another Python object, then you may safely set\n`refcheck` to False.",
            "examples": "--------\nShrinking an array: array is flattened (in the order that the data are\nstored in memory), resized, and reshaped:\n>>> a = np.array([[0, 1], [2, 3]], order='C')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n[1]])\n>>> a = np.array([[0, 1], [2, 3]], order='F')\n>>> a.resize((2, 1))\n>>> a\narray([[0],\n[2]])\nEnlarging an array: as above, but missing entries are filled with zeros:\n>>> b = np.array([[0, 1], [2, 3]])\n>>> b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n>>> b\narray([[0, 1, 2],\n[3, 0, 0]])\nReferencing an array prevents resizing...\n>>> c = a\n>>> a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\nUnless `refcheck` is False:\n>>> a.resize((1, 1), refcheck=False)\n>>> a\narray([[0]])\n>>> c\narray([[0]])"
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "a.round(decimals=0, out=None)\nReturn `a` with each element rounded to the given number of decimals.\nRefer to `numpy.around` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.around : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "a.searchsorted(v, side='left', sorter=None)\nFind indices where elements of v should be inserted in a to maintain order.\nFor full documentation, see `numpy.searchsorted`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.searchsorted : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "a.setfield(val, dtype, offset=0)\nPut a value into a specified place in a field defined by a data-type.\nPlace `val` into `a`'s field defined by `dtype` and beginning `offset`\nbytes into the field.",
            "parameters": {
              "val": {
                "type": "object",
                "description": "Value to be placed in field."
              },
              "dtype": {
                "type": "dtype object",
                "description": "Data-type of the field in which to place `val`."
              },
              "offset": {
                "type": "int, optional",
                "description": "The number of bytes into the field at which to place `val`."
              }
            },
            "returns": "-------\nNone",
            "raises": "",
            "see_also": "--------\ngetfield",
            "notes": "",
            "examples": "--------\n>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[1.,  0.,  0.],\n[0.,  1.,  0.],\n[0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n[3, 3, 3],\n[3, 3, 3]], dtype=int32)\n>>> x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n[1.5e-323, 1.0e+000, 1.5e-323],\n[1.5e-323, 1.5e-323, 1.0e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[1.,  0.,  0.],\n[0.,  1.,  0.],\n[0.,  0.,  1.]])"
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "a.setflags(write=None, align=None, uic=None)\nSet array flags WRITEABLE, ALIGNED, WRITEBACKIFCOPY,\nrespectively.\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by `a` (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and flag can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)",
            "parameters": {
              "write": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` can be written to."
              },
              "align": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is aligned properly for its type."
              },
              "uic": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is a copy of another \"base\" array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\nArray flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, WRITEABLE, and ALIGNED.\nWRITEABLE (W) the data area can be written to;\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.",
            "examples": "--------\n>>> y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n>>> y\narray([[3, 1, 7],\n[2, 0, 0],\n[8, 5, 9]])\n>>> y.flags\nC_CONTIGUOUS : True\nF_CONTIGUOUS : False\nOWNDATA : True\nWRITEABLE : True\nALIGNED : True\nWRITEBACKIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\nC_CONTIGUOUS : True\nF_CONTIGUOUS : False\nOWNDATA : True\nWRITEABLE : False\nALIGNED : False\nWRITEBACKIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: cannot set WRITEBACKIFCOPY flag to True"
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "a.sort(axis=-1, kind=None, order=None)\nSort an array in-place. Refer to `numpy.sort` for full documentation.",
            "parameters": {
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. Default is -1, which means sort along the\nlast axis."
              },
              "kind": {
                "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
                "description": "Sorting algorithm. The default is 'quicksort'. Note that both 'stable'\nand 'mergesort' use timsort under the covers and, in general, the\nactual implementation will vary with datatype. The 'mergesort' option\nis retained for backwards compatibility.\n.. versionchanged:: 1.15.0\nThe 'stable' option was added."
              },
              "order": {
                "type": "str or list of str, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  A single field can\nbe specified as a string, and not all fields need be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.sort : Return a sorted copy of an array.\nnumpy.argsort : Indirect sort.\nnumpy.lexsort : Indirect stable sort on multiple keys.\nnumpy.searchsorted : Find elements in sorted array.\nnumpy.partition: Partial sort.",
            "notes": "-----\nSee `numpy.sort` for notes on the different sorting algorithms.",
            "examples": "--------\n>>> a = np.array([[1,4], [3,1]])\n>>> a.sort(axis=1)\n>>> a\narray([[1, 4],\n[1, 3]])\n>>> a.sort(axis=0)\n>>> a\narray([[1, 3],\n[1, 4]])\nUse the `order` keyword to specify a field to use when sorting a\nstructured array:\n>>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n>>> a.sort(order='y')\n>>> a\narray([(b'c', 1), (b'a', 2)],\ndtype=[('x', 'S1'), ('y', '<i8')])"
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "a.squeeze(axis=None)\nRemove axes of length one from `a`.\nRefer to `numpy.squeeze` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.squeeze : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "a.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True)",
            "parameters": {},
            "returns": "Refer to `numpy.std` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.std : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "a.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)\nReturn the sum of the array elements over the given axis.\nRefer to `numpy.sum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.sum : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "a.swapaxes(axis1, axis2)\nReturn a view of the array with `axis1` and `axis2` interchanged.\nRefer to `numpy.swapaxes` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.swapaxes : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "a.take(indices, axis=None, out=None, mode='raise')\nReturn an array formed from the elements of `a` at the given indices.\nRefer to `numpy.take` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.take : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "a.tobytes(order='C')\nConstruct Python bytes containing the raw data bytes in the array.\nConstructs Python bytes showing a copy of the raw contents of\ndata memory. The bytes object is produced in C-order by default.\nThis behavior is controlled by the ``order`` parameter.\n.. versionadded:: 1.9.0",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A'}, optional",
                "description": "Controls the memory layout of the bytes object. 'C' means C-order,\n'F' means F-order, 'A' (short for *Any*) means 'F' if `a` is\nFortran contiguous, 'C' otherwise. Default is 'C'."
              }
            },
            "returns": "-------\ns : bytes\nPython bytes exhibiting a copy of `a`'s raw data.\nSee also\n--------\nfrombuffer\nInverse of this operation, construct a 1-dimensional array from Python\nbytes.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.array([[0, 1], [2, 3]], dtype='<u2')\n>>> x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n>>> x.tobytes('C') == x.tobytes()\nTrue\n>>> x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'"
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "a.tofile(fid, sep=\"\", format=\"%s\")\nWrite array to a file as text or binary (default).\nData is always written in 'C' order, independent of the order of `a`.\nThe data produced by this method can be recovered using the function\nfromfile().",
            "parameters": {
              "fid": {
                "type": "file or str or Path",
                "description": "An open file object, or a string containing a filename.\n.. versionchanged:: 1.17.0\n`pathlib.Path` objects are now accepted."
              },
              "sep": {
                "type": "str",
                "description": "Separator between array items for text output.\nIf \"\" (empty), a binary file is written, equivalent to\n``file.write(a.tobytes())``."
              },
              "format": {
                "type": "str",
                "description": "Format string for text file output.\nEach entry in the array is formatted to text by first converting\nit to the closest Python type, and then using \"format\" % item."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\nThis is a convenience function for quick storage of array data.\nInformation on endianness and precision is lost, so this method is not a\ngood choice for files intended to archive data or transport data between\nmachines with different endianness. Some of these problems can be overcome\nby outputting the data as text files, at the expense of speed and file\nsize.\nWhen fid is a file object, array contents are directly written to the\nfile, bypassing the file object's ``write`` method. As a result, tofile\ncannot be used with files objects supporting compression (e.g., GzipFile)\nor file-like objects that do not support ``fileno()`` (e.g., BytesIO).",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "a.tolist()\nReturn the array as an ``a.ndim``-levels deep nested list of Python scalars.\nReturn a copy of the array data as a (nested) Python list.\nData items are converted to the nearest compatible builtin Python type, via\nthe `~numpy.ndarray.item` function.\nIf ``a.ndim`` is 0, then since the depth of the nested list is 0, it will\nnot be a list at all, but a simple Python scalar.",
            "parameters": {},
            "returns": "-------\ny : object, or list of object, or list of list of object, or ...\nThe possibly nested list of array elements.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nThe array may be recreated via ``a = np.array(a.tolist())``, although this\nmay sometimes lose precision.",
            "examples": "--------\nFor a 1D array, ``a.tolist()`` is almost the same as ``list(a)``,\nexcept that ``tolist`` changes numpy scalars to Python scalars:\n>>> a = np.uint32([1, 2])\n>>> a_list = list(a)\n>>> a_list\n[1, 2]\n>>> type(a_list[0])\n<class 'numpy.uint32'>\n>>> a_tolist = a.tolist()\n>>> a_tolist\n[1, 2]\n>>> type(a_tolist[0])\n<class 'int'>\nAdditionally, for a 2D array, ``tolist`` applies recursively:\n>>> a = np.array([[1, 2], [3, 4]])\n>>> list(a)\n[array([1, 2]), array([3, 4])]\n>>> a.tolist()\n[[1, 2], [3, 4]]\nThe base case for this recursion is a 0D array:\n>>> a = np.array(1)\n>>> list(a)\nTraceback (most recent call last):\n...\nTypeError: iteration over a 0-d array\n>>> a.tolist()\n1"
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "a.tostring(order='C')\nA compatibility alias for `tobytes`, with exactly the same behavior.\nDespite its name, it returns `bytes` not `str`\\ s.\n.. deprecated:: 1.19.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\nReturn the sum along diagonals of the array.\nRefer to `numpy.trace` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.trace : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "a.transpose(*axes)",
            "parameters": {
              "axes": {
                "type": "None, tuple of ints, or `n` ints",
                "description": "* None or no argument: reverses the order of the axes.\n* tuple of ints: `i` in the `j`-th place in the tuple means that the\narray's `i`-th axis becomes the transposed array's `j`-th axis.\n* `n` ints: same as an n-tuple of the same ints (this form is\nintended simply as a \"convenience\" alternative to the tuple form)."
              }
            },
            "returns": "Refer to `numpy.transpose` for full documentation.\n-------\np : ndarray\nView of the array with its axes suitably permuted.",
            "raises": "",
            "see_also": "--------\ntranspose : Equivalent function.\nndarray.T : Array property returning the array transposed.\nndarray.reshape : Give a new shape to an array without changing its data.",
            "notes": "",
            "examples": "--------\n>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n[3, 4]])\n>>> a.transpose()\narray([[1, 3],\n[2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n[2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n[2, 4]])\n>>> a = np.array([1, 2, 3, 4])\n>>> a\narray([1, 2, 3, 4])\n>>> a.transpose()\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "a.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True)",
            "parameters": {},
            "returns": "Refer to `numpy.var` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.var : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "a.view([dtype][, type])\nNew view of array with the same data.\n.. note::\nPassing None for ``dtype`` is different from omitting the parameter,\nsince the former invokes ``dtype(None)`` which is an alias for\n``dtype('float_')``.",
            "parameters": {
              "dtype": {
                "type": "data-type or ndarray sub-class, optional",
                "description": "Data-type descriptor of the returned view, e.g., float32 or int16.\nOmitting it results in the view having the same data-type as `a`.\nThis argument can also be specified as an ndarray sub-class, which\nthen specifies the type of the returned object (this is equivalent to\nsetting the ``type`` parameter)."
              },
              "type": {
                "type": "Python type, optional",
                "description": "Type of the returned view, e.g., ndarray or matrix.  Again, omission\nof the parameter results in type preservation."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\n``a.view()`` is used two different ways:\n``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view\nof the array's memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\n``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just\nreturns an instance of `ndarray_subclass` that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\nFor ``a.view(some_dtype)``, if ``some_dtype`` has a different number of\nbytes per entry than the previous dtype (for example, converting a regular\narray to a structured array), then the last axis of ``a`` must be\ncontiguous. This axis will be resized in the result.\n.. versionchanged:: 1.23.0\nOnly the last axis needs to be contiguous. Previously, the entire array\nhad to be C-contiguous.",
            "examples": "--------\n>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\nViewing array data using a different type and dtype:\n>>> y = x.view(dtype=np.int16, type=np.matrix)\n>>> y\nmatrix([[513]], dtype=int16)\n>>> print(type(y))\n<class 'numpy.matrix'>\nCreating a view on a structured array so it can be used in calculations\n>>> x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n>>> xv = x.view(dtype=np.int8).reshape(-1,2)\n>>> xv\narray([[1, 2],\n[3, 4]], dtype=int8)\n>>> xv.mean(0)\narray([2.,  3.])\nMaking changes to the view changes the underlying array\n>>> xv[0,1] = 20\n>>> x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\nUsing a view to convert an array to a recarray:\n>>> z = x.view(np.recarray)\n>>> z.a\narray([1, 3], dtype=int8)\nViews share data:\n>>> x[0] = (9, 10)\n>>> z[0]\n(9, 10)\nViews that change the dtype size (bytes per entry) should normally be\navoided on arrays defined by slices, transposes, fortran-ordering, etc.:\n>>> x = np.array([[1, 2, 3], [4, 5, 6]], dtype=np.int16)\n>>> y = x[:, ::2]\n>>> y\narray([[1, 3],\n[4, 6]], dtype=int16)\n>>> y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n...\nValueError: To change to a dtype of a different size, the last axis must be contiguous\n>>> z = y.copy()\n>>> z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 3)],\n[(4, 6)]], dtype=[('width', '<i2'), ('length', '<i2')])\nHowever, views that change dtype are totally fine for arrays with a\ncontiguous last axis, even if the rest of the axes are not C-contiguous:\n>>> x = np.arange(2 * 3 * 4, dtype=np.int8).reshape(2, 3, 4)\n>>> x.transpose(1, 0, 2).view(np.int16)\narray([[[ 256,  770],\n[3340, 3854]],\n<BLANKLINE>\n[[1284, 1798],\n[4368, 4882]],\n<BLANKLINE>\n[[2312, 2826],\n[5396, 5910]]], dtype=int16)"
          }
        }
      ]
    }
  ]
}