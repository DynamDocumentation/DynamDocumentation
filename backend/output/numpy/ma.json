{
  "description": "=============\nMasked Arrays\n=============\n\nArrays sometimes contain invalid or missing data.  When doing operations\non such arrays, we wish to suppress invalid values, which is the purpose masked\narrays fulfill (an example of typical use is given below).\n\nFor example, examine the following array:\n\n>>> x = np.array([2, 1, 3, np.nan, 5, 2, 3, np.nan])\n\nWhen we try to calculate the mean of the data, the result is undetermined:\n\n>>> np.mean(x)\nnan\n\nThe mean is calculated using roughly ``np.sum(x)/len(x)``, but since\nany number added to ``NaN`` [1]_ produces ``NaN``, this doesn't work.  Enter\nmasked arrays:\n\n>>> m = np.ma.masked_array(x, np.isnan(x))\n>>> m\nmasked_array(data = [2.0 1.0 3.0 -- 5.0 2.0 3.0 --],\n      mask = [False False False  True False False False  True],\n      fill_value=1e+20)\n\nHere, we construct a masked array that suppress all ``NaN`` values.  We\nmay now proceed to calculate the mean of the other values:\n\n>>> np.mean(m)\n2.6666666666666665\n\n.. [1] Not-a-Number, a floating point value that is the result of an\n       invalid operation.\n\n.. moduleauthor:: Pierre Gerard-Marchant\n.. moduleauthor:: Jarrod Millman",
  "functions": [
    {
      "name": "abs",
      "signature": "absolute(a, *args, **kwargs)",
      "documentation": {
        "description": "absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCalculate the absolute value element-wise.\n``np.abs`` is a shorthand for this function.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nabsolute : ndarray\nAn ndarray containing the absolute value of\neach element in `x`.  For complex input, ``a + ib``, the\nabsolute value is :math:`\\sqrt{ a^2 + b^2 }`.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> x = np.array([-1.2, 1.2])\n>>> np.absolute(x)\narray([ 1.2,  1.2])\n>>> np.absolute(1.2 + 1j)\n1.5620499351813308\nPlot the function over ``[-10, 10]``:\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(start=-10, stop=10, num=101)\n>>> plt.plot(x, np.absolute(x))\n>>> plt.show()\nPlot the function over the complex plane:\n>>> xx = x + 1j * x[:, np.newaxis]\n>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')\n>>> plt.show()\nThe `abs` function can be used as a shorthand for ``np.absolute`` on\nndarrays.\n>>> x = np.array([-1.2, 1.2])\n>>> abs(x)\narray([1.2, 1.2])"
      }
    },
    {
      "name": "absolute",
      "signature": "absolute(a, *args, **kwargs)",
      "documentation": {
        "description": "absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCalculate the absolute value element-wise.\n``np.abs`` is a shorthand for this function.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nabsolute : ndarray\nAn ndarray containing the absolute value of\neach element in `x`.  For complex input, ``a + ib``, the\nabsolute value is :math:`\\sqrt{ a^2 + b^2 }`.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> x = np.array([-1.2, 1.2])\n>>> np.absolute(x)\narray([ 1.2,  1.2])\n>>> np.absolute(1.2 + 1j)\n1.5620499351813308\nPlot the function over ``[-10, 10]``:\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(start=-10, stop=10, num=101)\n>>> plt.plot(x, np.absolute(x))\n>>> plt.show()\nPlot the function over the complex plane:\n>>> xx = x + 1j * x[:, np.newaxis]\n>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')\n>>> plt.show()\nThe `abs` function can be used as a shorthand for ``np.absolute`` on\nndarrays.\n>>> x = np.array([-1.2, 1.2])\n>>> abs(x)\narray([1.2, 1.2])"
      }
    },
    {
      "name": "add",
      "signature": "add(a, b, *args, **kwargs)",
      "documentation": {
        "description": "add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nAdd arguments element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nadd : ndarray or scalar\nThe sum of `x1` and `x2`, element-wise.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "",
        "notes": "-----\nEquivalent to `x1` + `x2` in terms of array broadcasting.",
        "examples": "--------\n>>> np.add(1.0, 4.0)\n5.0\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.add(x1, x2)\narray([[  0.,   2.,   4.],\n[  3.,   5.,   7.],\n[  6.,   8.,  10.]])\nThe ``+`` operator can be used as a shorthand for ``np.add`` on ndarrays.\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> x1 + x2\narray([[ 0.,  2.,  4.],\n[ 3.,  5.,  7.],\n[ 6.,  8., 10.]])"
      }
    },
    {
      "name": "all",
      "signature": "all(a, *args, **params)",
      "documentation": {
        "description": "all(self, axis=None, out=None, keepdims=<no value>)",
        "parameters": {},
        "returns": "The output array is masked where all the values along the given axis\nare masked: if the output would have been a scalar and that all the\nvalues are masked, then the output is `masked`.\nRefer to `numpy.all` for full documentation.",
        "raises": "",
        "see_also": "--------\nnumpy.ndarray.all : corresponding function for ndarrays\nnumpy.all : equivalent function",
        "notes": "",
        "examples": "--------\n>>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue"
      }
    },
    {
      "name": "allclose",
      "signature": "allclose(a, b, masked_equal=True, rtol=1e-05, atol=1e-08)",
      "documentation": {
        "description": "",
        "parameters": {
          "masked_equal": {
            "type": "bool, optional",
            "description": "Whether masked values in `a` and `b` are considered equal (True) or not\n(False). They are considered equal by default."
          },
          "rtol": {
            "type": "float, optional",
            "description": "Relative tolerance. The relative difference is equal to ``rtol * b``.\nDefault is 1e-5."
          },
          "atol": {
            "type": "float, optional",
            "description": "Absolute tolerance. The absolute difference is equal to `atol`.\nDefault is 1e-8."
          }
        },
        "returns": "This function is equivalent to `allclose` except that masked values\nare treated as equal (default) or unequal, depending on the `masked_equal`\nargument.\n-------\ny : bool\ntolerance, False otherwise. If either array contains NaN, then\nFalse is returned.",
        "raises": "",
        "see_also": "--------\nall, any\nnumpy.allclose : the non-masked `allclose`.",
        "notes": "-----\nIf the following equation is element-wise True, then `allclose` returns\nTrue::\nabsolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\nReturn True if all elements of `a` and `b` are equal subject to\ngiven tolerances.",
        "examples": "--------\n>>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n>>> a\nmasked_array(data=[10000000000.0, 1e-07, --],\nmask=[False, False,  True],\nfill_value=1e+20)\n>>> b = np.ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])\n>>> np.ma.allclose(a, b)\nFalse\n>>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n>>> b = np.ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])\n>>> np.ma.allclose(a, b)\nTrue\n>>> np.ma.allclose(a, b, masked_equal=False)\nFalse\nMasked values are not compared directly.\n>>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n>>> b = np.ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])\n>>> np.ma.allclose(a, b)\nTrue\n>>> np.ma.allclose(a, b, masked_equal=False)\nFalse"
      }
    },
    {
      "name": "allequal",
      "signature": "allequal(a, b, fill_value=True)",
      "documentation": {
        "description": "Return True if all entries of a and b are equal, using\nfill_value as a truth value where either or both are masked.",
        "parameters": {
          "fill_value": {
            "type": "bool, optional",
            "description": "Whether masked values in a or b are considered equal (True) or not\n(False)."
          }
        },
        "returns": "-------\ny : bool\ntolerance, False otherwise. If either array contains NaN,\nthen False is returned.",
        "raises": "",
        "see_also": "--------\nall, any\nnumpy.ma.allclose",
        "notes": "",
        "examples": "--------\n>>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n>>> a\nmasked_array(data=[10000000000.0, 1e-07, --],\nmask=[False, False,  True],\nfill_value=1e+20)\n>>> b = np.array([1e10, 1e-7, -42.0])\n>>> b\narray([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])\n>>> np.ma.allequal(a, b, fill_value=False)\nFalse\n>>> np.ma.allequal(a, b)\nTrue"
      }
    },
    {
      "name": "alltrue",
      "signature": "reduce(target, axis=0, dtype=None)",
      "documentation": {
        "description": "Reduce `target` along the given `axis`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "amax",
      "signature": "amax(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)",
      "documentation": {
        "description": "Return the maximum of an array or maximum along an axis.\n`amax` is an alias of `~numpy.max`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nmax : alias of this function\nndarray.max : equivalent method",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "amin",
      "signature": "amin(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)",
      "documentation": {
        "description": "Return the minimum of an array or minimum along an axis.\n`amin` is an alias of `~numpy.min`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nmin : alias of this function\nndarray.min : equivalent method",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "angle",
      "signature": "angle(a, *args, **kwargs)",
      "documentation": {
        "description": "Return the angle of the complex argument.",
        "parameters": {
          "z": {
            "type": "array_like",
            "description": "A complex number or sequence of complex numbers."
          },
          "deg": {
            "type": "bool, optional",
            "description": "Return angle in degrees if True, radians if False (default)."
          }
        },
        "returns": "-------\nangle : ndarray or scalar\nThe counterclockwise angle from the positive real axis on the complex\nplane in the range ``(-pi, pi]``, with dtype as numpy.float64.\n.. versionchanged:: 1.16.0\nThis function works on subclasses of ndarray like `ma.array`.",
        "raises": "",
        "see_also": "--------\narctan2\nabsolute",
        "notes": "-----\nAlthough the angle of the complex number 0 is undefined, ``numpy.angle(0)``\nreturns the value 0.",
        "examples": "--------\n>>> np.angle([1.0, 1.0j, 1+1j])               # in radians\narray([ 0.        ,  1.57079633,  0.78539816]) # may vary\n>>> np.angle(1+1j, deg=True)                  # in degrees\n45.0"
      }
    },
    {
      "name": "anom",
      "signature": "anom(a, *args, **params)",
      "documentation": {
        "description": "anom(self, axis=None, dtype=None)\nCompute the anomalies (deviations from the arithmetic mean)\nalong the given axis.",
        "parameters": {
          "axis": {
            "type": "int, optional",
            "description": "Axis over which the anomalies are taken.\nThe default is to use the mean of the flattened array as reference."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Type to use in computing the variance. For arrays of integer type\nthe default is float32; for arrays of float types it is the same as\nthe array type."
          }
        },
        "returns": "where the arithmetic mean is computed along the given axis.",
        "raises": "",
        "see_also": "--------\nmean : Compute the mean of the array.",
        "notes": "",
        "examples": "--------\n>>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data=[-1.,  0.,  1.],\nmask=False,\nfill_value=1e+20)"
      }
    },
    {
      "name": "anomalies",
      "signature": "anom(a, *args, **params)",
      "documentation": {
        "description": "anom(self, axis=None, dtype=None)\nCompute the anomalies (deviations from the arithmetic mean)\nalong the given axis.",
        "parameters": {
          "axis": {
            "type": "int, optional",
            "description": "Axis over which the anomalies are taken.\nThe default is to use the mean of the flattened array as reference."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Type to use in computing the variance. For arrays of integer type\nthe default is float32; for arrays of float types it is the same as\nthe array type."
          }
        },
        "returns": "where the arithmetic mean is computed along the given axis.",
        "raises": "",
        "see_also": "--------\nmean : Compute the mean of the array.",
        "notes": "",
        "examples": "--------\n>>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data=[-1.,  0.,  1.],\nmask=False,\nfill_value=1e+20)"
      }
    },
    {
      "name": "any",
      "signature": "any(a, *args, **params)",
      "documentation": {
        "description": "any(self, axis=None, out=None, keepdims=<no value>)",
        "parameters": {},
        "returns": "Masked values are considered as False during computation.\nRefer to `numpy.any` for full documentation.",
        "raises": "",
        "see_also": "--------\nnumpy.ndarray.any : corresponding function for ndarrays\nnumpy.any : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "append",
      "signature": "append(a, b, axis=None)",
      "documentation": {
        "description": "Append values to the end of an array.\n.. versionadded:: 1.9.0",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Values are appended to a copy of this array."
          },
          "b": {
            "type": "array_like",
            "description": "These values are appended to a copy of `a`.  It must be of the\ncorrect shape (the same shape as `a`, excluding `axis`).  If `axis`\nis not specified, `b` can be any shape and will be flattened\nbefore use."
          },
          "axis": {
            "type": "int, optional",
            "description": "The axis along which `v` are appended.  If `axis` is not given,\nboth `a` and `b` are flattened before use."
          }
        },
        "returns": "-------\nappend : MaskedArray\nA copy of `a` with `b` appended to `axis`.  Note that `append`\ndoes not occur in-place: a new array is allocated and filled.  If\n`axis` is None, the result is a flattened array.",
        "raises": "",
        "see_also": "--------\nnumpy.append : Equivalent function in the top-level NumPy module.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = ma.masked_values([1, 2, 3], 2)\n>>> b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)\n>>> ma.append(a, b)\nmasked_array(data=[1, --, 3, 4, 5, 6, --, 8, 9],\nmask=[False,  True, False, False, False, False,  True, False,\nFalse],\nfill_value=999999)"
      }
    },
    {
      "name": "apply_along_axis",
      "signature": "apply_along_axis(func1d, axis, arr, *args, **kwargs)",
      "documentation": {
        "description": "Apply a function to 1-D slices along the given axis.\nExecute `func1d(a, *args, **kwargs)` where `func1d` operates on 1-D arrays\nand `a` is a 1-D slice of `arr` along `axis`.\nThis is equivalent to (but faster than) the following use of `ndindex` and\n`s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices::\nNi, Nk = a.shape[:axis], a.shape[axis+1:]\nfor ii in ndindex(Ni):\nfor kk in ndindex(Nk):\nf = func1d(arr[ii + s_[:,] + kk])\nNj = f.shape\nfor jj in ndindex(Nj):\nout[ii + jj + kk] = f[jj]\nEquivalently, eliminating the inner loop, this can be expressed as::\nNi, Nk = a.shape[:axis], a.shape[axis+1:]\nfor ii in ndindex(Ni):\nfor kk in ndindex(Nk):\nout[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])",
        "parameters": {
          "func1d": {
            "type": "function (M,) -> (Nj...)",
            "description": "This function should accept 1-D arrays. It is applied to 1-D\nslices of `arr` along the specified axis."
          },
          "axis": {
            "type": "integer",
            "description": "Axis along which `arr` is sliced."
          },
          "arr": {
            "type": "ndarray (Ni..., M, Nk...)",
            "description": "Input array."
          },
          "args": {
            "type": "any",
            "description": "Additional arguments to `func1d`."
          },
          "kwargs": {
            "type": "any",
            "description": "Additional named arguments to `func1d`.\n.. versionadded:: 1.9.0"
          }
        },
        "returns": "-------\nout : ndarray  (Ni..., Nj..., Nk...)\nThe output array. The shape of `out` is identical to the shape of\n`arr`, except along the `axis` dimension. This axis is removed, and\nreplaced with new dimensions equal to the shape of the return value\nof `func1d`. So if `func1d` returns a scalar `out` will have one\nfewer dimensions than `arr`.",
        "raises": "",
        "see_also": "--------\napply_over_axes : Apply a function repeatedly over multiple axes.",
        "notes": "",
        "examples": "--------\n>>> def my_func(a):\n...     \"\"\"Average first and last element of a 1-D array\"\"\"\n...     return (a[0] + a[-1]) * 0.5\n>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n>>> np.apply_along_axis(my_func, 0, b)\narray([4., 5., 6.])\n>>> np.apply_along_axis(my_func, 1, b)\narray([2.,  5.,  8.])\nFor a function that returns a 1D array, the number of dimensions in\n`outarr` is the same as `arr`.\n>>> b = np.array([[8,1,7], [4,3,9], [5,2,6]])\n>>> np.apply_along_axis(sorted, 1, b)\narray([[1, 7, 8],\n[3, 4, 9],\n[2, 5, 6]])\nFor a function that returns a higher dimensional array, those dimensions\nare inserted in place of the `axis` dimension.\n>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n>>> np.apply_along_axis(np.diag, -1, b)\narray([[[1, 0, 0],\n[0, 2, 0],\n[0, 0, 3]],\n[[4, 0, 0],\n[0, 5, 0],\n[0, 0, 6]],\n[[7, 0, 0],\n[0, 8, 0],\n[0, 0, 9]]])"
      }
    },
    {
      "name": "apply_over_axes",
      "signature": "apply_over_axes(func, a, axes)",
      "documentation": {
        "description": "Apply a function repeatedly over multiple axes.\n`func` is called as `res = func(a, axis)`, where `axis` is the first\nelement of `axes`.  The result `res` of the function call must have\neither the same dimensions as `a` or one less dimension.  If `res`\nhas one less dimension than `a`, a dimension is inserted before\n`axis`.  The call to `func` is then repeated for each axis in `axes`,\nwith `res` as the first argument.",
        "parameters": {
          "func": {
            "type": "function",
            "description": "This function must take two arguments, `func(a, axis)`."
          },
          "a": {
            "type": "array_like",
            "description": "Input array."
          },
          "axes": {
            "type": "array_like",
            "description": "Axes over which `func` is applied; the elements must be integers."
          }
        },
        "returns": "-------\napply_over_axis : ndarray\nThe output array.  The number of dimensions is the same as `a`,\nbut the shape can be different.  This depends on whether `func`\nchanges the shape of its output with respect to its input.",
        "raises": "",
        "see_also": "--------\napply_along_axis :\nApply a function to 1-D slices of an array along the given axis.",
        "notes": "",
        "examples": "--------\n>>> a = np.ma.arange(24).reshape(2,3,4)\n>>> a[:,0,1] = np.ma.masked\n>>> a[:,1,:] = np.ma.masked\n>>> a\nmasked_array(\ndata=[[[0, --, 2, 3],\n[--, --, --, --],\n[8, 9, 10, 11]],\n[[12, --, 14, 15],\n[--, --, --, --],\n[20, 21, 22, 23]]],\nmask=[[[False,  True, False, False],\n[ True,  True,  True,  True],\n[False, False, False, False]],\n[[False,  True, False, False],\n[ True,  True,  True,  True],\n[False, False, False, False]]],\nfill_value=999999)\n>>> np.ma.apply_over_axes(np.ma.sum, a, [0,2])\nmasked_array(\ndata=[[[46],\n[--],\n[124]]],\nmask=[[[False],\n[ True],\n[False]]],\nfill_value=999999)\nTuple axis arguments to ufuncs are equivalent:\n>>> np.ma.sum(a, axis=(0,2)).reshape((1,-1,1))\nmasked_array(\ndata=[[[46],\n[--],\n[124]]],\nmask=[[[False],\n[ True],\n[False]]],\nfill_value=999999)"
      }
    },
    {
      "name": "arccos",
      "signature": "arccos(a, *args, **kwargs)",
      "documentation": {
        "description": "arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nTrigonometric inverse cosine, element-wise.\nThe inverse of `cos` so that, if ``y = cos(x)``, then ``x = arccos(y)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "`x`-coordinate on the unit circle.\nFor real arguments, the domain is [-1, 1]."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nangle : ndarray\nThe angle of the ray intersecting the unit circle at the given\n`x`-coordinate in radians [0, pi].\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\ncos, arctan, arcsin, emath.arccos",
        "notes": "-----\n`arccos` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that ``cos(z) = x``. The convention is to return\nthe angle `z` whose real part lies in `[0, pi]`.\nFor real-valued input data types, `arccos` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\nFor complex-valued input, `arccos` is a complex analytic function that\nhas branch cuts ``[-inf, -1]`` and `[1, inf]` and is continuous from\nabove on the former and from below on the latter.\nThe inverse `cos` is also known as `acos` or cos^-1.\nReferences\n----------\nM. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n10th printing, 1964, pp. 79.\nhttps://personal.math.ubc.ca/~cbm/aands/page_79.htm",
        "examples": "--------\nWe expect the arccos of 1 to be 0, and of -1 to be pi:\n>>> np.arccos([1, -1])\narray([ 0.        ,  3.14159265])\nPlot arccos:\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-1, 1, num=100)\n>>> plt.plot(x, np.arccos(x))\n>>> plt.axis('tight')\n>>> plt.show()"
      }
    },
    {
      "name": "arccosh",
      "signature": "arccosh(a, *args, **kwargs)",
      "documentation": {
        "description": "arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nInverse hyperbolic cosine, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\narccosh : ndarray\nArray of the same shape as `x`.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\ncosh, arcsinh, sinh, arctanh, tanh",
        "notes": "-----\n`arccosh` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that `cosh(z) = x`. The convention is to return the\n`z` whose imaginary part lies in ``[-pi, pi]`` and the real part in\n``[0, inf]``.\nFor real-valued input data types, `arccosh` always returns real output.\nFor each value that cannot be expressed as a real number or infinity, it\nyields ``nan`` and sets the `invalid` floating point error flag.\nFor complex-valued input, `arccosh` is a complex analytical function that\nhas a branch cut `[-inf, 1]` and is continuous from above on it.\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n10th printing, 1964, pp. 86.\nhttps://personal.math.ubc.ca/~cbm/aands/page_86.htm\n.. [2] Wikipedia, \"Inverse hyperbolic function\",\nhttps://en.wikipedia.org/wiki/Arccosh",
        "examples": "--------\n>>> np.arccosh([np.e, 10.0])\narray([ 1.65745445,  2.99322285])\n>>> np.arccosh(1)\n0.0"
      }
    },
    {
      "name": "arcsin",
      "signature": "arcsin(a, *args, **kwargs)",
      "documentation": {
        "description": "arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nInverse sine, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "`y`-coordinate on the unit circle."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nangle : ndarray\nThe inverse sine of each element in `x`, in radians and in the\nclosed interval ``[-pi/2, pi/2]``.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\nsin, cos, arccos, tan, arctan, arctan2, emath.arcsin",
        "notes": "-----\n`arcsin` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that :math:`sin(z) = x`.  The convention is to\nreturn the angle `z` whose real part lies in [-pi/2, pi/2].\nFor real-valued input data types, *arcsin* always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\nFor complex-valued input, `arcsin` is a complex analytic function that\nhas, by convention, the branch cuts [-inf, -1] and [1, inf]  and is\ncontinuous from above on the former and from below on the latter.\nThe inverse sine is also known as `asin` or sin^{-1}.\nReferences\n----------\nAbramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,\n10th printing, New York: Dover, 1964, pp. 79ff.\nhttps://personal.math.ubc.ca/~cbm/aands/page_79.htm",
        "examples": "--------\n>>> np.arcsin(1)     # pi/2\n1.5707963267948966\n>>> np.arcsin(-1)    # -pi/2\n-1.5707963267948966\n>>> np.arcsin(0)\n0.0"
      }
    },
    {
      "name": "arcsinh",
      "signature": "arcsinh(a, *args, **kwargs)",
      "documentation": {
        "description": "arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nInverse hyperbolic sine element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : ndarray or scalar\nArray of the same shape as `x`.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "-----\n`arcsinh` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that `sinh(z) = x`. The convention is to return the\n`z` whose imaginary part lies in `[-pi/2, pi/2]`.\nFor real-valued input data types, `arcsinh` always returns real output.\nFor each value that cannot be expressed as a real number or infinity, it\nreturns ``nan`` and sets the `invalid` floating point error flag.\nFor complex-valued input, `arccos` is a complex analytical function that\nhas branch cuts `[1j, infj]` and `[-1j, -infj]` and is continuous from\nthe right on the former and from the left on the latter.\nThe inverse hyperbolic sine is also known as `asinh` or ``sinh^-1``.\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n10th printing, 1964, pp. 86.\nhttps://personal.math.ubc.ca/~cbm/aands/page_86.htm\n.. [2] Wikipedia, \"Inverse hyperbolic function\",\nhttps://en.wikipedia.org/wiki/Arcsinh",
        "examples": "--------\n>>> np.arcsinh(np.array([np.e, 10.0]))\narray([ 1.72538256,  2.99822295])"
      }
    },
    {
      "name": "arctan",
      "signature": "arctan(a, *args, **kwargs)",
      "documentation": {
        "description": "arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nTrigonometric inverse tangent, element-wise.\nThe inverse of tan, so that if ``y = tan(x)`` then ``x = arctan(y)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": ""
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : ndarray or scalar\nOut has the same shape as `x`.  Its real part is in\n``[-pi/2, pi/2]`` (``arctan(+/-inf)`` returns ``+/-pi/2``).\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\narctan2 : The \"four quadrant\" arctan of the angle formed by (`x`, `y`)\nand the positive `x`-axis.\nangle : Argument of complex values.",
        "notes": "-----\n`arctan` is a multi-valued function: for each `x` there are infinitely\nmany numbers `z` such that tan(`z`) = `x`.  The convention is to return\nthe angle `z` whose real part lies in [-pi/2, pi/2].\nFor real-valued input data types, `arctan` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\nFor complex-valued input, `arctan` is a complex analytic function that\nhas [``1j, infj``] and [``-1j, -infj``] as branch cuts, and is continuous\nfrom the left on the former and from the right on the latter.\nThe inverse tangent is also known as `atan` or tan^{-1}.\nReferences\n----------\nAbramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,\n10th printing, New York: Dover, 1964, pp. 79.\nhttps://personal.math.ubc.ca/~cbm/aands/page_79.htm",
        "examples": "--------\nWe expect the arctan of 0 to be 0, and of 1 to be pi/4:\n>>> np.arctan([0, 1])\narray([ 0.        ,  0.78539816])\n>>> np.pi/4\n0.78539816339744828\nPlot arctan:\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-10, 10)\n>>> plt.plot(x, np.arctan(x))\n>>> plt.axis('tight')\n>>> plt.show()"
      }
    },
    {
      "name": "arctan2",
      "signature": "arctan2(a, b, *args, **kwargs)",
      "documentation": {
        "description": "arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nElement-wise arc tangent of ``x1/x2`` choosing the quadrant correctly.\nThe quadrant (i.e., branch) is chosen so that ``arctan2(x1, x2)`` is\nthe signed angle in radians between the ray ending at the origin and\npassing through the point (1,0), and the ray ending at the origin and\npassing through the point (`x2`, `x1`).  (Note the role reversal: the\n\"`y`-coordinate\" is the first function parameter, the \"`x`-coordinate\"\nis the second.)  By IEEE convention, this function is defined for\n`x2` = +/-0 and for either or both of `x1` and `x2` = +/-inf (see",
        "parameters": {
          "x1": {
            "type": "array_like, real-valued",
            "description": "`y`-coordinates."
          },
          "x2": {
            "type": "array_like, real-valued",
            "description": "`x`-coordinates.\nIf ``x1.shape != x2.shape``, they must be broadcastable to a common\nshape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nangle : ndarray\nArray of angles in radians, in the range ``[-pi, pi]``.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\narctan, tan, angle",
        "notes": "This function is not defined for complex-valued arguments; for the\nso-called argument of complex values, use `angle`.\n-----\n*arctan2* is identical to the `atan2` function of the underlying\nC library.  The following special values are defined in the C\nstandard: [1]_\n====== ====== ================\n`x1`   `x2`   `arctan2(x1,x2)`\n====== ====== ================\n+/- 0  +0     +/- 0\n+/- 0  -0     +/- pi\n> 0   +/-inf +0 / +pi\n< 0   +/-inf -0 / -pi\n+/-inf +inf   +/- (pi/4)\n+/-inf -inf   +/- (3*pi/4)\n====== ====== ================\nNote that +0 and -0 are distinct floating point numbers, as are +inf\nand -inf.\nReferences\n----------\n.. [1] ISO/IEC standard 9899:1999, \"Programming language C.\"",
        "examples": "--------\nConsider four points in different quadrants:\n>>> x = np.array([-1, +1, +1, -1])\n>>> y = np.array([-1, -1, +1, +1])\n>>> np.arctan2(y, x) * 180 / np.pi\narray([-135.,  -45.,   45.,  135.])\nNote the order of the parameters. `arctan2` is defined also when `x2` = 0\nand at several other special points, obtaining values in\nthe range ``[-pi, pi]``:\n>>> np.arctan2([1., -1.], [0., 0.])\narray([ 1.57079633, -1.57079633])\n>>> np.arctan2([0., 0., np.inf], [+0., -0., np.inf])\narray([0.        , 3.14159265, 0.78539816])"
      }
    },
    {
      "name": "arctanh",
      "signature": "arctanh(a, *args, **kwargs)",
      "documentation": {
        "description": "arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nInverse hyperbolic tangent element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : ndarray or scalar\nArray of the same shape as `x`.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\nemath.arctanh",
        "notes": "-----\n`arctanh` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that ``tanh(z) = x``. The convention is to return\nthe `z` whose imaginary part lies in `[-pi/2, pi/2]`.\nFor real-valued input data types, `arctanh` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\nFor complex-valued input, `arctanh` is a complex analytical function\nthat has branch cuts `[-1, -inf]` and `[1, inf]` and is continuous from\nabove on the former and from below on the latter.\nThe inverse hyperbolic tangent is also known as `atanh` or ``tanh^-1``.\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n10th printing, 1964, pp. 86.\nhttps://personal.math.ubc.ca/~cbm/aands/page_86.htm\n.. [2] Wikipedia, \"Inverse hyperbolic function\",\nhttps://en.wikipedia.org/wiki/Arctanh",
        "examples": "--------\n>>> np.arctanh([0, -0.5])\narray([ 0.        , -0.54930614])"
      }
    },
    {
      "name": "argmax",
      "signature": "argmax(a, *args, **params)",
      "documentation": {
        "description": "argmax(self, axis=None, fill_value=None, out=None)",
        "parameters": {
          "axis": {
            "type": "{None, integer}",
            "description": "If None, the index is into the flattened array, otherwise along\nthe specified axis"
          },
          "fill_value": {
            "type": "scalar or None, optional",
            "description": "Value used to fill in the masked values.  If None, the output of\nmaximum_fill_value(self._data) is used instead."
          },
          "out": {
            "type": "{None, array}, optional",
            "description": "Array into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output."
          }
        },
        "returns": "Masked values are treated as if they had the value fill_value.\n-------\nindex_array : {integer_array}",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])"
      }
    },
    {
      "name": "argmin",
      "signature": "argmin(a, *args, **params)",
      "documentation": {
        "description": "argmin(self, axis=None, fill_value=None, out=None)\nReturn array of indices to the minimum values along the given axis.",
        "parameters": {
          "axis": {
            "type": "{None, integer}",
            "description": "If None, the index is into the flattened array, otherwise along\nthe specified axis"
          },
          "fill_value": {
            "type": "scalar or None, optional",
            "description": "Value used to fill in the masked values.  If None, the output of\nminimum_fill_value(self._data) is used instead."
          },
          "out": {
            "type": "{None, array}, optional",
            "description": "Array into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output."
          }
        },
        "returns": "-------\nndarray or scalar\nIf multi-dimension input, returns a new ndarray of indices to the\nminimum values along the given axis.  Otherwise, returns a scalar\nof index to the minimum values along the given axis.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> x\nmasked_array(\ndata=[[--, --],\n[2, 3]],\nmask=[[ True,  True],\n[False, False]],\nfill_value=999999)\n>>> x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n>>> x.argmin(axis=0, fill_value=9)\narray([1, 1])"
      }
    },
    {
      "name": "argsort",
      "signature": "argsort(a, axis=<no value>, kind=None, order=None, endwith=True, fill_value=None)",
      "documentation": {
        "description": "Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\n`fill_value`.",
        "parameters": {
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to sort. If None, the default, the flattened array\nis used.\n..  versionchanged:: 1.13.0\nPreviously, the default was documented to be -1, but that was\nin error. At some future date, the default will change to -1, as\noriginally intended.\nUntil then, the axis should be given explicitly when\n``arr.ndim > 1``, to avoid a FutureWarning."
          },
          "kind": {
            "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
            "description": "The sorting algorithm used."
          },
          "order": {
            "type": "list, optional",
            "description": "When `a` is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  Not all fields need be\nspecified."
          },
          "endwith": {
            "type": "{True, False}, optional",
            "description": "Whether missing values (if any) should be treated as the largest values\n(True) or the smallest values (False)\nWhen the array contains unmasked values at the same extremes of the\ndatatype, the ordering of these values and the masked values is\nundefined."
          },
          "fill_value": {
            "type": "scalar or None, optional",
            "description": "Value used internally for the masked values.\nIf ``fill_value`` is not None, it supersedes ``endwith``."
          }
        },
        "returns": "-------\nindex_array : ndarray, int\nArray of indices that sort `a` along the specified axis.\nIn other words, ``a[index_array]`` yields a sorted `a`.",
        "raises": "",
        "see_also": "--------\nma.MaskedArray.sort : Describes sorting algorithms used.\nlexsort : Indirect stable sort with multiple keys.\nnumpy.ndarray.sort : Inplace sort.",
        "notes": "-----\nSee `sort` for notes on the different sorting algorithms.",
        "examples": "--------\n>>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data=[3, 2, --],\nmask=[False, False,  True],\nfill_value=999999)\n>>> a.argsort()\narray([1, 0, 2])"
      }
    },
    {
      "name": "around",
      "signature": "round_(a, *args, **kwargs)",
      "documentation": {
        "description": "Round an array to the given number of decimals.\n`~numpy.round_` is a disrecommended backwards-compatibility\nalias of `~numpy.around` and `~numpy.round`.\n.. deprecated:: 1.25.0\n``round_`` is deprecated as of NumPy 1.25.0, and will be\nremoved in NumPy 2.0. Please use `round` instead.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\naround : equivalent function; see for details.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "array",
      "signature": "array(data, dtype=None, copy=False, order=None, mask=False, fill_value=None, keep_mask=True, hard_mask=False, shrink=True, subok=True, ndmin=0)",
      "documentation": {
        "description": "An array class with possibly masked values.\nMasked values of True exclude the corresponding element from any\ncomputation.\nConstruction::\nx = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\nndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\nshrink=True, order=None)",
        "parameters": {
          "data": {
            "type": "array_like",
            "description": "Input data."
          },
          "mask": {
            "type": "sequence, optional",
            "description": "Mask. Must be convertible to an array of booleans with the same\nshape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Data type of the output.\nIf `dtype` is None, the type of the data argument (``data.dtype``)\nis used. If `dtype` is not None and different from ``data.dtype``,\na copy is performed."
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to copy the input data (True), or to use a reference instead.\nDefault is False."
          },
          "subok": {
            "type": "bool, optional",
            "description": "Whether to return a subclass of `MaskedArray` if possible (True) or a\nplain `MaskedArray`. Default is True."
          },
          "ndmin": {
            "type": "int, optional",
            "description": "Minimum number of dimensions. Default is 0."
          },
          "fill_value": {
            "type": "scalar, optional",
            "description": "Value used to fill in the masked values when necessary.\nIf None, a default based on the data-type is used."
          },
          "keep_mask": {
            "type": "bool, optional",
            "description": "Whether to combine `mask` with the mask of the input data, if any\n(True), or to use only `mask` for the output (False). Default is True."
          },
          "hard_mask": {
            "type": "bool, optional",
            "description": "Whether to use a hard mask or not. With a hard mask, masked values\ncannot be unmasked. Default is False."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to force compression of an empty mask. Default is True."
          },
          "order": {
            "type": "{'C', 'F', 'A'}, optional",
            "description": "Specify the order of the array.  If order is 'C', then the array\nwill be in C-contiguous order (last-index varies the fastest).\nIf order is 'F', then the returned array will be in\nFortran-contiguous order (first-index varies the fastest).\nIf order is 'A' (default), then the returned array may be\nin any order (either C-, Fortran-contiguous, or even discontiguous),\nunless a copy is required, in which case it will be C-contiguous."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\nThe ``mask`` can be initialized with an array of boolean values\nwith the same shape as ``data``.\n>>> data = np.arange(6).reshape((2, 3))\n>>> np.ma.MaskedArray(data, mask=[[False, True, False],\n...                               [False, False, True]])\nmasked_array(\ndata=[[0, --, 2],\n[3, 4, --]],\nmask=[[False,  True, False],\n[False, False,  True]],\nfill_value=999999)\nAlternatively, the ``mask`` can be initialized to homogeneous boolean\narray with the same shape as ``data`` by passing in a scalar\nboolean value:\n>>> np.ma.MaskedArray(data, mask=False)\nmasked_array(\ndata=[[0, 1, 2],\n[3, 4, 5]],\nmask=[[False, False, False],\n[False, False, False]],\nfill_value=999999)\n>>> np.ma.MaskedArray(data, mask=True)\nmasked_array(\ndata=[[--, --, --],\n[--, --, --]],\nmask=[[ True,  True,  True],\n[ True,  True,  True]],\nfill_value=999999,\ndtype=int64)\n.. note::\nThe recommended practice for initializing ``mask`` with a scalar\nboolean value is to use ``True``/``False`` rather than\n``np.True_``/``np.False_``. The reason is :attr:`nomask`\nis represented internally as ``np.False_``.\n>>> np.False_ is np.ma.nomask\nTrue"
      }
    },
    {
      "name": "asanyarray",
      "signature": "asanyarray(a, dtype=None)",
      "documentation": {
        "description": "Convert the input to a masked array, conserving subclasses.\nIf `a` is a subclass of `MaskedArray`, its class is conserved.\nNo copy is performed if the input is already an `ndarray`.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input data, in any form that can be converted to an array."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "By default, the data-type is inferred from the input data."
          },
          "order": {
            "type": "{'C', 'F'}, optional",
            "description": "Whether to use row-major ('C') or column-major ('FORTRAN') memory\nrepresentation.  Default is 'C'."
          }
        },
        "returns": "-------\nout : MaskedArray\nMaskedArray interpretation of `a`.",
        "raises": "",
        "see_also": "--------\nasarray : Similar to `asanyarray`, but does not conserve subclass.",
        "notes": "",
        "examples": "--------\n>>> x = np.arange(10.).reshape(2, 5)\n>>> x\narray([[0., 1., 2., 3., 4.],\n[5., 6., 7., 8., 9.]])\n>>> np.ma.asanyarray(x)\nmasked_array(\ndata=[[0., 1., 2., 3., 4.],\n[5., 6., 7., 8., 9.]],\nmask=False,\nfill_value=1e+20)\n>>> type(np.ma.asanyarray(x))\n<class 'numpy.ma.core.MaskedArray'>"
      }
    },
    {
      "name": "asarray",
      "signature": "asarray(a, dtype=None, order=None)",
      "documentation": {
        "description": "Convert the input to a masked array of the given data-type.\nNo copy is performed if the input is already an `ndarray`. If `a` is\na subclass of `MaskedArray`, a base class `MaskedArray` is returned.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input data, in any form that can be converted to a masked array. This\nincludes lists, lists of tuples, tuples, tuples of tuples, tuples\nof lists, ndarrays and masked arrays."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "By default, the data-type is inferred from the input data."
          },
          "order": {
            "type": "{'C', 'F'}, optional",
            "description": "Whether to use row-major ('C') or column-major ('FORTRAN') memory\nrepresentation.  Default is 'C'."
          }
        },
        "returns": "-------\nout : MaskedArray\nMasked array interpretation of `a`.",
        "raises": "",
        "see_also": "--------\nasanyarray : Similar to `asarray`, but conserves subclasses.",
        "notes": "",
        "examples": "--------\n>>> x = np.arange(10.).reshape(2, 5)\n>>> x\narray([[0., 1., 2., 3., 4.],\n[5., 6., 7., 8., 9.]])\n>>> np.ma.asarray(x)\nmasked_array(\ndata=[[0., 1., 2., 3., 4.],\n[5., 6., 7., 8., 9.]],\nmask=False,\nfill_value=1e+20)\n>>> type(np.ma.asarray(x))\n<class 'numpy.ma.core.MaskedArray'>"
      }
    },
    {
      "name": "atleast_1d",
      "signature": "atleast_1d(*args, **params)",
      "documentation": {
        "description": "atleast_1d\nConvert inputs to arrays with at least one dimension.\nScalar inputs are converted to 1-dimensional arrays, whilst\nhigher-dimensional inputs are preserved.",
        "parameters": {},
        "returns": "-------\nret : ndarray\nAn array, or list of arrays, each with ``a.ndim >= 1``.\nCopies are made only if necessary.",
        "raises": "",
        "see_also": "--------\natleast_2d, atleast_3d",
        "notes": "-----\nThe function is applied to both the _data and the _mask, if any.",
        "examples": "--------\n>>> np.atleast_1d(1.0)\narray([1.])\n>>> x = np.arange(9.0).reshape(3,3)\n>>> np.atleast_1d(x)\narray([[0., 1., 2.],\n[3., 4., 5.],\n[6., 7., 8.]])\n>>> np.atleast_1d(x) is x\nTrue\n>>> np.atleast_1d(1, [3, 4])\n[array([1]), array([3, 4])]"
      }
    },
    {
      "name": "atleast_2d",
      "signature": "atleast_2d(*args, **params)",
      "documentation": {
        "description": "atleast_2d\nView inputs as arrays with at least two dimensions.",
        "parameters": {},
        "returns": "-------\nres, res2, ... : ndarray\nAn array, or list of arrays, each with ``a.ndim >= 2``.\nCopies are avoided where possible, and views with two or more\ndimensions are returned.",
        "raises": "",
        "see_also": "--------\natleast_1d, atleast_3d",
        "notes": "-----\nThe function is applied to both the _data and the _mask, if any.",
        "examples": "--------\n>>> np.atleast_2d(3.0)\narray([[3.]])\n>>> x = np.arange(3.0)\n>>> np.atleast_2d(x)\narray([[0., 1., 2.]])\n>>> np.atleast_2d(x).base is x\nTrue\n>>> np.atleast_2d(1, [1, 2], [[1, 2]])\n[array([[1]]), array([[1, 2]]), array([[1, 2]])]"
      }
    },
    {
      "name": "atleast_3d",
      "signature": "atleast_3d(*args, **params)",
      "documentation": {
        "description": "atleast_3d\nView inputs as arrays with at least three dimensions.",
        "parameters": {},
        "returns": "-------\nres1, res2, ... : ndarray\nAn array, or list of arrays, each with ``a.ndim >= 3``.  Copies are\navoided where possible, and views with three or more dimensions are\nreturned.  For example, a 1-D array of shape ``(N,)`` becomes a view\nof shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a\nview of shape ``(M, N, 1)``.",
        "raises": "",
        "see_also": "--------\natleast_1d, atleast_2d",
        "notes": "-----\nThe function is applied to both the _data and the _mask, if any.",
        "examples": "--------\n>>> np.atleast_3d(3.0)\narray([[[3.]]])\n>>> x = np.arange(3.0)\n>>> np.atleast_3d(x).shape\n(1, 3, 1)\n>>> x = np.arange(12.0).reshape(4,3)\n>>> np.atleast_3d(x).shape\n(4, 3, 1)\n>>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself\nTrue\n>>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n...     print(arr, arr.shape) # doctest: +SKIP\n...\n[[[1]\n[2]]] (1, 2, 1)\n[[[1]\n[2]]] (1, 2, 1)\n[[[1 2]]] (1, 1, 2)"
      }
    },
    {
      "name": "average",
      "signature": "average(a, axis=None, weights=None, returned=False, *, keepdims=<no value>)",
      "documentation": {
        "description": "Return the weighted average of array over the given axis.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Data to be averaged.\nMasked entries are not taken into account in the computation."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to average `a`. If None, averaging is done over\nthe flattened array."
          },
          "weights": {
            "type": "array_like, optional",
            "description": "The importance that each element has in the computation of the average.\nThe weights array can either be 1-D (in which case its length must be\nthe size of `a` along the given axis) or of the same shape as `a`.\nIf ``weights=None``, then all data in `a` are assumed to have a\nweight equal to one.  The 1-D calculation is::\navg = sum(a * weights) / sum(weights)\nThe only constraint on `weights` is that `sum(weights)` must not be 0."
          },
          "returned": {
            "type": "bool, optional",
            "description": "Flag indicating whether a tuple ``(result, sum of weights)``\nshould be returned as output (True), or just the result (False).\nDefault is False."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the original `a`.\n*Note:* `keepdims` will not work with instances of `numpy.matrix`\nor other classes whose methods do not support `keepdims`.\n.. versionadded:: 1.23.0"
          }
        },
        "returns": "-------\naverage, [sum_of_weights] : (tuple of) scalar or MaskedArray\nThe average along the specified axis. When returned is `True`,\nreturn a tuple with the average as the first element and the sum\nof the weights as the second element. The return type is `np.float64`\nif `a` is of integer type and floats smaller than `float64`, or the\ninput data-type, otherwise. If returned, `sum_of_weights` is always\n`float64`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])\n>>> np.ma.average(a, weights=[3, 1, 0, 0])\n1.25\n>>> x = np.ma.arange(6.).reshape(3, 2)\n>>> x\nmasked_array(\ndata=[[0., 1.],\n[2., 3.],\n[4., 5.]],\nmask=False,\nfill_value=1e+20)\n>>> avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],\n...                                 returned=True)\n>>> avg\nmasked_array(data=[2.6666666666666665, 3.6666666666666665],\nmask=[False, False],\nfill_value=1e+20)\nWith ``keepdims=True``, the following result has shape (3, 1).\n>>> np.ma.average(x, axis=1, keepdims=True)\nmasked_array(\ndata=[[0.5],\n[2.5],\n[4.5]],\nmask=False,\nfill_value=1e+20)"
      }
    },
    {
      "name": "bitwise_and",
      "signature": "bitwise_and(a, b, *args, **kwargs)",
      "documentation": {
        "description": "bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCompute the bit-wise AND of two arrays element-wise.\nComputes the bit-wise AND of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``&``.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : ndarray or scalar\nResult.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nlogical_and\nbitwise_or\nbitwise_xor\nbinary_repr :\nReturn the binary representation of the input number as a string.",
        "notes": "",
        "examples": "--------\nThe number 13 is represented by ``00001101``.  Likewise, 17 is\nrepresented by ``00010001``.  The bit-wise AND of 13 and 17 is\ntherefore ``000000001``, or 1:\n>>> np.bitwise_and(13, 17)\n1\n>>> np.bitwise_and(14, 13)\n12\n>>> np.binary_repr(12)\n'1100'\n>>> np.bitwise_and([14,3], 13)\narray([12,  1])\n>>> np.bitwise_and([11,7], [4,25])\narray([0, 1])\n>>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))\narray([ 2,  4, 16])\n>>> np.bitwise_and([True, True], [False, True])\narray([False,  True])\nThe ``&`` operator can be used as a shorthand for ``np.bitwise_and`` on\nndarrays.\n>>> x1 = np.array([2, 5, 255])\n>>> x2 = np.array([3, 14, 16])\n>>> x1 & x2\narray([ 2,  4, 16])"
      }
    },
    {
      "name": "bitwise_or",
      "signature": "bitwise_or(a, b, *args, **kwargs)",
      "documentation": {
        "description": "bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCompute the bit-wise OR of two arrays element-wise.\nComputes the bit-wise OR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``|``.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : ndarray or scalar\nResult.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nlogical_or\nbitwise_and\nbitwise_xor\nbinary_repr :\nReturn the binary representation of the input number as a string.",
        "notes": "",
        "examples": "--------\nThe number 13 has the binary representation ``00001101``. Likewise,\n16 is represented by ``00010000``.  The bit-wise OR of 13 and 16 is\nthen ``00011101``, or 29:\n>>> np.bitwise_or(13, 16)\n29\n>>> np.binary_repr(29)\n'11101'\n>>> np.bitwise_or(32, 2)\n34\n>>> np.bitwise_or([33, 4], 1)\narray([33,  5])\n>>> np.bitwise_or([33, 4], [1, 2])\narray([33,  6])\n>>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))\narray([  6,   5, 255])\n>>> np.array([2, 5, 255]) | np.array([4, 4, 4])\narray([  6,   5, 255])\n>>> np.bitwise_or(np.array([2, 5, 255, 2147483647], dtype=np.int32),\n...               np.array([4, 4, 4, 2147483647], dtype=np.int32))\narray([         6,          5,        255, 2147483647])\n>>> np.bitwise_or([True, True], [False, True])\narray([ True,  True])\nThe ``|`` operator can be used as a shorthand for ``np.bitwise_or`` on\nndarrays.\n>>> x1 = np.array([2, 5, 255])\n>>> x2 = np.array([4, 4, 4])\n>>> x1 | x2\narray([  6,   5, 255])"
      }
    },
    {
      "name": "bitwise_xor",
      "signature": "bitwise_xor(a, b, *args, **kwargs)",
      "documentation": {
        "description": "bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCompute the bit-wise XOR of two arrays element-wise.\nComputes the bit-wise XOR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``^``.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : ndarray or scalar\nResult.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nlogical_xor\nbitwise_and\nbitwise_or\nbinary_repr :\nReturn the binary representation of the input number as a string.",
        "notes": "",
        "examples": "--------\nThe number 13 is represented by ``00001101``. Likewise, 17 is\nrepresented by ``00010001``.  The bit-wise XOR of 13 and 17 is\ntherefore ``00011100``, or 28:\n>>> np.bitwise_xor(13, 17)\n28\n>>> np.binary_repr(28)\n'11100'\n>>> np.bitwise_xor(31, 5)\n26\n>>> np.bitwise_xor([31,3], 5)\narray([26,  6])\n>>> np.bitwise_xor([31,3], [5,6])\narray([26,  5])\n>>> np.bitwise_xor([True, True], [False, True])\narray([ True, False])\nThe ``^`` operator can be used as a shorthand for ``np.bitwise_xor`` on\nndarrays.\n>>> x1 = np.array([True, True])\n>>> x2 = np.array([False, True])\n>>> x1 ^ x2\narray([ True, False])"
      }
    },
    {
      "name": "ceil",
      "signature": "ceil(a, *args, **kwargs)",
      "documentation": {
        "description": "ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nReturn the ceiling of the input, element-wise.\nThe ceil of the scalar `x` is the smallest integer `i`, such that\n``i >= x``.  It is often denoted as :math:`\\lceil x \\rceil`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input data."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray or scalar\nThe ceiling of each element in `x`, with `float` dtype.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\nfloor, trunc, rint, fix",
        "notes": "",
        "examples": "--------\n>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.ceil(a)\narray([-1., -1., -0.,  1.,  2.,  2.,  2.])"
      }
    },
    {
      "name": "choose",
      "signature": "choose(indices, choices, out=None, mode='raise')",
      "documentation": {
        "description": "Use an index array to construct a new array from a list of choices.\nGiven an array of integers and a list of n choice arrays, this method\nwill create a new array that merges each of the choice arrays.  Where a\nvalue in `index` is i, the new array will have the value that choices[i]\ncontains in the same place.",
        "parameters": {
          "indices": {
            "type": "ndarray of ints",
            "description": "This array must contain integers in ``[0, n-1]``, where n is the\nnumber of choices."
          },
          "choices": {
            "type": "sequence of arrays",
            "description": "Choice arrays. The index array and all of the choices should be\nbroadcastable to the same shape."
          },
          "out": {
            "type": "array, optional",
            "description": "If provided, the result will be inserted into this array. It should\nbe of the appropriate shape and `dtype`."
          },
          "mode": {
            "type": "{'raise', 'wrap', 'clip'}, optional",
            "description": "Specifies how out-of-bounds indices will behave.\n* 'raise' : raise an error\n* 'wrap' : wrap around\n* 'clip' : clip to the range"
          }
        },
        "returns": "-------\nmerged_array : array",
        "raises": "",
        "see_also": "--------\nchoose : equivalent function",
        "notes": "",
        "examples": "--------\n>>> choice = np.array([[1,1,1], [2,2,2], [3,3,3]])\n>>> a = np.array([2, 1, 0])\n>>> np.ma.choose(a, choice)\nmasked_array(data=[3, 2, 1],\nmask=False,\nfill_value=999999)"
      }
    },
    {
      "name": "clump_masked",
      "signature": "clump_masked(a)",
      "documentation": {
        "description": "",
        "parameters": {
          "a": {
            "type": "ndarray",
            "description": "A one-dimensional masked array."
          }
        },
        "returns": "(A \"clump\" is defined as a contiguous region of the array).\n-------\nslices : list of slice\nThe list of slices, one for each continuous region of masked elements\nin `a`.",
        "raises": "",
        "see_also": "--------\nflatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges\nnotmasked_contiguous, clump_unmasked",
        "notes": "-----\n.. versionadded:: 1.4.0",
        "examples": "--------\n>>> a = np.ma.masked_array(np.arange(10))\n>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n>>> np.ma.clump_masked(a)\n[slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]"
      }
    },
    {
      "name": "clump_unmasked",
      "signature": "clump_unmasked(a)",
      "documentation": {
        "description": "Return list of slices corresponding to the unmasked clumps of a 1-D array.\n(A \"clump\" is defined as a contiguous region of the array).",
        "parameters": {
          "a": {
            "type": "ndarray",
            "description": "A one-dimensional masked array."
          }
        },
        "returns": "-------\nslices : list of slice\nThe list of slices, one for each continuous region of unmasked\nelements in `a`.",
        "raises": "",
        "see_also": "--------\nflatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges\nnotmasked_contiguous, clump_masked",
        "notes": "-----\n.. versionadded:: 1.4.0",
        "examples": "--------\n>>> a = np.ma.masked_array(np.arange(10))\n>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n>>> np.ma.clump_unmasked(a)\n[slice(3, 6, None), slice(7, 8, None)]"
      }
    },
    {
      "name": "column_stack",
      "signature": "column_stack(x, *args, **params)",
      "documentation": {
        "description": "column_stack\nStack 1-D arrays as columns into a 2-D array.\nTake a sequence of 1-D arrays and stack them as columns\nto make a single 2-D array. 2-D arrays are stacked as-is,\njust like with `hstack`.  1-D arrays are turned into 2-D columns\nfirst.",
        "parameters": {
          "tup": {
            "type": "sequence of 1-D or 2-D arrays.",
            "description": "Arrays to stack. All of them must have the same first dimension."
          }
        },
        "returns": "-------\nstacked : 2-D array\nThe array formed by stacking the given arrays.",
        "raises": "",
        "see_also": "--------\nstack, hstack, vstack, concatenate",
        "notes": "-----\nThe function is applied to both the _data and the _mask, if any.",
        "examples": "--------\n>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.column_stack((a,b))\narray([[1, 2],\n[2, 3],\n[3, 4]])"
      }
    },
    {
      "name": "common_fill_value",
      "signature": "common_fill_value(a, b)",
      "documentation": {
        "description": "Return the common filling value of two masked arrays, if any.\nIf ``a.fill_value == b.fill_value``, return the fill value,\notherwise return None.",
        "parameters": {},
        "returns": "-------\nfill_value : scalar or None\nThe common fill value, or None.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> x = np.ma.array([0, 1.], fill_value=3)\n>>> y = np.ma.array([0, 1.], fill_value=3)\n>>> np.ma.common_fill_value(x, y)\n3.0"
      }
    },
    {
      "name": "compress",
      "signature": "compress(a, *args, **params)",
      "documentation": {
        "description": "compress(self, condition, axis=None, out=None)\nReturn `a` where condition is ``True``.\nIf condition is a `~ma.MaskedArray`, missing values are considered\nas ``False``.",
        "parameters": {
          "condition": {
            "type": "var",
            "description": "Boolean 1-d array selecting which entries to return. If len(condition)\nis less than the size of a along the axis, then output is truncated\nto length of condition array."
          },
          "axis": {
            "type": "{None, int}, optional",
            "description": "Axis along which the operation must be performed."
          },
          "out": {
            "type": "{None, ndarray}, optional",
            "description": "Alternative output array in which to place the result. It must have\nthe same shape as the expected output but the type will be cast if\nnecessary."
          }
        },
        "returns": "-------\nresult : MaskedArray\nA :class:`~ma.MaskedArray` object.",
        "raises": "",
        "see_also": "",
        "notes": "-----\nPlease note the difference with :meth:`compressed` !\nThe output of :meth:`compress` has a mask, the output of\n:meth:`compressed` does not.",
        "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\nmask=[False, False],\nfill_value=999999)\n>>> x.compress([1, 0, 1], axis=1)\nmasked_array(\ndata=[[1, 3],\n[--, --],\n[7, 9]],\nmask=[[False, False],\n[ True,  True],\n[False, False]],\nfill_value=999999)"
      }
    },
    {
      "name": "compress_cols",
      "signature": "compress_cols(a)",
      "documentation": {
        "description": "Suppress whole columns of a 2-D array that contain masked values.\nThis is equivalent to ``np.ma.compress_rowcols(a, 1)``, see\n`compress_rowcols` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\ncompress_rowcols",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compress_nd",
      "signature": "compress_nd(x, axis=None)",
      "documentation": {
        "description": "Suppress slices from multiple dimensions which contain masked values.",
        "parameters": {
          "x": {
            "type": "array_like, MaskedArray",
            "description": "The array to operate on. If not a MaskedArray instance (or if no array\nelements are masked), `x` is interpreted as a MaskedArray with `mask`\nset to `nomask`."
          },
          "axis": {
            "type": "tuple of ints or int, optional",
            "description": "Which dimensions to suppress slices from can be configured with this\nparameter.\n- If axis is a tuple of ints, those are the axes to suppress slices from.\n- If axis is an int, then that is the only axis to suppress slices from.\n- If axis is None, all axis are selected."
          }
        },
        "returns": "-------\ncompress_array : ndarray\nThe compressed array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compress_rowcols",
      "signature": "compress_rowcols(x, axis=None)",
      "documentation": {
        "description": "Suppress the rows and/or columns of a 2-D array that contain\nmasked values.\nThe suppression behavior is selected with the `axis` parameter.\n- If axis is None, both rows and columns are suppressed.\n- If axis is 0, only rows are suppressed.\n- If axis is 1 or -1, only columns are suppressed.",
        "parameters": {
          "x": {
            "type": "array_like, MaskedArray",
            "description": "The array to operate on.  If not a MaskedArray instance (or if no array\nelements are masked), `x` is interpreted as a MaskedArray with\n`mask` set to `nomask`. Must be a 2D array."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to perform the operation. Default is None."
          }
        },
        "returns": "-------\ncompressed_array : ndarray\nThe compressed array.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n>>> x\nmasked_array(\ndata=[[--, 1, 2],\n[--, 4, 5],\n[6, 7, 8]],\nmask=[[ True, False, False],\n[ True, False, False],\n[False, False, False]],\nfill_value=999999)\n>>> np.ma.compress_rowcols(x)\narray([[7, 8]])\n>>> np.ma.compress_rowcols(x, 0)\narray([[6, 7, 8]])\n>>> np.ma.compress_rowcols(x, 1)\narray([[1, 2],\n[4, 5],\n[7, 8]])"
      }
    },
    {
      "name": "compress_rows",
      "signature": "compress_rows(a)",
      "documentation": {
        "description": "Suppress whole rows of a 2-D array that contain masked values.\nThis is equivalent to ``np.ma.compress_rowcols(a, 0)``, see\n`compress_rowcols` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\ncompress_rowcols",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compressed",
      "signature": "compressed(x)",
      "documentation": {
        "description": "Return all the non-masked data as a 1-D array.\nThis function is equivalent to calling the \"compressed\" method of a\n`ma.MaskedArray`, see `ma.MaskedArray.compressed` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nma.MaskedArray.compressed : Equivalent method.",
        "notes": "",
        "examples": "--------\nCreate an array with negative values masked:\n>>> import numpy as np\n>>> x = np.array([[1, -1, 0], [2, -1, 3], [7, 4, -1]])\n>>> masked_x = np.ma.masked_array(x, mask=x < 0)\n>>> masked_x\nmasked_array(\ndata=[[1, --, 0],\n[2, --, 3],\n[7, 4, --]],\nmask=[[False,  True, False],\n[False,  True, False],\n[False, False,  True]],\nfill_value=999999)\nCompress the masked array into a 1-D array of non-masked values:\n>>> np.ma.compressed(masked_x)\narray([1, 0, 2, 3, 7, 4])"
      }
    },
    {
      "name": "concatenate",
      "signature": "concatenate(arrays, axis=0)",
      "documentation": {
        "description": "Concatenate a sequence of arrays along the given axis.",
        "parameters": {
          "arrays": {
            "type": "sequence of array_like",
            "description": "The arrays must have the same shape, except in the dimension\ncorresponding to `axis` (the first, by default)."
          },
          "axis": {
            "type": "int, optional",
            "description": "The axis along which the arrays will be joined. Default is 0."
          }
        },
        "returns": "-------\nresult : MaskedArray\nThe concatenated array with any masked entries preserved.",
        "raises": "",
        "see_also": "--------\nnumpy.concatenate : Equivalent function in the top-level NumPy module.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = ma.arange(3)\n>>> a[1] = ma.masked\n>>> b = ma.arange(2, 5)\n>>> a\nmasked_array(data=[0, --, 2],\nmask=[False,  True, False],\nfill_value=999999)\n>>> b\nmasked_array(data=[2, 3, 4],\nmask=False,\nfill_value=999999)\n>>> ma.concatenate([a, b])\nmasked_array(data=[0, --, 2, 2, 3, 4],\nmask=[False,  True, False, False, False, False],\nfill_value=999999)"
      }
    },
    {
      "name": "conjugate",
      "signature": "conjugate(a, *args, **kwargs)",
      "documentation": {
        "description": "conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nReturn the complex conjugate, element-wise.\nThe complex conjugate of a complex number is obtained by changing the\nsign of its imaginary part.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input value."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray\nThe complex conjugate of `x`, with same dtype as `y`.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "-----\n`conj` is an alias for `conjugate`:\n>>> np.conj is np.conjugate\nTrue",
        "examples": "--------\n>>> np.conjugate(1+2j)\n(1-2j)\n>>> x = np.eye(2) + 1j * np.eye(2)\n>>> np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n[ 0.-0.j,  1.-1.j]])"
      }
    },
    {
      "name": "convolve",
      "signature": "convolve(a, v, mode='full', propagate_mask=True)",
      "documentation": {
        "description": "",
        "parameters": {
          "mode": {
            "type": "{'valid', 'same', 'full'}, optional",
            "description": "Refer to the `np.convolve` docstring."
          },
          "propagate_mask": {
            "type": "bool",
            "description": "If True, then if any masked element is included in the sum for a result\nelement, then the result is masked.\nIf False, then the result element is only masked if no non-masked cells\ncontribute towards it"
          }
        },
        "returns": "-------\nout : MaskedArray\nDiscrete, linear convolution of `a` and `v`.",
        "raises": "",
        "see_also": "--------\nnumpy.convolve : Equivalent function in the top-level NumPy module.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "copy",
      "signature": "copy(a, *args, **params)",
      "documentation": {
        "description": "copy(self, *args, **params)\na.copy(order='C')\nReturn a copy of the array.",
        "parameters": {
          "order": {
            "type": "{'C', 'F', 'A', 'K'}, optional",
            "description": "Controls the memory layout of the copy. 'C' means C-order,\n'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n'C' otherwise. 'K' means match the layout of `a` as closely\nas possible. (Note that this function and :func:`numpy.copy` are very\nsimilar but have different default values for their order=\narguments, and this function always passes sub-classes through.)\nSee also\n--------"
          },
          "numpy.copy": {
            "type": "Similar function with different default behavior",
            "description": "numpy.copyto"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "-----\nThis function is the preferred method for creating an array copy.  The\nfunction :func:`numpy.copy` is similar, but it defaults to using order 'K',\nand will not pass sub-classes through by default.",
        "examples": "--------\n>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n>>> y = x.copy()\n>>> x.fill(0)\n>>> x\narray([[0, 0, 0],\n[0, 0, 0]])\n>>> y\narray([[1, 2, 3],\n[4, 5, 6]])\n>>> y.flags['C_CONTIGUOUS']\nTrue"
      }
    },
    {
      "name": "corrcoef",
      "signature": "corrcoef(x, y=None, rowvar=True, bias=<no value>, allow_masked=True, ddof=<no value>)",
      "documentation": {
        "description": "Return Pearson product-moment correlation coefficients.\nExcept for the handling of missing data this function does the same as\n`numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "A 1-D or 2-D array containing multiple variables and observations.\nEach row of `x` represents a variable, and each column a single\nobservation of all those variables. Also see `rowvar` below."
          },
          "y": {
            "type": "array_like, optional",
            "description": "An additional set of variables and observations. `y` has the same\nshape as `x`."
          },
          "rowvar": {
            "type": "bool, optional",
            "description": "If `rowvar` is True (default), then each row represents a\nvariable, with observations in the columns. Otherwise, the relationship\nis transposed: each column represents a variable, while the rows\ncontain observations."
          },
          "bias": {
            "type": "_NoValue, optional",
            "description": "Has no effect, do not use.\n.. deprecated:: 1.10.0"
          },
          "allow_masked": {
            "type": "bool, optional",
            "description": "If True, masked values are propagated pair-wise: if a value is masked\nin `x`, the corresponding value is masked in `y`.\nIf False, raises an exception.  Because `bias` is deprecated, this\nargument needs to be treated as keyword only to avoid a warning."
          },
          "ddof": {
            "type": "_NoValue, optional",
            "description": "Has no effect, do not use.\n.. deprecated:: 1.10.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.corrcoef : Equivalent function in top-level NumPy module.\ncov : Estimate the covariance matrix.",
        "notes": "-----\nThis function accepts but discards arguments `bias` and `ddof`.  This is\nfor backwards compatibility with previous versions of this function.  These\narguments had no effect on the return values of the function and can be\nsafely ignored in this and previous versions of numpy.",
        "examples": ""
      }
    },
    {
      "name": "correlate",
      "signature": "correlate(a, v, mode='valid', propagate_mask=True)",
      "documentation": {
        "description": "Cross-correlation of two 1-dimensional sequences.",
        "parameters": {
          "mode": {
            "type": "{'valid', 'same', 'full'}, optional",
            "description": "Refer to the `np.convolve` docstring.  Note that the default\nis 'valid', unlike `convolve`, which uses 'full'."
          },
          "propagate_mask": {
            "type": "bool",
            "description": "If True, then a result element is masked if any masked element contributes towards it.\nIf False, then a result element is only masked if no non-masked element\ncontribute towards it"
          }
        },
        "returns": "-------\nout : MaskedArray\nDiscrete cross-correlation of `a` and `v`.",
        "raises": "",
        "see_also": "--------\nnumpy.correlate : Equivalent function in the top-level NumPy module.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cos",
      "signature": "cos(a, *args, **kwargs)",
      "documentation": {
        "description": "cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCosine element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array in radians."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray\nThe corresponding cosine values.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "-----\nIf `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\nReferences\n----------\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972.",
        "examples": "--------\n>>> np.cos(np.array([0, np.pi/2, np.pi]))\narray([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])\n>>>\n>>> # Example of providing the optional output parameter\n>>> out1 = np.array([0], dtype='d')\n>>> out2 = np.cos([0.1], out1)\n>>> out2 is out1\nTrue\n>>>\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)"
      }
    },
    {
      "name": "cosh",
      "signature": "cosh(a, *args, **kwargs)",
      "documentation": {
        "description": "cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nHyperbolic cosine, element-wise.\nEquivalent to ``1/2 * (np.exp(x) + np.exp(-x))`` and ``np.cos(1j*x)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : ndarray or scalar\nOutput array of same shape as `x`.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> np.cosh(0)\n1.0\nThe hyperbolic cosine describes the shape of a hanging cable:\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-4, 4, 1000)\n>>> plt.plot(x, np.cosh(x))\n>>> plt.show()"
      }
    },
    {
      "name": "count",
      "signature": "count(a, *args, **params)",
      "documentation": {
        "description": "count(self, axis=None, keepdims=<no value>)\nCount the non-masked elements of the array along the given axis.",
        "parameters": {
          "axis": {
            "type": "None or int or tuple of ints, optional",
            "description": "Axis or axes along which the count is performed.\nThe default, None, performs the count over all\nthe dimensions of the input array. `axis` may be negative, in\nwhich case it counts from the last to the first axis.\n.. versionadded:: 1.10.0\nIf this is a tuple of ints, the count is performed on multiple\naxes, instead of a single axis or all the axes as before."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
          }
        },
        "returns": "-------\nresult : ndarray or scalar\nAn array with the same shape as the input array, with the specified\naxis removed. If the array is a 0-d array, or if `axis` is None, a\nscalar is returned.",
        "raises": "",
        "see_also": "--------\nma.count_masked : Count masked elements in array or along a given axis.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(\ndata=[[0, 1, 2],\n[--, --, --]],\nmask=[[False, False, False],\n[ True,  True,  True]],\nfill_value=999999)\n>>> a.count()\n3\nWhen the `axis` keyword is specified an array of appropriate size is\nreturned.\n>>> a.count(axis=0)\narray([1, 1, 1])\n>>> a.count(axis=1)\narray([3, 0])"
      }
    },
    {
      "name": "count_masked",
      "signature": "count_masked(arr, axis=None)",
      "documentation": {
        "description": "Count the number of masked elements along the given axis.",
        "parameters": {
          "arr": {
            "type": "array_like",
            "description": "An array with (possibly) masked elements."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to count. If None (default), a flattened\nversion of the array is used."
          }
        },
        "returns": "-------\ncount : int, ndarray\nThe total number of masked elements (axis=None) or the number\nof masked elements along each slice of the given axis.",
        "raises": "",
        "see_also": "--------\nMaskedArray.count : Count non-masked elements.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.arange(9).reshape((3,3))\n>>> a = ma.array(a)\n>>> a[1, 0] = ma.masked\n>>> a[1, 2] = ma.masked\n>>> a[2, 1] = ma.masked\n>>> a\nmasked_array(\ndata=[[0, 1, 2],\n[--, 4, --],\n[6, --, 8]],\nmask=[[False, False, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> ma.count_masked(a)\n3\nWhen the `axis` keyword is used an array is returned.\n>>> ma.count_masked(a, axis=0)\narray([1, 1, 1])\n>>> ma.count_masked(a, axis=1)\narray([0, 2, 1])"
      }
    },
    {
      "name": "cov",
      "signature": "cov(x, y=None, rowvar=True, bias=False, allow_masked=True, ddof=None)",
      "documentation": {
        "description": "Estimate the covariance matrix.\nExcept for the handling of missing data this function does the same as\n`numpy.cov`. For more details and examples, see `numpy.cov`.\nBy default, masked values are recognized as such. If `x` and `y` have the\nsame shape, a common mask is allocated: if ``x[i,j]`` is masked, then\n``y[i,j]`` will also be masked.\nSetting `allow_masked` to False will raise an exception if values are\nmissing in either of the input arrays.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "A 1-D or 2-D array containing multiple variables and observations.\nEach row of `x` represents a variable, and each column a single\nobservation of all those variables. Also see `rowvar` below."
          },
          "y": {
            "type": "array_like, optional",
            "description": "An additional set of variables and observations. `y` has the same\nshape as `x`."
          },
          "rowvar": {
            "type": "bool, optional",
            "description": "If `rowvar` is True (default), then each row represents a\nvariable, with observations in the columns. Otherwise, the relationship\nis transposed: each column represents a variable, while the rows\ncontain observations."
          },
          "bias": {
            "type": "bool, optional",
            "description": "Default normalization (False) is by ``(N-1)``, where ``N`` is the\nnumber of observations given (unbiased estimate). If `bias` is True,\nthen normalization is by ``N``. This keyword can be overridden by\nthe keyword ``ddof`` in numpy versions >= 1.5."
          },
          "allow_masked": {
            "type": "bool, optional",
            "description": "If True, masked values are propagated pair-wise: if a value is masked\nin `x`, the corresponding value is masked in `y`.\nIf False, raises a `ValueError` exception when some values are missing."
          },
          "ddof": {
            "type": "{None, int}, optional",
            "description": "If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is\nthe number of observations; this overrides the value implied by\n``bias``. The default value is ``None``.\n.. versionadded:: 1.5"
          }
        },
        "returns": "",
        "raises": "------\nValueError\nRaised if some values are missing and `allow_masked` is False.",
        "see_also": "--------\nnumpy.cov",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cumprod",
      "signature": "cumprod(a, *args, **params)",
      "documentation": {
        "description": "cumprod(self, axis=None, dtype=None, out=None)\nReturn the cumulative product of the array elements over the given axis.\nMasked values are set to 1 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to `numpy.cumprod` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.ndarray.cumprod : corresponding function for ndarrays\nnumpy.cumprod : equivalent function",
        "notes": "-----\nThe mask is lost if `out` is not a valid MaskedArray !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
        "examples": ""
      }
    },
    {
      "name": "cumsum",
      "signature": "cumsum(a, *args, **params)",
      "documentation": {
        "description": "cumsum(self, axis=None, dtype=None, out=None)\nReturn the cumulative sum of the array elements over the given axis.\nMasked values are set to 0 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to `numpy.cumsum` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.ndarray.cumsum : corresponding function for ndarrays\nnumpy.cumsum : equivalent function",
        "notes": "-----\nThe mask is lost if `out` is not a valid :class:`ma.MaskedArray` !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
        "examples": "--------\n>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\nmask=[False, False, False,  True,  True,  True, False, False,\nFalse, False],\nfill_value=999999)"
      }
    },
    {
      "name": "default_fill_value",
      "signature": "default_fill_value(obj)",
      "documentation": {
        "description": "Return the default fill value for the argument object.\nThe default filling value depends on the datatype of the input\narray or the type of the input scalar:\n========  ========\ndatatype  default\n========  ========\nbool      True\nint       999999\nfloat     1.e20\ncomplex   1.e20+0j\nobject    '?'\nstring    'N/A'\n========  ========\nFor structured types, a structured scalar is returned, with each field the\ndefault fill value for its type.\nFor subarray types, the fill value is an array of the same size containing\nthe default scalar fill value.",
        "parameters": {
          "obj": {
            "type": "ndarray, dtype or scalar",
            "description": "The array data-type or scalar for which the default fill value\nis returned."
          }
        },
        "returns": "-------\nfill_value : scalar\nThe default fill value.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> np.ma.default_fill_value(1)\n999999\n>>> np.ma.default_fill_value(np.array([1.1, 2., np.pi]))\n1e+20\n>>> np.ma.default_fill_value(np.dtype(complex))\n(1e+20+0j)"
      }
    },
    {
      "name": "diag",
      "signature": "diag(v, k=0)",
      "documentation": {
        "description": "Extract a diagonal or construct a diagonal array.\nThis function is the equivalent of `numpy.diag` that takes masked\nvalues into account, see `numpy.diag` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.diag : Equivalent function for ndarrays.",
        "notes": "",
        "examples": "--------\nCreate an array with negative values masked:\n>>> import numpy as np\n>>> x = np.array([[11.2, -3.973, 18], [0.801, -1.41, 12], [7, 33, -12]])\n>>> masked_x = np.ma.masked_array(x, mask=x < 0)\n>>> masked_x\nmasked_array(\ndata=[[11.2, --, 18.0],\n[0.801, --, 12.0],\n[7.0, 33.0, --]],\nmask=[[False,  True, False],\n[False,  True, False],\n[False, False,  True]],\nfill_value=1e+20)\nIsolate the main diagonal from the masked array:\n>>> np.ma.diag(masked_x)\nmasked_array(data=[11.2, --, --],\nmask=[False,  True,  True],\nfill_value=1e+20)\nIsolate the first diagonal below the main diagonal:\n>>> np.ma.diag(masked_x, -1)\nmasked_array(data=[0.801, 33.0],\nmask=[False, False],\nfill_value=1e+20)"
      }
    },
    {
      "name": "diagflat",
      "signature": "diagflat(x, *args, **params)",
      "documentation": {
        "description": "diagflat\nCreate a two-dimensional array with the flattened input as a diagonal.",
        "parameters": {
          "v": {
            "type": "array_like",
            "description": "Input data, which is flattened and set as the `k`-th\ndiagonal of the output."
          },
          "k": {
            "type": "int, optional",
            "description": "Diagonal to set; 0, the default, corresponds to the \"main\" diagonal,\na positive (negative) `k` giving the number of the diagonal above\n(below) the main."
          }
        },
        "returns": "-------\nout : ndarray\nThe 2-D output array.",
        "raises": "",
        "see_also": "--------\ndiag : MATLAB work-alike for 1-D and 2-D arrays.\ndiagonal : Return specified diagonals.\ntrace : Sum along diagonals.",
        "notes": "-----\nThe function is applied to both the _data and the _mask, if any.",
        "examples": "--------\n>>> np.diagflat([[1,2], [3,4]])\narray([[1, 0, 0, 0],\n[0, 2, 0, 0],\n[0, 0, 3, 0],\n[0, 0, 0, 4]])\n>>> np.diagflat([1,2], 1)\narray([[0, 1, 0],\n[0, 0, 2],\n[0, 0, 0]])"
      }
    },
    {
      "name": "diagonal",
      "signature": "diagonal(a, *args, **params)",
      "documentation": {
        "description": "diagonal(self, *args, **params)\na.diagonal(offset=0, axis1=0, axis2=1)\nReturn specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\nRefer to :func:`numpy.diagonal` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.diagonal : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "diff",
      "signature": "diff(a, /, n=1, axis=-1, prepend=<no value>, append=<no value>)",
      "documentation": {
        "description": "Calculate the n-th discrete difference along the given axis.\nThe first difference is given by ``out[i] = a[i+1] - a[i]`` along\nthe given axis, higher differences are calculated by using `diff`\nrecursively.\nPreserves the input mask.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array"
          },
          "n": {
            "type": "int, optional",
            "description": "The number of times values are differenced. If zero, the input\nis returned as-is."
          },
          "axis": {
            "type": "int, optional",
            "description": "The axis along which the difference is taken, default is the\nlast axis.\nprepend, append : array_like, optional\nValues to prepend or append to `a` along axis prior to\nperforming the difference.  Scalar values are expanded to\narrays with length 1 in the direction of axis and the shape\nof the input array in along all other axes.  Otherwise the\ndimension and shape must match `a` except along axis."
          }
        },
        "returns": "-------\ndiff : MaskedArray\nThe n-th differences. The shape of the output is the same as `a`\nexcept along `axis` where the dimension is smaller by `n`. The\ntype of the output is the same as the type of the difference\nbetween any two elements of `a`. This is the same as the type of\n`a` in most cases. A notable exception is `datetime64`, which\nresults in a `timedelta64` output array.",
        "raises": "",
        "see_also": "--------\nnumpy.diff : Equivalent function in the top-level NumPy module.",
        "notes": "-----\nType is preserved for boolean arrays, so the result will contain\n`False` when consecutive elements are the same and `True` when they\ndiffer.\nFor unsigned integer arrays, the results will also be unsigned. This\nshould not be surprising, as the result is consistent with\ncalculating the difference directly:\n>>> u8_arr = np.array([1, 0], dtype=np.uint8)\n>>> np.ma.diff(u8_arr)\nmasked_array(data=[255],\nmask=False,\nfill_value=999999,\ndtype=uint8)\n>>> u8_arr[1,...] - u8_arr[0,...]\n255\nIf this is not desirable, then the array should be cast to a larger\ninteger type first:\n>>> i16_arr = u8_arr.astype(np.int16)\n>>> np.ma.diff(i16_arr)\nmasked_array(data=[-1],\nmask=False,\nfill_value=999999,\ndtype=int16)",
        "examples": "--------\n>>> a = np.array([1, 2, 3, 4, 7, 0, 2, 3])\n>>> x = np.ma.masked_where(a < 2, a)\n>>> np.ma.diff(x)\nmasked_array(data=[--, 1, 1, 3, --, --, 1],\nmask=[ True, False, False, False,  True,  True, False],\nfill_value=999999)\n>>> np.ma.diff(x, n=2)\nmasked_array(data=[--, 0, 2, --, --, --],\nmask=[ True, False, False,  True,  True,  True],\nfill_value=999999)\n>>> a = np.array([[1, 3, 1, 5, 10], [0, 1, 5, 6, 8]])\n>>> x = np.ma.masked_equal(a, value=1)\n>>> np.ma.diff(x)\nmasked_array(\ndata=[[--, --, --, 5],\n[--, --, 1, 2]],\nmask=[[ True,  True,  True, False],\n[ True,  True, False, False]],\nfill_value=1)\n>>> np.ma.diff(x, axis=0)\nmasked_array(data=[[--, --, --, 1, -2]],\nmask=[[ True,  True,  True, False, False]],\nfill_value=1)"
      }
    },
    {
      "name": "divide",
      "signature": "divide(a, b, *args, **kwargs)",
      "documentation": {
        "description": "divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nDivide arguments element-wise.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend array."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor array.\nIf ``x1.shape != x2.shape``, they must be broadcastable to a common\nshape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray or scalar\nThe quotient ``x1/x2``, element-wise.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nseterr : Set whether to raise or warn on overflow, underflow and\ndivision by zero.",
        "notes": "-----\nEquivalent to ``x1`` / ``x2`` in terms of array-broadcasting.\nThe ``true_divide(x1, x2)`` function is an alias for\n``divide(x1, x2)``.",
        "examples": "--------\n>>> np.divide(2.0, 4.0)\n0.5\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.divide(x1, x2)\narray([[nan, 1. , 1. ],\n[inf, 4. , 2.5],\n[inf, 7. , 4. ]])\nThe ``/`` operator can be used as a shorthand for ``np.divide`` on\nndarrays.\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = 2 * np.ones(3)\n>>> x1 / x2\narray([[0. , 0.5, 1. ],\n[1.5, 2. , 2.5],\n[3. , 3.5, 4. ]])"
      }
    },
    {
      "name": "dot",
      "signature": "dot(a, b, strict=False, out=None)",
      "documentation": {
        "description": "Return the dot product of two arrays.\nThis function is the equivalent of `numpy.dot` that takes masked values\ninto account. Note that `strict` and `out` are in different position\nthan in the method version. In order to maintain compatibility with the\ncorresponding method, it is recommended that the optional arguments be\ntreated as keyword only.  At some point that may be mandatory.",
        "parameters": {
          "strict": {
            "type": "bool, optional",
            "description": "Whether masked data are propagated (True) or set to 0 (False) for\nthe computation. Default is False.  Propagating the mask means that\nif a masked value appears in a row or column, the whole row or\ncolumn is considered masked."
          },
          "out": {
            "type": "masked_array, optional",
            "description": "Output argument. This must have the exact kind that would be returned\nif it was not used. In particular, it must have the right type, must be\nC-contiguous, and its dtype must be the dtype that would be returned\nfor `dot(a,b)`. This is a performance feature. Therefore, if these\nconditions are not met, an exception is raised, instead of attempting\nto be flexible.\n.. versionadded:: 1.10.2"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.dot : Equivalent function for ndarrays.",
        "notes": "",
        "examples": "--------\n>>> a = np.ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])\n>>> b = np.ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])\n>>> np.ma.dot(a, b)\nmasked_array(\ndata=[[21, 26],\n[45, 64]],\nmask=[[False, False],\n[False, False]],\nfill_value=999999)\n>>> np.ma.dot(a, b, strict=True)\nmasked_array(\ndata=[[--, --],\n[--, 64]],\nmask=[[ True,  True],\n[ True, False]],\nfill_value=999999)"
      }
    },
    {
      "name": "dstack",
      "signature": "dstack(x, *args, **params)",
      "documentation": {
        "description": "dstack\nStack arrays in sequence depth wise (along third axis).\nThis is equivalent to concatenation along the third axis after 2-D arrays\nof shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape\n`(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by\n`dsplit`.\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.",
        "parameters": {
          "tup": {
            "type": "sequence of arrays",
            "description": "The arrays must have the same shape along all but the third axis.\n1-D or 2-D arrays must have the same shape."
          }
        },
        "returns": "-------\nstacked : ndarray\nThe array formed by stacking the given arrays, will be at least 3-D.",
        "raises": "",
        "see_also": "--------\nconcatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nblock : Assemble an nd-array from nested lists of blocks.\nvstack : Stack arrays in sequence vertically (row wise).\nhstack : Stack arrays in sequence horizontally (column wise).\ncolumn_stack : Stack 1-D arrays as columns into a 2-D array.\ndsplit : Split array along third axis.",
        "notes": "-----\nThe function is applied to both the _data and the _mask, if any.",
        "examples": "--------\n>>> a = np.array((1,2,3))\n>>> b = np.array((2,3,4))\n>>> np.dstack((a,b))\narray([[[1, 2],\n[2, 3],\n[3, 4]]])\n>>> a = np.array([[1],[2],[3]])\n>>> b = np.array([[2],[3],[4]])\n>>> np.dstack((a,b))\narray([[[1, 2]],\n[[2, 3]],\n[[3, 4]]])"
      }
    },
    {
      "name": "ediff1d",
      "signature": "ediff1d(arr, to_end=None, to_begin=None)",
      "documentation": {
        "description": "Compute the differences between consecutive elements of an array.\nThis function is the equivalent of `numpy.ediff1d` that takes masked\nvalues into account, see `numpy.ediff1d` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.ediff1d : Equivalent function for ndarrays.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "equal",
      "signature": "equal(a, b, *args, **kwargs)",
      "documentation": {
        "description": "equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nReturn (x1 == x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : ndarray or scalar\nOutput array, element-wise comparison of `x1` and `x2`.\nTypically of type bool, unless ``dtype=object`` is passed.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nnot_equal, greater_equal, less_equal, greater, less",
        "notes": "",
        "examples": "--------\n>>> np.equal([0, 1, 3], np.arange(3))\narray([ True,  True, False])\nWhat is compared are values, not types. So an int (1) and an array of\nlength one can evaluate as True:\n>>> np.equal(1, np.ones(1))\narray([ True])\nThe ``==`` operator can be used as a shorthand for ``np.equal`` on\nndarrays.\n>>> a = np.array([2, 4, 6])\n>>> b = np.array([2, 4, 2])\n>>> a == b\narray([ True,  True, False])"
      }
    },
    {
      "name": "exp",
      "signature": "exp(a, *args, **kwargs)",
      "documentation": {
        "description": "exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCalculate the exponential of all elements in the input array.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input values."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : ndarray or scalar\nOutput array, element-wise exponential of `x`.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\nexpm1 : Calculate ``exp(x) - 1`` for all elements in the array.\nexp2  : Calculate ``2**x`` for all elements in the array.",
        "notes": "-----\nThe irrational number ``e`` is also known as Euler's number.  It is\napproximately 2.718281, and is the base of the natural logarithm,\n``ln`` (this means that, if :math:`x = \\ln y = \\log_e y`,\nthen :math:`e^x = y`. For real input, ``exp(x)`` is always positive.\nFor complex arguments, ``x = a + ib``, we can write\n:math:`e^x = e^a e^{ib}`.  The first term, :math:`e^a`, is already\nknown (it is the real argument, described above).  The second term,\n:math:`e^{ib}`, is :math:`\\cos b + i \\sin b`, a function with\nmagnitude 1 and a periodic phase.\nReferences\n----------\n.. [1] Wikipedia, \"Exponential function\",\nhttps://en.wikipedia.org/wiki/Exponential_function\n.. [2] M. Abramovitz and I. A. Stegun, \"Handbook of Mathematical Functions\nwith Formulas, Graphs, and Mathematical Tables,\" Dover, 1964, p. 69,\nhttps://personal.math.ubc.ca/~cbm/aands/page_69.htm",
        "examples": "--------\nPlot the magnitude and phase of ``exp(x)`` in the complex plane:\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-2*np.pi, 2*np.pi, 100)\n>>> xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane\n>>> out = np.exp(xx)\n>>> plt.subplot(121)\n>>> plt.imshow(np.abs(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')\n>>> plt.title('Magnitude of exp(x)')\n>>> plt.subplot(122)\n>>> plt.imshow(np.angle(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')\n>>> plt.title('Phase (angle) of exp(x)')\n>>> plt.show()"
      }
    },
    {
      "name": "expand_dims",
      "signature": "expand_dims(a, axis)",
      "documentation": {
        "description": "Expand the shape of an array.\nInsert a new axis that will appear at the `axis` position in the expanded\narray shape.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array."
          },
          "axis": {
            "type": "int or tuple of ints",
            "description": "Position in the expanded axes where the new axis (or axes) is placed.\n.. deprecated:: 1.13.0\nPassing an axis where ``axis > a.ndim`` will be treated as\n``axis == a.ndim``, and passing ``axis < -a.ndim - 1`` will\nbe treated as ``axis == 0``. This behavior is deprecated.\n.. versionchanged:: 1.18.0\nA tuple of axes is now supported.  Out of range axes as\ndescribed above are now forbidden and raise an `AxisError`."
          }
        },
        "returns": "-------\nresult : ndarray\nView of `a` with the number of dimensions increased.",
        "raises": "",
        "see_also": "--------\nsqueeze : The inverse operation, removing singleton dimensions\nreshape : Insert, remove, and combine dimensions, and resize existing ones\ndoc.indexing, atleast_1d, atleast_2d, atleast_3d",
        "notes": "",
        "examples": "--------\n>>> x = np.array([1, 2])\n>>> x.shape\n(2,)\nThe following is equivalent to ``x[np.newaxis, :]`` or ``x[np.newaxis]``:\n>>> y = np.expand_dims(x, axis=0)\n>>> y\narray([[1, 2]])\n>>> y.shape\n(1, 2)\nThe following is equivalent to ``x[:, np.newaxis]``:\n>>> y = np.expand_dims(x, axis=1)\n>>> y\narray([[1],\n[2]])\n>>> y.shape\n(2, 1)\n``axis`` may also be a tuple:\n>>> y = np.expand_dims(x, axis=(0, 1))\n>>> y\narray([[[1, 2]]])\n>>> y = np.expand_dims(x, axis=(2, 0))\n>>> y\narray([[[1],\n[2]]])\nNote that some examples may use ``None`` instead of ``np.newaxis``.  These\nare the same objects:\n>>> np.newaxis is None\nTrue"
      }
    },
    {
      "name": "fabs",
      "signature": "fabs(a, *args, **kwargs)",
      "documentation": {
        "description": "fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCompute the absolute values element-wise.\nThis function returns the absolute values (positive magnitude) of the\ndata in `x`. Complex values are not handled, use `absolute` to find the\nabsolute values of complex data.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "The array of numbers for which the absolute values are required. If\n`x` is a scalar, the result `y` will also be a scalar."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray or scalar\nThe absolute values of `x`, the returned values are always floats.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\nabsolute : Absolute values including `complex` types.",
        "notes": "",
        "examples": "--------\n>>> np.fabs(-1)\n1.0\n>>> np.fabs([-1.2, 1.2])\narray([ 1.2,  1.2])"
      }
    },
    {
      "name": "filled",
      "signature": "filled(a, fill_value=None)",
      "documentation": {
        "description": "Return input as an array with masked data replaced by a fill value.\nIf `a` is not a `MaskedArray`, `a` itself is returned.\nIf `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to\n``a.fill_value``.",
        "parameters": {
          "a": {
            "type": "MaskedArray or array_like",
            "description": "An input object."
          },
          "fill_value": {
            "type": "array_like, optional.",
            "description": "Can be scalar or non-scalar. If non-scalar, the\nresulting filled array should be broadcastable\nover input array. Default is None."
          }
        },
        "returns": "-------\na : ndarray\nThe filled array.",
        "raises": "",
        "see_also": "--------\ncompressed",
        "notes": "",
        "examples": "--------\n>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n>>> x.filled()\narray([[999999,      1,      2],\n[999999,      4,      5],\n[     6,      7,      8]])\n>>> x.filled(fill_value=333)\narray([[333,   1,   2],\n[333,   4,   5],\n[  6,   7,   8]])\n>>> x.filled(fill_value=np.arange(3))\narray([[0, 1, 2],\n[0, 4, 5],\n[6, 7, 8]])"
      }
    },
    {
      "name": "fix_invalid",
      "signature": "fix_invalid(a, mask=False, copy=True, fill_value=None)",
      "documentation": {
        "description": "Return input with invalid data masked and replaced by a fill value.\nInvalid data means values of `nan`, `inf`, etc.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array, a (subclass of) ndarray."
          },
          "mask": {
            "type": "sequence, optional",
            "description": "Mask. Must be convertible to an array of booleans with the same\nshape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to use a copy of `a` (True) or to fix `a` in place (False).\nDefault is True."
          },
          "fill_value": {
            "type": "scalar, optional",
            "description": "Value used for fixing invalid data. Default is None, in which case\nthe ``a.fill_value`` is used."
          }
        },
        "returns": "-------\nb : MaskedArray\nThe input array with invalid entries fixed.",
        "raises": "",
        "see_also": "",
        "notes": "-----\nA copy is performed by default.",
        "examples": "--------\n>>> x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)\n>>> x\nmasked_array(data=[--, -1.0, nan, inf],\nmask=[ True, False, False, False],\nfill_value=1e+20)\n>>> np.ma.fix_invalid(x)\nmasked_array(data=[--, -1.0, --, --],\nmask=[ True, False,  True,  True],\nfill_value=1e+20)\n>>> fixed = np.ma.fix_invalid(x)\n>>> fixed.data\narray([ 1.e+00, -1.e+00,  1.e+20,  1.e+20])\n>>> x.data\narray([ 1., -1., nan, inf])"
      }
    },
    {
      "name": "flatnotmasked_contiguous",
      "signature": "flatnotmasked_contiguous(a)",
      "documentation": {
        "description": "Find contiguous unmasked data in a masked array.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "The input array."
          }
        },
        "returns": "-------\nslice_list : list\nA sorted sequence of `slice` objects (start index, end index).\n.. versionchanged:: 1.15.0\nNow returns an empty list instead of None for a fully masked array",
        "raises": "",
        "see_also": "--------\nflatnotmasked_edges, notmasked_contiguous, notmasked_edges\nclump_masked, clump_unmasked",
        "notes": "-----\nOnly accepts 2-D arrays at most.",
        "examples": "--------\n>>> a = np.ma.arange(10)\n>>> np.ma.flatnotmasked_contiguous(a)\n[slice(0, 10, None)]\n>>> mask = (a < 3) | (a > 8) | (a == 5)\n>>> a[mask] = np.ma.masked\n>>> np.array(a[~a.mask])\narray([3, 4, 6, 7, 8])\n>>> np.ma.flatnotmasked_contiguous(a)\n[slice(3, 5, None), slice(6, 9, None)]\n>>> a[:] = np.ma.masked\n>>> np.ma.flatnotmasked_contiguous(a)\n[]"
      }
    },
    {
      "name": "flatnotmasked_edges",
      "signature": "flatnotmasked_edges(a)",
      "documentation": {
        "description": "Find the indices of the first and last unmasked values.\nExpects a 1-D `MaskedArray`, returns None if all values are masked.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input 1-D `MaskedArray`"
          }
        },
        "returns": "-------\nedges : ndarray or None\nThe indices of first and last non-masked value in the array.",
        "raises": "",
        "see_also": "--------\nflatnotmasked_contiguous, notmasked_contiguous, notmasked_edges\nclump_masked, clump_unmasked",
        "notes": "-----\nOnly accepts 1-D arrays.",
        "examples": "--------\n>>> a = np.ma.arange(10)\n>>> np.ma.flatnotmasked_edges(a)\narray([0, 9])\n>>> mask = (a < 3) | (a > 8) | (a == 5)\n>>> a[mask] = np.ma.masked\n>>> np.array(a[~a.mask])\narray([3, 4, 6, 7, 8])\n>>> np.ma.flatnotmasked_edges(a)\narray([3, 8])\n>>> a[:] = np.ma.masked\n>>> print(np.ma.flatnotmasked_edges(a))\nNone"
      }
    },
    {
      "name": "flatten_mask",
      "signature": "flatten_mask(mask)",
      "documentation": {
        "description": "",
        "parameters": {
          "mask": {
            "type": "array_like",
            "description": "Input array, which will be interpreted as booleans."
          }
        },
        "returns": "are collapsed.\n-------\nflattened_mask : ndarray of bools\nThe flattened input.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> mask = np.array([0, 0, 1])\n>>> np.ma.flatten_mask(mask)\narray([False, False,  True])\n>>> mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])\n>>> np.ma.flatten_mask(mask)\narray([False, False, False,  True])\n>>> mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]\n>>> mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)\n>>> np.ma.flatten_mask(mask)\narray([False, False, False, False, False,  True])"
      }
    },
    {
      "name": "flatten_structured_array",
      "signature": "flatten_structured_array(a)",
      "documentation": {
        "description": "Flatten a structured array.\nThe data type of the output is chosen such that it can represent all of the\n(nested) fields.",
        "parameters": {
          "a": {
            "type": "structured array",
            "description": ""
          }
        },
        "returns": "-------\noutput : masked array or ndarray\nA flattened masked array if the input is a masked array, otherwise a\nstandard ndarray.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> ndtype = [('a', int), ('b', float)]\n>>> a = np.array([(1, 1), (2, 2)], dtype=ndtype)\n>>> np.ma.flatten_structured_array(a)\narray([[1., 1.],\n[2., 2.]])"
      }
    },
    {
      "name": "floor",
      "signature": "floor(a, *args, **kwargs)",
      "documentation": {
        "description": "floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nReturn the floor of the input, element-wise.\nThe floor of the scalar `x` is the largest integer `i`, such that\n`i <= x`.  It is often denoted as :math:`\\lfloor x \\rfloor`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input data."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray or scalar\nThe floor of each element in `x`.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\nceil, trunc, rint, fix",
        "notes": "-----\nSome spreadsheet programs calculate the \"floor-towards-zero\", where\n``floor(-2.5) == -2``.  NumPy instead uses the definition of\n`floor` where `floor(-2.5) == -3`. The \"floor-towards-zero\"\nfunction is called ``fix`` in NumPy.",
        "examples": "--------\n>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.floor(a)\narray([-2., -2., -1.,  0.,  1.,  1.,  2.])"
      }
    },
    {
      "name": "floor_divide",
      "signature": "floor_divide(a, b, *args, **kwargs)",
      "documentation": {
        "description": "floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nReturn the largest integer smaller or equal to the division of the inputs.\nIt is equivalent to the Python ``//`` operator and pairs with the\nPython ``%`` (`remainder`), function so that ``a = a % b + b * (a // b)``\nup to roundoff.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Numerator."
          },
          "x2": {
            "type": "array_like",
            "description": "Denominator.\nIf ``x1.shape != x2.shape``, they must be broadcastable to a common\nshape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray\ny = floor(`x1`/`x2`)\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nremainder : Remainder complementary to floor_divide.\ndivmod : Simultaneous floor division and remainder.\ndivide : Standard division.\nfloor : Round a number to the nearest integer toward minus infinity.\nceil : Round a number to the nearest integer toward infinity.",
        "notes": "",
        "examples": "--------\n>>> np.floor_divide(7,3)\n2\n>>> np.floor_divide([1., 2., 3., 4.], 2.5)\narray([ 0.,  0.,  1.,  1.])\nThe ``//`` operator can be used as a shorthand for ``np.floor_divide``\non ndarrays.\n>>> x1 = np.array([1., 2., 3., 4.])\n>>> x1 // 2.5\narray([0., 0., 1., 1.])"
      }
    },
    {
      "name": "fmod",
      "signature": "fmod(a, b, *args, **kwargs)",
      "documentation": {
        "description": "fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor.\nIf ``x1.shape != x2.shape``, they must be broadcastable to a common\nshape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "This is the NumPy implementation of the C library function fmod, the\nremainder has the same sign as the dividend `x1`. It is equivalent to\nthe Matlab(TM) ``rem`` function and should not be confused with the\nPython modulus operator ``x1 % x2``.\n-------\ny : array_like\nThe remainder of the division of `x1` by `x2`.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nremainder : Equivalent to the Python ``%`` operator.\ndivide",
        "notes": "-----\nThe result of the modulo operation for negative dividend and divisors\nis bound by conventions. For `fmod`, the sign of result is the sign of\nthe dividend, while for `remainder` the sign of the result is the sign\nof the divisor. The `fmod` function is equivalent to the Matlab(TM)\n``rem`` function.",
        "examples": "--------\n>>> np.fmod([-3, -2, -1, 1, 2, 3], 2)\narray([-1,  0, -1,  1,  0,  1])\n>>> np.remainder([-3, -2, -1, 1, 2, 3], 2)\narray([1, 0, 1, 1, 0, 1])\n>>> np.fmod([5, 3], [2, 2.])\narray([ 1.,  1.])\n>>> a = np.arange(-3, 3).reshape(3, 2)\n>>> a\narray([[-3, -2],\n[-1,  0],\n[ 1,  2]])\n>>> np.fmod(a, [2,2])\narray([[-1,  0],\n[-1,  0],\n[ 1,  0]])"
      }
    },
    {
      "name": "fromflex",
      "signature": "fromflex(fxarray)",
      "documentation": {
        "description": "Build a masked array from a suitable flexible-type array.\nThe input array has to have a data-type with ``_data`` and ``_mask``\nfields. This type of array is output by `MaskedArray.toflex`.",
        "parameters": {
          "fxarray": {
            "type": "ndarray",
            "description": "The structured input array, containing ``_data`` and ``_mask``\nfields. If present, other fields are discarded."
          }
        },
        "returns": "-------\nresult : MaskedArray\nThe constructed masked array.",
        "raises": "",
        "see_also": "--------\nMaskedArray.toflex : Build a flexible-type array from a masked array.",
        "notes": "",
        "examples": "--------\n>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[0] + [1, 0] * 4)\n>>> rec = x.toflex()\n>>> rec\narray([[(0, False), (1,  True), (2, False)],\n[(3,  True), (4, False), (5,  True)],\n[(6, False), (7,  True), (8, False)]],\ndtype=[('_data', '<i8'), ('_mask', '?')])\n>>> x2 = np.ma.fromflex(rec)\n>>> x2\nmasked_array(\ndata=[[0, --, 2],\n[--, 4, --],\n[6, --, 8]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\nExtra fields can be present in the structured array but are discarded:\n>>> dt = [('_data', '<i4'), ('_mask', '|b1'), ('field3', '<f4')]\n>>> rec2 = np.zeros((2, 2), dtype=dt)\n>>> rec2\narray([[(0, False, 0.), (0, False, 0.)],\n[(0, False, 0.), (0, False, 0.)]],\ndtype=[('_data', '<i4'), ('_mask', '?'), ('field3', '<f4')])\n>>> y = np.ma.fromflex(rec2)\n>>> y\nmasked_array(\ndata=[[0, 0],\n[0, 0]],\nmask=[[False, False],\n[False, False]],\nfill_value=999999,\ndtype=int32)"
      }
    },
    {
      "name": "getdata",
      "signature": "getdata(a, subok=True)",
      "documentation": {
        "description": "Return the data of a masked array as an ndarray.\nReturn the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,\nelse return `a` as a ndarray or subclass (depending on `subok`) if not.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input ``MaskedArray``, alternatively a ndarray or a subclass thereof."
          },
          "subok": {
            "type": "bool",
            "description": "Whether to force the output to be a `pure` ndarray (False) or to\nreturn a subclass of ndarray if appropriate (True, default)."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\ngetmask : Return the mask of a masked array, or nomask.\ngetmaskarray : Return the mask of a masked array, or full array of False.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = ma.masked_equal([[1,2],[3,4]], 2)\n>>> a\nmasked_array(\ndata=[[1, --],\n[3, 4]],\nmask=[[False,  True],\n[False, False]],\nfill_value=2)\n>>> ma.getdata(a)\narray([[1, 2],\n[3, 4]])\nEquivalently use the ``MaskedArray`` `data` attribute.\n>>> a.data\narray([[1, 2],\n[3, 4]])"
      }
    },
    {
      "name": "getmask",
      "signature": "getmask(a)",
      "documentation": {
        "description": "Return the mask of a masked array, or nomask.\nReturn the mask of `a` as an ndarray if `a` is a `MaskedArray` and the\nmask is not `nomask`, else return `nomask`. To guarantee a full array\nof booleans of the same shape as a, use `getmaskarray`.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input `MaskedArray` for which the mask is required."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\ngetdata : Return the data of a masked array as an ndarray.\ngetmaskarray : Return the mask of a masked array, or full array of False.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = ma.masked_equal([[1,2],[3,4]], 2)\n>>> a\nmasked_array(\ndata=[[1, --],\n[3, 4]],\nmask=[[False,  True],\n[False, False]],\nfill_value=2)\n>>> ma.getmask(a)\narray([[False,  True],\n[False, False]])\nEquivalently use the `MaskedArray` `mask` attribute.\n>>> a.mask\narray([[False,  True],\n[False, False]])\nResult when mask == `nomask`\n>>> b = ma.masked_array([[1,2],[3,4]])\n>>> b\nmasked_array(\ndata=[[1, 2],\n[3, 4]],\nmask=False,\nfill_value=999999)\n>>> ma.nomask\nFalse\n>>> ma.getmask(b) == ma.nomask\nTrue\n>>> b.mask == ma.nomask\nTrue"
      }
    },
    {
      "name": "getmaskarray",
      "signature": "getmaskarray(arr)",
      "documentation": {
        "description": "Return the mask of a masked array, or full boolean array of False.\nReturn the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and\nthe mask is not `nomask`, else return a full boolean array of False of\nthe same shape as `arr`.",
        "parameters": {
          "arr": {
            "type": "array_like",
            "description": "Input `MaskedArray` for which the mask is required."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\ngetmask : Return the mask of a masked array, or nomask.\ngetdata : Return the data of a masked array as an ndarray.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = ma.masked_equal([[1,2],[3,4]], 2)\n>>> a\nmasked_array(\ndata=[[1, --],\n[3, 4]],\nmask=[[False,  True],\n[False, False]],\nfill_value=2)\n>>> ma.getmaskarray(a)\narray([[False,  True],\n[False, False]])\nResult when mask == ``nomask``\n>>> b = ma.masked_array([[1,2],[3,4]])\n>>> b\nmasked_array(\ndata=[[1, 2],\n[3, 4]],\nmask=False,\nfill_value=999999)\n>>> ma.getmaskarray(b)\narray([[False, False],\n[False, False]])"
      }
    },
    {
      "name": "greater",
      "signature": "greater(a, b, *args, **kwargs)",
      "documentation": {
        "description": "greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nReturn the truth value of (x1 > x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : ndarray or scalar\nOutput array, element-wise comparison of `x1` and `x2`.\nTypically of type bool, unless ``dtype=object`` is passed.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\ngreater_equal, less, less_equal, equal, not_equal",
        "notes": "",
        "examples": "--------\n>>> np.greater([4,2],[2,2])\narray([ True, False])\nThe ``>`` operator can be used as a shorthand for ``np.greater`` on\nndarrays.\n>>> a = np.array([4, 2])\n>>> b = np.array([2, 2])\n>>> a > b\narray([ True, False])"
      }
    },
    {
      "name": "greater_equal",
      "signature": "greater_equal(a, b, *args, **kwargs)",
      "documentation": {
        "description": "greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nReturn the truth value of (x1 >= x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : bool or ndarray of bool\nOutput array, element-wise comparison of `x1` and `x2`.\nTypically of type bool, unless ``dtype=object`` is passed.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\ngreater, less, less_equal, equal, not_equal",
        "notes": "",
        "examples": "--------\n>>> np.greater_equal([4, 2, 1], [2, 2, 2])\narray([ True, True, False])\nThe ``>=`` operator can be used as a shorthand for ``np.greater_equal``\non ndarrays.\n>>> a = np.array([4, 2, 1])\n>>> b = np.array([2, 2, 2])\n>>> a >= b\narray([ True,  True, False])"
      }
    },
    {
      "name": "harden_mask",
      "signature": "harden_mask(a, *args, **params)",
      "documentation": {
        "description": "harden_mask(self)\nForce the mask to hard, preventing unmasking by assignment.\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `harden_mask` sets\n`~ma.MaskedArray.hardmask` to ``True`` (and returns the modified\nself).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nma.MaskedArray.hardmask\nma.MaskedArray.soften_mask",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "hsplit",
      "signature": "hsplit(x, *args, **params)",
      "documentation": {
        "description": "hsplit\nSplit an array into multiple sub-arrays horizontally (column-wise).\nPlease refer to the `split` documentation.  `hsplit` is equivalent\nto `split` with ``axis=1``, the array is always split along the second\naxis except for 1-D arrays, where it is split at ``axis=0``.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nsplit : Split an array into multiple sub-arrays of equal size.",
        "notes": "-----\nThe function is applied to both the _data and the _mask, if any.",
        "examples": "--------\n>>> x = np.arange(16.0).reshape(4, 4)\n>>> x\narray([[ 0.,   1.,   2.,   3.],\n[ 4.,   5.,   6.,   7.],\n[ 8.,   9.,  10.,  11.],\n[12.,  13.,  14.,  15.]])\n>>> np.hsplit(x, 2)\n[array([[  0.,   1.],\n[  4.,   5.],\n[  8.,   9.],\n[12.,  13.]]),\narray([[  2.,   3.],\n[  6.,   7.],\n[10.,  11.],\n[14.,  15.]])]\n>>> np.hsplit(x, np.array([3, 6]))\n[array([[ 0.,   1.,   2.],\n[ 4.,   5.,   6.],\n[ 8.,   9.,  10.],\n[12.,  13.,  14.]]),\narray([[ 3.],\n[ 7.],\n[11.],\n[15.]]),\narray([], shape=(4, 0), dtype=float64)]\nWith a higher dimensional array the split is still along the second axis.\n>>> x = np.arange(8.0).reshape(2, 2, 2)\n>>> x\narray([[[0.,  1.],\n[2.,  3.]],\n[[4.,  5.],\n[6.,  7.]]])\n>>> np.hsplit(x, 2)\n[array([[[0.,  1.]],\n[[4.,  5.]]]),\narray([[[2.,  3.]],\n[[6.,  7.]]])]\nWith a 1-D array, the split is along axis 0.\n>>> x = np.array([0, 1, 2, 3, 4, 5])\n>>> np.hsplit(x, 2)\n[array([0, 1, 2]), array([3, 4, 5])]"
      }
    },
    {
      "name": "hstack",
      "signature": "hstack(x, *args, **params)",
      "documentation": {
        "description": "hstack\nStack arrays in sequence horizontally (column wise).\nThis is equivalent to concatenation along the second axis, except for 1-D\narrays where it concatenates along the first axis. Rebuilds arrays divided\nby `hsplit`.\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.",
        "parameters": {
          "tup": {
            "type": "sequence of ndarrays",
            "description": "The arrays must have the same shape along all but the second axis,\nexcept 1-D arrays which can be any length."
          },
          "dtype": {
            "type": "str or dtype",
            "description": "If provided, the destination array will have this dtype. Cannot be\nprovided together with `out`.\n.. versionadded:: 1.24"
          },
          "casting": {
            "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
            "description": "Controls what kind of data casting may occur. Defaults to 'same_kind'.\n.. versionadded:: 1.24"
          }
        },
        "returns": "-------\nstacked : ndarray\nThe array formed by stacking the given arrays.",
        "raises": "",
        "see_also": "--------\nconcatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nblock : Assemble an nd-array from nested lists of blocks.\nvstack : Stack arrays in sequence vertically (row wise).\ndstack : Stack arrays in sequence depth wise (along third axis).\ncolumn_stack : Stack 1-D arrays as columns into a 2-D array.\nhsplit : Split an array into multiple sub-arrays horizontally (column-wise).",
        "notes": "-----\nThe function is applied to both the _data and the _mask, if any.",
        "examples": "--------\n>>> a = np.array((1,2,3))\n>>> b = np.array((4,5,6))\n>>> np.hstack((a,b))\narray([1, 2, 3, 4, 5, 6])\n>>> a = np.array([[1],[2],[3]])\n>>> b = np.array([[4],[5],[6]])\n>>> np.hstack((a,b))\narray([[1, 4],\n[2, 5],\n[3, 6]])"
      }
    },
    {
      "name": "hypot",
      "signature": "hypot(a, b, *args, **kwargs)",
      "documentation": {
        "description": "hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nGiven the \"legs\" of a right triangle, return its hypotenuse.\nEquivalent to ``sqrt(x1**2 + x2**2)``, element-wise.  If `x1` or\n`x2` is scalar_like (i.e., unambiguously cast-able to a scalar type),\nit is broadcast for use with each element of the other argument.\n(See Examples)",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nz : ndarray\nThe hypotenuse of the triangle(s).\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))\narray([[ 5.,  5.,  5.],\n[ 5.,  5.,  5.],\n[ 5.,  5.,  5.]])\nExample showing broadcast of scalar_like argument:\n>>> np.hypot(3*np.ones((3, 3)), [4])\narray([[ 5.,  5.,  5.],\n[ 5.,  5.,  5.],\n[ 5.,  5.,  5.]])"
      }
    },
    {
      "name": "ids",
      "signature": "ids(a, *args, **params)",
      "documentation": {
        "description": "ids(self)\nReturn the addresses of the data and mask areas.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n>>> x.ids()\n(166670640, 166659832) # may vary\nIf the array has no mask, the address of `nomask` is returned. This address\nis typically not close to the data in memory:\n>>> x = np.ma.array([1, 2, 3])\n>>> x.ids()\n(166691080, 3083169284) # may vary"
      }
    },
    {
      "name": "in1d",
      "signature": "in1d(ar1, ar2, assume_unique=False, invert=False)",
      "documentation": {
        "description": "Test whether each element of an array is also present in a second\narray.\nThe output is always a masked array. See `numpy.in1d` for more details.\nWe recommend using :func:`isin` instead of `in1d` for new code.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nisin       : Version of this function that preserves the shape of ar1.\nnumpy.in1d : Equivalent function for ndarrays.",
        "notes": "-----\n.. versionadded:: 1.4.0",
        "examples": ""
      }
    },
    {
      "name": "inner",
      "signature": "inner(a, b)",
      "documentation": {
        "description": "inner(a, b, /)\nInner product of two arrays.\nOrdinary inner product of vectors for 1-D arrays (without complex\nconjugation), in higher dimensions a sum product over the last axes.",
        "parameters": {},
        "returns": "-------\nout : ndarray\nIf `a` and `b` are both\nscalars or both 1-D arrays then a scalar is returned; otherwise\nan array is returned.\n``out.shape = (*a.shape[:-1], *b.shape[:-1])``",
        "raises": "------\nValueError\nIf both `a` and `b` are nonscalar and their last dimensions have\ndifferent sizes.",
        "see_also": "--------\ntensordot : Sum products over arbitrary axes.\ndot : Generalised matrix product, using second last dimension of `b`.\neinsum : Einstein summation convention.",
        "notes": "-----\nMasked values are replaced by 0.\nFor vectors (1-D arrays) it computes the ordinary inner-product::\nnp.inner(a, b) = sum(a[:]*b[:])\nMore generally, if ``ndim(a) = r > 0`` and ``ndim(b) = s > 0``::\nnp.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))\nor explicitly::\nnp.inner(a, b)[i0,...,ir-2,j0,...,js-2]\n= sum(a[i0,...,ir-2,:]*b[j0,...,js-2,:])\nIn addition `a` or `b` may be scalars, in which case::\nnp.inner(a,b) = a*b",
        "examples": "--------\nOrdinary inner product for vectors:\n>>> a = np.array([1,2,3])\n>>> b = np.array([0,1,0])\n>>> np.inner(a, b)\n2\nSome multidimensional examples:\n>>> a = np.arange(24).reshape((2,3,4))\n>>> b = np.arange(4)\n>>> c = np.inner(a, b)\n>>> c.shape\n(2, 3)\n>>> c\narray([[ 14,  38,  62],\n[ 86, 110, 134]])\n>>> a = np.arange(2).reshape((1,1,2))\n>>> b = np.arange(6).reshape((3,2))\n>>> c = np.inner(a, b)\n>>> c.shape\n(1, 1, 3)\n>>> c\narray([[[1, 3, 5]]])\nAn example where `b` is a scalar:\n>>> np.inner(np.eye(2), 7)\narray([[7., 0.],\n[0., 7.]])"
      }
    },
    {
      "name": "innerproduct",
      "signature": "inner(a, b)",
      "documentation": {
        "description": "inner(a, b, /)\nInner product of two arrays.\nOrdinary inner product of vectors for 1-D arrays (without complex\nconjugation), in higher dimensions a sum product over the last axes.",
        "parameters": {},
        "returns": "-------\nout : ndarray\nIf `a` and `b` are both\nscalars or both 1-D arrays then a scalar is returned; otherwise\nan array is returned.\n``out.shape = (*a.shape[:-1], *b.shape[:-1])``",
        "raises": "------\nValueError\nIf both `a` and `b` are nonscalar and their last dimensions have\ndifferent sizes.",
        "see_also": "--------\ntensordot : Sum products over arbitrary axes.\ndot : Generalised matrix product, using second last dimension of `b`.\neinsum : Einstein summation convention.",
        "notes": "-----\nMasked values are replaced by 0.\nFor vectors (1-D arrays) it computes the ordinary inner-product::\nnp.inner(a, b) = sum(a[:]*b[:])\nMore generally, if ``ndim(a) = r > 0`` and ``ndim(b) = s > 0``::\nnp.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))\nor explicitly::\nnp.inner(a, b)[i0,...,ir-2,j0,...,js-2]\n= sum(a[i0,...,ir-2,:]*b[j0,...,js-2,:])\nIn addition `a` or `b` may be scalars, in which case::\nnp.inner(a,b) = a*b",
        "examples": "--------\nOrdinary inner product for vectors:\n>>> a = np.array([1,2,3])\n>>> b = np.array([0,1,0])\n>>> np.inner(a, b)\n2\nSome multidimensional examples:\n>>> a = np.arange(24).reshape((2,3,4))\n>>> b = np.arange(4)\n>>> c = np.inner(a, b)\n>>> c.shape\n(2, 3)\n>>> c\narray([[ 14,  38,  62],\n[ 86, 110, 134]])\n>>> a = np.arange(2).reshape((1,1,2))\n>>> b = np.arange(6).reshape((3,2))\n>>> c = np.inner(a, b)\n>>> c.shape\n(1, 1, 3)\n>>> c\narray([[[1, 3, 5]]])\nAn example where `b` is a scalar:\n>>> np.inner(np.eye(2), 7)\narray([[7., 0.],\n[0., 7.]])"
      }
    },
    {
      "name": "intersect1d",
      "signature": "intersect1d(ar1, ar2, assume_unique=False)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "Masked values are considered equal one to the other.\nThe output is always a masked array.\nSee `numpy.intersect1d` for more details.",
        "raises": "",
        "see_also": "--------\nnumpy.intersect1d : Equivalent function for ndarrays.",
        "notes": "",
        "examples": "--------\n>>> x = np.ma.array([1, 3, 3, 3], mask=[0, 0, 0, 1])\n>>> y = np.ma.array([3, 1, 1, 1], mask=[0, 0, 0, 1])\n>>> np.ma.intersect1d(x, y)\nmasked_array(data=[1, 3, --],\nmask=[False, False,  True],\nfill_value=999999)"
      }
    },
    {
      "name": "isMA",
      "signature": "isMaskedArray(x)",
      "documentation": {
        "description": "Test whether input is an instance of MaskedArray.\nThis function returns True if `x` is an instance of MaskedArray\nand returns False otherwise.  Any object is accepted as input.",
        "parameters": {
          "x": {
            "type": "object",
            "description": "Object to test."
          }
        },
        "returns": "-------\nresult : bool\nTrue if `x` is a MaskedArray.",
        "raises": "",
        "see_also": "--------\nisMA : Alias to isMaskedArray.\nisarray : Alias to isMaskedArray.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.eye(3, 3)\n>>> a\narray([[ 1.,  0.,  0.],\n[ 0.,  1.,  0.],\n[ 0.,  0.,  1.]])\n>>> m = ma.masked_values(a, 0)\n>>> m\nmasked_array(\ndata=[[1.0, --, --],\n[--, 1.0, --],\n[--, --, 1.0]],\nmask=[[False,  True,  True],\n[ True, False,  True],\n[ True,  True, False]],\nfill_value=0.0)\n>>> ma.isMaskedArray(a)\nFalse\n>>> ma.isMaskedArray(m)\nTrue\n>>> ma.isMaskedArray([0, 1, 2])\nFalse"
      }
    },
    {
      "name": "isMaskedArray",
      "signature": "isMaskedArray(x)",
      "documentation": {
        "description": "Test whether input is an instance of MaskedArray.\nThis function returns True if `x` is an instance of MaskedArray\nand returns False otherwise.  Any object is accepted as input.",
        "parameters": {
          "x": {
            "type": "object",
            "description": "Object to test."
          }
        },
        "returns": "-------\nresult : bool\nTrue if `x` is a MaskedArray.",
        "raises": "",
        "see_also": "--------\nisMA : Alias to isMaskedArray.\nisarray : Alias to isMaskedArray.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.eye(3, 3)\n>>> a\narray([[ 1.,  0.,  0.],\n[ 0.,  1.,  0.],\n[ 0.,  0.,  1.]])\n>>> m = ma.masked_values(a, 0)\n>>> m\nmasked_array(\ndata=[[1.0, --, --],\n[--, 1.0, --],\n[--, --, 1.0]],\nmask=[[False,  True,  True],\n[ True, False,  True],\n[ True,  True, False]],\nfill_value=0.0)\n>>> ma.isMaskedArray(a)\nFalse\n>>> ma.isMaskedArray(m)\nTrue\n>>> ma.isMaskedArray([0, 1, 2])\nFalse"
      }
    },
    {
      "name": "is_mask",
      "signature": "is_mask(m)",
      "documentation": {
        "description": "Return True if m is a valid, standard mask.\nThis function does not check the contents of the input, only that the\ntype is MaskType. In particular, this function returns False if the\nmask has a flexible dtype.",
        "parameters": {
          "m": {
            "type": "array_like",
            "description": "Array to test."
          }
        },
        "returns": "-------\nresult : bool\nTrue if `m.dtype.type` is MaskType, False otherwise.",
        "raises": "",
        "see_also": "--------\nma.isMaskedArray : Test whether input is an instance of MaskedArray.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> m = ma.masked_equal([0, 1, 0, 2, 3], 0)\n>>> m\nmasked_array(data=[--, 1, --, 2, 3],\nmask=[ True, False,  True, False, False],\nfill_value=0)\n>>> ma.is_mask(m)\nFalse\n>>> ma.is_mask(m.mask)\nTrue\nInput must be an ndarray (or have similar attributes)\nfor it to be considered a valid mask.\n>>> m = [False, True, False]\n>>> ma.is_mask(m)\nFalse\n>>> m = np.array([False, True, False])\n>>> m\narray([False,  True, False])\n>>> ma.is_mask(m)\nTrue\nArrays with complex dtypes don't return True.\n>>> dtype = np.dtype({'names':['monty', 'pithon'],\n...                   'formats':[bool, bool]})\n>>> dtype\ndtype([('monty', '|b1'), ('pithon', '|b1')])\n>>> m = np.array([(True, False), (False, True), (True, False)],\n...              dtype=dtype)\n>>> m\narray([( True, False), (False,  True), ( True, False)],\ndtype=[('monty', '?'), ('pithon', '?')])\n>>> ma.is_mask(m)\nFalse"
      }
    },
    {
      "name": "is_masked",
      "signature": "is_masked(x)",
      "documentation": {
        "description": "Determine whether input has masked values.\nAccepts any object as input, but always returns False unless the\ninput is a MaskedArray containing masked values.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Array to check for masked values."
          }
        },
        "returns": "-------\nresult : bool\nTrue if `x` is a MaskedArray with masked values, False otherwise.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> x = ma.masked_equal([0, 1, 0, 2, 3], 0)\n>>> x\nmasked_array(data=[--, 1, --, 2, 3],\nmask=[ True, False,  True, False, False],\nfill_value=0)\n>>> ma.is_masked(x)\nTrue\n>>> x = ma.masked_equal([0, 1, 0, 2, 3], 42)\n>>> x\nmasked_array(data=[0, 1, 0, 2, 3],\nmask=False,\nfill_value=42)\n>>> ma.is_masked(x)\nFalse\nAlways returns False if `x` isn't a MaskedArray.\n>>> x = [False, True, False]\n>>> ma.is_masked(x)\nFalse\n>>> x = 'a string'\n>>> ma.is_masked(x)\nFalse"
      }
    },
    {
      "name": "isarray",
      "signature": "isMaskedArray(x)",
      "documentation": {
        "description": "Test whether input is an instance of MaskedArray.\nThis function returns True if `x` is an instance of MaskedArray\nand returns False otherwise.  Any object is accepted as input.",
        "parameters": {
          "x": {
            "type": "object",
            "description": "Object to test."
          }
        },
        "returns": "-------\nresult : bool\nTrue if `x` is a MaskedArray.",
        "raises": "",
        "see_also": "--------\nisMA : Alias to isMaskedArray.\nisarray : Alias to isMaskedArray.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.eye(3, 3)\n>>> a\narray([[ 1.,  0.,  0.],\n[ 0.,  1.,  0.],\n[ 0.,  0.,  1.]])\n>>> m = ma.masked_values(a, 0)\n>>> m\nmasked_array(\ndata=[[1.0, --, --],\n[--, 1.0, --],\n[--, --, 1.0]],\nmask=[[False,  True,  True],\n[ True, False,  True],\n[ True,  True, False]],\nfill_value=0.0)\n>>> ma.isMaskedArray(a)\nFalse\n>>> ma.isMaskedArray(m)\nTrue\n>>> ma.isMaskedArray([0, 1, 2])\nFalse"
      }
    },
    {
      "name": "isin",
      "signature": "isin(element, test_elements, assume_unique=False, invert=False)",
      "documentation": {
        "description": "Calculates `element in test_elements`, broadcasting over\n`element` only.\nThe output is always a masked array of the same shape as `element`.\nSee `numpy.isin` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nin1d       : Flattened version of this function.\nnumpy.isin : Equivalent function for ndarrays.",
        "notes": "-----\n.. versionadded:: 1.13.0",
        "examples": ""
      }
    },
    {
      "name": "left_shift",
      "signature": "left_shift(a, n)",
      "documentation": {
        "description": "Shift the bits of an integer to the left.\nThis is the masked array version of `numpy.left_shift`, for details\nsee that function.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.left_shift",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "less",
      "signature": "less(a, b, *args, **kwargs)",
      "documentation": {
        "description": "less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nReturn the truth value of (x1 < x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : ndarray or scalar\nOutput array, element-wise comparison of `x1` and `x2`.\nTypically of type bool, unless ``dtype=object`` is passed.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\ngreater, less_equal, greater_equal, equal, not_equal",
        "notes": "",
        "examples": "--------\n>>> np.less([1, 2], [2, 2])\narray([ True, False])\nThe ``<`` operator can be used as a shorthand for ``np.less`` on ndarrays.\n>>> a = np.array([1, 2])\n>>> b = np.array([2, 2])\n>>> a < b\narray([ True, False])"
      }
    },
    {
      "name": "less_equal",
      "signature": "less_equal(a, b, *args, **kwargs)",
      "documentation": {
        "description": "less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nReturn the truth value of (x1 <= x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : ndarray or scalar\nOutput array, element-wise comparison of `x1` and `x2`.\nTypically of type bool, unless ``dtype=object`` is passed.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\ngreater, less, greater_equal, equal, not_equal",
        "notes": "",
        "examples": "--------\n>>> np.less_equal([4, 2, 1], [2, 2, 2])\narray([False,  True,  True])\nThe ``<=`` operator can be used as a shorthand for ``np.less_equal`` on\nndarrays.\n>>> a = np.array([4, 2, 1])\n>>> b = np.array([2, 2, 2])\n>>> a <= b\narray([False,  True,  True])"
      }
    },
    {
      "name": "log",
      "signature": "log(a, *args, **kwargs)",
      "documentation": {
        "description": "log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nNatural logarithm, element-wise.\nThe natural logarithm `log` is the inverse of the exponential function,\nso that `log(exp(x)) = x`. The natural logarithm is logarithm in base\n`e`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input value."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray\nThe natural logarithm of `x`, element-wise.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\nlog10, log2, log1p, emath.log",
        "notes": "-----\nLogarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `exp(z) = x`. The convention is to return the\n`z` whose imaginary part lies in `(-pi, pi]`.\nFor real-valued input data types, `log` always returns real output. For\neach value that cannot be expressed as a real number or infinity, it\nyields ``nan`` and sets the `invalid` floating point error flag.\nFor complex-valued input, `log` is a complex analytical function that\nhas a branch cut `[-inf, 0]` and is continuous from above on it. `log`\nhandles the floating-point negative zero as an infinitesimal negative\nnumber, conforming to the C99 standard.\nIn the cases where the input has a negative real part and a very small\nnegative complex part (approaching 0), the result is so close to `-pi`\nthat it evaluates to exactly `-pi`.\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n10th printing, 1964, pp. 67.\nhttps://personal.math.ubc.ca/~cbm/aands/page_67.htm\n.. [2] Wikipedia, \"Logarithm\". https://en.wikipedia.org/wiki/Logarithm",
        "examples": "--------\n>>> np.log([1, np.e, np.e**2, 0])\narray([  0.,   1.,   2., -Inf])"
      }
    },
    {
      "name": "log10",
      "signature": "log10(a, *args, **kwargs)",
      "documentation": {
        "description": "log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nReturn the base 10 logarithm of the input array, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input values."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray\nThe logarithm to the base 10 of `x`, element-wise. NaNs are\nreturned where x is negative.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\nemath.log10",
        "notes": "-----\nLogarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `10**z = x`. The convention is to return the\n`z` whose imaginary part lies in `(-pi, pi]`.\nFor real-valued input data types, `log10` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\nFor complex-valued input, `log10` is a complex analytical function that\nhas a branch cut `[-inf, 0]` and is continuous from above on it.\n`log10` handles the floating-point negative zero as an infinitesimal\nnegative number, conforming to the C99 standard.\nIn the cases where the input has a negative real part and a very small\nnegative complex part (approaching 0), the result is so close to `-pi`\nthat it evaluates to exactly `-pi`.\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n10th printing, 1964, pp. 67.\nhttps://personal.math.ubc.ca/~cbm/aands/page_67.htm\n.. [2] Wikipedia, \"Logarithm\". https://en.wikipedia.org/wiki/Logarithm",
        "examples": "--------\n>>> np.log10([1e-15, -3.])\narray([-15.,  nan])"
      }
    },
    {
      "name": "log2",
      "signature": "log2(a, *args, **kwargs)",
      "documentation": {
        "description": "log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nBase-2 logarithm of `x`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input values."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray\nBase-2 logarithm of `x`.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\nlog, log10, log1p, emath.log2",
        "notes": "-----\n.. versionadded:: 1.3.0\nLogarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `2**z = x`. The convention is to return the `z`\nwhose imaginary part lies in `(-pi, pi]`.\nFor real-valued input data types, `log2` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\nFor complex-valued input, `log2` is a complex analytical function that\nhas a branch cut `[-inf, 0]` and is continuous from above on it. `log2`\nhandles the floating-point negative zero as an infinitesimal negative\nnumber, conforming to the C99 standard.\nIn the cases where the input has a negative real part and a very small\nnegative complex part (approaching 0), the result is so close to `-pi`\nthat it evaluates to exactly `-pi`.",
        "examples": "--------\n>>> x = np.array([0, 1, 2, 2**4])\n>>> np.log2(x)\narray([-Inf,   0.,   1.,   4.])\n>>> xi = np.array([0+1.j, 1, 2+0.j, 4.j])\n>>> np.log2(xi)\narray([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])"
      }
    },
    {
      "name": "logical_and",
      "signature": "logical_and(a, b, *args, **kwargs)",
      "documentation": {
        "description": "logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCompute the truth value of x1 AND x2 element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray or bool\nBoolean result of the logical AND operation applied to the elements\nof `x1` and `x2`; the shape is determined by broadcasting.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nlogical_or, logical_not, logical_xor\nbitwise_and",
        "notes": "",
        "examples": "--------\n>>> np.logical_and(True, False)\nFalse\n>>> np.logical_and([True, False], [False, False])\narray([False, False])\n>>> x = np.arange(5)\n>>> np.logical_and(x>1, x<4)\narray([False, False,  True,  True, False])\nThe ``&`` operator can be used as a shorthand for ``np.logical_and`` on\nboolean ndarrays.\n>>> a = np.array([True, False])\n>>> b = np.array([False, False])\n>>> a & b\narray([False, False])"
      }
    },
    {
      "name": "logical_not",
      "signature": "logical_not(a, *args, **kwargs)",
      "documentation": {
        "description": "logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCompute the truth value of NOT x element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Logical NOT is applied to the elements of `x`."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : bool or ndarray of bool\nBoolean result with the same shape as `x` of the NOT operation\non elements of `x`.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\nlogical_and, logical_or, logical_xor",
        "notes": "",
        "examples": "--------\n>>> np.logical_not(3)\nFalse\n>>> np.logical_not([True, False, 0, 1])\narray([False,  True,  True, False])\n>>> x = np.arange(5)\n>>> np.logical_not(x<3)\narray([False, False, False,  True,  True])"
      }
    },
    {
      "name": "logical_or",
      "signature": "logical_or(a, b, *args, **kwargs)",
      "documentation": {
        "description": "logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCompute the truth value of x1 OR x2 element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray or bool\nBoolean result of the logical OR operation applied to the elements\nof `x1` and `x2`; the shape is determined by broadcasting.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nlogical_and, logical_not, logical_xor\nbitwise_or",
        "notes": "",
        "examples": "--------\n>>> np.logical_or(True, False)\nTrue\n>>> np.logical_or([True, False], [False, False])\narray([ True, False])\n>>> x = np.arange(5)\n>>> np.logical_or(x < 1, x > 3)\narray([ True, False, False, False,  True])\nThe ``|`` operator can be used as a shorthand for ``np.logical_or`` on\nboolean ndarrays.\n>>> a = np.array([True, False])\n>>> b = np.array([False, False])\n>>> a | b\narray([ True, False])"
      }
    },
    {
      "name": "logical_xor",
      "signature": "logical_xor(a, b, *args, **kwargs)",
      "documentation": {
        "description": "logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCompute the truth value of x1 XOR x2, element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : bool or ndarray of bool\nBoolean result of the logical XOR operation applied to the elements\nof `x1` and `x2`; the shape is determined by broadcasting.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nlogical_and, logical_or, logical_not, bitwise_xor",
        "notes": "",
        "examples": "--------\n>>> np.logical_xor(True, False)\nTrue\n>>> np.logical_xor([True, True, False, False], [True, False, True, False])\narray([False,  True,  True, False])\n>>> x = np.arange(5)\n>>> np.logical_xor(x < 1, x > 3)\narray([ True, False, False, False,  True])\nSimple example showing support of broadcasting\n>>> np.logical_xor(0, np.eye(2))\narray([[ True, False],\n[False,  True]])"
      }
    },
    {
      "name": "make_mask",
      "signature": "make_mask(m, copy=False, shrink=True, dtype=<class 'numpy.bool_'>)",
      "documentation": {
        "description": "Create a boolean mask from an array.\nReturn `m` as a boolean mask, creating a copy if necessary or requested.\nThe function can accept any sequence that is convertible to integers,\nor ``nomask``.  Does not require that contents must be 0s and 1s, values\nof 0 are interpreted as False, everything else as True.",
        "parameters": {
          "m": {
            "type": "array_like",
            "description": "Potential mask."
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to return a copy of `m` (True) or `m` itself (False)."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to shrink `m` to ``nomask`` if all its values are False."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Data-type of the output mask. By default, the output mask has a\ndtype of MaskType (bool). If the dtype is flexible, each field has\na boolean dtype. This is ignored when `m` is ``nomask``, in which\ncase ``nomask`` is always returned."
          }
        },
        "returns": "-------\nresult : ndarray\nA boolean mask derived from `m`.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> m = [True, False, True, True]\n>>> ma.make_mask(m)\narray([ True, False,  True,  True])\n>>> m = [1, 0, 1, 1]\n>>> ma.make_mask(m)\narray([ True, False,  True,  True])\n>>> m = [1, 0, 2, -3]\n>>> ma.make_mask(m)\narray([ True, False,  True,  True])\nEffect of the `shrink` parameter.\n>>> m = np.zeros(4)\n>>> m\narray([0., 0., 0., 0.])\n>>> ma.make_mask(m)\nFalse\n>>> ma.make_mask(m, shrink=False)\narray([False, False, False, False])\nUsing a flexible `dtype`.\n>>> m = [1, 0, 1, 1]\n>>> n = [0, 1, 0, 0]\n>>> arr = []\n>>> for man, mouse in zip(m, n):\n...     arr.append((man, mouse))\n>>> arr\n[(1, 0), (0, 1), (1, 0), (1, 0)]\n>>> dtype = np.dtype({'names':['man', 'mouse'],\n...                   'formats':[np.int64, np.int64]})\n>>> arr = np.array(arr, dtype=dtype)\n>>> arr\narray([(1, 0), (0, 1), (1, 0), (1, 0)],\ndtype=[('man', '<i8'), ('mouse', '<i8')])\n>>> ma.make_mask(arr, dtype=dtype)\narray([(True, False), (False, True), (True, False), (True, False)],\ndtype=[('man', '|b1'), ('mouse', '|b1')])"
      }
    },
    {
      "name": "make_mask_descr",
      "signature": "make_mask_descr(ndtype)",
      "documentation": {
        "description": "Construct a dtype description list from a given dtype.",
        "parameters": {
          "ndtype": {
            "type": "dtype",
            "description": "The dtype to convert."
          }
        },
        "returns": "boolean type. Field names are not altered.\n-------\nresult : dtype\nA dtype that looks like `ndtype`, the type of all fields is boolean.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> dtype = np.dtype({'names':['foo', 'bar'],\n...                   'formats':[np.float32, np.int64]})\n>>> dtype\ndtype([('foo', '<f4'), ('bar', '<i8')])\n>>> ma.make_mask_descr(dtype)\ndtype([('foo', '|b1'), ('bar', '|b1')])\n>>> ma.make_mask_descr(np.float32)\ndtype('bool')"
      }
    },
    {
      "name": "make_mask_none",
      "signature": "make_mask_none(newshape, dtype=None)",
      "documentation": {
        "description": "Return a boolean mask of the given shape, filled with False.\nThis function returns a boolean ndarray with all entries False, that can\nbe used in common mask manipulations. If a complex dtype is specified, the\ntype of each field is converted to a boolean type.",
        "parameters": {
          "newshape": {
            "type": "tuple",
            "description": "A tuple indicating the shape of the mask."
          },
          "dtype": {
            "type": "{None, dtype}, optional",
            "description": "If None, use a MaskType instance. Otherwise, use a new datatype with\nthe same fields as `dtype`, converted to boolean types."
          }
        },
        "returns": "-------\nresult : ndarray\nAn ndarray of appropriate shape and dtype, filled with False.",
        "raises": "",
        "see_also": "--------\nmake_mask : Create a boolean mask from an array.\nmake_mask_descr : Construct a dtype description list from a given dtype.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> ma.make_mask_none((3,))\narray([False, False, False])\nDefining a more complex dtype.\n>>> dtype = np.dtype({'names':['foo', 'bar'],\n...                   'formats':[np.float32, np.int64]})\n>>> dtype\ndtype([('foo', '<f4'), ('bar', '<i8')])\n>>> ma.make_mask_none((3,), dtype=dtype)\narray([(False, False), (False, False), (False, False)],\ndtype=[('foo', '|b1'), ('bar', '|b1')])"
      }
    },
    {
      "name": "mask_cols",
      "signature": "mask_cols(a, axis=<no value>)",
      "documentation": {
        "description": "Mask columns of a 2D array that contain masked values.\nThis function is a shortcut to ``mask_rowcols`` with `axis` equal to 1.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nmask_rowcols : Mask rows and/or columns of a 2D array.\nmasked_where : Mask where a condition is met.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.zeros((3, 3), dtype=int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n[0, 1, 0],\n[0, 0, 0]])\n>>> a = ma.masked_equal(a, 1)\n>>> a\nmasked_array(\ndata=[[0, 0, 0],\n[0, --, 0],\n[0, 0, 0]],\nmask=[[False, False, False],\n[False,  True, False],\n[False, False, False]],\nfill_value=1)\n>>> ma.mask_cols(a)\nmasked_array(\ndata=[[0, --, 0],\n[0, --, 0],\n[0, --, 0]],\nmask=[[False,  True, False],\n[False,  True, False],\n[False,  True, False]],\nfill_value=1)"
      }
    },
    {
      "name": "mask_or",
      "signature": "mask_or(m1, m2, copy=False, shrink=True)",
      "documentation": {
        "description": "Combine two masks with the ``logical_or`` operator.\nThe result may be a view on `m1` or `m2` if the other is `nomask`\n(i.e. False).",
        "parameters": {
          "copy": {
            "type": "bool, optional",
            "description": "If copy is False and one of the inputs is `nomask`, return a view\nof the other input mask. Defaults to False."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to shrink the output to `nomask` if all its values are\nFalse. Defaults to True."
          }
        },
        "returns": "-------\nmask : output mask\nThe result masks values that are masked in either `m1` or `m2`.",
        "raises": "------\nValueError\nIf `m1` and `m2` have different flexible dtypes.",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> m1 = np.ma.make_mask([0, 1, 1, 0])\n>>> m2 = np.ma.make_mask([1, 0, 0, 0])\n>>> np.ma.mask_or(m1, m2)\narray([ True,  True,  True, False])"
      }
    },
    {
      "name": "mask_rowcols",
      "signature": "mask_rowcols(a, axis=None)",
      "documentation": {
        "description": "Mask rows and/or columns of a 2D array that contain masked values.\nMask whole rows and/or columns of a 2D array that contain\nmasked values.  The masking behavior is selected using the\n`axis` parameter.\n- If `axis` is None, rows *and* columns are masked.\n- If `axis` is 0, only rows are masked.\n- If `axis` is 1 or -1, only columns are masked.",
        "parameters": {
          "a": {
            "type": "array_like, MaskedArray",
            "description": "The array to mask.  If not a MaskedArray instance (or if no array\nelements are masked), the result is a MaskedArray with `mask` set\nto `nomask` (False). Must be a 2D array."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to perform the operation. If None, applies to a\nflattened version of the array."
          }
        },
        "returns": "-------\na : MaskedArray\nA modified version of the input array, masked depending on the value\nof the `axis` parameter.",
        "raises": "------\nNotImplementedError\nIf input array `a` is not 2D.",
        "see_also": "--------\nmask_rows : Mask rows of a 2D array that contain masked values.\nmask_cols : Mask cols of a 2D array that contain masked values.\nmasked_where : Mask where a condition is met.",
        "notes": "-----\nThe input array's mask is modified by this function.",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.zeros((3, 3), dtype=int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n[0, 1, 0],\n[0, 0, 0]])\n>>> a = ma.masked_equal(a, 1)\n>>> a\nmasked_array(\ndata=[[0, 0, 0],\n[0, --, 0],\n[0, 0, 0]],\nmask=[[False, False, False],\n[False,  True, False],\n[False, False, False]],\nfill_value=1)\n>>> ma.mask_rowcols(a)\nmasked_array(\ndata=[[0, --, 0],\n[--, --, --],\n[0, --, 0]],\nmask=[[False,  True, False],\n[ True,  True,  True],\n[False,  True, False]],\nfill_value=1)"
      }
    },
    {
      "name": "mask_rows",
      "signature": "mask_rows(a, axis=<no value>)",
      "documentation": {
        "description": "Mask rows of a 2D array that contain masked values.\nThis function is a shortcut to ``mask_rowcols`` with `axis` equal to 0.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nmask_rowcols : Mask rows and/or columns of a 2D array.\nmasked_where : Mask where a condition is met.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.zeros((3, 3), dtype=int)\n>>> a[1, 1] = 1\n>>> a\narray([[0, 0, 0],\n[0, 1, 0],\n[0, 0, 0]])\n>>> a = ma.masked_equal(a, 1)\n>>> a\nmasked_array(\ndata=[[0, 0, 0],\n[0, --, 0],\n[0, 0, 0]],\nmask=[[False, False, False],\n[False,  True, False],\n[False, False, False]],\nfill_value=1)\n>>> ma.mask_rows(a)\nmasked_array(\ndata=[[0, 0, 0],\n[--, --, --],\n[0, 0, 0]],\nmask=[[False, False, False],\n[ True,  True,  True],\n[False, False, False]],\nfill_value=1)"
      }
    },
    {
      "name": "masked_all",
      "signature": "masked_all(shape, dtype=<class 'float'>)",
      "documentation": {
        "description": "Empty masked array with all elements masked.\nReturn an empty masked array of the given shape and dtype, where all the\ndata are masked.",
        "parameters": {
          "shape": {
            "type": "int or tuple of ints",
            "description": "Shape of the required MaskedArray, e.g., ``(2, 3)`` or ``2``."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Data type of the output."
          }
        },
        "returns": "-------\na : MaskedArray\nA masked array with all data masked.",
        "raises": "",
        "see_also": "--------\nmasked_all_like : Empty masked array modelled on an existing array.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> ma.masked_all((3, 3))\nmasked_array(\ndata=[[--, --, --],\n[--, --, --],\n[--, --, --]],\nmask=[[ True,  True,  True],\n[ True,  True,  True],\n[ True,  True,  True]],\nfill_value=1e+20,\ndtype=float64)\nThe `dtype` parameter defines the underlying data type.\n>>> a = ma.masked_all((3, 3))\n>>> a.dtype\ndtype('float64')\n>>> a = ma.masked_all((3, 3), dtype=np.int32)\n>>> a.dtype\ndtype('int32')"
      }
    },
    {
      "name": "masked_all_like",
      "signature": "masked_all_like(arr)",
      "documentation": {
        "description": "Empty masked array with the properties of an existing array.\nReturn an empty masked array of the same shape and dtype as\nthe array `arr`, where all the data are masked.",
        "parameters": {
          "arr": {
            "type": "ndarray",
            "description": "An array describing the shape and dtype of the required MaskedArray."
          }
        },
        "returns": "-------\na : MaskedArray\nA masked array with all data masked.",
        "raises": "------\nAttributeError\nIf `arr` doesn't have a shape attribute (i.e. not an ndarray)",
        "see_also": "--------\nmasked_all : Empty masked array with all elements masked.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> arr = np.zeros((2, 3), dtype=np.float32)\n>>> arr\narray([[0., 0., 0.],\n[0., 0., 0.]], dtype=float32)\n>>> ma.masked_all_like(arr)\nmasked_array(\ndata=[[--, --, --],\n[--, --, --]],\nmask=[[ True,  True,  True],\n[ True,  True,  True]],\nfill_value=1e+20,\ndtype=float32)\nThe dtype of the masked array matches the dtype of `arr`.\n>>> arr.dtype\ndtype('float32')\n>>> ma.masked_all_like(arr).dtype\ndtype('float32')"
      }
    },
    {
      "name": "masked_equal",
      "signature": "masked_equal(x, value, copy=True)",
      "documentation": {
        "description": "Mask an array where equal to a given value.\nReturn a MaskedArray, masked where the data in array `x` are\nequal to `value`. The fill_value of the returned MaskedArray\nis set to `value`.\nFor floating point arrays, consider using ``masked_values(x, value)``.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nmasked_where : Mask where a condition is met.\nmasked_values : Mask using floating point equality.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_equal(a, 2)\nmasked_array(data=[0, 1, --, 3],\nmask=[False, False,  True, False],\nfill_value=2)"
      }
    },
    {
      "name": "masked_greater",
      "signature": "masked_greater(x, value, copy=True)",
      "documentation": {
        "description": "Mask an array where greater than a given value.\nThis function is a shortcut to ``masked_where``, with\n`condition` = (x > value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nmasked_where : Mask where a condition is met.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_greater(a, 2)\nmasked_array(data=[0, 1, 2, --],\nmask=[False, False, False,  True],\nfill_value=999999)"
      }
    },
    {
      "name": "masked_greater_equal",
      "signature": "masked_greater_equal(x, value, copy=True)",
      "documentation": {
        "description": "Mask an array where greater than or equal to a given value.\nThis function is a shortcut to ``masked_where``, with\n`condition` = (x >= value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nmasked_where : Mask where a condition is met.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_greater_equal(a, 2)\nmasked_array(data=[0, 1, --, --],\nmask=[False, False,  True,  True],\nfill_value=999999)"
      }
    },
    {
      "name": "masked_inside",
      "signature": "masked_inside(x, v1, v2, copy=True)",
      "documentation": {
        "description": "Mask an array inside a given interval.\nShortcut to ``masked_where``, where `condition` is True for `x` inside\nthe interval [v1,v2] (v1 <= x <= v2).  The boundaries `v1` and `v2`\ncan be given in either order.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nmasked_where : Mask where a condition is met.",
        "notes": "-----\nThe array `x` is prefilled with its filling value.",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n>>> ma.masked_inside(x, -0.3, 0.3)\nmasked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\nmask=[False, False,  True,  True, False, False],\nfill_value=1e+20)\nThe order of `v1` and `v2` doesn't matter.\n>>> ma.masked_inside(x, 0.3, -0.3)\nmasked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\nmask=[False, False,  True,  True, False, False],\nfill_value=1e+20)"
      }
    },
    {
      "name": "masked_invalid",
      "signature": "masked_invalid(a, copy=True)",
      "documentation": {
        "description": "Mask an array where invalid values occur (NaNs or infs).\nThis function is a shortcut to ``masked_where``, with\n`condition` = ~(np.isfinite(a)). Any pre-existing mask is conserved.\nOnly applies to arrays with a dtype where NaNs or infs make sense\n(i.e. floating point types), but accepts any array_like object.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nmasked_where : Mask where a condition is met.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.arange(5, dtype=float)\n>>> a[2] = np.NaN\n>>> a[3] = np.PINF\n>>> a\narray([ 0.,  1., nan, inf,  4.])\n>>> ma.masked_invalid(a)\nmasked_array(data=[0.0, 1.0, --, --, 4.0],\nmask=[False, False,  True,  True, False],\nfill_value=1e+20)"
      }
    },
    {
      "name": "masked_less",
      "signature": "masked_less(x, value, copy=True)",
      "documentation": {
        "description": "Mask an array where less than a given value.\nThis function is a shortcut to ``masked_where``, with\n`condition` = (x < value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nmasked_where : Mask where a condition is met.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_less(a, 2)\nmasked_array(data=[--, --, 2, 3],\nmask=[ True,  True, False, False],\nfill_value=999999)"
      }
    },
    {
      "name": "masked_less_equal",
      "signature": "masked_less_equal(x, value, copy=True)",
      "documentation": {
        "description": "Mask an array where less than or equal to a given value.\nThis function is a shortcut to ``masked_where``, with\n`condition` = (x <= value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nmasked_where : Mask where a condition is met.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_less_equal(a, 2)\nmasked_array(data=[--, --, --, 3],\nmask=[ True,  True,  True, False],\nfill_value=999999)"
      }
    },
    {
      "name": "masked_not_equal",
      "signature": "masked_not_equal(x, value, copy=True)",
      "documentation": {
        "description": "Mask an array where `not` equal to a given value.\nThis function is a shortcut to ``masked_where``, with\n`condition` = (x != value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nmasked_where : Mask where a condition is met.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_not_equal(a, 2)\nmasked_array(data=[--, --, 2, --],\nmask=[ True,  True, False,  True],\nfill_value=999999)"
      }
    },
    {
      "name": "masked_object",
      "signature": "masked_object(x, value, copy=True, shrink=True)",
      "documentation": {
        "description": "Mask the array `x` where the data are exactly equal to value.\nThis function is similar to `masked_values`, but only suitable\nfor object arrays: for floating point, use `masked_values` instead.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Array to mask"
          },
          "value": {
            "type": "object",
            "description": "Comparison value"
          },
          "copy": {
            "type": "{True, False}, optional",
            "description": "Whether to return a copy of `x`."
          },
          "shrink": {
            "type": "{True, False}, optional",
            "description": "Whether to collapse a mask full of False to nomask"
          }
        },
        "returns": "-------\nresult : MaskedArray\nThe result of masking `x` where equal to `value`.",
        "raises": "",
        "see_also": "--------\nmasked_where : Mask where a condition is met.\nmasked_equal : Mask where equal to a given value (integers).\nmasked_values : Mask using floating point equality.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> food = np.array(['green_eggs', 'ham'], dtype=object)\n>>> # don't eat spoiled food\n>>> eat = ma.masked_object(food, 'green_eggs')\n>>> eat\nmasked_array(data=[--, 'ham'],\nmask=[ True, False],\nfill_value='green_eggs',\ndtype=object)\n>>> # plain ol` ham is boring\n>>> fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)\n>>> eat = ma.masked_object(fresh_food, 'green_eggs')\n>>> eat\nmasked_array(data=['cheese', 'ham', 'pineapple'],\nmask=False,\nfill_value='green_eggs',\ndtype=object)\nNote that `mask` is set to ``nomask`` if possible.\n>>> eat\nmasked_array(data=['cheese', 'ham', 'pineapple'],\nmask=False,\nfill_value='green_eggs',\ndtype=object)"
      }
    },
    {
      "name": "masked_outside",
      "signature": "masked_outside(x, v1, v2, copy=True)",
      "documentation": {
        "description": "Mask an array outside a given interval.\nShortcut to ``masked_where``, where `condition` is True for `x` outside\nthe interval [v1,v2] (x < v1)|(x > v2).\nThe boundaries `v1` and `v2` can be given in either order.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nmasked_where : Mask where a condition is met.",
        "notes": "-----\nThe array `x` is prefilled with its filling value.",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n>>> ma.masked_outside(x, -0.3, 0.3)\nmasked_array(data=[--, --, 0.01, 0.2, --, --],\nmask=[ True,  True, False, False,  True,  True],\nfill_value=1e+20)\nThe order of `v1` and `v2` doesn't matter.\n>>> ma.masked_outside(x, 0.3, -0.3)\nmasked_array(data=[--, --, 0.01, 0.2, --, --],\nmask=[ True,  True, False, False,  True,  True],\nfill_value=1e+20)"
      }
    },
    {
      "name": "masked_values",
      "signature": "masked_values(x, value, rtol=1e-05, atol=1e-08, copy=True, shrink=True)",
      "documentation": {
        "description": "Mask using floating point equality.\nReturn a MaskedArray, masked where the data in array `x` are approximately\nequal to `value`, determined using `isclose`. The default tolerances for\n`masked_values` are the same as those for `isclose`.\nFor integer types, exact equality is used, in the same way as\n`masked_equal`.\nThe fill_value is set to `value` and the mask is set to ``nomask`` if\npossible.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Array to mask."
          },
          "value": {
            "type": "float",
            "description": "Masking value.\nrtol, atol : float, optional\nTolerance parameters passed on to `isclose`"
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to return a copy of `x`."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to collapse a mask full of False to ``nomask``."
          }
        },
        "returns": "-------\nresult : MaskedArray\nThe result of masking `x` where approximately equal to `value`.",
        "raises": "",
        "see_also": "--------\nmasked_where : Mask where a condition is met.\nmasked_equal : Mask where equal to a given value (integers).",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> x = np.array([1, 1.1, 2, 1.1, 3])\n>>> ma.masked_values(x, 1.1)\nmasked_array(data=[1.0, --, 2.0, --, 3.0],\nmask=[False,  True, False,  True, False],\nfill_value=1.1)\nNote that `mask` is set to ``nomask`` if possible.\n>>> ma.masked_values(x, 2.1)\nmasked_array(data=[1. , 1.1, 2. , 1.1, 3. ],\nmask=False,\nfill_value=2.1)\nUnlike `masked_equal`, `masked_values` can perform approximate equalities.\n>>> ma.masked_values(x, 2.1, atol=1e-1)\nmasked_array(data=[1.0, 1.1, --, 1.1, 3.0],\nmask=[False, False,  True, False, False],\nfill_value=2.1)"
      }
    },
    {
      "name": "masked_where",
      "signature": "masked_where(condition, a, copy=True)",
      "documentation": {
        "description": "Mask an array where a condition is met.\nReturn `a` as an array masked where `condition` is True.\nAny masked values of `a` or `condition` are also masked in the output.",
        "parameters": {
          "condition": {
            "type": "array_like",
            "description": "Masking condition.  When `condition` tests floating point values for\nequality, consider using ``masked_values`` instead."
          },
          "a": {
            "type": "array_like",
            "description": "Array to mask."
          },
          "copy": {
            "type": "bool",
            "description": "If True (default) make a copy of `a` in the result.  If False modify\n`a` in place and return a view."
          }
        },
        "returns": "-------\nresult : MaskedArray\nThe result of masking `a` where `condition` is True.",
        "raises": "",
        "see_also": "--------\nmasked_values : Mask using floating point equality.\nmasked_equal : Mask where equal to a given value.\nmasked_not_equal : Mask where `not` equal to a given value.\nmasked_less_equal : Mask where less than or equal to a given value.\nmasked_greater_equal : Mask where greater than or equal to a given value.\nmasked_less : Mask where less than a given value.\nmasked_greater : Mask where greater than a given value.\nmasked_inside : Mask inside a given interval.\nmasked_outside : Mask outside a given interval.\nmasked_invalid : Mask invalid values (NaNs or infs).",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.arange(4)\n>>> a\narray([0, 1, 2, 3])\n>>> ma.masked_where(a <= 2, a)\nmasked_array(data=[--, --, --, 3],\nmask=[ True,  True,  True, False],\nfill_value=999999)\nMask array `b` conditional on `a`.\n>>> b = ['a', 'b', 'c', 'd']\n>>> ma.masked_where(a == 2, b)\nmasked_array(data=['a', 'b', --, 'd'],\nmask=[False, False,  True, False],\nfill_value='N/A',\ndtype='<U1')\nEffect of the `copy` argument.\n>>> c = ma.masked_where(a <= 2, a)\n>>> c\nmasked_array(data=[--, --, --, 3],\nmask=[ True,  True,  True, False],\nfill_value=999999)\n>>> c[0] = 99\n>>> c\nmasked_array(data=[99, --, --, 3],\nmask=[False,  True,  True, False],\nfill_value=999999)\n>>> a\narray([0, 1, 2, 3])\n>>> c = ma.masked_where(a <= 2, a, copy=False)\n>>> c[0] = 99\n>>> c\nmasked_array(data=[99, --, --, 3],\nmask=[False,  True,  True, False],\nfill_value=999999)\n>>> a\narray([99,  1,  2,  3])\nWhen `condition` or `a` contain masked values.\n>>> a = np.arange(4)\n>>> a = ma.masked_where(a == 2, a)\n>>> a\nmasked_array(data=[0, 1, --, 3],\nmask=[False, False,  True, False],\nfill_value=999999)\n>>> b = np.arange(4)\n>>> b = ma.masked_where(b == 0, b)\n>>> b\nmasked_array(data=[--, 1, 2, 3],\nmask=[ True, False, False, False],\nfill_value=999999)\n>>> ma.masked_where(a == 3, b)\nmasked_array(data=[--, 1, --, --],\nmask=[ True, False,  True,  True],\nfill_value=999999)"
      }
    },
    {
      "name": "max",
      "signature": "max(obj, axis=None, out=None, fill_value=None, keepdims=<no value>)",
      "documentation": {
        "description": "Return the maximum along a given axis.",
        "parameters": {
          "axis": {
            "type": "None or int or tuple of ints, optional",
            "description": "Axis along which to operate.  By default, ``axis`` is None and the\nflattened input is used.\n.. versionadded:: 1.7.0\nIf this is a tuple of ints, the maximum is selected over multiple\naxes, instead of a single axis or all the axes as before."
          },
          "out": {
            "type": "array_like, optional",
            "description": "Alternative output array in which to place the result.  Must\nbe of the same shape and buffer length as the expected output."
          },
          "fill_value": {
            "type": "scalar or None, optional",
            "description": "Value used to fill in the masked values.\nIf None, use the output of maximum_fill_value()."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
          }
        },
        "returns": "-------\namax : array_like\nNew array holding the result.\nIf ``out`` was specified, ``out`` is returned.",
        "raises": "",
        "see_also": "--------\nma.maximum_fill_value",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [[-1., 2.5], [4., -2.], [3., 0.]]\n>>> mask = [[0, 0], [1, 0], [1, 0]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\ndata=[[-1.0, 2.5],\n[--, -2.0],\n[--, 0.0]],\nmask=[[False, False],\n[ True, False],\n[ True, False]],\nfill_value=1e+20)\n>>> ma.max(masked_x)\n2.5\n>>> ma.max(masked_x, axis=0)\nmasked_array(data=[-1.0, 2.5],\nmask=[False, False],\nfill_value=1e+20)\n>>> ma.max(masked_x, axis=1, keepdims=True)\nmasked_array(\ndata=[[2.5],\n[-2.0],\n[0.0]],\nmask=[[False],\n[False],\n[False]],\nfill_value=1e+20)\n>>> mask = [[1, 1], [1, 1], [1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.max(masked_x, axis=1)\nmasked_array(data=[--, --, --],\nmask=[ True,  True,  True],\nfill_value=1e+20,\ndtype=float64)"
      }
    },
    {
      "name": "maximum",
      "signature": "maximum(a, b)",
      "documentation": {
        "description": "maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nElement-wise maximum of array elements.\nCompare two arrays and return a new array containing the element-wise\nmaxima. If one of the elements being compared is a NaN, then that\nelement is returned. If both elements are NaNs then the first is\nreturned. The latter distinction is important for complex NaNs, which\nare defined as at least one of the real or imaginary parts being a NaN.\nThe net effect is that NaNs are propagated.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray or scalar\nThe maximum of `x1` and `x2`, element-wise.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nminimum :\nElement-wise minimum of two arrays, propagates NaNs.\nfmax :\nElement-wise maximum of two arrays, ignores NaNs.\namax :\nThe maximum value of an array along a given axis, propagates NaNs.\nnanmax :\nThe maximum value of an array along a given axis, ignores NaNs.\nfmin, amin, nanmin",
        "notes": "-----\nThe maximum is equivalent to ``np.where(x1 >= x2, x1, x2)`` when\nneither x1 nor x2 are nans, but it is faster and does proper\nbroadcasting.",
        "examples": "--------\n>>> np.maximum([2, 3, 4], [1, 5, 2])\narray([2, 5, 4])\n>>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 1. ,  2. ],\n[ 0.5,  2. ]])\n>>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])\narray([nan, nan, nan])\n>>> np.maximum(np.Inf, 1)\ninf"
      }
    },
    {
      "name": "maximum_fill_value",
      "signature": "maximum_fill_value(obj)",
      "documentation": {
        "description": "Return the minimum value that can be represented by the dtype of an object.\nThis function is useful for calculating a fill value suitable for\ntaking the maximum of an array with a given dtype.",
        "parameters": {
          "obj": {
            "type": "ndarray, dtype or scalar",
            "description": "An object that can be queried for it's numeric type."
          }
        },
        "returns": "-------\nval : scalar\nThe minimum representable value.",
        "raises": "------\nTypeError\nIf `obj` isn't a suitable numeric type.",
        "see_also": "--------\nminimum_fill_value : The inverse function.\nset_fill_value : Set the filling value of a masked array.\nMaskedArray.fill_value : Return current fill value.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.int8()\n>>> ma.maximum_fill_value(a)\n-128\n>>> a = np.int32()\n>>> ma.maximum_fill_value(a)\n-2147483648\nAn array of numeric data can also be passed.\n>>> a = np.array([1, 2, 3], dtype=np.int8)\n>>> ma.maximum_fill_value(a)\n-128\n>>> a = np.array([1, 2, 3], dtype=np.float32)\n>>> ma.maximum_fill_value(a)\n-inf"
      }
    },
    {
      "name": "mean",
      "signature": "mean(a, *args, **params)",
      "documentation": {
        "description": "mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
        "parameters": {},
        "returns": "Masked entries are ignored, and result elements which are not\nfinite will be masked.\nRefer to `numpy.mean` for full documentation.",
        "raises": "",
        "see_also": "--------\nnumpy.ndarray.mean : corresponding function for ndarrays\nnumpy.mean : Equivalent function\nnumpy.ma.average : Weighted average.",
        "notes": "",
        "examples": "--------\n>>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data=[1, 2, --],\nmask=[False, False,  True],\nfill_value=999999)\n>>> a.mean()\n1.5"
      }
    },
    {
      "name": "median",
      "signature": "median(a, axis=None, out=None, overwrite_input=False, keepdims=False)",
      "documentation": {
        "description": "Compute the median along the specified axis.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array or object that can be converted to an array."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which the medians are computed. The default (None) is\nto compute the median along a flattened version of the array."
          },
          "out": {
            "type": "ndarray, optional",
            "description": "Alternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output\nbut the type will be cast if necessary."
          },
          "overwrite_input": {
            "type": "bool, optional",
            "description": "If True, then allow use of memory of input array (a) for\ncalculations. The input array will be modified by the call to\nmedian. This will save memory when you do not need to preserve\nthe contents of the input array. Treat the input as undefined,\nbut it will probably be fully or partially sorted. Default is\nFalse. Note that, if `overwrite_input` is True, and the input\nis not already an `ndarray`, an error will be raised."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\n.. versionadded:: 1.10.0"
          }
        },
        "returns": "-------\nmedian : ndarray\nA new array holding the result is returned unless out is\nspecified, in which case a reference to out is returned.\nReturn data-type is `float64` for integers and floats smaller than\n`float64`, or the input data-type, otherwise.",
        "raises": "",
        "see_also": "--------\nmean",
        "notes": "-----\nGiven a vector ``V`` with ``N`` non masked values, the median of ``V``\nis the middle value of a sorted copy of ``V`` (``Vs``) - i.e.\n``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2``\nwhen ``N`` is even.",
        "examples": "--------\n>>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)\n>>> np.ma.median(x)\n1.5\n>>> x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)\n>>> np.ma.median(x)\n2.5\n>>> np.ma.median(x, axis=-1, overwrite_input=True)\nmasked_array(data=[2.0, 5.0],\nmask=[False, False],\nfill_value=1e+20)"
      }
    },
    {
      "name": "min",
      "signature": "min(obj, axis=None, out=None, fill_value=None, keepdims=<no value>)",
      "documentation": {
        "description": "Return the minimum along a given axis.",
        "parameters": {
          "axis": {
            "type": "None or int or tuple of ints, optional",
            "description": "Axis along which to operate.  By default, ``axis`` is None and the\nflattened input is used.\n.. versionadded:: 1.7.0\nIf this is a tuple of ints, the minimum is selected over multiple\naxes, instead of a single axis or all the axes as before."
          },
          "out": {
            "type": "array_like, optional",
            "description": "Alternative output array in which to place the result.  Must be of\nthe same shape and buffer length as the expected output."
          },
          "fill_value": {
            "type": "scalar or None, optional",
            "description": "Value used to fill in the masked values.\nIf None, use the output of `minimum_fill_value`."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
          }
        },
        "returns": "-------\namin : array_like\nNew array holding the result.\nIf ``out`` was specified, ``out`` is returned.",
        "raises": "",
        "see_also": "--------\nma.minimum_fill_value",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [[1., -2., 3.], [0.2, -0.7, 0.1]]\n>>> mask = [[1, 1, 0], [0, 0, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\ndata=[[--, --, 3.0],\n[0.2, -0.7, --]],\nmask=[[ True,  True, False],\n[False, False,  True]],\nfill_value=1e+20)\n>>> ma.min(masked_x)\n-0.7\n>>> ma.min(masked_x, axis=-1)\nmasked_array(data=[3.0, -0.7],\nmask=[False, False],\nfill_value=1e+20)\n>>> ma.min(masked_x, axis=0, keepdims=True)\nmasked_array(data=[[0.2, -0.7, 3.0]],\nmask=[[False, False, False]],\nfill_value=1e+20)\n>>> mask = [[1, 1, 1,], [1, 1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.min(masked_x, axis=0)\nmasked_array(data=[--, --, --],\nmask=[ True,  True,  True],\nfill_value=1e+20,\ndtype=float64)"
      }
    },
    {
      "name": "minimum",
      "signature": "minimum(a, b)",
      "documentation": {
        "description": "minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nElement-wise minimum of array elements.\nCompare two arrays and return a new array containing the element-wise\nminima. If one of the elements being compared is a NaN, then that\nelement is returned. If both elements are NaNs then the first is\nreturned. The latter distinction is important for complex NaNs, which\nare defined as at least one of the real or imaginary parts being a NaN.\nThe net effect is that NaNs are propagated.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray or scalar\nThe minimum of `x1` and `x2`, element-wise.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nmaximum :\nElement-wise maximum of two arrays, propagates NaNs.\nfmin :\nElement-wise minimum of two arrays, ignores NaNs.\namin :\nThe minimum value of an array along a given axis, propagates NaNs.\nnanmin :\nThe minimum value of an array along a given axis, ignores NaNs.\nfmax, amax, nanmax",
        "notes": "-----\nThe minimum is equivalent to ``np.where(x1 <= x2, x1, x2)`` when\nneither x1 nor x2 are NaNs, but it is faster and does proper\nbroadcasting.",
        "examples": "--------\n>>> np.minimum([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n>>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 0.5,  0. ],\n[ 0. ,  1. ]])\n>>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([nan, nan, nan])\n>>> np.minimum(-np.Inf, 1)\n-inf"
      }
    },
    {
      "name": "minimum_fill_value",
      "signature": "minimum_fill_value(obj)",
      "documentation": {
        "description": "Return the maximum value that can be represented by the dtype of an object.\nThis function is useful for calculating a fill value suitable for\ntaking the minimum of an array with a given dtype.",
        "parameters": {
          "obj": {
            "type": "ndarray, dtype or scalar",
            "description": "An object that can be queried for it's numeric type."
          }
        },
        "returns": "-------\nval : scalar\nThe maximum representable value.",
        "raises": "------\nTypeError\nIf `obj` isn't a suitable numeric type.",
        "see_also": "--------\nmaximum_fill_value : The inverse function.\nset_fill_value : Set the filling value of a masked array.\nMaskedArray.fill_value : Return current fill value.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.int8()\n>>> ma.minimum_fill_value(a)\n127\n>>> a = np.int32()\n>>> ma.minimum_fill_value(a)\n2147483647\nAn array of numeric data can also be passed.\n>>> a = np.array([1, 2, 3], dtype=np.int8)\n>>> ma.minimum_fill_value(a)\n127\n>>> a = np.array([1, 2, 3], dtype=np.float32)\n>>> ma.minimum_fill_value(a)\ninf"
      }
    },
    {
      "name": "mod",
      "signature": "remainder(a, b, *args, **kwargs)",
      "documentation": {
        "description": "remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend array."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor array.\nIf ``x1.shape != x2.shape``, they must be broadcastable to a common\nshape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "Computes the remainder complementary to the `floor_divide` function.  It is\nequivalent to the Python modulus operator``x1 % x2`` and has the same sign\nas the divisor `x2`. The MATLAB function equivalent to ``np.remainder``\nis ``mod``.\n.. warning::\nThis should not be confused with:\n* Python 3.7's `math.remainder` and C's ``remainder``, which\ncomputes the IEEE remainder, which are the complement to\n``round(x1 / x2)``.\n* The MATLAB ``rem`` function and or the C ``%`` operator which is the\ncomplement to ``int(x1 / x2)``.\n-------\ny : ndarray\nThe element-wise remainder of the quotient ``floor_divide(x1, x2)``.\nThis is a scalar if both `x1` and `x2` are scalars.\nintegers.\n``mod`` is an alias of ``remainder``.",
        "raises": "",
        "see_also": "--------\nfloor_divide : Equivalent of Python ``//`` operator.\ndivmod : Simultaneous floor division and remainder.\nfmod : Equivalent of the MATLAB ``rem`` function.\ndivide, floor",
        "notes": "-----",
        "examples": "--------\n>>> np.remainder([4, 7], [2, 3])\narray([0, 1])\n>>> np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])\nThe ``%`` operator can be used as a shorthand for ``np.remainder`` on\nndarrays.\n>>> x1 = np.arange(7)\n>>> x1 % 5\narray([0, 1, 2, 3, 4, 0, 1])"
      }
    },
    {
      "name": "multiply",
      "signature": "multiply(a, b, *args, **kwargs)",
      "documentation": {
        "description": "multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nMultiply arguments element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray\nThe product of `x1` and `x2`, element-wise.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "",
        "notes": "-----\nEquivalent to `x1` * `x2` in terms of array broadcasting.",
        "examples": "--------\n>>> np.multiply(2.0, 4.0)\n8.0\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.multiply(x1, x2)\narray([[  0.,   1.,   4.],\n[  0.,   4.,  10.],\n[  0.,   7.,  16.]])\nThe ``*`` operator can be used as a shorthand for ``np.multiply`` on\nndarrays.\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> x1 * x2\narray([[  0.,   1.,   4.],\n[  0.,   4.,  10.],\n[  0.,   7.,  16.]])"
      }
    },
    {
      "name": "ndenumerate",
      "signature": "ndenumerate(a, compressed=True)",
      "documentation": {
        "description": "Multidimensional index iterator.\nReturn an iterator yielding pairs of array coordinates and values,\nskipping elements that are masked. With `compressed=False`,\n`ma.masked` is yielded as the value of masked elements. This\nbehavior differs from that of `numpy.ndenumerate`, which yields the\nvalue of the underlying data array.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "An array with (possibly) masked elements."
          },
          "compressed": {
            "type": "bool, optional",
            "description": "If True (default), masked elements are skipped."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.ndenumerate : Equivalent function ignoring any mask.",
        "notes": "-----\n.. versionadded:: 1.23.0",
        "examples": "--------\n>>> a = np.ma.arange(9).reshape((3, 3))\n>>> a[1, 0] = np.ma.masked\n>>> a[1, 2] = np.ma.masked\n>>> a[2, 1] = np.ma.masked\n>>> a\nmasked_array(\ndata=[[0, 1, 2],\n[--, 4, --],\n[6, --, 8]],\nmask=[[False, False, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> for index, x in np.ma.ndenumerate(a):\n...     print(index, x)\n(0, 0) 0\n(0, 1) 1\n(0, 2) 2\n(1, 1) 4\n(2, 0) 6\n(2, 2) 8\n>>> for index, x in np.ma.ndenumerate(a, compressed=False):\n...     print(index, x)\n(0, 0) 0\n(0, 1) 1\n(0, 2) 2\n(1, 0) --\n(1, 1) 4\n(1, 2) --\n(2, 0) 6\n(2, 1) --\n(2, 2) 8"
      }
    },
    {
      "name": "ndim",
      "signature": "ndim(obj)",
      "documentation": {
        "description": "Return the number of dimensions of an array.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array.  If it is not already an ndarray, a conversion is\nattempted."
          }
        },
        "returns": "-------\nnumber_of_dimensions : int\nThe number of dimensions in `a`.  Scalars are zero-dimensional.",
        "raises": "",
        "see_also": "--------\nndarray.ndim : equivalent method\nshape : dimensions of array\nndarray.shape : dimensions of array",
        "notes": "",
        "examples": "--------\n>>> np.ndim([[1,2,3],[4,5,6]])\n2\n>>> np.ndim(np.array([[1,2,3],[4,5,6]]))\n2\n>>> np.ndim(1)\n0"
      }
    },
    {
      "name": "negative",
      "signature": "negative(a, *args, **kwargs)",
      "documentation": {
        "description": "negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nNumerical negative, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like or scalar",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray or scalar\nReturned array or scalar: `y = -x`.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> np.negative([1.,-1.])\narray([-1.,  1.])\nThe unary ``-`` operator can be used as a shorthand for ``np.negative`` on\nndarrays.\n>>> x1 = np.array(([1., -1.]))\n>>> -x1\narray([-1.,  1.])"
      }
    },
    {
      "name": "nonzero",
      "signature": "nonzero(a, *args, **params)",
      "documentation": {
        "description": "nonzero(self)\nReturn the indices of unmasked elements that are not zero.",
        "parameters": {},
        "returns": "indices of the non-zero elements in that dimension. The corresponding\nnon-zero values can be obtained with::\na[a.nonzero()]\nTo group the indices by element, rather than dimension, use\ninstead::\nnp.transpose(a.nonzero())\nThe result of this is always a 2d array, with a row for each non-zero\nelement.\n-------\ntuple_of_arrays : tuple\nIndices of elements that are non-zero.",
        "raises": "",
        "see_also": "--------\nnumpy.nonzero :\nFunction operating on ndarrays.\nflatnonzero :\nReturn indices that are non-zero in the flattened version of the input\narray.\nnumpy.ndarray.nonzero :\nEquivalent ndarray method.\ncount_nonzero :\nCounts the number of non-zero elements in the input array.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> x = ma.array(np.eye(3))\n>>> x\nmasked_array(\ndata=[[1., 0., 0.],\n[0., 1., 0.],\n[0., 0., 1.]],\nmask=False,\nfill_value=1e+20)\n>>> x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\nMasked elements are ignored.\n>>> x[1, 1] = ma.masked\n>>> x\nmasked_array(\ndata=[[1.0, 0.0, 0.0],\n[0.0, --, 0.0],\n[0.0, 0.0, 1.0]],\nmask=[[False, False, False],\n[False,  True, False],\n[False, False, False]],\nfill_value=1e+20)\n>>> x.nonzero()\n(array([0, 2]), array([0, 2]))\nIndices can also be grouped by element.\n>>> np.transpose(x.nonzero())\narray([[0, 0],\n[2, 2]])\nA common use for ``nonzero`` is to find the indices of an array, where\na condition is True.  Given an array `a`, the condition `a` > 3 is a\nboolean array and since False is interpreted as 0, ma.nonzero(a > 3)\nyields the indices of the `a` where the condition is true.\n>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n>>> a > 3\nmasked_array(\ndata=[[False, False, False],\n[ True,  True,  True],\n[ True,  True,  True]],\nmask=False,\nfill_value=True)\n>>> ma.nonzero(a > 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\nThe ``nonzero`` method of the condition array can also be called.\n>>> (a > 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))"
      }
    },
    {
      "name": "not_equal",
      "signature": "not_equal(a, b, *args, **kwargs)",
      "documentation": {
        "description": "not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nReturn (x1 != x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\nout : ndarray or scalar\nOutput array, element-wise comparison of `x1` and `x2`.\nTypically of type bool, unless ``dtype=object`` is passed.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nequal, greater, greater_equal, less, less_equal",
        "notes": "",
        "examples": "--------\n>>> np.not_equal([1.,2.], [1., 3.])\narray([False,  True])\n>>> np.not_equal([1, 2], [[1, 3],[1, 4]])\narray([[False,  True],\n[False,  True]])\nThe ``!=`` operator can be used as a shorthand for ``np.not_equal`` on\nndarrays.\n>>> a = np.array([1., 2.])\n>>> b = np.array([1., 3.])\n>>> a != b\narray([False,  True])"
      }
    },
    {
      "name": "notmasked_contiguous",
      "signature": "notmasked_contiguous(a, axis=None)",
      "documentation": {
        "description": "Find contiguous unmasked data in a masked array along the given axis.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "The input array."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to perform the operation.\nIf None (default), applies to a flattened version of the array, and this\nis the same as `flatnotmasked_contiguous`."
          }
        },
        "returns": "-------\nendpoints : list\nA list of slices (start and end indexes) of unmasked indexes\nin the array.\nIf the input is 2d and axis is specified, the result is a list of lists.",
        "raises": "",
        "see_also": "--------\nflatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges\nclump_masked, clump_unmasked",
        "notes": "-----\nOnly accepts 2-D arrays at most.",
        "examples": "--------\n>>> a = np.arange(12).reshape((3, 4))\n>>> mask = np.zeros_like(a)\n>>> mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0\n>>> ma = np.ma.array(a, mask=mask)\n>>> ma\nmasked_array(\ndata=[[0, --, 2, 3],\n[--, --, --, 7],\n[8, --, --, 11]],\nmask=[[False,  True, False, False],\n[ True,  True,  True, False],\n[False,  True,  True, False]],\nfill_value=999999)\n>>> np.array(ma[~ma.mask])\narray([ 0,  2,  3,  7, 8, 11])\n>>> np.ma.notmasked_contiguous(ma)\n[slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]\n>>> np.ma.notmasked_contiguous(ma, axis=0)\n[[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]]\n>>> np.ma.notmasked_contiguous(ma, axis=1)\n[[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]]"
      }
    },
    {
      "name": "notmasked_edges",
      "signature": "notmasked_edges(a, axis=None)",
      "documentation": {
        "description": "Find the indices of the first and last unmasked values along an axis.\nIf all values are masked, return None.  Otherwise, return a list\nof two tuples, corresponding to the indices of the first and last\nunmasked values respectively.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "The input array."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which to perform the operation.\nIf None (default), applies to a flattened version of the array."
          }
        },
        "returns": "-------\nedges : ndarray or list\nAn array of start and end indexes if there are any masked data in\nthe array. If there are no masked data in the array, `edges` is a\nlist of the first and last index.",
        "raises": "",
        "see_also": "--------\nflatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous\nclump_masked, clump_unmasked",
        "notes": "",
        "examples": "--------\n>>> a = np.arange(9).reshape((3, 3))\n>>> m = np.zeros_like(a)\n>>> m[1:, 1:] = 1\n>>> am = np.ma.array(a, mask=m)\n>>> np.array(am[~am.mask])\narray([0, 1, 2, 3, 6])\n>>> np.ma.notmasked_edges(am)\narray([0, 6])"
      }
    },
    {
      "name": "outer",
      "signature": "outer(a, b)",
      "documentation": {
        "description": "Compute the outer product of two vectors.\nGiven two vectors `a` and `b` of length ``M`` and ``N``, repsectively,\nthe outer product [1]_ is::\n[[a_0*b_0  a_0*b_1 ... a_0*b_{N-1} ]\n[a_1*b_0    .\n[ ...          .\n[a_{M-1}*b_0            a_{M-1}*b_{N-1} ]]",
        "parameters": {
          "a": {
            "type": "(M,) array_like",
            "description": "First input vector.  Input is flattened if\nnot already 1-dimensional."
          },
          "b": {
            "type": "(N,) array_like",
            "description": "Second input vector.  Input is flattened if\nnot already 1-dimensional."
          },
          "out": {
            "type": "(M, N) ndarray, optional",
            "description": "A location where the result is stored\n.. versionadded:: 1.9.0"
          }
        },
        "returns": "-------\nout : (M, N) ndarray\n``out[i, j] = a[i] * b[j]``\nSee also\n--------\ninner\neinsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.\nufunc.outer : A generalization to dimensions other than 1D and other\noperations. ``np.multiply.outer(a.ravel(), b.ravel())``\nis the equivalent.\ntensordot : ``np.tensordot(a.ravel(), b.ravel(), axes=((), ()))``\nis the equivalent.\nReferences\n----------\n.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd\ned., Baltimore, MD, Johns Hopkins University Press, 1996,\npg. 8.",
        "raises": "",
        "see_also": "",
        "notes": "-----\nMasked values are replaced by 0.",
        "examples": "--------\nMake a (*very* coarse) grid for computing a Mandelbrot set:\n>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n>>> rl\narray([[-2., -1.,  0.,  1.,  2.],\n[-2., -1.,  0.,  1.,  2.],\n[-2., -1.,  0.,  1.,  2.],\n[-2., -1.,  0.,  1.,  2.],\n[-2., -1.,  0.,  1.,  2.]])\n>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n>>> im\narray([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n[0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n[0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n>>> grid = rl + im\n>>> grid\narray([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n[-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n[-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n[-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n[-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\nAn example using a \"vector\" of letters:\n>>> x = np.array(['a', 'b', 'c'], dtype=object)\n>>> np.outer(x, [1, 2, 3])\narray([['a', 'aa', 'aaa'],\n['b', 'bb', 'bbb'],\n['c', 'cc', 'ccc']], dtype=object)"
      }
    },
    {
      "name": "outerproduct",
      "signature": "outer(a, b)",
      "documentation": {
        "description": "Compute the outer product of two vectors.\nGiven two vectors `a` and `b` of length ``M`` and ``N``, repsectively,\nthe outer product [1]_ is::\n[[a_0*b_0  a_0*b_1 ... a_0*b_{N-1} ]\n[a_1*b_0    .\n[ ...          .\n[a_{M-1}*b_0            a_{M-1}*b_{N-1} ]]",
        "parameters": {
          "a": {
            "type": "(M,) array_like",
            "description": "First input vector.  Input is flattened if\nnot already 1-dimensional."
          },
          "b": {
            "type": "(N,) array_like",
            "description": "Second input vector.  Input is flattened if\nnot already 1-dimensional."
          },
          "out": {
            "type": "(M, N) ndarray, optional",
            "description": "A location where the result is stored\n.. versionadded:: 1.9.0"
          }
        },
        "returns": "-------\nout : (M, N) ndarray\n``out[i, j] = a[i] * b[j]``\nSee also\n--------\ninner\neinsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.\nufunc.outer : A generalization to dimensions other than 1D and other\noperations. ``np.multiply.outer(a.ravel(), b.ravel())``\nis the equivalent.\ntensordot : ``np.tensordot(a.ravel(), b.ravel(), axes=((), ()))``\nis the equivalent.\nReferences\n----------\n.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd\ned., Baltimore, MD, Johns Hopkins University Press, 1996,\npg. 8.",
        "raises": "",
        "see_also": "",
        "notes": "-----\nMasked values are replaced by 0.",
        "examples": "--------\nMake a (*very* coarse) grid for computing a Mandelbrot set:\n>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n>>> rl\narray([[-2., -1.,  0.,  1.,  2.],\n[-2., -1.,  0.,  1.,  2.],\n[-2., -1.,  0.,  1.,  2.],\n[-2., -1.,  0.,  1.,  2.],\n[-2., -1.,  0.,  1.,  2.]])\n>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n>>> im\narray([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n[0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n[0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n>>> grid = rl + im\n>>> grid\narray([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n[-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n[-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n[-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n[-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\nAn example using a \"vector\" of letters:\n>>> x = np.array(['a', 'b', 'c'], dtype=object)\n>>> np.outer(x, [1, 2, 3])\narray([['a', 'aa', 'aaa'],\n['b', 'bb', 'bbb'],\n['c', 'cc', 'ccc']], dtype=object)"
      }
    },
    {
      "name": "polyfit",
      "signature": "polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False)",
      "documentation": {
        "description": "Least squares polynomial fit.\n.. note::\nThis forms part of the old polynomial API. Since version 1.4, the\nnew polynomial API defined in `numpy.polynomial` is preferred.\nA summary of the differences can be found in the\n:doc:`transition guide </reference/routines.polynomials>`.\nFit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`\nto points `(x, y)`. Returns a vector of coefficients `p` that minimises\nthe squared error in the order `deg`, `deg-1`, ... `0`.\nThe `Polynomial.fit <numpy.polynomial.polynomial.Polynomial.fit>` class\nmethod is recommended for new code as it is more stable numerically. See\nthe documentation of the method for more information.",
        "parameters": {
          "x": {
            "type": "array_like, shape (M,)",
            "description": "x-coordinates of the M sample points ``(x[i], y[i])``."
          },
          "y": {
            "type": "array_like, shape (M,) or (M, K)",
            "description": "y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column."
          },
          "deg": {
            "type": "int",
            "description": "Degree of the fitting polynomial"
          },
          "rcond": {
            "type": "float, optional",
            "description": "Relative condition number of the fit. Singular values smaller than\nthis relative to the largest singular value will be ignored. The\ndefault value is len(x)*eps, where eps is the relative precision of\nthe float type, about 2e-16 in most cases."
          },
          "full": {
            "type": "bool, optional",
            "description": "Switch determining nature of return value. When it is False (the\ndefault) just the coefficients are returned, when True diagnostic\ninformation from the singular value decomposition is also returned."
          },
          "w": {
            "type": "array_like, shape (M,), optional",
            "description": "Weights. If not None, the weight ``w[i]`` applies to the unsquared\nresidual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are\nchosen so that the errors of the products ``w[i]*y[i]`` all have the\nsame variance.  When using inverse-variance weighting, use\n``w[i] = 1/sigma(y[i])``.  The default value is None."
          },
          "cov": {
            "type": "bool or str, optional",
            "description": "If given and not `False`, return not just the estimate but also its\ncovariance matrix. By default, the covariance are scaled by\nchi2/dof, where dof = M - (deg + 1), i.e., the weights are presumed\nto be unreliable except in a relative sense and everything is scaled\nsuch that the reduced chi2 is unity. This scaling is omitted if\n``cov='unscaled'``, as is relevant for the case that the weights are\nw = 1/sigma, with sigma known to be a reliable estimate of the\nuncertainty."
          }
        },
        "returns": "-------\np : ndarray, shape (deg + 1,) or (deg + 1, K)\nPolynomial coefficients, highest power first.  If `y` was 2-D, the\ncoefficients for `k`-th data set are in ``p[:,k]``.\nresiduals, rank, singular_values, rcond\nThese values are only returned if ``full == True``\n- residuals -- sum of squared residuals of the least squares fit\n- rank -- the effective rank of the scaled Vandermonde\ncoefficient matrix\n- singular_values -- singular values of the scaled Vandermonde\ncoefficient matrix\n- rcond -- value of `rcond`.\nFor more details, see `numpy.linalg.lstsq`.\nV : ndarray, shape (M,M) or (M,M,K)\nPresent only if ``full == False`` and ``cov == True``.  The covariance\nmatrix of the polynomial coefficient estimates.  The diagonal of\nthis matrix are the variance estimates for each coefficient.  If y\nis a 2-D array, then the covariance matrix for the `k`-th data set\nare in ``V[:,:,k]``\nWarns\n-----\nRankWarning\nThe rank of the coefficient matrix in the least-squares fit is\ndeficient. The warning is only raised if ``full == False``.\nThe warnings can be turned off by\n>>> import warnings\n>>> warnings.simplefilter('ignore', np.RankWarning)",
        "raises": "",
        "see_also": "--------\npolyval : Compute polynomial values.\nlinalg.lstsq : Computes a least-squares fit.\nscipy.interpolate.UnivariateSpline : Computes spline fits.",
        "notes": "-----\nAny masked values in x is propagated in y, and vice-versa.\nThe solution minimizes the squared error\n.. math::\nE = \\sum_{j=0}^k |p(x_j) - y_j|^2\nin the equations::\nx[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]\nx[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]\n...\nx[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]\nThe coefficient matrix of the coefficients `p` is a Vandermonde matrix.\n`polyfit` issues a `RankWarning` when the least-squares fit is badly\nconditioned. This implies that the best fit is not well-defined due\nto numerical error. The results may be improved by lowering the polynomial\ndegree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter\ncan also be set to a value smaller than its default, but the resulting\nfit may be spurious: including contributions from the small singular\nvalues can add numerical noise to the result.\nNote that fitting polynomial coefficients is inherently badly conditioned\nwhen the degree of the polynomial is large or the interval of sample points\nis badly centered. The quality of the fit should always be checked in these\ncases. When polynomial fits are not satisfactory, splines may be a good\nalternative.\nReferences\n----------\n.. [1] Wikipedia, \"Curve fitting\",\nhttps://en.wikipedia.org/wiki/Curve_fitting\n.. [2] Wikipedia, \"Polynomial interpolation\",\nhttps://en.wikipedia.org/wiki/Polynomial_interpolation",
        "examples": "--------\n>>> import warnings\n>>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n>>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n>>> z = np.polyfit(x, y, 3)\n>>> z\narray([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary\nIt is convenient to use `poly1d` objects for dealing with polynomials:\n>>> p = np.poly1d(z)\n>>> p(0.5)\n0.6143849206349179 # may vary\n>>> p(3.5)\n-0.34732142857143039 # may vary\n>>> p(10)\n22.579365079365115 # may vary\nHigh-order polynomials may oscillate wildly:\n>>> with warnings.catch_warnings():\n...     warnings.simplefilter('ignore', np.RankWarning)\n...     p30 = np.poly1d(np.polyfit(x, y, 30))\n...\n>>> p30(4)\n-0.80000000000000204 # may vary\n>>> p30(5)\n-0.99999999999999445 # may vary\n>>> p30(4.5)\n-0.10547061179440398 # may vary\nIllustration:\n>>> import matplotlib.pyplot as plt\n>>> xp = np.linspace(-2, 6, 100)\n>>> _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n>>> plt.ylim(-2,2)\n(-2, 2)\n>>> plt.show()"
      }
    },
    {
      "name": "power",
      "signature": "power(a, b, third=None)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "This is the masked array version of `numpy.power`. For details see\n`numpy.power`.",
        "raises": "",
        "see_also": "--------\nnumpy.power",
        "notes": "-----\nThe *out* argument to `numpy.power` is not supported, `third` has to be\nNone.",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [11.2, -3.973, 0.801, -1.41]\n>>> mask = [0, 0, 0, 1]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(data=[11.2, -3.973, 0.801, --],\nmask=[False, False, False,  True],\nfill_value=1e+20)\n>>> ma.power(masked_x, 2)\nmasked_array(data=[125.43999999999998, 15.784728999999999,\n0.6416010000000001, --],\nmask=[False, False, False,  True],\nfill_value=1e+20)\n>>> y = [-0.5, 2, 0, 17]\n>>> masked_y = ma.masked_array(y, mask)\n>>> masked_y\nmasked_array(data=[-0.5, 2.0, 0.0, --],\nmask=[False, False, False,  True],\nfill_value=1e+20)\n>>> ma.power(masked_x, masked_y)\nmasked_array(data=[0.29880715233359845, 15.784728999999999, 1.0, --],\nmask=[False, False, False,  True],\nfill_value=1e+20)"
      }
    },
    {
      "name": "prod",
      "signature": "prod(a, *args, **params)",
      "documentation": {
        "description": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)\nReturn the product of the array elements over the given axis.\nMasked elements are set to 1 internally for computation.\nRefer to `numpy.prod` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
        "notes": "-----\nArithmetic is modular when using integer types, and no error is raised\non overflow.",
        "examples": ""
      }
    },
    {
      "name": "product",
      "signature": "prod(a, *args, **params)",
      "documentation": {
        "description": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)\nReturn the product of the array elements over the given axis.\nMasked elements are set to 1 internally for computation.\nRefer to `numpy.prod` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
        "notes": "-----\nArithmetic is modular when using integer types, and no error is raised\non overflow.",
        "examples": ""
      }
    },
    {
      "name": "ptp",
      "signature": "ptp(obj, axis=None, out=None, fill_value=None, keepdims=<no value>)",
      "documentation": {
        "description": "Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).\n.. warning::\n`ptp` preserves the data type of the array. This means the\nreturn value for an input of signed integers with n bits\n(e.g. `np.int8`, `np.int16`, etc) is also a signed integer\nwith n bits.  In that case, peak-to-peak values greater than\n``2**(n-1)-1`` will be returned as negative values. An example\nwith a work-around is shown below.",
        "parameters": {
          "axis": {
            "type": "{None, int}, optional",
            "description": "Axis along which to find the peaks.  If None (default) the\nflattened array is used."
          },
          "out": {
            "type": "{None, array_like}, optional",
            "description": "Alternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output\nbut the type will be cast if necessary."
          },
          "fill_value": {
            "type": "scalar or None, optional",
            "description": "Value used to fill in the masked values."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
          }
        },
        "returns": "-------\nptp : ndarray.\nA new array holding the result, unless ``out`` was\nspecified, in which case a reference to ``out`` is returned.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> x = np.ma.MaskedArray([[4, 9, 2, 10],\n...                        [6, 9, 7, 12]])\n>>> x.ptp(axis=1)\nmasked_array(data=[8, 6],\nmask=False,\nfill_value=999999)\n>>> x.ptp(axis=0)\nmasked_array(data=[2, 0, 5, 2],\nmask=False,\nfill_value=999999)\n>>> x.ptp()\n10\nThis example shows that a negative value can be returned when\nthe input is an array of signed integers.\n>>> y = np.ma.MaskedArray([[1, 127],\n...                        [0, 127],\n...                        [-1, 127],\n...                        [-2, 127]], dtype=np.int8)\n>>> y.ptp(axis=1)\nmasked_array(data=[ 126,  127, -128, -127],\nmask=False,\nfill_value=999999,\ndtype=int8)\nA work-around is to use the `view()` method to view the result as\nunsigned integers with the same bit width:\n>>> y.ptp(axis=1).view(np.uint8)\nmasked_array(data=[126, 127, 128, 129],\nmask=False,\nfill_value=999999,\ndtype=uint8)"
      }
    },
    {
      "name": "put",
      "signature": "put(a, indices, values, mode='raise')",
      "documentation": {
        "description": "Set storage-indexed locations to corresponding values.\nThis function is equivalent to `MaskedArray.put`, see that method\nfor details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nMaskedArray.put",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "putmask",
      "signature": "putmask(a, mask, values)",
      "documentation": {
        "description": "Changes elements of an array based on conditional and input values.\nThis is the masked array version of `numpy.putmask`, for details see\n`numpy.putmask`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.putmask",
        "notes": "-----\nUsing a masked array as `values` will **not** transform a `ndarray` into\na `MaskedArray`.",
        "examples": ""
      }
    },
    {
      "name": "ravel",
      "signature": "ravel(a, *args, **params)",
      "documentation": {
        "description": "ravel(self, order='C')",
        "parameters": {
          "order": {
            "type": "{'C', 'F', 'A', 'K'}, optional",
            "description": "The elements of `a` are read using this index order. 'C' means to\nindex the elements in C-like order, with the last axis index\nchanging fastest, back to the first axis index changing slowest.\n'F' means to index the elements in Fortran-like index order, with\nthe first index changing fastest, and the last index changing\nslowest. Note that the 'C' and 'F' options take no account of the\nmemory layout of the underlying array, and only refer to the order\nof axis indexing.  'A' means to read the elements in Fortran-like\nindex order if `m` is Fortran *contiguous* in memory, C-like order\notherwise.  'K' means to read the elements in the order they occur\nin memory, except for reversing the data when strides are negative.\nBy default, 'C' index order is used.\n(Masked arrays currently use 'A' on the data when 'K' is passed.)"
          }
        },
        "returns": "-------\nMaskedArray\nOutput view is of shape ``(self.size,)`` (or\n``(np.ma.product(self.shape),)``).",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\nmask=[False,  True, False,  True, False,  True, False,  True,\nFalse],\nfill_value=999999)"
      }
    },
    {
      "name": "remainder",
      "signature": "remainder(a, b, *args, **kwargs)",
      "documentation": {
        "description": "remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend array."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor array.\nIf ``x1.shape != x2.shape``, they must be broadcastable to a common\nshape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "Computes the remainder complementary to the `floor_divide` function.  It is\nequivalent to the Python modulus operator``x1 % x2`` and has the same sign\nas the divisor `x2`. The MATLAB function equivalent to ``np.remainder``\nis ``mod``.\n.. warning::\nThis should not be confused with:\n* Python 3.7's `math.remainder` and C's ``remainder``, which\ncomputes the IEEE remainder, which are the complement to\n``round(x1 / x2)``.\n* The MATLAB ``rem`` function and or the C ``%`` operator which is the\ncomplement to ``int(x1 / x2)``.\n-------\ny : ndarray\nThe element-wise remainder of the quotient ``floor_divide(x1, x2)``.\nThis is a scalar if both `x1` and `x2` are scalars.\nintegers.\n``mod`` is an alias of ``remainder``.",
        "raises": "",
        "see_also": "--------\nfloor_divide : Equivalent of Python ``//`` operator.\ndivmod : Simultaneous floor division and remainder.\nfmod : Equivalent of the MATLAB ``rem`` function.\ndivide, floor",
        "notes": "-----",
        "examples": "--------\n>>> np.remainder([4, 7], [2, 3])\narray([0, 1])\n>>> np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])\nThe ``%`` operator can be used as a shorthand for ``np.remainder`` on\nndarrays.\n>>> x1 = np.arange(7)\n>>> x1 % 5\narray([0, 1, 2, 3, 4, 0, 1])"
      }
    },
    {
      "name": "repeat",
      "signature": "repeat(a, *args, **params)",
      "documentation": {
        "description": "repeat(self, *args, **params)\na.repeat(repeats, axis=None)\nRepeat elements of an array.\nRefer to `numpy.repeat` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.repeat : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "reshape",
      "signature": "reshape(a, new_shape, order='C')",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "Refer to `MaskedArray.reshape` for full documentation.",
        "raises": "",
        "see_also": "--------\nMaskedArray.reshape : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "resize",
      "signature": "resize(x, new_shape)",
      "documentation": {
        "description": "Return a new masked array with the specified size and shape.\nThis is the masked equivalent of the `numpy.resize` function. The new\narray is filled with repeated copies of `x` (in the order that the\ndata are stored in memory). If `x` is masked, the new array will be\nmasked, and the new mask will be a repetition of the old one.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.resize : Equivalent function in the top level NumPy module.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = ma.array([[1, 2] ,[3, 4]])\n>>> a[0, 1] = ma.masked\n>>> a\nmasked_array(\ndata=[[1, --],\n[3, 4]],\nmask=[[False,  True],\n[False, False]],\nfill_value=999999)\n>>> np.resize(a, (3, 3))\nmasked_array(\ndata=[[1, 2, 3],\n[4, 1, 2],\n[3, 4, 1]],\nmask=False,\nfill_value=999999)\n>>> ma.resize(a, (3, 3))\nmasked_array(\ndata=[[1, --, 3],\n[4, 1, --],\n[3, 4, 1]],\nmask=[[False,  True, False],\n[False, False,  True],\n[False, False, False]],\nfill_value=999999)\nA MaskedArray is always returned, regardless of the input type.\n>>> a = np.array([[1, 2] ,[3, 4]])\n>>> ma.resize(a, (3, 3))\nmasked_array(\ndata=[[1, 2, 3],\n[4, 1, 2],\n[3, 4, 1]],\nmask=False,\nfill_value=999999)"
      }
    },
    {
      "name": "right_shift",
      "signature": "right_shift(a, n)",
      "documentation": {
        "description": "Shift the bits of an integer to the right.\nThis is the masked array version of `numpy.right_shift`, for details\nsee that function.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.right_shift",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [11, 3, 8, 1]\n>>> mask = [0, 0, 0, 1]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(data=[11, 3, 8, --],\nmask=[False, False, False,  True],\nfill_value=999999)\n>>> ma.right_shift(masked_x,1)\nmasked_array(data=[5, 1, 4, --],\nmask=[False, False, False,  True],\nfill_value=999999)"
      }
    },
    {
      "name": "round",
      "signature": "round_(a, decimals=0, out=None)",
      "documentation": {
        "description": "Return a copy of a, rounded to 'decimals' places.\nWhen 'decimals' is negative, it specifies the number of positions\nto the left of the decimal point.  The real and imaginary parts of\ncomplex numbers are rounded separately. Nothing is done if the\narray is not of float type and 'decimals' is greater than or equal\nto 0.",
        "parameters": {
          "decimals": {
            "type": "int",
            "description": "Number of decimals to round to. May be negative."
          },
          "out": {
            "type": "array_like",
            "description": "Existing array to use for output.\nIf not given, returns a default copy of a."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "-----\nIf out is given and does not have a mask attribute, the mask of a\nis lost!",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [11.2, -3.973, 0.801, -1.41]\n>>> mask = [0, 0, 0, 1]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(data=[11.2, -3.973, 0.801, --],\nmask=[False, False, False, True],\nfill_value=1e+20)\n>>> ma.round_(masked_x)\nmasked_array(data=[11.0, -4.0, 1.0, --],\nmask=[False, False, False, True],\nfill_value=1e+20)\n>>> ma.round(masked_x, decimals=1)\nmasked_array(data=[11.2, -4.0, 0.8, --],\nmask=[False, False, False, True],\nfill_value=1e+20)\n>>> ma.round_(masked_x, decimals=-1)\nmasked_array(data=[10.0, -0.0, 0.0, --],\nmask=[False, False, False, True],\nfill_value=1e+20)"
      }
    },
    {
      "name": "round_",
      "signature": "round_(a, decimals=0, out=None)",
      "documentation": {
        "description": "Return a copy of a, rounded to 'decimals' places.\nWhen 'decimals' is negative, it specifies the number of positions\nto the left of the decimal point.  The real and imaginary parts of\ncomplex numbers are rounded separately. Nothing is done if the\narray is not of float type and 'decimals' is greater than or equal\nto 0.",
        "parameters": {
          "decimals": {
            "type": "int",
            "description": "Number of decimals to round to. May be negative."
          },
          "out": {
            "type": "array_like",
            "description": "Existing array to use for output.\nIf not given, returns a default copy of a."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "-----\nIf out is given and does not have a mask attribute, the mask of a\nis lost!",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [11.2, -3.973, 0.801, -1.41]\n>>> mask = [0, 0, 0, 1]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(data=[11.2, -3.973, 0.801, --],\nmask=[False, False, False, True],\nfill_value=1e+20)\n>>> ma.round_(masked_x)\nmasked_array(data=[11.0, -4.0, 1.0, --],\nmask=[False, False, False, True],\nfill_value=1e+20)\n>>> ma.round(masked_x, decimals=1)\nmasked_array(data=[11.2, -4.0, 0.8, --],\nmask=[False, False, False, True],\nfill_value=1e+20)\n>>> ma.round_(masked_x, decimals=-1)\nmasked_array(data=[10.0, -0.0, 0.0, --],\nmask=[False, False, False, True],\nfill_value=1e+20)"
      }
    },
    {
      "name": "row_stack",
      "signature": "vstack(x, *args, **params)",
      "documentation": {
        "description": "vstack\nStack arrays in sequence vertically (row wise).\nThis is equivalent to concatenation along the first axis after 1-D arrays\nof shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by\n`vsplit`.\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.\n``np.row_stack`` is an alias for `vstack`. They are the same function.",
        "parameters": {
          "tup": {
            "type": "sequence of ndarrays",
            "description": "The arrays must have the same shape along all but the first axis.\n1-D arrays must have the same length."
          },
          "dtype": {
            "type": "str or dtype",
            "description": "If provided, the destination array will have this dtype. Cannot be\nprovided together with `out`.\n.. versionadded:: 1.24"
          },
          "casting": {
            "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
            "description": "Controls what kind of data casting may occur. Defaults to 'same_kind'.\n.. versionadded:: 1.24"
          }
        },
        "returns": "-------\nstacked : ndarray\nThe array formed by stacking the given arrays, will be at least 2-D.",
        "raises": "",
        "see_also": "--------\nconcatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nblock : Assemble an nd-array from nested lists of blocks.\nhstack : Stack arrays in sequence horizontally (column wise).\ndstack : Stack arrays in sequence depth wise (along third axis).\ncolumn_stack : Stack 1-D arrays as columns into a 2-D array.\nvsplit : Split an array into multiple sub-arrays vertically (row-wise).",
        "notes": "-----\nThe function is applied to both the _data and the _mask, if any.",
        "examples": "--------\n>>> a = np.array([1, 2, 3])\n>>> b = np.array([4, 5, 6])\n>>> np.vstack((a,b))\narray([[1, 2, 3],\n[4, 5, 6]])\n>>> a = np.array([[1], [2], [3]])\n>>> b = np.array([[4], [5], [6]])\n>>> np.vstack((a,b))\narray([[1],\n[2],\n[3],\n[4],\n[5],\n[6]])"
      }
    },
    {
      "name": "set_fill_value",
      "signature": "set_fill_value(a, fill_value)",
      "documentation": {
        "description": "Set the filling value of a, if a is a masked array.\nThis function changes the fill value of the masked array `a` in place.\nIf `a` is not a masked array, the function returns silently, without\ndoing anything.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array."
          },
          "fill_value": {
            "type": "dtype",
            "description": "Filling value. A consistency test is performed to make sure\nthe value is compatible with the dtype of `a`."
          }
        },
        "returns": "-------\nNone\nNothing returned by this function.",
        "raises": "",
        "see_also": "--------\nmaximum_fill_value : Return the default fill value for a dtype.\nMaskedArray.fill_value : Return current fill value.\nMaskedArray.set_fill_value : Equivalent method.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = np.arange(5)\n>>> a\narray([0, 1, 2, 3, 4])\n>>> a = ma.masked_where(a < 3, a)\n>>> a\nmasked_array(data=[--, --, --, 3, 4],\nmask=[ True,  True,  True, False, False],\nfill_value=999999)\n>>> ma.set_fill_value(a, -999)\n>>> a\nmasked_array(data=[--, --, --, 3, 4],\nmask=[ True,  True,  True, False, False],\nfill_value=-999)\nNothing happens if `a` is not a masked array.\n>>> a = list(range(5))\n>>> a\n[0, 1, 2, 3, 4]\n>>> ma.set_fill_value(a, 100)\n>>> a\n[0, 1, 2, 3, 4]\n>>> a = np.arange(5)\n>>> a\narray([0, 1, 2, 3, 4])\n>>> ma.set_fill_value(a, 100)\n>>> a\narray([0, 1, 2, 3, 4])"
      }
    },
    {
      "name": "setdiff1d",
      "signature": "setdiff1d(ar1, ar2, assume_unique=False)",
      "documentation": {
        "description": "Set difference of 1D arrays with unique elements.\nThe output is always a masked array. See `numpy.setdiff1d` for more\ndetails.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.setdiff1d : Equivalent function for ndarrays.",
        "notes": "",
        "examples": "--------\n>>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])\n>>> np.ma.setdiff1d(x, [1, 2])\nmasked_array(data=[3, --],\nmask=[False,  True],\nfill_value=999999)"
      }
    },
    {
      "name": "setxor1d",
      "signature": "setxor1d(ar1, ar2, assume_unique=False)",
      "documentation": {
        "description": "Set exclusive-or of 1-D arrays with unique elements.\nThe output is always a masked array. See `numpy.setxor1d` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.setxor1d : Equivalent function for ndarrays.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "shape",
      "signature": "shape(obj)",
      "documentation": {
        "description": "Return the shape of an array.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array."
          }
        },
        "returns": "-------\nshape : tuple of ints\nThe elements of the shape tuple give the lengths of the\ncorresponding array dimensions.",
        "raises": "",
        "see_also": "--------\nlen : ``len(a)`` is equivalent to ``np.shape(a)[0]`` for N-D arrays with\n``N>=1``.\nndarray.shape : Equivalent array method.",
        "notes": "",
        "examples": "--------\n>>> np.shape(np.eye(3))\n(3, 3)\n>>> np.shape([[1, 3]])\n(1, 2)\n>>> np.shape([0])\n(1,)\n>>> np.shape(0)\n()\n>>> a = np.array([(1, 2), (3, 4), (5, 6)],\n...              dtype=[('x', 'i4'), ('y', 'i4')])\n>>> np.shape(a)\n(3,)\n>>> a.shape\n(3,)"
      }
    },
    {
      "name": "sin",
      "signature": "sin(a, *args, **kwargs)",
      "documentation": {
        "description": "sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nTrigonometric sine, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Angle, in radians (:math:`2 \\pi` rad equals 360 degrees)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : array_like\nThe sine of each element of x.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\narcsin, sinh, cos",
        "notes": "-----\nThe sine is one of the fundamental functions of trigonometry (the\nmathematical study of triangles).  Consider a circle of radius 1\ncentered on the origin.  A ray comes in from the :math:`+x` axis, makes\nan angle at the origin (measured counter-clockwise from that axis), and\ndeparts from the origin.  The :math:`y` coordinate of the outgoing\nray's intersection with the unit circle is the sine of that angle.  It\nranges from -1 for :math:`x=3\\pi / 2` to +1 for :math:`\\pi / 2.`  The\nfunction has zeroes where the angle is a multiple of :math:`\\pi`.\nSines of angles between :math:`\\pi` and :math:`2\\pi` are negative.\nThe numerous properties of the sine and related functions are included\nin any standard trigonometry text.",
        "examples": "--------\nPrint sine of one angle:\n>>> np.sin(np.pi/2.)\n1.0\nPrint sines of an array of angles given in degrees:\n>>> np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )\narray([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])\nPlot the sine function:\n>>> import matplotlib.pylab as plt\n>>> x = np.linspace(-np.pi, np.pi, 201)\n>>> plt.plot(x, np.sin(x))\n>>> plt.xlabel('Angle [rad]')\n>>> plt.ylabel('sin(x)')\n>>> plt.axis('tight')\n>>> plt.show()"
      }
    },
    {
      "name": "sinh",
      "signature": "sinh(a, *args, **kwargs)",
      "documentation": {
        "description": "sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nHyperbolic sine, element-wise.\nEquivalent to ``1/2 * (np.exp(x) - np.exp(-x))`` or\n``-1j * np.sin(1j*x)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray\nThe corresponding hyperbolic sine values.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "-----\nIf `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\nReferences\n----------\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972, pg. 83.",
        "examples": "--------\n>>> np.sinh(0)\n0.0\n>>> np.sinh(np.pi*1j/2)\n1j\n>>> np.sinh(np.pi*1j) # (exact value is 0)\n1.2246063538223773e-016j\n>>> # Discrepancy due to vagaries of floating point arithmetic.\n>>> # Example of providing the optional output parameter\n>>> out1 = np.array([0], dtype='d')\n>>> out2 = np.sinh([0.1], out1)\n>>> out2 is out1\nTrue\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.sinh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)"
      }
    },
    {
      "name": "size",
      "signature": "size(obj, axis=None)",
      "documentation": {
        "description": "Return the number of elements along a given axis.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input data."
          },
          "axis": {
            "type": "int, optional",
            "description": "Axis along which the elements are counted.  By default, give\nthe total number of elements."
          }
        },
        "returns": "-------\nelement_count : int\nNumber of elements along the specified axis.",
        "raises": "",
        "see_also": "--------\nshape : dimensions of array\nndarray.shape : dimensions of array\nndarray.size : number of elements in array",
        "notes": "",
        "examples": "--------\n>>> a = np.array([[1,2,3],[4,5,6]])\n>>> np.size(a)\n6\n>>> np.size(a,1)\n3\n>>> np.size(a,0)\n2"
      }
    },
    {
      "name": "soften_mask",
      "signature": "soften_mask(a, *args, **params)",
      "documentation": {
        "description": "soften_mask(self)\nForce the mask to soft (default), allowing unmasking by assignment.\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `soften_mask` sets\n`~ma.MaskedArray.hardmask` to ``False`` (and returns the modified\nself).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nma.MaskedArray.hardmask\nma.MaskedArray.harden_mask",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sometrue",
      "signature": "reduce(target, axis=0, dtype=None)",
      "documentation": {
        "description": "Reduce `target` along the given `axis`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sort",
      "signature": "sort(a, axis=-1, kind=None, order=None, endwith=True, fill_value=None)",
      "documentation": {
        "description": "Return a sorted copy of the masked array.\nEquivalent to creating a copy of the array\nand applying the  MaskedArray ``sort()`` method.\nRefer to ``MaskedArray.sort`` for the full documentation",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nMaskedArray.sort : equivalent method",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [11.2, -3.973, 0.801, -1.41]\n>>> mask = [0, 0, 0, 1]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(data=[11.2, -3.973, 0.801, --],\nmask=[False, False, False,  True],\nfill_value=1e+20)\n>>> ma.sort(masked_x)\nmasked_array(data=[-3.973, 0.801, 11.2, --],\nmask=[False, False, False,  True],\nfill_value=1e+20)"
      }
    },
    {
      "name": "sqrt",
      "signature": "sqrt(a, *args, **kwargs)",
      "documentation": {
        "description": "sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nReturn the non-negative square-root of an array, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "The values whose square-roots are required."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray\nAn array of the same shape as `x`, containing the positive\nsquare-root of each element in `x`.  If any element in `x` is\ncomplex, a complex array is returned (and the square-roots of\nnegative reals are calculated).  If all of the elements in `x`\nare real, so is `y`, with negative elements returning ``nan``.\nIf `out` was provided, `y` is a reference to it.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "--------\nemath.sqrt\nA version which returns complex numbers when given negative reals.\nNote that 0.0 and -0.0 are handled differently for complex inputs.",
        "notes": "-----\n*sqrt* has--consistent with common convention--as its branch cut the\nreal \"interval\" [`-inf`, 0), and is continuous from above on it.\nA branch cut is a curve in the complex plane across which a given\ncomplex function fails to be continuous.",
        "examples": "--------\n>>> np.sqrt([1,4,9])\narray([ 1.,  2.,  3.])\n>>> np.sqrt([4, -1, -3+4J])\narray([ 2.+0.j,  0.+1.j,  1.+2.j])\n>>> np.sqrt([4, -1, np.inf])\narray([ 2., nan, inf])"
      }
    },
    {
      "name": "stack",
      "signature": "stack(x, *args, **params)",
      "documentation": {
        "description": "stack\nJoin a sequence of arrays along a new axis.\nThe ``axis`` parameter specifies the index of the new axis in the\ndimensions of the result. For example, if ``axis=0`` it will be the first\ndimension and if ``axis=-1`` it will be the last dimension.\n.. versionadded:: 1.10.0",
        "parameters": {
          "arrays": {
            "type": "sequence of array_like",
            "description": "Each array must have the same shape."
          },
          "axis": {
            "type": "int, optional",
            "description": "The axis in the result array along which the input arrays are stacked."
          },
          "out": {
            "type": "ndarray, optional",
            "description": "If provided, the destination to place the result. The shape must be\ncorrect, matching that of what stack would have returned if no\nout argument were specified."
          },
          "dtype": {
            "type": "str or dtype",
            "description": "If provided, the destination array will have this dtype. Cannot be\nprovided together with `out`.\n.. versionadded:: 1.24"
          },
          "casting": {
            "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
            "description": "Controls what kind of data casting may occur. Defaults to 'same_kind'.\n.. versionadded:: 1.24"
          }
        },
        "returns": "-------\nstacked : ndarray\nThe stacked array has one more dimension than the input arrays.",
        "raises": "",
        "see_also": "--------\nconcatenate : Join a sequence of arrays along an existing axis.\nblock : Assemble an nd-array from nested lists of blocks.\nsplit : Split array into a list of multiple sub-arrays of equal size.",
        "notes": "-----\nThe function is applied to both the _data and the _mask, if any.",
        "examples": "--------\n>>> arrays = [np.random.randn(3, 4) for _ in range(10)]\n>>> np.stack(arrays, axis=0).shape\n(10, 3, 4)\n>>> np.stack(arrays, axis=1).shape\n(3, 10, 4)\n>>> np.stack(arrays, axis=2).shape\n(3, 4, 10)\n>>> a = np.array([1, 2, 3])\n>>> b = np.array([4, 5, 6])\n>>> np.stack((a, b))\narray([[1, 2, 3],\n[4, 5, 6]])\n>>> np.stack((a, b), axis=-1)\narray([[1, 4],\n[2, 5],\n[3, 6]])"
      }
    },
    {
      "name": "std",
      "signature": "std(a, *args, **params)",
      "documentation": {
        "description": "std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
        "parameters": {},
        "returns": "Masked entries are ignored.\nRefer to `numpy.std` for full documentation.",
        "raises": "",
        "see_also": "--------\nnumpy.ndarray.std : corresponding function for ndarrays\nnumpy.std : Equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "subtract",
      "signature": "subtract(a, b, *args, **kwargs)",
      "documentation": {
        "description": "subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nSubtract arguments, element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray\nThe difference of `x1` and `x2`, element-wise.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "",
        "notes": "-----\nEquivalent to ``x1 - x2`` in terms of array broadcasting.",
        "examples": "--------\n>>> np.subtract(1.0, 4.0)\n-3.0\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.subtract(x1, x2)\narray([[ 0.,  0.,  0.],\n[ 3.,  3.,  3.],\n[ 6.,  6.,  6.]])\nThe ``-`` operator can be used as a shorthand for ``np.subtract`` on\nndarrays.\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> x1 - x2\narray([[0., 0., 0.],\n[3., 3., 3.],\n[6., 6., 6.]])"
      }
    },
    {
      "name": "sum",
      "signature": "sum(a, *args, **params)",
      "documentation": {
        "description": "sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)\nReturn the sum of the array elements over the given axis.\nMasked elements are set to 0 internally.\nRefer to `numpy.sum` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.ndarray.sum : corresponding function for ndarrays\nnumpy.sum : equivalent function",
        "notes": "",
        "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.sum()\n25\n>>> x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\nmask=[False, False, False],\nfill_value=999999)\n>>> x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\nmask=[False, False, False],\nfill_value=999999)\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<class 'numpy.int64'>"
      }
    },
    {
      "name": "swapaxes",
      "signature": "swapaxes(a, *args, **params)",
      "documentation": {
        "description": "swapaxes(self, *args, **params)\na.swapaxes(axis1, axis2)\nReturn a view of the array with `axis1` and `axis2` interchanged.\nRefer to `numpy.swapaxes` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.swapaxes : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "take",
      "signature": "take(a, indices, axis=None, out=None, mode='raise')",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "tan",
      "signature": "tan(a, *args, **kwargs)",
      "documentation": {
        "description": "tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCompute tangent element-wise.\nEquivalent to ``np.sin(x)/np.cos(x)`` element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray\nThe corresponding tangent values.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "-----\nIf `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\nReferences\n----------\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972.",
        "examples": "--------\n>>> from math import pi\n>>> np.tan(np.array([-pi,pi/2,pi]))\narray([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])\n>>>\n>>> # Example of providing the optional output parameter illustrating\n>>> # that what is returned is a reference to said parameter\n>>> out1 = np.array([0], dtype='d')\n>>> out2 = np.cos([0.1], out1)\n>>> out2 is out1\nTrue\n>>>\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)"
      }
    },
    {
      "name": "tanh",
      "signature": "tanh(a, *args, **kwargs)",
      "documentation": {
        "description": "tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nCompute hyperbolic tangent element-wise.\nEquivalent to ``np.sinh(x)/np.cosh(x)`` or ``-1j * np.tan(1j*x)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray\nThe corresponding hyperbolic tangent values.\nThis is a scalar if `x` is a scalar.",
        "raises": "",
        "see_also": "",
        "notes": "-----\nIf `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\nReferences\n----------\n.. [1] M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972, pg. 83.\nhttps://personal.math.ubc.ca/~cbm/aands/page_83.htm\n.. [2] Wikipedia, \"Hyperbolic function\",\nhttps://en.wikipedia.org/wiki/Hyperbolic_function",
        "examples": "--------\n>>> np.tanh((0, np.pi*1j, np.pi*1j/2))\narray([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])\n>>> # Example of providing the optional output parameter illustrating\n>>> # that what is returned is a reference to said parameter\n>>> out1 = np.array([0], dtype='d')\n>>> out2 = np.tanh([0.1], out1)\n>>> out2 is out1\nTrue\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.tanh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)"
      }
    },
    {
      "name": "trace",
      "signature": "trace(a, *args, **params)",
      "documentation": {
        "description": "trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)\na.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\nReturn the sum along diagonals of the array.\nRefer to `numpy.trace` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.trace : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "transpose",
      "signature": "transpose(a, axes=None)",
      "documentation": {
        "description": "Permute the dimensions of an array.\nThis function is exactly equivalent to `numpy.transpose`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.transpose : Equivalent function in top-level NumPy module.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> x = ma.arange(4).reshape((2,2))\n>>> x[1, 1] = ma.masked\n>>> x\nmasked_array(\ndata=[[0, 1],\n[2, --]],\nmask=[[False, False],\n[False,  True]],\nfill_value=999999)\n>>> ma.transpose(x)\nmasked_array(\ndata=[[0, 2],\n[1, --]],\nmask=[[False, False],\n[False,  True]],\nfill_value=999999)"
      }
    },
    {
      "name": "true_divide",
      "signature": "divide(a, b, *args, **kwargs)",
      "documentation": {
        "description": "divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\nDivide arguments element-wise.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend array."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor array.\nIf ``x1.shape != x2.shape``, they must be broadcastable to a common\nshape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray, None, or tuple of ndarray and None, optional",
            "description": "A location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like, optional",
            "description": "This condition is broadcast over the input. At locations where the\ncondition is True, the `out` array will be set to the ufunc result.\nElsewhere, the `out` array will retain its original value.\nNote that if an uninitialized `out` array is created via the default\n``out=None``, locations within it where the condition is False will\nremain uninitialized.\n**kwargs\nFor other keyword-only arguments, see the\n:ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "-------\ny : ndarray or scalar\nThe quotient ``x1/x2``, element-wise.\nThis is a scalar if both `x1` and `x2` are scalars.",
        "raises": "",
        "see_also": "--------\nseterr : Set whether to raise or warn on overflow, underflow and\ndivision by zero.",
        "notes": "-----\nEquivalent to ``x1`` / ``x2`` in terms of array-broadcasting.\nThe ``true_divide(x1, x2)`` function is an alias for\n``divide(x1, x2)``.",
        "examples": "--------\n>>> np.divide(2.0, 4.0)\n0.5\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.divide(x1, x2)\narray([[nan, 1. , 1. ],\n[inf, 4. , 2.5],\n[inf, 7. , 4. ]])\nThe ``/`` operator can be used as a shorthand for ``np.divide`` on\nndarrays.\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = 2 * np.ones(3)\n>>> x1 / x2\narray([[0. , 0.5, 1. ],\n[1.5, 2. , 2.5],\n[3. , 3.5, 4. ]])"
      }
    },
    {
      "name": "union1d",
      "signature": "union1d(ar1, ar2)",
      "documentation": {
        "description": "Union of two arrays.\nThe output is always a masked array. See `numpy.union1d` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.union1d : Equivalent function for ndarrays.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "unique",
      "signature": "unique(ar1, return_index=False, return_inverse=False)",
      "documentation": {
        "description": "Finds the unique elements of an array.\nMasked values are considered the same element (masked). The output array\nis always a masked array. See `numpy.unique` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\nnumpy.unique : Equivalent function for ndarrays.",
        "notes": "",
        "examples": "--------\n>>> import numpy.ma as ma\n>>> a = [1, 2, 1000, 2, 3]\n>>> mask = [0, 0, 1, 0, 0]\n>>> masked_a = ma.masked_array(a, mask)\n>>> masked_a\nmasked_array(data=[1, 2, --, 2, 3],\nmask=[False, False,  True, False, False],\nfill_value=999999)\n>>> ma.unique(masked_a)\nmasked_array(data=[1, 2, 3, --],\nmask=[False, False, False,  True],\nfill_value=999999)\n>>> ma.unique(masked_a, return_index=True)\n(masked_array(data=[1, 2, 3, --],\nmask=[False, False, False,  True],\nfill_value=999999), array([0, 1, 4, 2]))\n>>> ma.unique(masked_a, return_inverse=True)\n(masked_array(data=[1, 2, 3, --],\nmask=[False, False, False,  True],\nfill_value=999999), array([0, 1, 3, 1, 2]))\n>>> ma.unique(masked_a, return_index=True, return_inverse=True)\n(masked_array(data=[1, 2, 3, --],\nmask=[False, False, False,  True],\nfill_value=999999), array([0, 1, 4, 2]), array([0, 1, 3, 1, 2]))"
      }
    },
    {
      "name": "vander",
      "signature": "vander(x, n=None)",
      "documentation": {
        "description": "Generate a Vandermonde matrix.\nThe columns of the output matrix are powers of the input vector. The\norder of the powers is determined by the `increasing` boolean argument.\nSpecifically, when `increasing` is False, the `i`-th output column is\nthe input vector raised element-wise to the power of ``N - i - 1``. Such\na matrix with a geometric progression in each row is named for Alexandre-\nTheophile Vandermonde.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "1-D input array."
          },
          "N": {
            "type": "int, optional",
            "description": "Number of columns in the output.  If `N` is not specified, a square\narray is returned (``N = len(x)``)."
          },
          "increasing": {
            "type": "bool, optional",
            "description": "Order of the powers of the columns.  If True, the powers increase\nfrom left to right, if False (the default) they are reversed.\n.. versionadded:: 1.9.0"
          }
        },
        "returns": "-------\nout : ndarray\nVandermonde matrix.  If `increasing` is False, the first column is\n``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is\nTrue, the columns are ``x^0, x^1, ..., x^(N-1)``.",
        "raises": "",
        "see_also": "--------\npolynomial.polynomial.polyvander",
        "notes": "-----\nMasked values in the input array result in rows of zeros.",
        "examples": "--------\n>>> x = np.array([1, 2, 3, 5])\n>>> N = 3\n>>> np.vander(x, N)\narray([[ 1,  1,  1],\n[ 4,  2,  1],\n[ 9,  3,  1],\n[25,  5,  1]])\n>>> np.column_stack([x**(N-1-i) for i in range(N)])\narray([[ 1,  1,  1],\n[ 4,  2,  1],\n[ 9,  3,  1],\n[25,  5,  1]])\n>>> x = np.array([1, 2, 3, 5])\n>>> np.vander(x)\narray([[  1,   1,   1,   1],\n[  8,   4,   2,   1],\n[ 27,   9,   3,   1],\n[125,  25,   5,   1]])\n>>> np.vander(x, increasing=True)\narray([[  1,   1,   1,   1],\n[  1,   2,   4,   8],\n[  1,   3,   9,  27],\n[  1,   5,  25, 125]])\nThe determinant of a square Vandermonde matrix is the product\nof the differences between the values of the input vector:\n>>> np.linalg.det(np.vander(x))\n48.000000000000043 # may vary\n>>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n48"
      }
    },
    {
      "name": "var",
      "signature": "var(a, *args, **params)",
      "documentation": {
        "description": "var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)\nCompute the variance along the specified axis.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Array containing numbers whose variance is desired.  If `a` is not an\narray, a conversion is attempted."
          },
          "axis": {
            "type": "None or int or tuple of ints, optional",
            "description": "Axis or axes along which the variance is computed.  The default is to\ncompute the variance of the flattened array.\n.. versionadded:: 1.7.0\nIf this is a tuple of ints, a variance is performed over multiple axes,\ninstead of a single axis or all the axes as before."
          },
          "dtype": {
            "type": "data-type, optional",
            "description": "Type to use in computing the variance.  For arrays of integer type\nthe default is `float64`; for arrays of float types it is the same as\nthe array type."
          },
          "out": {
            "type": "ndarray, optional",
            "description": "Alternate output array in which to place the result.  It must have\nthe same shape as the expected output, but the type is cast if\nnecessary."
          },
          "ddof": {
            "type": "int, optional",
            "description": "\"Delta Degrees of Freedom\": the divisor used in the calculation is\n``N - ddof``, where ``N`` represents the number of elements. By\ndefault `ddof` is zero."
          },
          "keepdims": {
            "type": "bool, optional",
            "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then `keepdims` will not be\npassed through to the `var` method of sub-classes of\n`ndarray`, however any non-default value will be.  If the\nsub-class' method does not implement `keepdims` any\nexceptions will be raised."
          },
          "where": {
            "type": "array_like of bool, optional",
            "description": "Elements to include in the variance. See `~numpy.ufunc.reduce` for\ndetails.\n.. versionadded:: 1.20.0"
          }
        },
        "returns": "distribution.  The variance is computed for the flattened array by\ndefault, otherwise over the specified axis.\n-------\nvariance : ndarray, see dtype parameter above\nIf ``out=None``, returns a new array containing the variance;\notherwise, a reference to the output array is returned.",
        "raises": "",
        "see_also": "--------\nstd, mean, nanmean, nanstd, nanvar\n:ref:`ufuncs-output-type`",
        "notes": "-----\nThe variance is the average of the squared deviations from the mean,\ni.e.,  ``var = mean(x)``, where ``x = abs(a - a.mean())**2``.\nThe mean is typically calculated as ``x.sum() / N``, where ``N = len(x)``.\nIf, however, `ddof` is specified, the divisor ``N - ddof`` is used\ninstead.  In standard statistical practice, ``ddof=1`` provides an\nunbiased estimator of the variance of a hypothetical infinite population.\n``ddof=0`` provides a maximum likelihood estimate of the variance for\nnormally distributed variables.\nNote that for complex numbers, the absolute value is taken before\nsquaring, so that the result is always real and nonnegative.\nFor floating-point input, the variance is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for `float32` (see example\nbelow).  Specifying a higher-accuracy accumulator using the ``dtype``\nkeyword can alleviate this issue.",
        "examples": "--------\n>>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([1.,  1.])\n>>> np.var(a, axis=1)\narray([0.25,  0.25])\nIn single precision, var() can be inaccurate:\n>>> a = np.zeros((2, 512*512), dtype=np.float32)\n>>> a[0, :] = 1.0\n>>> a[1, :] = 0.1\n>>> np.var(a)\n0.20250003\nComputing the variance in float64 is more accurate:\n>>> np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n>>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\nSpecifying a where argument:\n>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])\n>>> np.var(a)\n6.833333333333333 # may vary\n>>> np.var(a, where=[[True], [True], [False]])\n4.0"
      }
    },
    {
      "name": "vstack",
      "signature": "vstack(x, *args, **params)",
      "documentation": {
        "description": "vstack\nStack arrays in sequence vertically (row wise).\nThis is equivalent to concatenation along the first axis after 1-D arrays\nof shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by\n`vsplit`.\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.\n``np.row_stack`` is an alias for `vstack`. They are the same function.",
        "parameters": {
          "tup": {
            "type": "sequence of ndarrays",
            "description": "The arrays must have the same shape along all but the first axis.\n1-D arrays must have the same length."
          },
          "dtype": {
            "type": "str or dtype",
            "description": "If provided, the destination array will have this dtype. Cannot be\nprovided together with `out`.\n.. versionadded:: 1.24"
          },
          "casting": {
            "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
            "description": "Controls what kind of data casting may occur. Defaults to 'same_kind'.\n.. versionadded:: 1.24"
          }
        },
        "returns": "-------\nstacked : ndarray\nThe array formed by stacking the given arrays, will be at least 2-D.",
        "raises": "",
        "see_also": "--------\nconcatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nblock : Assemble an nd-array from nested lists of blocks.\nhstack : Stack arrays in sequence horizontally (column wise).\ndstack : Stack arrays in sequence depth wise (along third axis).\ncolumn_stack : Stack 1-D arrays as columns into a 2-D array.\nvsplit : Split an array into multiple sub-arrays vertically (row-wise).",
        "notes": "-----\nThe function is applied to both the _data and the _mask, if any.",
        "examples": "--------\n>>> a = np.array([1, 2, 3])\n>>> b = np.array([4, 5, 6])\n>>> np.vstack((a,b))\narray([[1, 2, 3],\n[4, 5, 6]])\n>>> a = np.array([[1], [2], [3]])\n>>> b = np.array([[4], [5], [6]])\n>>> np.vstack((a,b))\narray([[1],\n[2],\n[3],\n[4],\n[5],\n[6]])"
      }
    },
    {
      "name": "where",
      "signature": "where(condition, x=<no value>, y=<no value>)",
      "documentation": {
        "description": "Return a masked array with elements from `x` or `y`, depending on condition.\n.. note::\nWhen only `condition` is provided, this function is identical to\n`nonzero`. The rest of this documentation covers only the case where\nall three arguments are provided.",
        "parameters": {
          "condition": {
            "type": "array_like, bool",
            "description": "Where True, yield `x`, otherwise yield `y`.\nx, y : array_like, optional\nValues from which to choose. `x`, `y` and `condition` need to be\nbroadcastable to some shape."
          }
        },
        "returns": "-------\nout : MaskedArray\nAn masked array with `masked` elements where the condition is masked,\nelements from `x` where `condition` is True, and elements from `y`\nelsewhere.",
        "raises": "",
        "see_also": "--------\nnumpy.where : Equivalent function in the top-level NumPy module.\nnonzero : The function that is called when x and y are omitted",
        "notes": "",
        "examples": "--------\n>>> x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],\n...                                                    [1, 0, 1],\n...                                                    [0, 1, 0]])\n>>> x\nmasked_array(\ndata=[[0.0, --, 2.0],\n[--, 4.0, --],\n[6.0, --, 8.0]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=1e+20)\n>>> np.ma.where(x > 5, x, -3.1416)\nmasked_array(\ndata=[[-3.1416, --, -3.1416],\n[--, -3.1416, --],\n[6.0, --, 8.0]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=1e+20)"
      }
    }
  ],
  "classes": [
    {
      "name": "MAError",
      "documentation": {
        "description": "Class for masked array related errors.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "documentation": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "MaskError",
      "documentation": {
        "description": "Class for mask related errors.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(...)",
          "documentation": {
            "description": "Exception.add_note(note) --\nadd a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(...)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\nset self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "MaskType",
      "documentation": {
        "description": "Boolean type (True or False), stored as a byte.\n.. warning::\nThe :class:`bool_` type is not a subclass of the :class:`int_` type\n(the :class:`bool_` is not even a number type). This is different\nthan Python's default implementation of :class:`bool` as a\nsub-class of :class:`int`.\n:Character code: ``'?'``",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "MaskedArray",
      "documentation": {
        "description": "An array class with possibly masked values.\nMasked values of True exclude the corresponding element from any\ncomputation.\nConstruction::\nx = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\nndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\nshrink=True, order=None)",
        "parameters": {
          "data": {
            "type": "array_like",
            "description": "Input data."
          },
          "mask": {
            "type": "sequence, optional",
            "description": "Mask. Must be convertible to an array of booleans with the same\nshape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Data type of the output.\nIf `dtype` is None, the type of the data argument (``data.dtype``)\nis used. If `dtype` is not None and different from ``data.dtype``,\na copy is performed."
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to copy the input data (True), or to use a reference instead.\nDefault is False."
          },
          "subok": {
            "type": "bool, optional",
            "description": "Whether to return a subclass of `MaskedArray` if possible (True) or a\nplain `MaskedArray`. Default is True."
          },
          "ndmin": {
            "type": "int, optional",
            "description": "Minimum number of dimensions. Default is 0."
          },
          "fill_value": {
            "type": "scalar, optional",
            "description": "Value used to fill in the masked values when necessary.\nIf None, a default based on the data-type is used."
          },
          "keep_mask": {
            "type": "bool, optional",
            "description": "Whether to combine `mask` with the mask of the input data, if any\n(True), or to use only `mask` for the output (False). Default is True."
          },
          "hard_mask": {
            "type": "bool, optional",
            "description": "Whether to use a hard mask or not. With a hard mask, masked values\ncannot be unmasked. Default is False."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to force compression of an empty mask. Default is True."
          },
          "order": {
            "type": "{'C', 'F', 'A'}, optional",
            "description": "Specify the order of the array.  If order is 'C', then the array\nwill be in C-contiguous order (last-index varies the fastest).\nIf order is 'F', then the returned array will be in\nFortran-contiguous order (first-index varies the fastest).\nIf order is 'A' (default), then the returned array may be\nin any order (either C-, Fortran-contiguous, or even discontiguous),\nunless a copy is required, in which case it will be C-contiguous."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\nThe ``mask`` can be initialized with an array of boolean values\nwith the same shape as ``data``.\n>>> data = np.arange(6).reshape((2, 3))\n>>> np.ma.MaskedArray(data, mask=[[False, True, False],\n...                               [False, False, True]])\nmasked_array(\ndata=[[0, --, 2],\n[3, 4, --]],\nmask=[[False,  True, False],\n[False, False,  True]],\nfill_value=999999)\nAlternatively, the ``mask`` can be initialized to homogeneous boolean\narray with the same shape as ``data`` by passing in a scalar\nboolean value:\n>>> np.ma.MaskedArray(data, mask=False)\nmasked_array(\ndata=[[0, 1, 2],\n[3, 4, 5]],\nmask=[[False, False, False],\n[False, False, False]],\nfill_value=999999)\n>>> np.ma.MaskedArray(data, mask=True)\nmasked_array(\ndata=[[--, --, --],\n[--, --, --]],\nmask=[[ True,  True,  True],\n[ True,  True,  True]],\nfill_value=999999,\ndtype=int64)\n.. note::\nThe recommended practice for initializing ``mask`` with a scalar\nboolean value is to use ``True``/``False`` rather than\n``np.True_``/``np.False_``. The reason is :attr:`nomask`\nis represented internally as ``np.False_``.\n>>> np.False_ is np.ma.nomask\nTrue"
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(self, axis=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "The output array is masked where all the values along the given axis\nare masked: if the output would have been a scalar and that all the\nvalues are masked, then the output is `masked`.\nRefer to `numpy.all` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.all : corresponding function for ndarrays\nnumpy.all : equivalent function",
            "notes": "",
            "examples": "--------\n>>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue"
          }
        },
        {
          "name": "anom",
          "signature": "anom(self, axis=None, dtype=None)",
          "documentation": {
            "description": "Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.",
            "parameters": {
              "axis": {
                "type": "int, optional",
                "description": "Axis over which the anomalies are taken.\nThe default is to use the mean of the flattened array as reference."
              },
              "dtype": {
                "type": "dtype, optional",
                "description": "Type to use in computing the variance. For arrays of integer type\nthe default is float32; for arrays of float types it is the same as\nthe array type."
              }
            },
            "returns": "where the arithmetic mean is computed along the given axis.",
            "raises": "",
            "see_also": "--------\nmean : Compute the mean of the array.",
            "notes": "",
            "examples": "--------\n>>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data=[-1.,  0.,  1.],\nmask=False,\nfill_value=1e+20)"
          }
        },
        {
          "name": "any",
          "signature": "any(self, axis=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "Masked values are considered as False during computation.\nRefer to `numpy.any` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.any : corresponding function for ndarrays\nnumpy.any : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {
              "axis": {
                "type": "{None, integer}",
                "description": "If None, the index is into the flattened array, otherwise along\nthe specified axis"
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.  If None, the output of\nmaximum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None, array}, optional",
                "description": "Array into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output."
              }
            },
            "returns": "Masked values are treated as if they had the value fill_value.\n-------\nindex_array : {integer_array}",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])"
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "documentation": {
            "description": "Return array of indices to the minimum values along the given axis.",
            "parameters": {
              "axis": {
                "type": "{None, integer}",
                "description": "If None, the index is into the flattened array, otherwise along\nthe specified axis"
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.  If None, the output of\nminimum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None, array}, optional",
                "description": "Array into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output."
              }
            },
            "returns": "-------\nndarray or scalar\nIf multi-dimension input, returns a new ndarray of indices to the\nminimum values along the given axis.  Otherwise, returns a scalar\nof index to the minimum values along the given axis.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> x\nmasked_array(\ndata=[[--, --],\n[2, 3]],\nmask=[[ True,  True],\n[False, False]],\nfill_value=999999)\n>>> x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n>>> x.argmin(axis=0, fill_value=9)\narray([1, 1])"
          }
        },
        {
          "name": "argpartition",
          "signature": "argpartition(self, *args, **kwargs)",
          "documentation": {
            "description": "a.argpartition(kth, axis=-1, kind='introselect', order=None)",
            "parameters": {},
            "returns": "Refer to `numpy.argpartition` for full documentation.\n.. versionadded:: 1.8.0",
            "raises": "",
            "see_also": "--------\nnumpy.argpartition : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(self, axis=<no value>, kind=None, order=None, endwith=True, fill_value=None)",
          "documentation": {
            "description": "Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\n`fill_value`.",
            "parameters": {
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. If None, the default, the flattened array\nis used.\n..  versionchanged:: 1.13.0\nPreviously, the default was documented to be -1, but that was\nin error. At some future date, the default will change to -1, as\noriginally intended.\nUntil then, the axis should be given explicitly when\n``arr.ndim > 1``, to avoid a FutureWarning."
              },
              "kind": {
                "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
                "description": "The sorting algorithm used."
              },
              "order": {
                "type": "list, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  Not all fields need be\nspecified."
              },
              "endwith": {
                "type": "{True, False}, optional",
                "description": "Whether missing values (if any) should be treated as the largest values\n(True) or the smallest values (False)\nWhen the array contains unmasked values at the same extremes of the\ndatatype, the ordering of these values and the masked values is\nundefined."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used internally for the masked values.\nIf ``fill_value`` is not None, it supersedes ``endwith``."
              }
            },
            "returns": "-------\nindex_array : ndarray, int\nArray of indices that sort `a` along the specified axis.\nIn other words, ``a[index_array]`` yields a sorted `a`.",
            "raises": "",
            "see_also": "--------\nma.MaskedArray.sort : Describes sorting algorithms used.\nlexsort : Indirect stable sort with multiple keys.\nnumpy.ndarray.sort : Inplace sort.",
            "notes": "-----\nSee `sort` for notes on the different sorting algorithms.",
            "examples": "--------\n>>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data=[3, 2, --],\nmask=[False, False,  True],\nfill_value=999999)\n>>> a.argsort()\narray([1, 0, 2])"
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\nCopy of the array, cast to a specified type.",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "Typecode or data-type to which the array is cast."
              },
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout order of the result.\n'C' means C order, 'F' means Fortran order, 'A'\nmeans 'F' order if all the arrays are Fortran contiguous,\n'C' order otherwise, and 'K' means as close to the\norder the array elements appear in memory as possible.\nDefault is 'K'."
              },
              "casting": {
                "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
                "description": "Controls what kind of data casting may occur. Defaults to 'unsafe'\nfor backwards compatibility.\n* 'no' means the data types should not be cast at all.\n* 'equiv' means only byte-order changes are allowed.\n* 'safe' means only casts which can preserve values are allowed.\n* 'same_kind' means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n* 'unsafe' means any data conversions may be done."
              },
              "subok": {
                "type": "bool, optional",
                "description": "If True, then sub-classes will be passed-through (default), otherwise\nthe returned array will be forced to be a base-class array."
              },
              "copy": {
                "type": "bool, optional",
                "description": "By default, astype always returns a newly allocated array. If this\nis set to false, and the `dtype`, `order`, and `subok`\nrequirements are satisfied, the input array is returned instead\nof a copy."
              }
            },
            "returns": "-------\narr_t : ndarray\nUnless `copy` is False and the other conditions for returning the input\narray are satisfied (see description for `copy` input parameter), `arr_t`\nis a new array of the same shape as the input array, with dtype, order\ngiven by `dtype`, `order`.",
            "raises": "------\nComplexWarning\nWhen casting from complex to float or int. To avoid this,\none should use ``a.real.astype(t)``.",
            "see_also": "",
            "notes": "-----\n.. versionchanged:: 1.17.0\nCasting between a simple data type and a structured one is possible only\nfor \"unsafe\" casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n.. versionchanged:: 1.9.0\nCasting from numeric to string types in 'safe' casting mode requires\nthat the string dtype length is long enough to store the max\ninteger/float value converted.",
            "examples": "--------\n>>> x = np.array([1, 2, 2.5])\n>>> x\narray([1. ,  2. ,  2.5])\n>>> x.astype(int)\narray([1, 2, 2])"
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "a.byteswap(inplace=False)\nSwap the bytes of the array elements\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.",
            "parameters": {
              "inplace": {
                "type": "bool, optional",
                "description": "If ``True``, swap bytes in-place, default is ``False``."
              }
            },
            "returns": "-------\nout : ndarray\nThe byteswapped array. If `inplace` is ``True``, this is\na view to self.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> list(map(hex, A))\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n>>> list(map(hex, A))\n['0x100', '0x1', '0x3322']\nArrays of byte-strings are not swapped\n>>> A = np.array([b'ceg', b'fac'])\n>>> A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n``A.newbyteorder().byteswap()`` produces an array with the same values\nbut different representation in memory\n>>> A = np.array([1, 2, 3])\n>>> A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n0, 0], dtype=uint8)\n>>> A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n>>> A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n0, 3], dtype=uint8)"
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "a.choose(choices, out=None, mode='raise')\nUse an index array to construct a new array from a set of choices.\nRefer to `numpy.choose` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.choose : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "a.clip(min=None, max=None, out=None, **kwargs)\nReturn an array whose values are limited to ``[min, max]``.\nOne of max or min must be given.\nRefer to `numpy.clip` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.clip : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(self, condition, axis=None, out=None)",
          "documentation": {
            "description": "Return `a` where condition is ``True``.\nIf condition is a `~ma.MaskedArray`, missing values are considered\nas ``False``.",
            "parameters": {
              "condition": {
                "type": "var",
                "description": "Boolean 1-d array selecting which entries to return. If len(condition)\nis less than the size of a along the axis, then output is truncated\nto length of condition array."
              },
              "axis": {
                "type": "{None, int}, optional",
                "description": "Axis along which the operation must be performed."
              },
              "out": {
                "type": "{None, ndarray}, optional",
                "description": "Alternative output array in which to place the result. It must have\nthe same shape as the expected output but the type will be cast if\nnecessary."
              }
            },
            "returns": "-------\nresult : MaskedArray\nA :class:`~ma.MaskedArray` object.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nPlease note the difference with :meth:`compressed` !\nThe output of :meth:`compress` has a mask, the output of\n:meth:`compressed` does not.",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\nmask=[False, False],\nfill_value=999999)\n>>> x.compress([1, 0, 1], axis=1)\nmasked_array(\ndata=[[1, 3],\n[--, --],\n[7, 9]],\nmask=[[False, False],\n[ True,  True],\n[False, False]],\nfill_value=999999)"
          }
        },
        {
          "name": "compressed",
          "signature": "compressed(self)",
          "documentation": {
            "description": "Return all the non-masked data as a 1-D array.",
            "parameters": {},
            "returns": "-------\ndata : ndarray\nA new `ndarray` holding the non-masked data is returned.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nThe result is **not** a MaskedArray!",
            "examples": "--------\n>>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n>>> x.compressed()\narray([0, 1])\n>>> type(x.compressed())\n<class 'numpy.ndarray'>"
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "a.conj()\nComplex-conjugate all elements.\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "a.conjugate()\nReturn the complex conjugate, element-wise.\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(self, *args, **params)",
          "documentation": {
            "description": "a.copy(order='C')\nReturn a copy of the array.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout of the copy. 'C' means C-order,\n'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n'C' otherwise. 'K' means match the layout of `a` as closely\nas possible. (Note that this function and :func:`numpy.copy` are very\nsimilar but have different default values for their order=\narguments, and this function always passes sub-classes through.)\nSee also\n--------"
              },
              "numpy.copy": {
                "type": "Similar function with different default behavior",
                "description": "numpy.copyto"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\nThis function is the preferred method for creating an array copy.  The\nfunction :func:`numpy.copy` is similar, but it defaults to using order 'K',\nand will not pass sub-classes through by default.",
            "examples": "--------\n>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n>>> y = x.copy()\n>>> x.fill(0)\n>>> x\narray([[0, 0, 0],\n[0, 0, 0]])\n>>> y\narray([[1, 2, 3],\n[4, 5, 6]])\n>>> y.flags['C_CONTIGUOUS']\nTrue"
          }
        },
        {
          "name": "count",
          "signature": "count(self, axis=None, keepdims=<no value>)",
          "documentation": {
            "description": "Count the non-masked elements of the array along the given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis or axes along which the count is performed.\nThe default, None, performs the count over all\nthe dimensions of the input array. `axis` may be negative, in\nwhich case it counts from the last to the first axis.\n.. versionadded:: 1.10.0\nIf this is a tuple of ints, the count is performed on multiple\naxes, instead of a single axis or all the axes as before."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
              }
            },
            "returns": "-------\nresult : ndarray or scalar\nAn array with the same shape as the input array, with the specified\naxis removed. If the array is a 0-d array, or if `axis` is None, a\nscalar is returned.",
            "raises": "",
            "see_also": "--------\nma.count_masked : Count masked elements in array or along a given axis.",
            "notes": "",
            "examples": "--------\n>>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(\ndata=[[0, 1, 2],\n[--, --, --]],\nmask=[[False, False, False],\n[ True,  True,  True]],\nfill_value=999999)\n>>> a.count()\n3\nWhen the `axis` keyword is specified an array of appropriate size is\nreturned.\n>>> a.count(axis=0)\narray([1, 1, 1])\n>>> a.count(axis=1)\narray([3, 0])"
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(self, axis=None, dtype=None, out=None)",
          "documentation": {
            "description": "Return the cumulative product of the array elements over the given axis.\nMasked values are set to 1 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to `numpy.cumprod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.cumprod : corresponding function for ndarrays\nnumpy.cumprod : equivalent function",
            "notes": "-----\nThe mask is lost if `out` is not a valid MaskedArray !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(self, axis=None, dtype=None, out=None)",
          "documentation": {
            "description": "Return the cumulative sum of the array elements over the given axis.\nMasked values are set to 0 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to `numpy.cumsum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.cumsum : corresponding function for ndarrays\nnumpy.cumsum : equivalent function",
            "notes": "-----\nThe mask is lost if `out` is not a valid :class:`ma.MaskedArray` !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
            "examples": "--------\n>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\nmask=[False, False, False,  True,  True,  True, False, False,\nFalse, False],\nfill_value=999999)"
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(self, *args, **params)",
          "documentation": {
            "description": "a.diagonal(offset=0, axis1=0, axis2=1)\nReturn specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\nRefer to :func:`numpy.diagonal` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.diagonal : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dot",
          "signature": "dot(self, b, out=None, strict=False)",
          "documentation": {
            "description": "a.dot(b, out=None)\nMasked dot product of two arrays. Note that `out` and `strict` are\nlocated in different positions than in `ma.dot`. In order to\nmaintain compatibility with the functional version, it is\nrecommended that the optional arguments be treated as keyword only.\nAt some point that may be mandatory.\n.. versionadded:: 1.10.0",
            "parameters": {
              "b": {
                "type": "masked_array_like",
                "description": "Inputs array."
              },
              "out": {
                "type": "masked_array, optional",
                "description": "Output argument. This must have the exact kind that would be\nreturned if it was not used. In particular, it must have the\nright type, must be C-contiguous, and its dtype must be the\ndtype that would be returned for `ma.dot(a,b)`. This is a\nperformance feature. Therefore, if these conditions are not\nmet, an exception is raised, instead of attempting to be\nflexible."
              },
              "strict": {
                "type": "bool, optional",
                "description": "Whether masked data are propagated (True) or set to 0 (False)\nfor the computation. Default is False.  Propagating the mask\nmeans that if a masked value appears in a row or column, the\nwhole row or column is considered masked.\n.. versionadded:: 1.10.2"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ma.dot : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "a.dump(file)\nDump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.",
            "parameters": {
              "file": {
                "type": "str or Path",
                "description": "A string naming the dump file.\n.. versionchanged:: 1.17.0\n`pathlib.Path` objects are now accepted."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "a.dumps()",
            "parameters": {},
            "returns": "pickle.loads will convert the string back to an array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "a.fill(value)\nFill the array with a scalar value.",
            "parameters": {
              "value": {
                "type": "scalar",
                "description": "All elements of `a` will be assigned this value."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([1.,  1.])\nFill expects a scalar value and always behaves the same as assigning\nto a single array element.  The following is a rare example where this\ndistinction is important:\n>>> a = np.array([None, None], dtype=object)\n>>> a[0] = np.array(3)\n>>> a\narray([array(3), None], dtype=object)\n>>> a.fill(np.array(3))\n>>> a\narray([array(3), array(3)], dtype=object)\nWhere other forms of assignments will unpack the array being assigned:\n>>> a[...] = np.array(3)\n>>> a\narray([3, 3], dtype=object)"
          }
        },
        {
          "name": "filled",
          "signature": "filled(self, fill_value=None)",
          "documentation": {
            "description": "Return a copy of self, with masked values filled with a given value.\n**However**, if there are no masked values to fill, self will be\nreturned instead as an ndarray.",
            "parameters": {
              "fill_value": {
                "type": "array_like, optional",
                "description": "The value to use for invalid entries. Can be scalar or non-scalar.\nIf non-scalar, the resulting ndarray must be broadcastable over\ninput array. Default is None, in which case, the `fill_value`\nattribute of the array is used instead."
              }
            },
            "returns": "-------\nfilled_array : ndarray\nA copy of ``self`` with invalid entries replaced by *fill_value*\n(be it the function argument or the attribute of ``self``), or\n``self`` itself as an ndarray if there are no invalid entries to\nbe replaced.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nThe result is **not** a MaskedArray!",
            "examples": "--------\n>>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n>>> x.filled()\narray([   1,    2, -999,    4, -999])\n>>> x.filled(fill_value=1000)\narray([   1,    2, 1000,    4, 1000])\n>>> type(x.filled())\n<class 'numpy.ndarray'>\nSubclassing is preserved. This means that if, e.g., the data part of\nthe masked array is a recarray, `filled` returns a recarray:\n>>> x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)\n>>> m = np.ma.array(x, mask=[(True, False), (False, True)])\n>>> m.filled()\nrec.array([(999999,      2), (    -3, 999999)],\ndtype=[('f0', '<i8'), ('f1', '<i8')])"
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(self, *args, **params)",
          "documentation": {
            "description": "a.flatten(order='C')\nReturn a copy of the array collapsed into one dimension.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "'C' means to flatten in row-major (C-style) order.\n'F' means to flatten in column-major (Fortran-\nstyle) order. 'A' means to flatten in column-major\norder if `a` is Fortran *contiguous* in memory,\nrow-major order otherwise. 'K' means to flatten\n`a` in the order the elements occur in memory.\nThe default is 'C'."
              }
            },
            "returns": "-------\ny : ndarray\nA copy of the input array, flattened to one dimension.",
            "raises": "",
            "see_also": "--------\nravel : Return a flattened array.\nflat : A 1-D flat iterator over the array.",
            "notes": "",
            "examples": "--------\n>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])"
          }
        },
        {
          "name": "get_fill_value",
          "signature": "fill_value(self)",
          "documentation": {
            "description": "The filling value of the masked array is a scalar. When setting, None\nwill set to a default based on the data type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n>>> x = np.ma.array([0, 1.], fill_value=-np.inf)\n>>> x.fill_value\n-inf\n>>> x.fill_value = np.pi\n>>> x.fill_value\n3.1415926535897931 # may vary\nReset to default:\n>>> x.fill_value = None\n>>> x.fill_value\n1e+20"
          }
        },
        {
          "name": "get_imag",
          "signature": "imag(self)",
          "documentation": {
            "description": "The imaginary part of the masked array.\nThis property is a view on the imaginary part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nreal",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.imag\nmasked_array(data=[1.0, --, 1.6],\nmask=[False,  True, False],\nfill_value=1e+20)"
          }
        },
        {
          "name": "get_real",
          "signature": "real(self)",
          "documentation": {
            "description": "The real part of the masked array.\nThis property is a view on the real part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nimag",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.real\nmasked_array(data=[1.0, --, 3.45],\nmask=[False,  True, False],\nfill_value=1e+20)"
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "a.getfield(dtype, offset=0)",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "The data type of the view. The dtype size of the view can not be larger\nthan that of the array itself."
              },
              "offset": {
                "type": "int",
                "description": "Number of bytes to skip before beginning the element view."
              }
            },
            "returns": "A field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[1.+1.j,  0.+0.j],\n[0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[1.,  0.],\n[0.,  2.]])\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n>>> x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n[0.,  4.]])"
          }
        },
        {
          "name": "harden_mask",
          "signature": "harden_mask(self)",
          "documentation": {
            "description": "Force the mask to hard, preventing unmasking by assignment.\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `harden_mask` sets\n`~ma.MaskedArray.hardmask` to ``True`` (and returns the modified\nself).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nma.MaskedArray.hardmask\nma.MaskedArray.soften_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ids",
          "signature": "ids(self)",
          "documentation": {
            "description": "Return the addresses of the data and mask areas.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n>>> x.ids()\n(166670640, 166659832) # may vary\nIf the array has no mask, the address of `nomask` is returned. This address\nis typically not close to the data in memory:\n>>> x = np.ma.array([1, 2, 3])\n>>> x.ids()\n(166691080, 3083169284) # may vary"
          }
        },
        {
          "name": "iscontiguous",
          "signature": "iscontiguous(self)",
          "documentation": {
            "description": "Return a boolean indicating whether the data is contiguous.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([1, 2, 3])\n>>> x.iscontiguous()\nTrue\n`iscontiguous` returns one of the flags of the masked array:\n>>> x.flags\nC_CONTIGUOUS : True\nF_CONTIGUOUS : True\nOWNDATA : False\nWRITEABLE : True\nALIGNED : True\nWRITEBACKIFCOPY : False"
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "a.item(*args)\nCopy an element of an array to a standard Python scalar and return it.",
            "parameters": {},
            "returns": "-------\nz : Standard Python scalar object\nA copy of the specified element of the array as a suitable\nPython scalar",
            "raises": "",
            "see_also": "",
            "notes": "-----\nWhen the data type of `a` is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\n`item` is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python's optimized math.",
            "examples": "--------\n>>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n[1, 3, 6],\n[1, 0, 1]])\n>>> x.item(3)\n1\n>>> x.item(7)\n0\n>>> x.item((0, 1))\n2\n>>> x.item((2, 2))\n1"
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "a.itemset(*args)\nInsert scalar into an array (scalar is cast to array's dtype, if possible)\nThere must be at least 1 argument, and define the last argument\nas *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster\nthan ``a[args] = item``.  The item should be a scalar value and `args`\nmust select a single item in the array `a`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\nCompared to indexing syntax, `itemset` provides some speed increase\nfor placing a scalar into a particular location in an `ndarray`,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using `itemset` (and `item`) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.",
            "examples": "--------\n>>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n[1, 3, 6],\n[1, 0, 1]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[2, 2, 6],\n[1, 0, 6],\n[1, 0, 9]])"
          }
        },
        {
          "name": "max",
          "signature": "max(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the maximum along a given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis along which to operate.  By default, ``axis`` is None and the\nflattened input is used.\n.. versionadded:: 1.7.0\nIf this is a tuple of ints, the maximum is selected over multiple\naxes, instead of a single axis or all the axes as before."
              },
              "out": {
                "type": "array_like, optional",
                "description": "Alternative output array in which to place the result.  Must\nbe of the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.\nIf None, use the output of maximum_fill_value()."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
              }
            },
            "returns": "-------\namax : array_like\nNew array holding the result.\nIf ``out`` was specified, ``out`` is returned.",
            "raises": "",
            "see_also": "--------\nma.maximum_fill_value",
            "notes": "",
            "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [[-1., 2.5], [4., -2.], [3., 0.]]\n>>> mask = [[0, 0], [1, 0], [1, 0]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\ndata=[[-1.0, 2.5],\n[--, -2.0],\n[--, 0.0]],\nmask=[[False, False],\n[ True, False],\n[ True, False]],\nfill_value=1e+20)\n>>> ma.max(masked_x)\n2.5\n>>> ma.max(masked_x, axis=0)\nmasked_array(data=[-1.0, 2.5],\nmask=[False, False],\nfill_value=1e+20)\n>>> ma.max(masked_x, axis=1, keepdims=True)\nmasked_array(\ndata=[[2.5],\n[-2.0],\n[0.0]],\nmask=[[False],\n[False],\n[False]],\nfill_value=1e+20)\n>>> mask = [[1, 1], [1, 1], [1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.max(masked_x, axis=1)\nmasked_array(data=[--, --, --],\nmask=[ True,  True,  True],\nfill_value=1e+20,\ndtype=float64)"
          }
        },
        {
          "name": "mean",
          "signature": "mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "Masked entries are ignored, and result elements which are not\nfinite will be masked.\nRefer to `numpy.mean` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.mean : corresponding function for ndarrays\nnumpy.mean : Equivalent function\nnumpy.ma.average : Weighted average.",
            "notes": "",
            "examples": "--------\n>>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data=[1, 2, --],\nmask=[False, False,  True],\nfill_value=999999)\n>>> a.mean()\n1.5"
          }
        },
        {
          "name": "min",
          "signature": "min(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the minimum along a given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis along which to operate.  By default, ``axis`` is None and the\nflattened input is used.\n.. versionadded:: 1.7.0\nIf this is a tuple of ints, the minimum is selected over multiple\naxes, instead of a single axis or all the axes as before."
              },
              "out": {
                "type": "array_like, optional",
                "description": "Alternative output array in which to place the result.  Must be of\nthe same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.\nIf None, use the output of `minimum_fill_value`."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
              }
            },
            "returns": "-------\namin : array_like\nNew array holding the result.\nIf ``out`` was specified, ``out`` is returned.",
            "raises": "",
            "see_also": "--------\nma.minimum_fill_value",
            "notes": "",
            "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [[1., -2., 3.], [0.2, -0.7, 0.1]]\n>>> mask = [[1, 1, 0], [0, 0, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\ndata=[[--, --, 3.0],\n[0.2, -0.7, --]],\nmask=[[ True,  True, False],\n[False, False,  True]],\nfill_value=1e+20)\n>>> ma.min(masked_x)\n-0.7\n>>> ma.min(masked_x, axis=-1)\nmasked_array(data=[3.0, -0.7],\nmask=[False, False],\nfill_value=1e+20)\n>>> ma.min(masked_x, axis=0, keepdims=True)\nmasked_array(data=[[0.2, -0.7, 3.0]],\nmask=[[False, False, False]],\nfill_value=1e+20)\n>>> mask = [[1, 1, 1,], [1, 1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.min(masked_x, axis=0)\nmasked_array(data=[--, --, --],\nmask=[ True,  True,  True],\nfill_value=1e+20,\ndtype=float64)"
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(...)",
          "documentation": {
            "description": "arr.newbyteorder(new_order='S', /)\nReturn the array with the same data viewed with a different byte order.\nEquivalent to::\narr.view(arr.dtype.newbytorder(new_order))\nChanges are also made in all fields and sub-arrays of the array data\ntype.",
            "parameters": {
              "new_order": {
                "type": "string, optional",
                "description": "Byte order to force; a value from the byte order specifications\nbelow. `new_order` codes can be any of:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order, equivalent to `sys.byteorder`\n* {'|', 'I'} - ignore (no change to byte order)\nThe default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_arr : array\nNew array object with the dtype reflecting given change to the\nbyte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(self)",
          "documentation": {
            "description": "Return the indices of unmasked elements that are not zero.",
            "parameters": {},
            "returns": "indices of the non-zero elements in that dimension. The corresponding\nnon-zero values can be obtained with::\na[a.nonzero()]\nTo group the indices by element, rather than dimension, use\ninstead::\nnp.transpose(a.nonzero())\nThe result of this is always a 2d array, with a row for each non-zero\nelement.\n-------\ntuple_of_arrays : tuple\nIndices of elements that are non-zero.",
            "raises": "",
            "see_also": "--------\nnumpy.nonzero :\nFunction operating on ndarrays.\nflatnonzero :\nReturn indices that are non-zero in the flattened version of the input\narray.\nnumpy.ndarray.nonzero :\nEquivalent ndarray method.\ncount_nonzero :\nCounts the number of non-zero elements in the input array.",
            "notes": "",
            "examples": "--------\n>>> import numpy.ma as ma\n>>> x = ma.array(np.eye(3))\n>>> x\nmasked_array(\ndata=[[1., 0., 0.],\n[0., 1., 0.],\n[0., 0., 1.]],\nmask=False,\nfill_value=1e+20)\n>>> x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\nMasked elements are ignored.\n>>> x[1, 1] = ma.masked\n>>> x\nmasked_array(\ndata=[[1.0, 0.0, 0.0],\n[0.0, --, 0.0],\n[0.0, 0.0, 1.0]],\nmask=[[False, False, False],\n[False,  True, False],\n[False, False, False]],\nfill_value=1e+20)\n>>> x.nonzero()\n(array([0, 2]), array([0, 2]))\nIndices can also be grouped by element.\n>>> np.transpose(x.nonzero())\narray([[0, 0],\n[2, 2]])\nA common use for ``nonzero`` is to find the indices of an array, where\na condition is True.  Given an array `a`, the condition `a` > 3 is a\nboolean array and since False is interpreted as 0, ma.nonzero(a > 3)\nyields the indices of the `a` where the condition is true.\n>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n>>> a > 3\nmasked_array(\ndata=[[False, False, False],\n[ True,  True,  True],\n[ True,  True,  True]],\nmask=False,\nfill_value=True)\n>>> ma.nonzero(a > 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\nThe ``nonzero`` method of the condition array can also be called.\n>>> (a > 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))"
          }
        },
        {
          "name": "partition",
          "signature": "partition(self, *args, **kwargs)",
          "documentation": {
            "description": "a.partition(kth, axis=-1, kind='introselect', order=None)\nRearranges the elements in the array in such a way that the value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.\n.. versionadded:: 1.8.0",
            "parameters": {
              "kth": {
                "type": "int or sequence of ints",
                "description": "Element index to partition by. The kth element value will be in its\nfinal sorted position and all smaller elements will be moved before it\nand all equal or greater elements behind it.\nThe order of all elements in the partitions is undefined.\nIf provided with a sequence of kth it will partition all elements\nindexed by kth of them into their sorted position at once.\n.. deprecated:: 1.22.0\nPassing booleans as index is deprecated."
              },
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. Default is -1, which means sort along the\nlast axis."
              },
              "kind": {
                "type": "{'introselect'}, optional",
                "description": "Selection algorithm. Default is 'introselect'."
              },
              "order": {
                "type": "str or list of str, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc. A single field can\nbe specified as a string, and not all fields need to be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.partition : Return a partitioned copy of an array.\nargpartition : Indirect partition.\nsort : Full sort.",
            "notes": "-----\nSee ``np.partition`` for notes on the different algorithms.",
            "examples": "--------\n>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])\n>>> a.partition((1, 3))\n>>> a\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "prod",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the product of the array elements over the given axis.\nMasked elements are set to 1 internally for computation.\nRefer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
            "notes": "-----\nArithmetic is modular when using integer types, and no error is raised\non overflow.",
            "examples": ""
          }
        },
        {
          "name": "product",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the product of the array elements over the given axis.\nMasked elements are set to 1 internally for computation.\nRefer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
            "notes": "-----\nArithmetic is modular when using integer types, and no error is raised\non overflow.",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(self, axis=None, out=None, fill_value=None, keepdims=False)",
          "documentation": {
            "description": "Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).\n.. warning::\n`ptp` preserves the data type of the array. This means the\nreturn value for an input of signed integers with n bits\n(e.g. `np.int8`, `np.int16`, etc) is also a signed integer\nwith n bits.  In that case, peak-to-peak values greater than\n``2**(n-1)-1`` will be returned as negative values. An example\nwith a work-around is shown below.",
            "parameters": {
              "axis": {
                "type": "{None, int}, optional",
                "description": "Axis along which to find the peaks.  If None (default) the\nflattened array is used."
              },
              "out": {
                "type": "{None, array_like}, optional",
                "description": "Alternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output\nbut the type will be cast if necessary."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
              }
            },
            "returns": "-------\nptp : ndarray.\nA new array holding the result, unless ``out`` was\nspecified, in which case a reference to ``out`` is returned.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.MaskedArray([[4, 9, 2, 10],\n...                        [6, 9, 7, 12]])\n>>> x.ptp(axis=1)\nmasked_array(data=[8, 6],\nmask=False,\nfill_value=999999)\n>>> x.ptp(axis=0)\nmasked_array(data=[2, 0, 5, 2],\nmask=False,\nfill_value=999999)\n>>> x.ptp()\n10\nThis example shows that a negative value can be returned when\nthe input is an array of signed integers.\n>>> y = np.ma.MaskedArray([[1, 127],\n...                        [0, 127],\n...                        [-1, 127],\n...                        [-2, 127]], dtype=np.int8)\n>>> y.ptp(axis=1)\nmasked_array(data=[ 126,  127, -128, -127],\nmask=False,\nfill_value=999999,\ndtype=int8)\nA work-around is to use the `view()` method to view the result as\nunsigned integers with the same bit width:\n>>> y.ptp(axis=1).view(np.uint8)\nmasked_array(data=[126, 127, 128, 129],\nmask=False,\nfill_value=999999,\ndtype=uint8)"
          }
        },
        {
          "name": "put",
          "signature": "put(self, indices, values, mode='raise')",
          "documentation": {
            "description": "Set storage-indexed locations to corresponding values.\nSets self._data.flat[n] = values[n] for each n in indices.\nIf `values` is shorter than `indices` then it will repeat.\nIf `values` has some masked values, the initial mask is updated\nin consequence, else the corresponding values are unmasked.",
            "parameters": {
              "indices": {
                "type": "1-D array_like",
                "description": "Target indices, interpreted as integers."
              },
              "values": {
                "type": "array_like",
                "description": "Values to place in self._data copy at target indices."
              },
              "mode": {
                "type": "{'raise', 'wrap', 'clip'}, optional",
                "description": "Specifies how out-of-bounds indices will behave.\n'raise' : raise an error.\n'wrap' : wrap around.\n'clip' : clip to the range."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\n`values` can be a scalar or length 1 array.",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.put([0,4,8],[10,20,30])\n>>> x\nmasked_array(\ndata=[[10, --, 3],\n[--, 20, --],\n[7, --, 30]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.put(4,999)\n>>> x\nmasked_array(\ndata=[[10, --, 3],\n[--, 999, --],\n[7, --, 30]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)"
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(self, order='C')",
          "documentation": {
            "description": "",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "The elements of `a` are read using this index order. 'C' means to\nindex the elements in C-like order, with the last axis index\nchanging fastest, back to the first axis index changing slowest.\n'F' means to index the elements in Fortran-like index order, with\nthe first index changing fastest, and the last index changing\nslowest. Note that the 'C' and 'F' options take no account of the\nmemory layout of the underlying array, and only refer to the order\nof axis indexing.  'A' means to read the elements in Fortran-like\nindex order if `m` is Fortran *contiguous* in memory, C-like order\notherwise.  'K' means to read the elements in the order they occur\nin memory, except for reversing the data when strides are negative.\nBy default, 'C' index order is used.\n(Masked arrays currently use 'A' on the data when 'K' is passed.)"
              }
            },
            "returns": "-------\nMaskedArray\nOutput view is of shape ``(self.size,)`` (or\n``(np.ma.product(self.shape),)``).",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\nmask=[False,  True, False,  True, False,  True, False,  True,\nFalse],\nfill_value=999999)"
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(self, *args, **params)",
          "documentation": {
            "description": "a.repeat(repeats, axis=None)\nRepeat elements of an array.\nRefer to `numpy.repeat` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.repeat : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(self, *s, **kwargs)",
          "documentation": {
            "description": "Give a new shape to the array without changing its data.",
            "parameters": {
              "shape": {
                "type": "int or tuple of ints",
                "description": "The new shape should be compatible with the original shape. If an\ninteger is supplied, then the result will be a 1-D array of that\nlength."
              },
              "order": {
                "type": "{'C', 'F'}, optional",
                "description": "Determines whether the array data should be viewed as in C\n(row-major) or FORTRAN (column-major) order."
              }
            },
            "returns": "The result is a view on the original array; if this is not possible, a\nValueError is raised.\n-------\nreshaped_array : array\nA new view on the array.",
            "raises": "",
            "see_also": "--------\nreshape : Equivalent function in the masked array module.\nnumpy.ndarray.reshape : Equivalent method on ndarray object.\nnumpy.reshape : Equivalent function in the NumPy module.",
            "notes": "-----\nThe reshaping operation cannot guarantee that a copy will not be made,\nto modify the shape in place, use ``a.shape = s``",
            "examples": "--------\n>>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n>>> x\nmasked_array(\ndata=[[--, 2],\n[3, --]],\nmask=[[ True, False],\n[False,  True]],\nfill_value=999999)\n>>> x = x.reshape((4,1))\n>>> x\nmasked_array(\ndata=[[--],\n[2],\n[3],\n[--]],\nmask=[[ True],\n[False],\n[False],\n[ True]],\nfill_value=999999)"
          }
        },
        {
          "name": "resize",
          "signature": "resize(self, newshape, refcheck=True, order=False)",
          "documentation": {
            "description": ".. warning::\nThis method does nothing, except raise a ValueError exception. A\nmasked array does not own its data and therefore cannot safely be\nresized in place. Use the `numpy.ma.resize` function instead.\nThis method is difficult to implement safely and may be deprecated in\nfuture releases of NumPy.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(self, decimals=0, out=None)",
          "documentation": {
            "description": "Return each element rounded to the given number of decimals.\nRefer to `numpy.around` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.round : corresponding function for ndarrays\nnumpy.around : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "a.searchsorted(v, side='left', sorter=None)\nFind indices where elements of v should be inserted in a to maintain order.\nFor full documentation, see `numpy.searchsorted`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.searchsorted : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_fill_value",
          "signature": "fill_value(self, value=None)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "a.setfield(val, dtype, offset=0)\nPut a value into a specified place in a field defined by a data-type.\nPlace `val` into `a`'s field defined by `dtype` and beginning `offset`\nbytes into the field.",
            "parameters": {
              "val": {
                "type": "object",
                "description": "Value to be placed in field."
              },
              "dtype": {
                "type": "dtype object",
                "description": "Data-type of the field in which to place `val`."
              },
              "offset": {
                "type": "int, optional",
                "description": "The number of bytes into the field at which to place `val`."
              }
            },
            "returns": "-------\nNone",
            "raises": "",
            "see_also": "--------\ngetfield",
            "notes": "",
            "examples": "--------\n>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[1.,  0.,  0.],\n[0.,  1.,  0.],\n[0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n[3, 3, 3],\n[3, 3, 3]], dtype=int32)\n>>> x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n[1.5e-323, 1.0e+000, 1.5e-323],\n[1.5e-323, 1.5e-323, 1.0e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[1.,  0.,  0.],\n[0.,  1.,  0.],\n[0.,  0.,  1.]])"
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "a.setflags(write=None, align=None, uic=None)\nSet array flags WRITEABLE, ALIGNED, WRITEBACKIFCOPY,\nrespectively.\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by `a` (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and flag can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)",
            "parameters": {
              "write": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` can be written to."
              },
              "align": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is aligned properly for its type."
              },
              "uic": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is a copy of another \"base\" array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\nArray flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, WRITEABLE, and ALIGNED.\nWRITEABLE (W) the data area can be written to;\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.",
            "examples": "--------\n>>> y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n>>> y\narray([[3, 1, 7],\n[2, 0, 0],\n[8, 5, 9]])\n>>> y.flags\nC_CONTIGUOUS : True\nF_CONTIGUOUS : False\nOWNDATA : True\nWRITEABLE : True\nALIGNED : True\nWRITEBACKIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\nC_CONTIGUOUS : True\nF_CONTIGUOUS : False\nOWNDATA : True\nWRITEABLE : False\nALIGNED : False\nWRITEBACKIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: cannot set WRITEBACKIFCOPY flag to True"
          }
        },
        {
          "name": "shrink_mask",
          "signature": "shrink_mask(self)",
          "documentation": {
            "description": "Reduce a mask to nomask when possible.",
            "parameters": {},
            "returns": "-------\nNone",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n>>> x.mask\narray([[False, False],\n[False, False]])\n>>> x.shrink_mask()\nmasked_array(\ndata=[[1, 2],\n[3, 4]],\nmask=False,\nfill_value=999999)\n>>> x.mask\nFalse"
          }
        },
        {
          "name": "soften_mask",
          "signature": "soften_mask(self)",
          "documentation": {
            "description": "Force the mask to soft (default), allowing unmasking by assignment.\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `soften_mask` sets\n`~ma.MaskedArray.hardmask` to ``False`` (and returns the modified\nself).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nma.MaskedArray.hardmask\nma.MaskedArray.harden_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(self, axis=-1, kind=None, order=None, endwith=True, fill_value=None)",
          "documentation": {
            "description": "Sort the array, in-place",
            "parameters": {
              "a": {
                "type": "array_like",
                "description": "Array to be sorted."
              },
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. If None, the array is flattened before\nsorting. The default is -1, which sorts along the last axis."
              },
              "kind": {
                "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
                "description": "The sorting algorithm used."
              },
              "order": {
                "type": "list, optional",
                "description": "When `a` is a structured array, this argument specifies which fields\nto compare first, second, and so on.  This list does not need to\ninclude all of the fields."
              },
              "endwith": {
                "type": "{True, False}, optional",
                "description": "Whether missing values (if any) should be treated as the largest values\n(True) or the smallest values (False)\nWhen the array contains unmasked values sorting at the same extremes of the\ndatatype, the ordering of these values and the masked values is\nundefined."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used internally for the masked values.\nIf ``fill_value`` is not None, it supersedes ``endwith``."
              }
            },
            "returns": "-------\nsorted_array : ndarray\nArray of the same type and shape as `a`.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.sort : Method to sort an array in-place.\nargsort : Indirect sort.\nlexsort : Indirect stable sort on multiple keys.\nsearchsorted : Find elements in a sorted array.",
            "notes": "-----\nSee ``sort`` for notes on the different sorting algorithms.",
            "examples": "--------\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Default\n>>> a.sort()\n>>> a\nmasked_array(data=[1, 3, 5, --, --],\nmask=[False, False, False,  True,  True],\nfill_value=999999)\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Put missing values in the front\n>>> a.sort(endwith=False)\n>>> a\nmasked_array(data=[--, --, 1, 3, 5],\nmask=[ True,  True, False, False, False],\nfill_value=999999)\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # fill_value takes over endwith\n>>> a.sort(endwith=False, fill_value=3)\n>>> a\nmasked_array(data=[1, --, --, 3, 5],\nmask=[False,  True,  True, False, False],\nfill_value=999999)"
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(self, *args, **params)",
          "documentation": {
            "description": "a.squeeze(axis=None)\nRemove axes of length one from `a`.\nRefer to `numpy.squeeze` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.squeeze : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "Masked entries are ignored.\nRefer to `numpy.std` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.std : corresponding function for ndarrays\nnumpy.std : Equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the sum of the array elements over the given axis.\nMasked elements are set to 0 internally.\nRefer to `numpy.sum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.sum : corresponding function for ndarrays\nnumpy.sum : equivalent function",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.sum()\n25\n>>> x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\nmask=[False, False, False],\nfill_value=999999)\n>>> x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\nmask=[False, False, False],\nfill_value=999999)\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<class 'numpy.int64'>"
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(self, *args, **params)",
          "documentation": {
            "description": "a.swapaxes(axis1, axis2)\nReturn a view of the array with `axis1` and `axis2` interchanged.\nRefer to `numpy.swapaxes` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.swapaxes : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(self, indices, axis=None, out=None, mode='raise')",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(self, fill_value=None, order='C')",
          "documentation": {
            "description": "Return the array data as a string containing the raw bytes in the array.\nThe array is filled with a fill value before the string conversion.\n.. versionadded:: 1.9.0",
            "parameters": {
              "fill_value": {
                "type": "scalar, optional",
                "description": "Value used to fill in the masked values. Default is None, in which\ncase `MaskedArray.fill_value` is used."
              },
              "order": {
                "type": "{'C','F','A'}, optional",
                "description": "Order of the data item in the copy. Default is 'C'.\n- 'C'   -- C order (row major).\n- 'F'   -- Fortran order (column major).\n- 'A'   -- Any, current order of array.\n- None  -- Same as 'A'."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.tobytes\ntolist, tofile",
            "notes": "-----\nAs for `ndarray.tobytes`, information about the shape, dtype, etc.,\nbut also about `fill_value`, will be lost.",
            "examples": "--------\n>>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n>>> x.tobytes()\nb'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(self, fid, sep='', format='%s')",
          "documentation": {
            "description": "Save a masked array to a file in binary format.\n.. warning::\nThis function is not implemented yet.",
            "parameters": {},
            "returns": "",
            "raises": "------\nNotImplementedError\nWhen `tofile` is called.",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "toflex",
          "signature": "toflex(self)",
          "documentation": {
            "description": "Transforms a masked array into a flexible-type array.\nThe flexible type array that is returned will have two fields:\n* the ``_data`` field stores the ``_data`` part of the array.\n* the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "-------\nrecord : ndarray\nA new flexible-type `ndarray` with two fields: the first element\ncontaining a value, the second element containing the corresponding\nmask boolean. The returned record shape matches self.shape.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nA side-effect of transforming a masked array into a flexible `ndarray` is\nthat meta information (``fill_value``, ...) will be lost.",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n[(4,  True), (5, False), (6,  True)],\n[(7, False), (8,  True), (9, False)]],\ndtype=[('_data', '<i8'), ('_mask', '?')])"
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(self, fill_value=None)",
          "documentation": {
            "description": "Return the data portion of the masked array as a hierarchical Python list.\nData items are converted to the nearest compatible Python type.\nMasked values are converted to `fill_value`. If `fill_value` is None,\nthe corresponding entries in the output list will be ``None``.",
            "parameters": {
              "fill_value": {
                "type": "scalar, optional",
                "description": "The value to use for invalid entries. Default is None."
              }
            },
            "returns": "-------\nresult : list\nThe Python list representation of the masked array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n>>> x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n>>> x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]"
          }
        },
        {
          "name": "torecords",
          "signature": "toflex(self)",
          "documentation": {
            "description": "Transforms a masked array into a flexible-type array.\nThe flexible type array that is returned will have two fields:\n* the ``_data`` field stores the ``_data`` part of the array.\n* the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "-------\nrecord : ndarray\nA new flexible-type `ndarray` with two fields: the first element\ncontaining a value, the second element containing the corresponding\nmask boolean. The returned record shape matches self.shape.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nA side-effect of transforming a masked array into a flexible `ndarray` is\nthat meta information (``fill_value``, ...) will be lost.",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n[(4,  True), (5, False), (6,  True)],\n[(7, False), (8,  True), (9, False)]],\ndtype=[('_data', '<i8'), ('_mask', '?')])"
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(self, fill_value=None, order='C')",
          "documentation": {
            "description": "A compatibility alias for `tobytes`, with exactly the same behavior.\nDespite its name, it returns `bytes` not `str`\\ s.\n.. deprecated:: 1.19.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)",
          "documentation": {
            "description": "a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\nReturn the sum along diagonals of the array.\nRefer to `numpy.trace` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.trace : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(self, *args, **params)",
          "documentation": {
            "description": "a.transpose(*axes)",
            "parameters": {
              "axes": {
                "type": "None, tuple of ints, or `n` ints",
                "description": "* None or no argument: reverses the order of the axes.\n* tuple of ints: `i` in the `j`-th place in the tuple means that the\narray's `i`-th axis becomes the transposed array's `j`-th axis.\n* `n` ints: same as an n-tuple of the same ints (this form is\nintended simply as a \"convenience\" alternative to the tuple form)."
              }
            },
            "returns": "Refer to `numpy.transpose` for full documentation.\n-------\np : ndarray\nView of the array with its axes suitably permuted.",
            "raises": "",
            "see_also": "--------\ntranspose : Equivalent function.\nndarray.T : Array property returning the array transposed.\nndarray.reshape : Give a new shape to an array without changing its data.",
            "notes": "",
            "examples": "--------\n>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n[3, 4]])\n>>> a.transpose()\narray([[1, 3],\n[2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n[2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n[2, 4]])\n>>> a = np.array([1, 2, 3, 4])\n>>> a\narray([1, 2, 3, 4])\n>>> a.transpose()\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "unshare_mask",
          "signature": "unshare_mask(self)",
          "documentation": {
            "description": "Copy the mask and set the `sharedmask` flag to ``False``.\nWhether the mask is shared between masked arrays can be seen from\nthe `sharedmask` property. `unshare_mask` ensures the mask is not\nshared. A copy of the mask is only made if it was shared.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nsharedmask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "documentation": {
            "description": "Compute the variance along the specified axis.",
            "parameters": {
              "a": {
                "type": "array_like",
                "description": "Array containing numbers whose variance is desired.  If `a` is not an\narray, a conversion is attempted."
              },
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis or axes along which the variance is computed.  The default is to\ncompute the variance of the flattened array.\n.. versionadded:: 1.7.0\nIf this is a tuple of ints, a variance is performed over multiple axes,\ninstead of a single axis or all the axes as before."
              },
              "dtype": {
                "type": "data-type, optional",
                "description": "Type to use in computing the variance.  For arrays of integer type\nthe default is `float64`; for arrays of float types it is the same as\nthe array type."
              },
              "out": {
                "type": "ndarray, optional",
                "description": "Alternate output array in which to place the result.  It must have\nthe same shape as the expected output, but the type is cast if\nnecessary."
              },
              "ddof": {
                "type": "int, optional",
                "description": "\"Delta Degrees of Freedom\": the divisor used in the calculation is\n``N - ddof``, where ``N`` represents the number of elements. By\ndefault `ddof` is zero."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then `keepdims` will not be\npassed through to the `var` method of sub-classes of\n`ndarray`, however any non-default value will be.  If the\nsub-class' method does not implement `keepdims` any\nexceptions will be raised."
              },
              "where": {
                "type": "array_like of bool, optional",
                "description": "Elements to include in the variance. See `~numpy.ufunc.reduce` for\ndetails.\n.. versionadded:: 1.20.0"
              }
            },
            "returns": "distribution.  The variance is computed for the flattened array by\ndefault, otherwise over the specified axis.\n-------\nvariance : ndarray, see dtype parameter above\nIf ``out=None``, returns a new array containing the variance;\notherwise, a reference to the output array is returned.",
            "raises": "",
            "see_also": "--------\nstd, mean, nanmean, nanstd, nanvar\n:ref:`ufuncs-output-type`",
            "notes": "-----\nThe variance is the average of the squared deviations from the mean,\ni.e.,  ``var = mean(x)``, where ``x = abs(a - a.mean())**2``.\nThe mean is typically calculated as ``x.sum() / N``, where ``N = len(x)``.\nIf, however, `ddof` is specified, the divisor ``N - ddof`` is used\ninstead.  In standard statistical practice, ``ddof=1`` provides an\nunbiased estimator of the variance of a hypothetical infinite population.\n``ddof=0`` provides a maximum likelihood estimate of the variance for\nnormally distributed variables.\nNote that for complex numbers, the absolute value is taken before\nsquaring, so that the result is always real and nonnegative.\nFor floating-point input, the variance is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for `float32` (see example\nbelow).  Specifying a higher-accuracy accumulator using the ``dtype``\nkeyword can alleviate this issue.",
            "examples": "--------\n>>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([1.,  1.])\n>>> np.var(a, axis=1)\narray([0.25,  0.25])\nIn single precision, var() can be inaccurate:\n>>> a = np.zeros((2, 512*512), dtype=np.float32)\n>>> a[0, :] = 1.0\n>>> a[1, :] = 0.1\n>>> np.var(a)\n0.20250003\nComputing the variance in float64 is more accurate:\n>>> np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n>>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\nSpecifying a where argument:\n>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])\n>>> np.var(a)\n6.833333333333333 # may vary\n>>> np.var(a, where=[[True], [True], [False]])\n4.0"
          }
        },
        {
          "name": "view",
          "signature": "view(self, dtype=None, type=None, fill_value=None)",
          "documentation": {
            "description": "Return a view of the MaskedArray data.",
            "parameters": {
              "dtype": {
                "type": "data-type or ndarray sub-class, optional",
                "description": "Data-type descriptor of the returned view, e.g., float32 or int16.\nThe default, None, results in the view having the same data-type\nas `a`. As with ``ndarray.view``, dtype can also be specified as\nan ndarray sub-class, which then specifies the type of the\nreturned object (this is equivalent to setting the ``type``\nparameter)."
              },
              "type": {
                "type": "Python type, optional",
                "description": "Type of the returned view, either ndarray or a subclass.  The\ndefault None results in type preservation."
              },
              "fill_value": {
                "type": "scalar, optional",
                "description": "The value to use for invalid entries (None by default).\nIf None, then this argument is inferred from the passed `dtype`, or\nin its absence the original array, as discussed in the notes below."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.view : Equivalent method on ndarray object.",
            "notes": "-----\n``a.view()`` is used two different ways:\n``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view\nof the array's memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\n``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just\nreturns an instance of `ndarray_subclass` that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\nIf `fill_value` is not specified, but `dtype` is specified (and is not\nan ndarray sub-class), the `fill_value` of the MaskedArray will be\nreset. If neither `fill_value` nor `dtype` are specified (or if\n`dtype` is an ndarray sub-class), then the fill value is preserved.\nFinally, if `fill_value` is specified, but `dtype` is not, the fill\nvalue is set to the specified value.\nFor ``a.view(some_dtype)``, if ``some_dtype`` has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of ``a`` (shown\nby ``print(a)``). It also depends on exactly how ``a`` is stored in\nmemory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "bool_",
      "documentation": {
        "description": "Boolean type (True or False), stored as a byte.\n.. warning::\nThe :class:`bool_` type is not a subclass of the :class:`int_` type\n(the :class:`bool_` is not even a number type). This is different\nthan Python's default implementation of :class:`bool` as a\nsub-class of :class:`int`.\n:Character code: ``'?'``",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\nReturn a new `dtype` with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe `new_order` code can be any from the following:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order\n* {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {
              "new_order": {
                "type": "str, optional",
                "description": "Byte order to force; a value from the byte order specifications\nabove.  The default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_dtype : dtype\nNew `dtype` object with the given change to the byte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\nPlease see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "masked_array",
      "documentation": {
        "description": "An array class with possibly masked values.\nMasked values of True exclude the corresponding element from any\ncomputation.\nConstruction::\nx = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\nndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\nshrink=True, order=None)",
        "parameters": {
          "data": {
            "type": "array_like",
            "description": "Input data."
          },
          "mask": {
            "type": "sequence, optional",
            "description": "Mask. Must be convertible to an array of booleans with the same\nshape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "dtype": {
            "type": "dtype, optional",
            "description": "Data type of the output.\nIf `dtype` is None, the type of the data argument (``data.dtype``)\nis used. If `dtype` is not None and different from ``data.dtype``,\na copy is performed."
          },
          "copy": {
            "type": "bool, optional",
            "description": "Whether to copy the input data (True), or to use a reference instead.\nDefault is False."
          },
          "subok": {
            "type": "bool, optional",
            "description": "Whether to return a subclass of `MaskedArray` if possible (True) or a\nplain `MaskedArray`. Default is True."
          },
          "ndmin": {
            "type": "int, optional",
            "description": "Minimum number of dimensions. Default is 0."
          },
          "fill_value": {
            "type": "scalar, optional",
            "description": "Value used to fill in the masked values when necessary.\nIf None, a default based on the data-type is used."
          },
          "keep_mask": {
            "type": "bool, optional",
            "description": "Whether to combine `mask` with the mask of the input data, if any\n(True), or to use only `mask` for the output (False). Default is True."
          },
          "hard_mask": {
            "type": "bool, optional",
            "description": "Whether to use a hard mask or not. With a hard mask, masked values\ncannot be unmasked. Default is False."
          },
          "shrink": {
            "type": "bool, optional",
            "description": "Whether to force compression of an empty mask. Default is True."
          },
          "order": {
            "type": "{'C', 'F', 'A'}, optional",
            "description": "Specify the order of the array.  If order is 'C', then the array\nwill be in C-contiguous order (last-index varies the fastest).\nIf order is 'F', then the returned array will be in\nFortran-contiguous order (first-index varies the fastest).\nIf order is 'A' (default), then the returned array may be\nin any order (either C-, Fortran-contiguous, or even discontiguous),\nunless a copy is required, in which case it will be C-contiguous."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\nThe ``mask`` can be initialized with an array of boolean values\nwith the same shape as ``data``.\n>>> data = np.arange(6).reshape((2, 3))\n>>> np.ma.MaskedArray(data, mask=[[False, True, False],\n...                               [False, False, True]])\nmasked_array(\ndata=[[0, --, 2],\n[3, 4, --]],\nmask=[[False,  True, False],\n[False, False,  True]],\nfill_value=999999)\nAlternatively, the ``mask`` can be initialized to homogeneous boolean\narray with the same shape as ``data`` by passing in a scalar\nboolean value:\n>>> np.ma.MaskedArray(data, mask=False)\nmasked_array(\ndata=[[0, 1, 2],\n[3, 4, 5]],\nmask=[[False, False, False],\n[False, False, False]],\nfill_value=999999)\n>>> np.ma.MaskedArray(data, mask=True)\nmasked_array(\ndata=[[--, --, --],\n[--, --, --]],\nmask=[[ True,  True,  True],\n[ True,  True,  True]],\nfill_value=999999,\ndtype=int64)\n.. note::\nThe recommended practice for initializing ``mask`` with a scalar\nboolean value is to use ``True``/``False`` rather than\n``np.True_``/``np.False_``. The reason is :attr:`nomask`\nis represented internally as ``np.False_``.\n>>> np.False_ is np.ma.nomask\nTrue"
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(self, axis=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "The output array is masked where all the values along the given axis\nare masked: if the output would have been a scalar and that all the\nvalues are masked, then the output is `masked`.\nRefer to `numpy.all` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.all : corresponding function for ndarrays\nnumpy.all : equivalent function",
            "notes": "",
            "examples": "--------\n>>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue"
          }
        },
        {
          "name": "anom",
          "signature": "anom(self, axis=None, dtype=None)",
          "documentation": {
            "description": "Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.",
            "parameters": {
              "axis": {
                "type": "int, optional",
                "description": "Axis over which the anomalies are taken.\nThe default is to use the mean of the flattened array as reference."
              },
              "dtype": {
                "type": "dtype, optional",
                "description": "Type to use in computing the variance. For arrays of integer type\nthe default is float32; for arrays of float types it is the same as\nthe array type."
              }
            },
            "returns": "where the arithmetic mean is computed along the given axis.",
            "raises": "",
            "see_also": "--------\nmean : Compute the mean of the array.",
            "notes": "",
            "examples": "--------\n>>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data=[-1.,  0.,  1.],\nmask=False,\nfill_value=1e+20)"
          }
        },
        {
          "name": "any",
          "signature": "any(self, axis=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "Masked values are considered as False during computation.\nRefer to `numpy.any` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.any : corresponding function for ndarrays\nnumpy.any : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {
              "axis": {
                "type": "{None, integer}",
                "description": "If None, the index is into the flattened array, otherwise along\nthe specified axis"
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.  If None, the output of\nmaximum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None, array}, optional",
                "description": "Array into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output."
              }
            },
            "returns": "Masked values are treated as if they had the value fill_value.\n-------\nindex_array : {integer_array}",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])"
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "documentation": {
            "description": "Return array of indices to the minimum values along the given axis.",
            "parameters": {
              "axis": {
                "type": "{None, integer}",
                "description": "If None, the index is into the flattened array, otherwise along\nthe specified axis"
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.  If None, the output of\nminimum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None, array}, optional",
                "description": "Array into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output."
              }
            },
            "returns": "-------\nndarray or scalar\nIf multi-dimension input, returns a new ndarray of indices to the\nminimum values along the given axis.  Otherwise, returns a scalar\nof index to the minimum values along the given axis.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> x\nmasked_array(\ndata=[[--, --],\n[2, 3]],\nmask=[[ True,  True],\n[False, False]],\nfill_value=999999)\n>>> x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n>>> x.argmin(axis=0, fill_value=9)\narray([1, 1])"
          }
        },
        {
          "name": "argpartition",
          "signature": "argpartition(self, *args, **kwargs)",
          "documentation": {
            "description": "a.argpartition(kth, axis=-1, kind='introselect', order=None)",
            "parameters": {},
            "returns": "Refer to `numpy.argpartition` for full documentation.\n.. versionadded:: 1.8.0",
            "raises": "",
            "see_also": "--------\nnumpy.argpartition : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(self, axis=<no value>, kind=None, order=None, endwith=True, fill_value=None)",
          "documentation": {
            "description": "Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\n`fill_value`.",
            "parameters": {
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. If None, the default, the flattened array\nis used.\n..  versionchanged:: 1.13.0\nPreviously, the default was documented to be -1, but that was\nin error. At some future date, the default will change to -1, as\noriginally intended.\nUntil then, the axis should be given explicitly when\n``arr.ndim > 1``, to avoid a FutureWarning."
              },
              "kind": {
                "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
                "description": "The sorting algorithm used."
              },
              "order": {
                "type": "list, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  Not all fields need be\nspecified."
              },
              "endwith": {
                "type": "{True, False}, optional",
                "description": "Whether missing values (if any) should be treated as the largest values\n(True) or the smallest values (False)\nWhen the array contains unmasked values at the same extremes of the\ndatatype, the ordering of these values and the masked values is\nundefined."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used internally for the masked values.\nIf ``fill_value`` is not None, it supersedes ``endwith``."
              }
            },
            "returns": "-------\nindex_array : ndarray, int\nArray of indices that sort `a` along the specified axis.\nIn other words, ``a[index_array]`` yields a sorted `a`.",
            "raises": "",
            "see_also": "--------\nma.MaskedArray.sort : Describes sorting algorithms used.\nlexsort : Indirect stable sort with multiple keys.\nnumpy.ndarray.sort : Inplace sort.",
            "notes": "-----\nSee `sort` for notes on the different sorting algorithms.",
            "examples": "--------\n>>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data=[3, 2, --],\nmask=[False, False,  True],\nfill_value=999999)\n>>> a.argsort()\narray([1, 0, 2])"
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\nCopy of the array, cast to a specified type.",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "Typecode or data-type to which the array is cast."
              },
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout order of the result.\n'C' means C order, 'F' means Fortran order, 'A'\nmeans 'F' order if all the arrays are Fortran contiguous,\n'C' order otherwise, and 'K' means as close to the\norder the array elements appear in memory as possible.\nDefault is 'K'."
              },
              "casting": {
                "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
                "description": "Controls what kind of data casting may occur. Defaults to 'unsafe'\nfor backwards compatibility.\n* 'no' means the data types should not be cast at all.\n* 'equiv' means only byte-order changes are allowed.\n* 'safe' means only casts which can preserve values are allowed.\n* 'same_kind' means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n* 'unsafe' means any data conversions may be done."
              },
              "subok": {
                "type": "bool, optional",
                "description": "If True, then sub-classes will be passed-through (default), otherwise\nthe returned array will be forced to be a base-class array."
              },
              "copy": {
                "type": "bool, optional",
                "description": "By default, astype always returns a newly allocated array. If this\nis set to false, and the `dtype`, `order`, and `subok`\nrequirements are satisfied, the input array is returned instead\nof a copy."
              }
            },
            "returns": "-------\narr_t : ndarray\nUnless `copy` is False and the other conditions for returning the input\narray are satisfied (see description for `copy` input parameter), `arr_t`\nis a new array of the same shape as the input array, with dtype, order\ngiven by `dtype`, `order`.",
            "raises": "------\nComplexWarning\nWhen casting from complex to float or int. To avoid this,\none should use ``a.real.astype(t)``.",
            "see_also": "",
            "notes": "-----\n.. versionchanged:: 1.17.0\nCasting between a simple data type and a structured one is possible only\nfor \"unsafe\" casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n.. versionchanged:: 1.9.0\nCasting from numeric to string types in 'safe' casting mode requires\nthat the string dtype length is long enough to store the max\ninteger/float value converted.",
            "examples": "--------\n>>> x = np.array([1, 2, 2.5])\n>>> x\narray([1. ,  2. ,  2.5])\n>>> x.astype(int)\narray([1, 2, 2])"
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "a.byteswap(inplace=False)\nSwap the bytes of the array elements\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.",
            "parameters": {
              "inplace": {
                "type": "bool, optional",
                "description": "If ``True``, swap bytes in-place, default is ``False``."
              }
            },
            "returns": "-------\nout : ndarray\nThe byteswapped array. If `inplace` is ``True``, this is\na view to self.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> list(map(hex, A))\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n>>> list(map(hex, A))\n['0x100', '0x1', '0x3322']\nArrays of byte-strings are not swapped\n>>> A = np.array([b'ceg', b'fac'])\n>>> A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n``A.newbyteorder().byteswap()`` produces an array with the same values\nbut different representation in memory\n>>> A = np.array([1, 2, 3])\n>>> A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n0, 0], dtype=uint8)\n>>> A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n>>> A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n0, 3], dtype=uint8)"
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "a.choose(choices, out=None, mode='raise')\nUse an index array to construct a new array from a set of choices.\nRefer to `numpy.choose` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.choose : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "a.clip(min=None, max=None, out=None, **kwargs)\nReturn an array whose values are limited to ``[min, max]``.\nOne of max or min must be given.\nRefer to `numpy.clip` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.clip : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(self, condition, axis=None, out=None)",
          "documentation": {
            "description": "Return `a` where condition is ``True``.\nIf condition is a `~ma.MaskedArray`, missing values are considered\nas ``False``.",
            "parameters": {
              "condition": {
                "type": "var",
                "description": "Boolean 1-d array selecting which entries to return. If len(condition)\nis less than the size of a along the axis, then output is truncated\nto length of condition array."
              },
              "axis": {
                "type": "{None, int}, optional",
                "description": "Axis along which the operation must be performed."
              },
              "out": {
                "type": "{None, ndarray}, optional",
                "description": "Alternative output array in which to place the result. It must have\nthe same shape as the expected output but the type will be cast if\nnecessary."
              }
            },
            "returns": "-------\nresult : MaskedArray\nA :class:`~ma.MaskedArray` object.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nPlease note the difference with :meth:`compressed` !\nThe output of :meth:`compress` has a mask, the output of\n:meth:`compressed` does not.",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\nmask=[False, False],\nfill_value=999999)\n>>> x.compress([1, 0, 1], axis=1)\nmasked_array(\ndata=[[1, 3],\n[--, --],\n[7, 9]],\nmask=[[False, False],\n[ True,  True],\n[False, False]],\nfill_value=999999)"
          }
        },
        {
          "name": "compressed",
          "signature": "compressed(self)",
          "documentation": {
            "description": "Return all the non-masked data as a 1-D array.",
            "parameters": {},
            "returns": "-------\ndata : ndarray\nA new `ndarray` holding the non-masked data is returned.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nThe result is **not** a MaskedArray!",
            "examples": "--------\n>>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n>>> x.compressed()\narray([0, 1])\n>>> type(x.compressed())\n<class 'numpy.ndarray'>"
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "a.conj()\nComplex-conjugate all elements.\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "a.conjugate()\nReturn the complex conjugate, element-wise.\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(self, *args, **params)",
          "documentation": {
            "description": "a.copy(order='C')\nReturn a copy of the array.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout of the copy. 'C' means C-order,\n'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n'C' otherwise. 'K' means match the layout of `a` as closely\nas possible. (Note that this function and :func:`numpy.copy` are very\nsimilar but have different default values for their order=\narguments, and this function always passes sub-classes through.)\nSee also\n--------"
              },
              "numpy.copy": {
                "type": "Similar function with different default behavior",
                "description": "numpy.copyto"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\nThis function is the preferred method for creating an array copy.  The\nfunction :func:`numpy.copy` is similar, but it defaults to using order 'K',\nand will not pass sub-classes through by default.",
            "examples": "--------\n>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n>>> y = x.copy()\n>>> x.fill(0)\n>>> x\narray([[0, 0, 0],\n[0, 0, 0]])\n>>> y\narray([[1, 2, 3],\n[4, 5, 6]])\n>>> y.flags['C_CONTIGUOUS']\nTrue"
          }
        },
        {
          "name": "count",
          "signature": "count(self, axis=None, keepdims=<no value>)",
          "documentation": {
            "description": "Count the non-masked elements of the array along the given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis or axes along which the count is performed.\nThe default, None, performs the count over all\nthe dimensions of the input array. `axis` may be negative, in\nwhich case it counts from the last to the first axis.\n.. versionadded:: 1.10.0\nIf this is a tuple of ints, the count is performed on multiple\naxes, instead of a single axis or all the axes as before."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
              }
            },
            "returns": "-------\nresult : ndarray or scalar\nAn array with the same shape as the input array, with the specified\naxis removed. If the array is a 0-d array, or if `axis` is None, a\nscalar is returned.",
            "raises": "",
            "see_also": "--------\nma.count_masked : Count masked elements in array or along a given axis.",
            "notes": "",
            "examples": "--------\n>>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(\ndata=[[0, 1, 2],\n[--, --, --]],\nmask=[[False, False, False],\n[ True,  True,  True]],\nfill_value=999999)\n>>> a.count()\n3\nWhen the `axis` keyword is specified an array of appropriate size is\nreturned.\n>>> a.count(axis=0)\narray([1, 1, 1])\n>>> a.count(axis=1)\narray([3, 0])"
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(self, axis=None, dtype=None, out=None)",
          "documentation": {
            "description": "Return the cumulative product of the array elements over the given axis.\nMasked values are set to 1 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to `numpy.cumprod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.cumprod : corresponding function for ndarrays\nnumpy.cumprod : equivalent function",
            "notes": "-----\nThe mask is lost if `out` is not a valid MaskedArray !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(self, axis=None, dtype=None, out=None)",
          "documentation": {
            "description": "Return the cumulative sum of the array elements over the given axis.\nMasked values are set to 0 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to `numpy.cumsum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.cumsum : corresponding function for ndarrays\nnumpy.cumsum : equivalent function",
            "notes": "-----\nThe mask is lost if `out` is not a valid :class:`ma.MaskedArray` !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
            "examples": "--------\n>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\nmask=[False, False, False,  True,  True,  True, False, False,\nFalse, False],\nfill_value=999999)"
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(self, *args, **params)",
          "documentation": {
            "description": "a.diagonal(offset=0, axis1=0, axis2=1)\nReturn specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\nRefer to :func:`numpy.diagonal` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.diagonal : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dot",
          "signature": "dot(self, b, out=None, strict=False)",
          "documentation": {
            "description": "a.dot(b, out=None)\nMasked dot product of two arrays. Note that `out` and `strict` are\nlocated in different positions than in `ma.dot`. In order to\nmaintain compatibility with the functional version, it is\nrecommended that the optional arguments be treated as keyword only.\nAt some point that may be mandatory.\n.. versionadded:: 1.10.0",
            "parameters": {
              "b": {
                "type": "masked_array_like",
                "description": "Inputs array."
              },
              "out": {
                "type": "masked_array, optional",
                "description": "Output argument. This must have the exact kind that would be\nreturned if it was not used. In particular, it must have the\nright type, must be C-contiguous, and its dtype must be the\ndtype that would be returned for `ma.dot(a,b)`. This is a\nperformance feature. Therefore, if these conditions are not\nmet, an exception is raised, instead of attempting to be\nflexible."
              },
              "strict": {
                "type": "bool, optional",
                "description": "Whether masked data are propagated (True) or set to 0 (False)\nfor the computation. Default is False.  Propagating the mask\nmeans that if a masked value appears in a row or column, the\nwhole row or column is considered masked.\n.. versionadded:: 1.10.2"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ma.dot : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "a.dump(file)\nDump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.",
            "parameters": {
              "file": {
                "type": "str or Path",
                "description": "A string naming the dump file.\n.. versionchanged:: 1.17.0\n`pathlib.Path` objects are now accepted."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "a.dumps()",
            "parameters": {},
            "returns": "pickle.loads will convert the string back to an array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "a.fill(value)\nFill the array with a scalar value.",
            "parameters": {
              "value": {
                "type": "scalar",
                "description": "All elements of `a` will be assigned this value."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([1.,  1.])\nFill expects a scalar value and always behaves the same as assigning\nto a single array element.  The following is a rare example where this\ndistinction is important:\n>>> a = np.array([None, None], dtype=object)\n>>> a[0] = np.array(3)\n>>> a\narray([array(3), None], dtype=object)\n>>> a.fill(np.array(3))\n>>> a\narray([array(3), array(3)], dtype=object)\nWhere other forms of assignments will unpack the array being assigned:\n>>> a[...] = np.array(3)\n>>> a\narray([3, 3], dtype=object)"
          }
        },
        {
          "name": "filled",
          "signature": "filled(self, fill_value=None)",
          "documentation": {
            "description": "Return a copy of self, with masked values filled with a given value.\n**However**, if there are no masked values to fill, self will be\nreturned instead as an ndarray.",
            "parameters": {
              "fill_value": {
                "type": "array_like, optional",
                "description": "The value to use for invalid entries. Can be scalar or non-scalar.\nIf non-scalar, the resulting ndarray must be broadcastable over\ninput array. Default is None, in which case, the `fill_value`\nattribute of the array is used instead."
              }
            },
            "returns": "-------\nfilled_array : ndarray\nA copy of ``self`` with invalid entries replaced by *fill_value*\n(be it the function argument or the attribute of ``self``), or\n``self`` itself as an ndarray if there are no invalid entries to\nbe replaced.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nThe result is **not** a MaskedArray!",
            "examples": "--------\n>>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n>>> x.filled()\narray([   1,    2, -999,    4, -999])\n>>> x.filled(fill_value=1000)\narray([   1,    2, 1000,    4, 1000])\n>>> type(x.filled())\n<class 'numpy.ndarray'>\nSubclassing is preserved. This means that if, e.g., the data part of\nthe masked array is a recarray, `filled` returns a recarray:\n>>> x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)\n>>> m = np.ma.array(x, mask=[(True, False), (False, True)])\n>>> m.filled()\nrec.array([(999999,      2), (    -3, 999999)],\ndtype=[('f0', '<i8'), ('f1', '<i8')])"
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(self, *args, **params)",
          "documentation": {
            "description": "a.flatten(order='C')\nReturn a copy of the array collapsed into one dimension.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "'C' means to flatten in row-major (C-style) order.\n'F' means to flatten in column-major (Fortran-\nstyle) order. 'A' means to flatten in column-major\norder if `a` is Fortran *contiguous* in memory,\nrow-major order otherwise. 'K' means to flatten\n`a` in the order the elements occur in memory.\nThe default is 'C'."
              }
            },
            "returns": "-------\ny : ndarray\nA copy of the input array, flattened to one dimension.",
            "raises": "",
            "see_also": "--------\nravel : Return a flattened array.\nflat : A 1-D flat iterator over the array.",
            "notes": "",
            "examples": "--------\n>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])"
          }
        },
        {
          "name": "get_fill_value",
          "signature": "fill_value(self)",
          "documentation": {
            "description": "The filling value of the masked array is a scalar. When setting, None\nwill set to a default based on the data type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n>>> x = np.ma.array([0, 1.], fill_value=-np.inf)\n>>> x.fill_value\n-inf\n>>> x.fill_value = np.pi\n>>> x.fill_value\n3.1415926535897931 # may vary\nReset to default:\n>>> x.fill_value = None\n>>> x.fill_value\n1e+20"
          }
        },
        {
          "name": "get_imag",
          "signature": "imag(self)",
          "documentation": {
            "description": "The imaginary part of the masked array.\nThis property is a view on the imaginary part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nreal",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.imag\nmasked_array(data=[1.0, --, 1.6],\nmask=[False,  True, False],\nfill_value=1e+20)"
          }
        },
        {
          "name": "get_real",
          "signature": "real(self)",
          "documentation": {
            "description": "The real part of the masked array.\nThis property is a view on the real part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nimag",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.real\nmasked_array(data=[1.0, --, 3.45],\nmask=[False,  True, False],\nfill_value=1e+20)"
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "a.getfield(dtype, offset=0)",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "The data type of the view. The dtype size of the view can not be larger\nthan that of the array itself."
              },
              "offset": {
                "type": "int",
                "description": "Number of bytes to skip before beginning the element view."
              }
            },
            "returns": "A field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[1.+1.j,  0.+0.j],\n[0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[1.,  0.],\n[0.,  2.]])\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n>>> x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n[0.,  4.]])"
          }
        },
        {
          "name": "harden_mask",
          "signature": "harden_mask(self)",
          "documentation": {
            "description": "Force the mask to hard, preventing unmasking by assignment.\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `harden_mask` sets\n`~ma.MaskedArray.hardmask` to ``True`` (and returns the modified\nself).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nma.MaskedArray.hardmask\nma.MaskedArray.soften_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ids",
          "signature": "ids(self)",
          "documentation": {
            "description": "Return the addresses of the data and mask areas.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n>>> x.ids()\n(166670640, 166659832) # may vary\nIf the array has no mask, the address of `nomask` is returned. This address\nis typically not close to the data in memory:\n>>> x = np.ma.array([1, 2, 3])\n>>> x.ids()\n(166691080, 3083169284) # may vary"
          }
        },
        {
          "name": "iscontiguous",
          "signature": "iscontiguous(self)",
          "documentation": {
            "description": "Return a boolean indicating whether the data is contiguous.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([1, 2, 3])\n>>> x.iscontiguous()\nTrue\n`iscontiguous` returns one of the flags of the masked array:\n>>> x.flags\nC_CONTIGUOUS : True\nF_CONTIGUOUS : True\nOWNDATA : False\nWRITEABLE : True\nALIGNED : True\nWRITEBACKIFCOPY : False"
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "a.item(*args)\nCopy an element of an array to a standard Python scalar and return it.",
            "parameters": {},
            "returns": "-------\nz : Standard Python scalar object\nA copy of the specified element of the array as a suitable\nPython scalar",
            "raises": "",
            "see_also": "",
            "notes": "-----\nWhen the data type of `a` is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\n`item` is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python's optimized math.",
            "examples": "--------\n>>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n[1, 3, 6],\n[1, 0, 1]])\n>>> x.item(3)\n1\n>>> x.item(7)\n0\n>>> x.item((0, 1))\n2\n>>> x.item((2, 2))\n1"
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "a.itemset(*args)\nInsert scalar into an array (scalar is cast to array's dtype, if possible)\nThere must be at least 1 argument, and define the last argument\nas *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster\nthan ``a[args] = item``.  The item should be a scalar value and `args`\nmust select a single item in the array `a`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\nCompared to indexing syntax, `itemset` provides some speed increase\nfor placing a scalar into a particular location in an `ndarray`,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using `itemset` (and `item`) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.",
            "examples": "--------\n>>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n[1, 3, 6],\n[1, 0, 1]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[2, 2, 6],\n[1, 0, 6],\n[1, 0, 9]])"
          }
        },
        {
          "name": "max",
          "signature": "max(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the maximum along a given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis along which to operate.  By default, ``axis`` is None and the\nflattened input is used.\n.. versionadded:: 1.7.0\nIf this is a tuple of ints, the maximum is selected over multiple\naxes, instead of a single axis or all the axes as before."
              },
              "out": {
                "type": "array_like, optional",
                "description": "Alternative output array in which to place the result.  Must\nbe of the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.\nIf None, use the output of maximum_fill_value()."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
              }
            },
            "returns": "-------\namax : array_like\nNew array holding the result.\nIf ``out`` was specified, ``out`` is returned.",
            "raises": "",
            "see_also": "--------\nma.maximum_fill_value",
            "notes": "",
            "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [[-1., 2.5], [4., -2.], [3., 0.]]\n>>> mask = [[0, 0], [1, 0], [1, 0]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\ndata=[[-1.0, 2.5],\n[--, -2.0],\n[--, 0.0]],\nmask=[[False, False],\n[ True, False],\n[ True, False]],\nfill_value=1e+20)\n>>> ma.max(masked_x)\n2.5\n>>> ma.max(masked_x, axis=0)\nmasked_array(data=[-1.0, 2.5],\nmask=[False, False],\nfill_value=1e+20)\n>>> ma.max(masked_x, axis=1, keepdims=True)\nmasked_array(\ndata=[[2.5],\n[-2.0],\n[0.0]],\nmask=[[False],\n[False],\n[False]],\nfill_value=1e+20)\n>>> mask = [[1, 1], [1, 1], [1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.max(masked_x, axis=1)\nmasked_array(data=[--, --, --],\nmask=[ True,  True,  True],\nfill_value=1e+20,\ndtype=float64)"
          }
        },
        {
          "name": "mean",
          "signature": "mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "Masked entries are ignored, and result elements which are not\nfinite will be masked.\nRefer to `numpy.mean` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.mean : corresponding function for ndarrays\nnumpy.mean : Equivalent function\nnumpy.ma.average : Weighted average.",
            "notes": "",
            "examples": "--------\n>>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data=[1, 2, --],\nmask=[False, False,  True],\nfill_value=999999)\n>>> a.mean()\n1.5"
          }
        },
        {
          "name": "min",
          "signature": "min(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the minimum along a given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis along which to operate.  By default, ``axis`` is None and the\nflattened input is used.\n.. versionadded:: 1.7.0\nIf this is a tuple of ints, the minimum is selected over multiple\naxes, instead of a single axis or all the axes as before."
              },
              "out": {
                "type": "array_like, optional",
                "description": "Alternative output array in which to place the result.  Must be of\nthe same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.\nIf None, use the output of `minimum_fill_value`."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
              }
            },
            "returns": "-------\namin : array_like\nNew array holding the result.\nIf ``out`` was specified, ``out`` is returned.",
            "raises": "",
            "see_also": "--------\nma.minimum_fill_value",
            "notes": "",
            "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [[1., -2., 3.], [0.2, -0.7, 0.1]]\n>>> mask = [[1, 1, 0], [0, 0, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\ndata=[[--, --, 3.0],\n[0.2, -0.7, --]],\nmask=[[ True,  True, False],\n[False, False,  True]],\nfill_value=1e+20)\n>>> ma.min(masked_x)\n-0.7\n>>> ma.min(masked_x, axis=-1)\nmasked_array(data=[3.0, -0.7],\nmask=[False, False],\nfill_value=1e+20)\n>>> ma.min(masked_x, axis=0, keepdims=True)\nmasked_array(data=[[0.2, -0.7, 3.0]],\nmask=[[False, False, False]],\nfill_value=1e+20)\n>>> mask = [[1, 1, 1,], [1, 1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.min(masked_x, axis=0)\nmasked_array(data=[--, --, --],\nmask=[ True,  True,  True],\nfill_value=1e+20,\ndtype=float64)"
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(...)",
          "documentation": {
            "description": "arr.newbyteorder(new_order='S', /)\nReturn the array with the same data viewed with a different byte order.\nEquivalent to::\narr.view(arr.dtype.newbytorder(new_order))\nChanges are also made in all fields and sub-arrays of the array data\ntype.",
            "parameters": {
              "new_order": {
                "type": "string, optional",
                "description": "Byte order to force; a value from the byte order specifications\nbelow. `new_order` codes can be any of:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order, equivalent to `sys.byteorder`\n* {'|', 'I'} - ignore (no change to byte order)\nThe default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_arr : array\nNew array object with the dtype reflecting given change to the\nbyte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(self)",
          "documentation": {
            "description": "Return the indices of unmasked elements that are not zero.",
            "parameters": {},
            "returns": "indices of the non-zero elements in that dimension. The corresponding\nnon-zero values can be obtained with::\na[a.nonzero()]\nTo group the indices by element, rather than dimension, use\ninstead::\nnp.transpose(a.nonzero())\nThe result of this is always a 2d array, with a row for each non-zero\nelement.\n-------\ntuple_of_arrays : tuple\nIndices of elements that are non-zero.",
            "raises": "",
            "see_also": "--------\nnumpy.nonzero :\nFunction operating on ndarrays.\nflatnonzero :\nReturn indices that are non-zero in the flattened version of the input\narray.\nnumpy.ndarray.nonzero :\nEquivalent ndarray method.\ncount_nonzero :\nCounts the number of non-zero elements in the input array.",
            "notes": "",
            "examples": "--------\n>>> import numpy.ma as ma\n>>> x = ma.array(np.eye(3))\n>>> x\nmasked_array(\ndata=[[1., 0., 0.],\n[0., 1., 0.],\n[0., 0., 1.]],\nmask=False,\nfill_value=1e+20)\n>>> x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\nMasked elements are ignored.\n>>> x[1, 1] = ma.masked\n>>> x\nmasked_array(\ndata=[[1.0, 0.0, 0.0],\n[0.0, --, 0.0],\n[0.0, 0.0, 1.0]],\nmask=[[False, False, False],\n[False,  True, False],\n[False, False, False]],\nfill_value=1e+20)\n>>> x.nonzero()\n(array([0, 2]), array([0, 2]))\nIndices can also be grouped by element.\n>>> np.transpose(x.nonzero())\narray([[0, 0],\n[2, 2]])\nA common use for ``nonzero`` is to find the indices of an array, where\na condition is True.  Given an array `a`, the condition `a` > 3 is a\nboolean array and since False is interpreted as 0, ma.nonzero(a > 3)\nyields the indices of the `a` where the condition is true.\n>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n>>> a > 3\nmasked_array(\ndata=[[False, False, False],\n[ True,  True,  True],\n[ True,  True,  True]],\nmask=False,\nfill_value=True)\n>>> ma.nonzero(a > 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\nThe ``nonzero`` method of the condition array can also be called.\n>>> (a > 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))"
          }
        },
        {
          "name": "partition",
          "signature": "partition(self, *args, **kwargs)",
          "documentation": {
            "description": "a.partition(kth, axis=-1, kind='introselect', order=None)\nRearranges the elements in the array in such a way that the value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.\n.. versionadded:: 1.8.0",
            "parameters": {
              "kth": {
                "type": "int or sequence of ints",
                "description": "Element index to partition by. The kth element value will be in its\nfinal sorted position and all smaller elements will be moved before it\nand all equal or greater elements behind it.\nThe order of all elements in the partitions is undefined.\nIf provided with a sequence of kth it will partition all elements\nindexed by kth of them into their sorted position at once.\n.. deprecated:: 1.22.0\nPassing booleans as index is deprecated."
              },
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. Default is -1, which means sort along the\nlast axis."
              },
              "kind": {
                "type": "{'introselect'}, optional",
                "description": "Selection algorithm. Default is 'introselect'."
              },
              "order": {
                "type": "str or list of str, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc. A single field can\nbe specified as a string, and not all fields need to be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.partition : Return a partitioned copy of an array.\nargpartition : Indirect partition.\nsort : Full sort.",
            "notes": "-----\nSee ``np.partition`` for notes on the different algorithms.",
            "examples": "--------\n>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])\n>>> a.partition((1, 3))\n>>> a\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "prod",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the product of the array elements over the given axis.\nMasked elements are set to 1 internally for computation.\nRefer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
            "notes": "-----\nArithmetic is modular when using integer types, and no error is raised\non overflow.",
            "examples": ""
          }
        },
        {
          "name": "product",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the product of the array elements over the given axis.\nMasked elements are set to 1 internally for computation.\nRefer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
            "notes": "-----\nArithmetic is modular when using integer types, and no error is raised\non overflow.",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(self, axis=None, out=None, fill_value=None, keepdims=False)",
          "documentation": {
            "description": "Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).\n.. warning::\n`ptp` preserves the data type of the array. This means the\nreturn value for an input of signed integers with n bits\n(e.g. `np.int8`, `np.int16`, etc) is also a signed integer\nwith n bits.  In that case, peak-to-peak values greater than\n``2**(n-1)-1`` will be returned as negative values. An example\nwith a work-around is shown below.",
            "parameters": {
              "axis": {
                "type": "{None, int}, optional",
                "description": "Axis along which to find the peaks.  If None (default) the\nflattened array is used."
              },
              "out": {
                "type": "{None, array_like}, optional",
                "description": "Alternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output\nbut the type will be cast if necessary."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
              }
            },
            "returns": "-------\nptp : ndarray.\nA new array holding the result, unless ``out`` was\nspecified, in which case a reference to ``out`` is returned.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.MaskedArray([[4, 9, 2, 10],\n...                        [6, 9, 7, 12]])\n>>> x.ptp(axis=1)\nmasked_array(data=[8, 6],\nmask=False,\nfill_value=999999)\n>>> x.ptp(axis=0)\nmasked_array(data=[2, 0, 5, 2],\nmask=False,\nfill_value=999999)\n>>> x.ptp()\n10\nThis example shows that a negative value can be returned when\nthe input is an array of signed integers.\n>>> y = np.ma.MaskedArray([[1, 127],\n...                        [0, 127],\n...                        [-1, 127],\n...                        [-2, 127]], dtype=np.int8)\n>>> y.ptp(axis=1)\nmasked_array(data=[ 126,  127, -128, -127],\nmask=False,\nfill_value=999999,\ndtype=int8)\nA work-around is to use the `view()` method to view the result as\nunsigned integers with the same bit width:\n>>> y.ptp(axis=1).view(np.uint8)\nmasked_array(data=[126, 127, 128, 129],\nmask=False,\nfill_value=999999,\ndtype=uint8)"
          }
        },
        {
          "name": "put",
          "signature": "put(self, indices, values, mode='raise')",
          "documentation": {
            "description": "Set storage-indexed locations to corresponding values.\nSets self._data.flat[n] = values[n] for each n in indices.\nIf `values` is shorter than `indices` then it will repeat.\nIf `values` has some masked values, the initial mask is updated\nin consequence, else the corresponding values are unmasked.",
            "parameters": {
              "indices": {
                "type": "1-D array_like",
                "description": "Target indices, interpreted as integers."
              },
              "values": {
                "type": "array_like",
                "description": "Values to place in self._data copy at target indices."
              },
              "mode": {
                "type": "{'raise', 'wrap', 'clip'}, optional",
                "description": "Specifies how out-of-bounds indices will behave.\n'raise' : raise an error.\n'wrap' : wrap around.\n'clip' : clip to the range."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\n`values` can be a scalar or length 1 array.",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.put([0,4,8],[10,20,30])\n>>> x\nmasked_array(\ndata=[[10, --, 3],\n[--, 20, --],\n[7, --, 30]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.put(4,999)\n>>> x\nmasked_array(\ndata=[[10, --, 3],\n[--, 999, --],\n[7, --, 30]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)"
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(self, order='C')",
          "documentation": {
            "description": "",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "The elements of `a` are read using this index order. 'C' means to\nindex the elements in C-like order, with the last axis index\nchanging fastest, back to the first axis index changing slowest.\n'F' means to index the elements in Fortran-like index order, with\nthe first index changing fastest, and the last index changing\nslowest. Note that the 'C' and 'F' options take no account of the\nmemory layout of the underlying array, and only refer to the order\nof axis indexing.  'A' means to read the elements in Fortran-like\nindex order if `m` is Fortran *contiguous* in memory, C-like order\notherwise.  'K' means to read the elements in the order they occur\nin memory, except for reversing the data when strides are negative.\nBy default, 'C' index order is used.\n(Masked arrays currently use 'A' on the data when 'K' is passed.)"
              }
            },
            "returns": "-------\nMaskedArray\nOutput view is of shape ``(self.size,)`` (or\n``(np.ma.product(self.shape),)``).",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\nmask=[False,  True, False,  True, False,  True, False,  True,\nFalse],\nfill_value=999999)"
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(self, *args, **params)",
          "documentation": {
            "description": "a.repeat(repeats, axis=None)\nRepeat elements of an array.\nRefer to `numpy.repeat` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.repeat : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(self, *s, **kwargs)",
          "documentation": {
            "description": "Give a new shape to the array without changing its data.",
            "parameters": {
              "shape": {
                "type": "int or tuple of ints",
                "description": "The new shape should be compatible with the original shape. If an\ninteger is supplied, then the result will be a 1-D array of that\nlength."
              },
              "order": {
                "type": "{'C', 'F'}, optional",
                "description": "Determines whether the array data should be viewed as in C\n(row-major) or FORTRAN (column-major) order."
              }
            },
            "returns": "The result is a view on the original array; if this is not possible, a\nValueError is raised.\n-------\nreshaped_array : array\nA new view on the array.",
            "raises": "",
            "see_also": "--------\nreshape : Equivalent function in the masked array module.\nnumpy.ndarray.reshape : Equivalent method on ndarray object.\nnumpy.reshape : Equivalent function in the NumPy module.",
            "notes": "-----\nThe reshaping operation cannot guarantee that a copy will not be made,\nto modify the shape in place, use ``a.shape = s``",
            "examples": "--------\n>>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n>>> x\nmasked_array(\ndata=[[--, 2],\n[3, --]],\nmask=[[ True, False],\n[False,  True]],\nfill_value=999999)\n>>> x = x.reshape((4,1))\n>>> x\nmasked_array(\ndata=[[--],\n[2],\n[3],\n[--]],\nmask=[[ True],\n[False],\n[False],\n[ True]],\nfill_value=999999)"
          }
        },
        {
          "name": "resize",
          "signature": "resize(self, newshape, refcheck=True, order=False)",
          "documentation": {
            "description": ".. warning::\nThis method does nothing, except raise a ValueError exception. A\nmasked array does not own its data and therefore cannot safely be\nresized in place. Use the `numpy.ma.resize` function instead.\nThis method is difficult to implement safely and may be deprecated in\nfuture releases of NumPy.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(self, decimals=0, out=None)",
          "documentation": {
            "description": "Return each element rounded to the given number of decimals.\nRefer to `numpy.around` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.round : corresponding function for ndarrays\nnumpy.around : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "a.searchsorted(v, side='left', sorter=None)\nFind indices where elements of v should be inserted in a to maintain order.\nFor full documentation, see `numpy.searchsorted`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.searchsorted : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_fill_value",
          "signature": "fill_value(self, value=None)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "a.setfield(val, dtype, offset=0)\nPut a value into a specified place in a field defined by a data-type.\nPlace `val` into `a`'s field defined by `dtype` and beginning `offset`\nbytes into the field.",
            "parameters": {
              "val": {
                "type": "object",
                "description": "Value to be placed in field."
              },
              "dtype": {
                "type": "dtype object",
                "description": "Data-type of the field in which to place `val`."
              },
              "offset": {
                "type": "int, optional",
                "description": "The number of bytes into the field at which to place `val`."
              }
            },
            "returns": "-------\nNone",
            "raises": "",
            "see_also": "--------\ngetfield",
            "notes": "",
            "examples": "--------\n>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[1.,  0.,  0.],\n[0.,  1.,  0.],\n[0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n[3, 3, 3],\n[3, 3, 3]], dtype=int32)\n>>> x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n[1.5e-323, 1.0e+000, 1.5e-323],\n[1.5e-323, 1.5e-323, 1.0e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[1.,  0.,  0.],\n[0.,  1.,  0.],\n[0.,  0.,  1.]])"
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "a.setflags(write=None, align=None, uic=None)\nSet array flags WRITEABLE, ALIGNED, WRITEBACKIFCOPY,\nrespectively.\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by `a` (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and flag can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)",
            "parameters": {
              "write": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` can be written to."
              },
              "align": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is aligned properly for its type."
              },
              "uic": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is a copy of another \"base\" array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\nArray flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, WRITEABLE, and ALIGNED.\nWRITEABLE (W) the data area can be written to;\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.",
            "examples": "--------\n>>> y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n>>> y\narray([[3, 1, 7],\n[2, 0, 0],\n[8, 5, 9]])\n>>> y.flags\nC_CONTIGUOUS : True\nF_CONTIGUOUS : False\nOWNDATA : True\nWRITEABLE : True\nALIGNED : True\nWRITEBACKIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\nC_CONTIGUOUS : True\nF_CONTIGUOUS : False\nOWNDATA : True\nWRITEABLE : False\nALIGNED : False\nWRITEBACKIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: cannot set WRITEBACKIFCOPY flag to True"
          }
        },
        {
          "name": "shrink_mask",
          "signature": "shrink_mask(self)",
          "documentation": {
            "description": "Reduce a mask to nomask when possible.",
            "parameters": {},
            "returns": "-------\nNone",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n>>> x.mask\narray([[False, False],\n[False, False]])\n>>> x.shrink_mask()\nmasked_array(\ndata=[[1, 2],\n[3, 4]],\nmask=False,\nfill_value=999999)\n>>> x.mask\nFalse"
          }
        },
        {
          "name": "soften_mask",
          "signature": "soften_mask(self)",
          "documentation": {
            "description": "Force the mask to soft (default), allowing unmasking by assignment.\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `soften_mask` sets\n`~ma.MaskedArray.hardmask` to ``False`` (and returns the modified\nself).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nma.MaskedArray.hardmask\nma.MaskedArray.harden_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(self, axis=-1, kind=None, order=None, endwith=True, fill_value=None)",
          "documentation": {
            "description": "Sort the array, in-place",
            "parameters": {
              "a": {
                "type": "array_like",
                "description": "Array to be sorted."
              },
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. If None, the array is flattened before\nsorting. The default is -1, which sorts along the last axis."
              },
              "kind": {
                "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
                "description": "The sorting algorithm used."
              },
              "order": {
                "type": "list, optional",
                "description": "When `a` is a structured array, this argument specifies which fields\nto compare first, second, and so on.  This list does not need to\ninclude all of the fields."
              },
              "endwith": {
                "type": "{True, False}, optional",
                "description": "Whether missing values (if any) should be treated as the largest values\n(True) or the smallest values (False)\nWhen the array contains unmasked values sorting at the same extremes of the\ndatatype, the ordering of these values and the masked values is\nundefined."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used internally for the masked values.\nIf ``fill_value`` is not None, it supersedes ``endwith``."
              }
            },
            "returns": "-------\nsorted_array : ndarray\nArray of the same type and shape as `a`.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.sort : Method to sort an array in-place.\nargsort : Indirect sort.\nlexsort : Indirect stable sort on multiple keys.\nsearchsorted : Find elements in a sorted array.",
            "notes": "-----\nSee ``sort`` for notes on the different sorting algorithms.",
            "examples": "--------\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Default\n>>> a.sort()\n>>> a\nmasked_array(data=[1, 3, 5, --, --],\nmask=[False, False, False,  True,  True],\nfill_value=999999)\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Put missing values in the front\n>>> a.sort(endwith=False)\n>>> a\nmasked_array(data=[--, --, 1, 3, 5],\nmask=[ True,  True, False, False, False],\nfill_value=999999)\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # fill_value takes over endwith\n>>> a.sort(endwith=False, fill_value=3)\n>>> a\nmasked_array(data=[1, --, --, 3, 5],\nmask=[False,  True,  True, False, False],\nfill_value=999999)"
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(self, *args, **params)",
          "documentation": {
            "description": "a.squeeze(axis=None)\nRemove axes of length one from `a`.\nRefer to `numpy.squeeze` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.squeeze : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "Masked entries are ignored.\nRefer to `numpy.std` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.std : corresponding function for ndarrays\nnumpy.std : Equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the sum of the array elements over the given axis.\nMasked elements are set to 0 internally.\nRefer to `numpy.sum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.sum : corresponding function for ndarrays\nnumpy.sum : equivalent function",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.sum()\n25\n>>> x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\nmask=[False, False, False],\nfill_value=999999)\n>>> x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\nmask=[False, False, False],\nfill_value=999999)\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<class 'numpy.int64'>"
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(self, *args, **params)",
          "documentation": {
            "description": "a.swapaxes(axis1, axis2)\nReturn a view of the array with `axis1` and `axis2` interchanged.\nRefer to `numpy.swapaxes` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.swapaxes : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(self, indices, axis=None, out=None, mode='raise')",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(self, fill_value=None, order='C')",
          "documentation": {
            "description": "Return the array data as a string containing the raw bytes in the array.\nThe array is filled with a fill value before the string conversion.\n.. versionadded:: 1.9.0",
            "parameters": {
              "fill_value": {
                "type": "scalar, optional",
                "description": "Value used to fill in the masked values. Default is None, in which\ncase `MaskedArray.fill_value` is used."
              },
              "order": {
                "type": "{'C','F','A'}, optional",
                "description": "Order of the data item in the copy. Default is 'C'.\n- 'C'   -- C order (row major).\n- 'F'   -- Fortran order (column major).\n- 'A'   -- Any, current order of array.\n- None  -- Same as 'A'."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.tobytes\ntolist, tofile",
            "notes": "-----\nAs for `ndarray.tobytes`, information about the shape, dtype, etc.,\nbut also about `fill_value`, will be lost.",
            "examples": "--------\n>>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n>>> x.tobytes()\nb'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(self, fid, sep='', format='%s')",
          "documentation": {
            "description": "Save a masked array to a file in binary format.\n.. warning::\nThis function is not implemented yet.",
            "parameters": {},
            "returns": "",
            "raises": "------\nNotImplementedError\nWhen `tofile` is called.",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "toflex",
          "signature": "toflex(self)",
          "documentation": {
            "description": "Transforms a masked array into a flexible-type array.\nThe flexible type array that is returned will have two fields:\n* the ``_data`` field stores the ``_data`` part of the array.\n* the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "-------\nrecord : ndarray\nA new flexible-type `ndarray` with two fields: the first element\ncontaining a value, the second element containing the corresponding\nmask boolean. The returned record shape matches self.shape.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nA side-effect of transforming a masked array into a flexible `ndarray` is\nthat meta information (``fill_value``, ...) will be lost.",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n[(4,  True), (5, False), (6,  True)],\n[(7, False), (8,  True), (9, False)]],\ndtype=[('_data', '<i8'), ('_mask', '?')])"
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(self, fill_value=None)",
          "documentation": {
            "description": "Return the data portion of the masked array as a hierarchical Python list.\nData items are converted to the nearest compatible Python type.\nMasked values are converted to `fill_value`. If `fill_value` is None,\nthe corresponding entries in the output list will be ``None``.",
            "parameters": {
              "fill_value": {
                "type": "scalar, optional",
                "description": "The value to use for invalid entries. Default is None."
              }
            },
            "returns": "-------\nresult : list\nThe Python list representation of the masked array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n>>> x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n>>> x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]"
          }
        },
        {
          "name": "torecords",
          "signature": "toflex(self)",
          "documentation": {
            "description": "Transforms a masked array into a flexible-type array.\nThe flexible type array that is returned will have two fields:\n* the ``_data`` field stores the ``_data`` part of the array.\n* the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "-------\nrecord : ndarray\nA new flexible-type `ndarray` with two fields: the first element\ncontaining a value, the second element containing the corresponding\nmask boolean. The returned record shape matches self.shape.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nA side-effect of transforming a masked array into a flexible `ndarray` is\nthat meta information (``fill_value``, ...) will be lost.",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n[(4,  True), (5, False), (6,  True)],\n[(7, False), (8,  True), (9, False)]],\ndtype=[('_data', '<i8'), ('_mask', '?')])"
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(self, fill_value=None, order='C')",
          "documentation": {
            "description": "A compatibility alias for `tobytes`, with exactly the same behavior.\nDespite its name, it returns `bytes` not `str`\\ s.\n.. deprecated:: 1.19.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)",
          "documentation": {
            "description": "a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\nReturn the sum along diagonals of the array.\nRefer to `numpy.trace` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.trace : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(self, *args, **params)",
          "documentation": {
            "description": "a.transpose(*axes)",
            "parameters": {
              "axes": {
                "type": "None, tuple of ints, or `n` ints",
                "description": "* None or no argument: reverses the order of the axes.\n* tuple of ints: `i` in the `j`-th place in the tuple means that the\narray's `i`-th axis becomes the transposed array's `j`-th axis.\n* `n` ints: same as an n-tuple of the same ints (this form is\nintended simply as a \"convenience\" alternative to the tuple form)."
              }
            },
            "returns": "Refer to `numpy.transpose` for full documentation.\n-------\np : ndarray\nView of the array with its axes suitably permuted.",
            "raises": "",
            "see_also": "--------\ntranspose : Equivalent function.\nndarray.T : Array property returning the array transposed.\nndarray.reshape : Give a new shape to an array without changing its data.",
            "notes": "",
            "examples": "--------\n>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n[3, 4]])\n>>> a.transpose()\narray([[1, 3],\n[2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n[2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n[2, 4]])\n>>> a = np.array([1, 2, 3, 4])\n>>> a\narray([1, 2, 3, 4])\n>>> a.transpose()\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "unshare_mask",
          "signature": "unshare_mask(self)",
          "documentation": {
            "description": "Copy the mask and set the `sharedmask` flag to ``False``.\nWhether the mask is shared between masked arrays can be seen from\nthe `sharedmask` property. `unshare_mask` ensures the mask is not\nshared. A copy of the mask is only made if it was shared.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nsharedmask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "documentation": {
            "description": "Compute the variance along the specified axis.",
            "parameters": {
              "a": {
                "type": "array_like",
                "description": "Array containing numbers whose variance is desired.  If `a` is not an\narray, a conversion is attempted."
              },
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis or axes along which the variance is computed.  The default is to\ncompute the variance of the flattened array.\n.. versionadded:: 1.7.0\nIf this is a tuple of ints, a variance is performed over multiple axes,\ninstead of a single axis or all the axes as before."
              },
              "dtype": {
                "type": "data-type, optional",
                "description": "Type to use in computing the variance.  For arrays of integer type\nthe default is `float64`; for arrays of float types it is the same as\nthe array type."
              },
              "out": {
                "type": "ndarray, optional",
                "description": "Alternate output array in which to place the result.  It must have\nthe same shape as the expected output, but the type is cast if\nnecessary."
              },
              "ddof": {
                "type": "int, optional",
                "description": "\"Delta Degrees of Freedom\": the divisor used in the calculation is\n``N - ddof``, where ``N`` represents the number of elements. By\ndefault `ddof` is zero."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then `keepdims` will not be\npassed through to the `var` method of sub-classes of\n`ndarray`, however any non-default value will be.  If the\nsub-class' method does not implement `keepdims` any\nexceptions will be raised."
              },
              "where": {
                "type": "array_like of bool, optional",
                "description": "Elements to include in the variance. See `~numpy.ufunc.reduce` for\ndetails.\n.. versionadded:: 1.20.0"
              }
            },
            "returns": "distribution.  The variance is computed for the flattened array by\ndefault, otherwise over the specified axis.\n-------\nvariance : ndarray, see dtype parameter above\nIf ``out=None``, returns a new array containing the variance;\notherwise, a reference to the output array is returned.",
            "raises": "",
            "see_also": "--------\nstd, mean, nanmean, nanstd, nanvar\n:ref:`ufuncs-output-type`",
            "notes": "-----\nThe variance is the average of the squared deviations from the mean,\ni.e.,  ``var = mean(x)``, where ``x = abs(a - a.mean())**2``.\nThe mean is typically calculated as ``x.sum() / N``, where ``N = len(x)``.\nIf, however, `ddof` is specified, the divisor ``N - ddof`` is used\ninstead.  In standard statistical practice, ``ddof=1`` provides an\nunbiased estimator of the variance of a hypothetical infinite population.\n``ddof=0`` provides a maximum likelihood estimate of the variance for\nnormally distributed variables.\nNote that for complex numbers, the absolute value is taken before\nsquaring, so that the result is always real and nonnegative.\nFor floating-point input, the variance is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for `float32` (see example\nbelow).  Specifying a higher-accuracy accumulator using the ``dtype``\nkeyword can alleviate this issue.",
            "examples": "--------\n>>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([1.,  1.])\n>>> np.var(a, axis=1)\narray([0.25,  0.25])\nIn single precision, var() can be inaccurate:\n>>> a = np.zeros((2, 512*512), dtype=np.float32)\n>>> a[0, :] = 1.0\n>>> a[1, :] = 0.1\n>>> np.var(a)\n0.20250003\nComputing the variance in float64 is more accurate:\n>>> np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n>>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\nSpecifying a where argument:\n>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])\n>>> np.var(a)\n6.833333333333333 # may vary\n>>> np.var(a, where=[[True], [True], [False]])\n4.0"
          }
        },
        {
          "name": "view",
          "signature": "view(self, dtype=None, type=None, fill_value=None)",
          "documentation": {
            "description": "Return a view of the MaskedArray data.",
            "parameters": {
              "dtype": {
                "type": "data-type or ndarray sub-class, optional",
                "description": "Data-type descriptor of the returned view, e.g., float32 or int16.\nThe default, None, results in the view having the same data-type\nas `a`. As with ``ndarray.view``, dtype can also be specified as\nan ndarray sub-class, which then specifies the type of the\nreturned object (this is equivalent to setting the ``type``\nparameter)."
              },
              "type": {
                "type": "Python type, optional",
                "description": "Type of the returned view, either ndarray or a subclass.  The\ndefault None results in type preservation."
              },
              "fill_value": {
                "type": "scalar, optional",
                "description": "The value to use for invalid entries (None by default).\nIf None, then this argument is inferred from the passed `dtype`, or\nin its absence the original array, as discussed in the notes below."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.view : Equivalent method on ndarray object.",
            "notes": "-----\n``a.view()`` is used two different ways:\n``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view\nof the array's memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\n``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just\nreturns an instance of `ndarray_subclass` that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\nIf `fill_value` is not specified, but `dtype` is specified (and is not\nan ndarray sub-class), the `fill_value` of the MaskedArray will be\nreset. If neither `fill_value` nor `dtype` are specified (or if\n`dtype` is an ndarray sub-class), then the fill value is preserved.\nFinally, if `fill_value` is specified, but `dtype` is not, the fill\nvalue is set to the specified value.\nFor ``a.view(some_dtype)``, if ``some_dtype`` has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of ``a`` (shown\nby ``print(a)``). It also depends on exactly how ``a`` is stored in\nmemory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "mvoid",
      "documentation": {
        "description": "Fake a 'void' object to use for masked array with structured dtypes.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(self, axis=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "The output array is masked where all the values along the given axis\nare masked: if the output would have been a scalar and that all the\nvalues are masked, then the output is `masked`.\nRefer to `numpy.all` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.all : corresponding function for ndarrays\nnumpy.all : equivalent function",
            "notes": "",
            "examples": "--------\n>>> np.ma.array([1,2,3]).all()\nTrue\n>>> a = np.ma.array([1,2,3], mask=True)\n>>> (a.all() is np.ma.masked)\nTrue"
          }
        },
        {
          "name": "anom",
          "signature": "anom(self, axis=None, dtype=None)",
          "documentation": {
            "description": "Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.",
            "parameters": {
              "axis": {
                "type": "int, optional",
                "description": "Axis over which the anomalies are taken.\nThe default is to use the mean of the flattened array as reference."
              },
              "dtype": {
                "type": "dtype, optional",
                "description": "Type to use in computing the variance. For arrays of integer type\nthe default is float32; for arrays of float types it is the same as\nthe array type."
              }
            },
            "returns": "where the arithmetic mean is computed along the given axis.",
            "raises": "",
            "see_also": "--------\nmean : Compute the mean of the array.",
            "notes": "",
            "examples": "--------\n>>> a = np.ma.array([1,2,3])\n>>> a.anom()\nmasked_array(data=[-1.,  0.,  1.],\nmask=False,\nfill_value=1e+20)"
          }
        },
        {
          "name": "any",
          "signature": "any(self, axis=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "Masked values are considered as False during computation.\nRefer to `numpy.any` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.any : corresponding function for ndarrays\nnumpy.any : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {
              "axis": {
                "type": "{None, integer}",
                "description": "If None, the index is into the flattened array, otherwise along\nthe specified axis"
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.  If None, the output of\nmaximum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None, array}, optional",
                "description": "Array into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output."
              }
            },
            "returns": "Masked values are treated as if they had the value fill_value.\n-------\nindex_array : {integer_array}",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> a = np.arange(6).reshape(2,3)\n>>> a.argmax()\n5\n>>> a.argmax(0)\narray([1, 1, 1])\n>>> a.argmax(1)\narray([2, 2])"
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "documentation": {
            "description": "Return array of indices to the minimum values along the given axis.",
            "parameters": {
              "axis": {
                "type": "{None, integer}",
                "description": "If None, the index is into the flattened array, otherwise along\nthe specified axis"
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.  If None, the output of\nminimum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None, array}, optional",
                "description": "Array into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output."
              }
            },
            "returns": "-------\nndarray or scalar\nIf multi-dimension input, returns a new ndarray of indices to the\nminimum values along the given axis.  Otherwise, returns a scalar\nof index to the minimum values along the given axis.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n>>> x.shape = (2,2)\n>>> x\nmasked_array(\ndata=[[--, --],\n[2, 3]],\nmask=[[ True,  True],\n[False, False]],\nfill_value=999999)\n>>> x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n>>> x.argmin(axis=0, fill_value=9)\narray([1, 1])"
          }
        },
        {
          "name": "argpartition",
          "signature": "argpartition(self, *args, **kwargs)",
          "documentation": {
            "description": "a.argpartition(kth, axis=-1, kind='introselect', order=None)",
            "parameters": {},
            "returns": "Refer to `numpy.argpartition` for full documentation.\n.. versionadded:: 1.8.0",
            "raises": "",
            "see_also": "--------\nnumpy.argpartition : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(self, axis=<no value>, kind=None, order=None, endwith=True, fill_value=None)",
          "documentation": {
            "description": "Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\n`fill_value`.",
            "parameters": {
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. If None, the default, the flattened array\nis used.\n..  versionchanged:: 1.13.0\nPreviously, the default was documented to be -1, but that was\nin error. At some future date, the default will change to -1, as\noriginally intended.\nUntil then, the axis should be given explicitly when\n``arr.ndim > 1``, to avoid a FutureWarning."
              },
              "kind": {
                "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
                "description": "The sorting algorithm used."
              },
              "order": {
                "type": "list, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  Not all fields need be\nspecified."
              },
              "endwith": {
                "type": "{True, False}, optional",
                "description": "Whether missing values (if any) should be treated as the largest values\n(True) or the smallest values (False)\nWhen the array contains unmasked values at the same extremes of the\ndatatype, the ordering of these values and the masked values is\nundefined."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used internally for the masked values.\nIf ``fill_value`` is not None, it supersedes ``endwith``."
              }
            },
            "returns": "-------\nindex_array : ndarray, int\nArray of indices that sort `a` along the specified axis.\nIn other words, ``a[index_array]`` yields a sorted `a`.",
            "raises": "",
            "see_also": "--------\nma.MaskedArray.sort : Describes sorting algorithms used.\nlexsort : Indirect stable sort with multiple keys.\nnumpy.ndarray.sort : Inplace sort.",
            "notes": "-----\nSee `sort` for notes on the different sorting algorithms.",
            "examples": "--------\n>>> a = np.ma.array([3,2,1], mask=[False, False, True])\n>>> a\nmasked_array(data=[3, 2, --],\nmask=[False, False,  True],\nfill_value=999999)\n>>> a.argsort()\narray([1, 0, 2])"
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\nCopy of the array, cast to a specified type.",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "Typecode or data-type to which the array is cast."
              },
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout order of the result.\n'C' means C order, 'F' means Fortran order, 'A'\nmeans 'F' order if all the arrays are Fortran contiguous,\n'C' order otherwise, and 'K' means as close to the\norder the array elements appear in memory as possible.\nDefault is 'K'."
              },
              "casting": {
                "type": "{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
                "description": "Controls what kind of data casting may occur. Defaults to 'unsafe'\nfor backwards compatibility.\n* 'no' means the data types should not be cast at all.\n* 'equiv' means only byte-order changes are allowed.\n* 'safe' means only casts which can preserve values are allowed.\n* 'same_kind' means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n* 'unsafe' means any data conversions may be done."
              },
              "subok": {
                "type": "bool, optional",
                "description": "If True, then sub-classes will be passed-through (default), otherwise\nthe returned array will be forced to be a base-class array."
              },
              "copy": {
                "type": "bool, optional",
                "description": "By default, astype always returns a newly allocated array. If this\nis set to false, and the `dtype`, `order`, and `subok`\nrequirements are satisfied, the input array is returned instead\nof a copy."
              }
            },
            "returns": "-------\narr_t : ndarray\nUnless `copy` is False and the other conditions for returning the input\narray are satisfied (see description for `copy` input parameter), `arr_t`\nis a new array of the same shape as the input array, with dtype, order\ngiven by `dtype`, `order`.",
            "raises": "------\nComplexWarning\nWhen casting from complex to float or int. To avoid this,\none should use ``a.real.astype(t)``.",
            "see_also": "",
            "notes": "-----\n.. versionchanged:: 1.17.0\nCasting between a simple data type and a structured one is possible only\nfor \"unsafe\" casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n.. versionchanged:: 1.9.0\nCasting from numeric to string types in 'safe' casting mode requires\nthat the string dtype length is long enough to store the max\ninteger/float value converted.",
            "examples": "--------\n>>> x = np.array([1, 2, 2.5])\n>>> x\narray([1. ,  2. ,  2.5])\n>>> x.astype(int)\narray([1, 2, 2])"
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "a.byteswap(inplace=False)\nSwap the bytes of the array elements\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.",
            "parameters": {
              "inplace": {
                "type": "bool, optional",
                "description": "If ``True``, swap bytes in-place, default is ``False``."
              }
            },
            "returns": "-------\nout : ndarray\nThe byteswapped array. If `inplace` is ``True``, this is\na view to self.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> A = np.array([1, 256, 8755], dtype=np.int16)\n>>> list(map(hex, A))\n['0x1', '0x100', '0x2233']\n>>> A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n>>> list(map(hex, A))\n['0x100', '0x1', '0x3322']\nArrays of byte-strings are not swapped\n>>> A = np.array([b'ceg', b'fac'])\n>>> A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n``A.newbyteorder().byteswap()`` produces an array with the same values\nbut different representation in memory\n>>> A = np.array([1, 2, 3])\n>>> A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n0, 0], dtype=uint8)\n>>> A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n>>> A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n0, 3], dtype=uint8)"
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "a.choose(choices, out=None, mode='raise')\nUse an index array to construct a new array from a set of choices.\nRefer to `numpy.choose` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.choose : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "a.clip(min=None, max=None, out=None, **kwargs)\nReturn an array whose values are limited to ``[min, max]``.\nOne of max or min must be given.\nRefer to `numpy.clip` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.clip : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(self, condition, axis=None, out=None)",
          "documentation": {
            "description": "Return `a` where condition is ``True``.\nIf condition is a `~ma.MaskedArray`, missing values are considered\nas ``False``.",
            "parameters": {
              "condition": {
                "type": "var",
                "description": "Boolean 1-d array selecting which entries to return. If len(condition)\nis less than the size of a along the axis, then output is truncated\nto length of condition array."
              },
              "axis": {
                "type": "{None, int}, optional",
                "description": "Axis along which the operation must be performed."
              },
              "out": {
                "type": "{None, ndarray}, optional",
                "description": "Alternative output array in which to place the result. It must have\nthe same shape as the expected output but the type will be cast if\nnecessary."
              }
            },
            "returns": "-------\nresult : MaskedArray\nA :class:`~ma.MaskedArray` object.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nPlease note the difference with :meth:`compressed` !\nThe output of :meth:`compress` has a mask, the output of\n:meth:`compressed` does not.",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\nmask=[False, False],\nfill_value=999999)\n>>> x.compress([1, 0, 1], axis=1)\nmasked_array(\ndata=[[1, 3],\n[--, --],\n[7, 9]],\nmask=[[False, False],\n[ True,  True],\n[False, False]],\nfill_value=999999)"
          }
        },
        {
          "name": "compressed",
          "signature": "compressed(self)",
          "documentation": {
            "description": "Return all the non-masked data as a 1-D array.",
            "parameters": {},
            "returns": "-------\ndata : ndarray\nA new `ndarray` holding the non-masked data is returned.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nThe result is **not** a MaskedArray!",
            "examples": "--------\n>>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n>>> x.compressed()\narray([0, 1])\n>>> type(x.compressed())\n<class 'numpy.ndarray'>"
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "a.conj()\nComplex-conjugate all elements.\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "a.conjugate()\nReturn the complex conjugate, element-wise.\nRefer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(self, *args, **params)",
          "documentation": {
            "description": "a.copy(order='C')\nReturn a copy of the array.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "Controls the memory layout of the copy. 'C' means C-order,\n'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n'C' otherwise. 'K' means match the layout of `a` as closely\nas possible. (Note that this function and :func:`numpy.copy` are very\nsimilar but have different default values for their order=\narguments, and this function always passes sub-classes through.)\nSee also\n--------"
              },
              "numpy.copy": {
                "type": "Similar function with different default behavior",
                "description": "numpy.copyto"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\nThis function is the preferred method for creating an array copy.  The\nfunction :func:`numpy.copy` is similar, but it defaults to using order 'K',\nand will not pass sub-classes through by default.",
            "examples": "--------\n>>> x = np.array([[1,2,3],[4,5,6]], order='F')\n>>> y = x.copy()\n>>> x.fill(0)\n>>> x\narray([[0, 0, 0],\n[0, 0, 0]])\n>>> y\narray([[1, 2, 3],\n[4, 5, 6]])\n>>> y.flags['C_CONTIGUOUS']\nTrue"
          }
        },
        {
          "name": "count",
          "signature": "count(self, axis=None, keepdims=<no value>)",
          "documentation": {
            "description": "Count the non-masked elements of the array along the given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis or axes along which the count is performed.\nThe default, None, performs the count over all\nthe dimensions of the input array. `axis` may be negative, in\nwhich case it counts from the last to the first axis.\n.. versionadded:: 1.10.0\nIf this is a tuple of ints, the count is performed on multiple\naxes, instead of a single axis or all the axes as before."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
              }
            },
            "returns": "-------\nresult : ndarray or scalar\nAn array with the same shape as the input array, with the specified\naxis removed. If the array is a 0-d array, or if `axis` is None, a\nscalar is returned.",
            "raises": "",
            "see_also": "--------\nma.count_masked : Count masked elements in array or along a given axis.",
            "notes": "",
            "examples": "--------\n>>> import numpy.ma as ma\n>>> a = ma.arange(6).reshape((2, 3))\n>>> a[1, :] = ma.masked\n>>> a\nmasked_array(\ndata=[[0, 1, 2],\n[--, --, --]],\nmask=[[False, False, False],\n[ True,  True,  True]],\nfill_value=999999)\n>>> a.count()\n3\nWhen the `axis` keyword is specified an array of appropriate size is\nreturned.\n>>> a.count(axis=0)\narray([1, 1, 1])\n>>> a.count(axis=1)\narray([3, 0])"
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(self, axis=None, dtype=None, out=None)",
          "documentation": {
            "description": "Return the cumulative product of the array elements over the given axis.\nMasked values are set to 1 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to `numpy.cumprod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.cumprod : corresponding function for ndarrays\nnumpy.cumprod : equivalent function",
            "notes": "-----\nThe mask is lost if `out` is not a valid MaskedArray !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(self, axis=None, dtype=None, out=None)",
          "documentation": {
            "description": "Return the cumulative sum of the array elements over the given axis.\nMasked values are set to 0 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to `numpy.cumsum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.cumsum : corresponding function for ndarrays\nnumpy.cumsum : equivalent function",
            "notes": "-----\nThe mask is lost if `out` is not a valid :class:`ma.MaskedArray` !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.",
            "examples": "--------\n>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n>>> marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\nmask=[False, False, False,  True,  True,  True, False, False,\nFalse, False],\nfill_value=999999)"
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(self, *args, **params)",
          "documentation": {
            "description": "a.diagonal(offset=0, axis1=0, axis2=1)\nReturn specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\nRefer to :func:`numpy.diagonal` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.diagonal : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dot",
          "signature": "dot(self, b, out=None, strict=False)",
          "documentation": {
            "description": "a.dot(b, out=None)\nMasked dot product of two arrays. Note that `out` and `strict` are\nlocated in different positions than in `ma.dot`. In order to\nmaintain compatibility with the functional version, it is\nrecommended that the optional arguments be treated as keyword only.\nAt some point that may be mandatory.\n.. versionadded:: 1.10.0",
            "parameters": {
              "b": {
                "type": "masked_array_like",
                "description": "Inputs array."
              },
              "out": {
                "type": "masked_array, optional",
                "description": "Output argument. This must have the exact kind that would be\nreturned if it was not used. In particular, it must have the\nright type, must be C-contiguous, and its dtype must be the\ndtype that would be returned for `ma.dot(a,b)`. This is a\nperformance feature. Therefore, if these conditions are not\nmet, an exception is raised, instead of attempting to be\nflexible."
              },
              "strict": {
                "type": "bool, optional",
                "description": "Whether masked data are propagated (True) or set to 0 (False)\nfor the computation. Default is False.  Propagating the mask\nmeans that if a masked value appears in a row or column, the\nwhole row or column is considered masked.\n.. versionadded:: 1.10.2"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ma.dot : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "a.dump(file)\nDump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.",
            "parameters": {
              "file": {
                "type": "str or Path",
                "description": "A string naming the dump file.\n.. versionchanged:: 1.17.0\n`pathlib.Path` objects are now accepted."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "a.dumps()",
            "parameters": {},
            "returns": "pickle.loads will convert the string back to an array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "a.fill(value)\nFill the array with a scalar value.",
            "parameters": {
              "value": {
                "type": "scalar",
                "description": "All elements of `a` will be assigned this value."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> a = np.array([1, 2])\n>>> a.fill(0)\n>>> a\narray([0, 0])\n>>> a = np.empty(2)\n>>> a.fill(1)\n>>> a\narray([1.,  1.])\nFill expects a scalar value and always behaves the same as assigning\nto a single array element.  The following is a rare example where this\ndistinction is important:\n>>> a = np.array([None, None], dtype=object)\n>>> a[0] = np.array(3)\n>>> a\narray([array(3), None], dtype=object)\n>>> a.fill(np.array(3))\n>>> a\narray([array(3), array(3)], dtype=object)\nWhere other forms of assignments will unpack the array being assigned:\n>>> a[...] = np.array(3)\n>>> a\narray([3, 3], dtype=object)"
          }
        },
        {
          "name": "filled",
          "signature": "filled(self, fill_value=None)",
          "documentation": {
            "description": "Return a copy with masked fields filled with a given value.",
            "parameters": {
              "fill_value": {
                "type": "array_like, optional",
                "description": "The value to use for invalid entries. Can be scalar or\nnon-scalar. If latter is the case, the filled array should\nbe broadcastable over input array. Default is None, in\nwhich case the `fill_value` attribute is used instead."
              }
            },
            "returns": "-------\nfilled_void\nA `np.void` object",
            "raises": "",
            "see_also": "--------\nMaskedArray.filled",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(self, *args, **params)",
          "documentation": {
            "description": "a.flatten(order='C')\nReturn a copy of the array collapsed into one dimension.",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "'C' means to flatten in row-major (C-style) order.\n'F' means to flatten in column-major (Fortran-\nstyle) order. 'A' means to flatten in column-major\norder if `a` is Fortran *contiguous* in memory,\nrow-major order otherwise. 'K' means to flatten\n`a` in the order the elements occur in memory.\nThe default is 'C'."
              }
            },
            "returns": "-------\ny : ndarray\nA copy of the input array, flattened to one dimension.",
            "raises": "",
            "see_also": "--------\nravel : Return a flattened array.\nflat : A 1-D flat iterator over the array.",
            "notes": "",
            "examples": "--------\n>>> a = np.array([[1,2], [3,4]])\n>>> a.flatten()\narray([1, 2, 3, 4])\n>>> a.flatten('F')\narray([1, 3, 2, 4])"
          }
        },
        {
          "name": "get_fill_value",
          "signature": "fill_value(self)",
          "documentation": {
            "description": "The filling value of the masked array is a scalar. When setting, None\nwill set to a default based on the data type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n>>> x = np.ma.array([0, 1.], fill_value=-np.inf)\n>>> x.fill_value\n-inf\n>>> x.fill_value = np.pi\n>>> x.fill_value\n3.1415926535897931 # may vary\nReset to default:\n>>> x.fill_value = None\n>>> x.fill_value\n1e+20"
          }
        },
        {
          "name": "get_imag",
          "signature": "imag(self)",
          "documentation": {
            "description": "The imaginary part of the masked array.\nThis property is a view on the imaginary part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nreal",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.imag\nmasked_array(data=[1.0, --, 1.6],\nmask=[False,  True, False],\nfill_value=1e+20)"
          }
        },
        {
          "name": "get_real",
          "signature": "real(self)",
          "documentation": {
            "description": "The real part of the masked array.\nThis property is a view on the real part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nimag",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n>>> x.real\nmasked_array(data=[1.0, --, 3.45],\nmask=[False,  True, False],\nfill_value=1e+20)"
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "a.getfield(dtype, offset=0)",
            "parameters": {
              "dtype": {
                "type": "str or dtype",
                "description": "The data type of the view. The dtype size of the view can not be larger\nthan that of the array itself."
              },
              "offset": {
                "type": "int",
                "description": "Number of bytes to skip before beginning the element view."
              }
            },
            "returns": "A field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.diag([1.+1.j]*2)\n>>> x[1, 1] = 2 + 4.j\n>>> x\narray([[1.+1.j,  0.+0.j],\n[0.+0.j,  2.+4.j]])\n>>> x.getfield(np.float64)\narray([[1.,  0.],\n[0.,  2.]])\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n>>> x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n[0.,  4.]])"
          }
        },
        {
          "name": "harden_mask",
          "signature": "harden_mask(self)",
          "documentation": {
            "description": "Force the mask to hard, preventing unmasking by assignment.\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `harden_mask` sets\n`~ma.MaskedArray.hardmask` to ``True`` (and returns the modified\nself).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nma.MaskedArray.hardmask\nma.MaskedArray.soften_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ids",
          "signature": "ids(self)",
          "documentation": {
            "description": "Return the addresses of the data and mask areas.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n>>> x.ids()\n(166670640, 166659832) # may vary\nIf the array has no mask, the address of `nomask` is returned. This address\nis typically not close to the data in memory:\n>>> x = np.ma.array([1, 2, 3])\n>>> x.ids()\n(166691080, 3083169284) # may vary"
          }
        },
        {
          "name": "iscontiguous",
          "signature": "iscontiguous(self)",
          "documentation": {
            "description": "Return a boolean indicating whether the data is contiguous.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([1, 2, 3])\n>>> x.iscontiguous()\nTrue\n`iscontiguous` returns one of the flags of the masked array:\n>>> x.flags\nC_CONTIGUOUS : True\nF_CONTIGUOUS : True\nOWNDATA : False\nWRITEABLE : True\nALIGNED : True\nWRITEBACKIFCOPY : False"
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "a.item(*args)\nCopy an element of an array to a standard Python scalar and return it.",
            "parameters": {},
            "returns": "-------\nz : Standard Python scalar object\nA copy of the specified element of the array as a suitable\nPython scalar",
            "raises": "",
            "see_also": "",
            "notes": "-----\nWhen the data type of `a` is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\n`item` is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python's optimized math.",
            "examples": "--------\n>>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n[1, 3, 6],\n[1, 0, 1]])\n>>> x.item(3)\n1\n>>> x.item(7)\n0\n>>> x.item((0, 1))\n2\n>>> x.item((2, 2))\n1"
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "a.itemset(*args)\nInsert scalar into an array (scalar is cast to array's dtype, if possible)\nThere must be at least 1 argument, and define the last argument\nas *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster\nthan ``a[args] = item``.  The item should be a scalar value and `args`\nmust select a single item in the array `a`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\nCompared to indexing syntax, `itemset` provides some speed increase\nfor placing a scalar into a particular location in an `ndarray`,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using `itemset` (and `item`) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.",
            "examples": "--------\n>>> np.random.seed(123)\n>>> x = np.random.randint(9, size=(3, 3))\n>>> x\narray([[2, 2, 6],\n[1, 3, 6],\n[1, 0, 1]])\n>>> x.itemset(4, 0)\n>>> x.itemset((2, 2), 9)\n>>> x\narray([[2, 2, 6],\n[1, 0, 6],\n[1, 0, 9]])"
          }
        },
        {
          "name": "max",
          "signature": "max(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the maximum along a given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis along which to operate.  By default, ``axis`` is None and the\nflattened input is used.\n.. versionadded:: 1.7.0\nIf this is a tuple of ints, the maximum is selected over multiple\naxes, instead of a single axis or all the axes as before."
              },
              "out": {
                "type": "array_like, optional",
                "description": "Alternative output array in which to place the result.  Must\nbe of the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.\nIf None, use the output of maximum_fill_value()."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
              }
            },
            "returns": "-------\namax : array_like\nNew array holding the result.\nIf ``out`` was specified, ``out`` is returned.",
            "raises": "",
            "see_also": "--------\nma.maximum_fill_value",
            "notes": "",
            "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [[-1., 2.5], [4., -2.], [3., 0.]]\n>>> mask = [[0, 0], [1, 0], [1, 0]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\ndata=[[-1.0, 2.5],\n[--, -2.0],\n[--, 0.0]],\nmask=[[False, False],\n[ True, False],\n[ True, False]],\nfill_value=1e+20)\n>>> ma.max(masked_x)\n2.5\n>>> ma.max(masked_x, axis=0)\nmasked_array(data=[-1.0, 2.5],\nmask=[False, False],\nfill_value=1e+20)\n>>> ma.max(masked_x, axis=1, keepdims=True)\nmasked_array(\ndata=[[2.5],\n[-2.0],\n[0.0]],\nmask=[[False],\n[False],\n[False]],\nfill_value=1e+20)\n>>> mask = [[1, 1], [1, 1], [1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.max(masked_x, axis=1)\nmasked_array(data=[--, --, --],\nmask=[ True,  True,  True],\nfill_value=1e+20,\ndtype=float64)"
          }
        },
        {
          "name": "mean",
          "signature": "mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "Masked entries are ignored, and result elements which are not\nfinite will be masked.\nRefer to `numpy.mean` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.mean : corresponding function for ndarrays\nnumpy.mean : Equivalent function\nnumpy.ma.average : Weighted average.",
            "notes": "",
            "examples": "--------\n>>> a = np.ma.array([1,2,3], mask=[False, False, True])\n>>> a\nmasked_array(data=[1, 2, --],\nmask=[False, False,  True],\nfill_value=999999)\n>>> a.mean()\n1.5"
          }
        },
        {
          "name": "min",
          "signature": "min(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the minimum along a given axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis along which to operate.  By default, ``axis`` is None and the\nflattened input is used.\n.. versionadded:: 1.7.0\nIf this is a tuple of ints, the minimum is selected over multiple\naxes, instead of a single axis or all the axes as before."
              },
              "out": {
                "type": "array_like, optional",
                "description": "Alternative output array in which to place the result.  Must be of\nthe same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values.\nIf None, use the output of `minimum_fill_value`."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
              }
            },
            "returns": "-------\namin : array_like\nNew array holding the result.\nIf ``out`` was specified, ``out`` is returned.",
            "raises": "",
            "see_also": "--------\nma.minimum_fill_value",
            "notes": "",
            "examples": "--------\n>>> import numpy.ma as ma\n>>> x = [[1., -2., 3.], [0.2, -0.7, 0.1]]\n>>> mask = [[1, 1, 0], [0, 0, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> masked_x\nmasked_array(\ndata=[[--, --, 3.0],\n[0.2, -0.7, --]],\nmask=[[ True,  True, False],\n[False, False,  True]],\nfill_value=1e+20)\n>>> ma.min(masked_x)\n-0.7\n>>> ma.min(masked_x, axis=-1)\nmasked_array(data=[3.0, -0.7],\nmask=[False, False],\nfill_value=1e+20)\n>>> ma.min(masked_x, axis=0, keepdims=True)\nmasked_array(data=[[0.2, -0.7, 3.0]],\nmask=[[False, False, False]],\nfill_value=1e+20)\n>>> mask = [[1, 1, 1,], [1, 1, 1]]\n>>> masked_x = ma.masked_array(x, mask)\n>>> ma.min(masked_x, axis=0)\nmasked_array(data=[--, --, --],\nmask=[ True,  True,  True],\nfill_value=1e+20,\ndtype=float64)"
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(...)",
          "documentation": {
            "description": "arr.newbyteorder(new_order='S', /)\nReturn the array with the same data viewed with a different byte order.\nEquivalent to::\narr.view(arr.dtype.newbytorder(new_order))\nChanges are also made in all fields and sub-arrays of the array data\ntype.",
            "parameters": {
              "new_order": {
                "type": "string, optional",
                "description": "Byte order to force; a value from the byte order specifications\nbelow. `new_order` codes can be any of:\n* 'S' - swap dtype from current to opposite endian\n* {'<', 'little'} - little endian\n* {'>', 'big'} - big endian\n* {'=', 'native'} - native order, equivalent to `sys.byteorder`\n* {'|', 'I'} - ignore (no change to byte order)\nThe default value ('S') results in swapping the current\nbyte order."
              }
            },
            "returns": "-------\nnew_arr : array\nNew array object with the dtype reflecting given change to the\nbyte order.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(self)",
          "documentation": {
            "description": "Return the indices of unmasked elements that are not zero.",
            "parameters": {},
            "returns": "indices of the non-zero elements in that dimension. The corresponding\nnon-zero values can be obtained with::\na[a.nonzero()]\nTo group the indices by element, rather than dimension, use\ninstead::\nnp.transpose(a.nonzero())\nThe result of this is always a 2d array, with a row for each non-zero\nelement.\n-------\ntuple_of_arrays : tuple\nIndices of elements that are non-zero.",
            "raises": "",
            "see_also": "--------\nnumpy.nonzero :\nFunction operating on ndarrays.\nflatnonzero :\nReturn indices that are non-zero in the flattened version of the input\narray.\nnumpy.ndarray.nonzero :\nEquivalent ndarray method.\ncount_nonzero :\nCounts the number of non-zero elements in the input array.",
            "notes": "",
            "examples": "--------\n>>> import numpy.ma as ma\n>>> x = ma.array(np.eye(3))\n>>> x\nmasked_array(\ndata=[[1., 0., 0.],\n[0., 1., 0.],\n[0., 0., 1.]],\nmask=False,\nfill_value=1e+20)\n>>> x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\nMasked elements are ignored.\n>>> x[1, 1] = ma.masked\n>>> x\nmasked_array(\ndata=[[1.0, 0.0, 0.0],\n[0.0, --, 0.0],\n[0.0, 0.0, 1.0]],\nmask=[[False, False, False],\n[False,  True, False],\n[False, False, False]],\nfill_value=1e+20)\n>>> x.nonzero()\n(array([0, 2]), array([0, 2]))\nIndices can also be grouped by element.\n>>> np.transpose(x.nonzero())\narray([[0, 0],\n[2, 2]])\nA common use for ``nonzero`` is to find the indices of an array, where\na condition is True.  Given an array `a`, the condition `a` > 3 is a\nboolean array and since False is interpreted as 0, ma.nonzero(a > 3)\nyields the indices of the `a` where the condition is true.\n>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n>>> a > 3\nmasked_array(\ndata=[[False, False, False],\n[ True,  True,  True],\n[ True,  True,  True]],\nmask=False,\nfill_value=True)\n>>> ma.nonzero(a > 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\nThe ``nonzero`` method of the condition array can also be called.\n>>> (a > 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))"
          }
        },
        {
          "name": "partition",
          "signature": "partition(self, *args, **kwargs)",
          "documentation": {
            "description": "a.partition(kth, axis=-1, kind='introselect', order=None)\nRearranges the elements in the array in such a way that the value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.\n.. versionadded:: 1.8.0",
            "parameters": {
              "kth": {
                "type": "int or sequence of ints",
                "description": "Element index to partition by. The kth element value will be in its\nfinal sorted position and all smaller elements will be moved before it\nand all equal or greater elements behind it.\nThe order of all elements in the partitions is undefined.\nIf provided with a sequence of kth it will partition all elements\nindexed by kth of them into their sorted position at once.\n.. deprecated:: 1.22.0\nPassing booleans as index is deprecated."
              },
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. Default is -1, which means sort along the\nlast axis."
              },
              "kind": {
                "type": "{'introselect'}, optional",
                "description": "Selection algorithm. Default is 'introselect'."
              },
              "order": {
                "type": "str or list of str, optional",
                "description": "When `a` is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc. A single field can\nbe specified as a string, and not all fields need to be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.partition : Return a partitioned copy of an array.\nargpartition : Indirect partition.\nsort : Full sort.",
            "notes": "-----\nSee ``np.partition`` for notes on the different algorithms.",
            "examples": "--------\n>>> a = np.array([3, 4, 2, 1])\n>>> a.partition(3)\n>>> a\narray([2, 1, 3, 4])\n>>> a.partition((1, 3))\n>>> a\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "prod",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the product of the array elements over the given axis.\nMasked elements are set to 1 internally for computation.\nRefer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
            "notes": "-----\nArithmetic is modular when using integer types, and no error is raised\non overflow.",
            "examples": ""
          }
        },
        {
          "name": "product",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the product of the array elements over the given axis.\nMasked elements are set to 1 internally for computation.\nRefer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.prod : corresponding function for ndarrays\nnumpy.prod : equivalent function",
            "notes": "-----\nArithmetic is modular when using integer types, and no error is raised\non overflow.",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(self, axis=None, out=None, fill_value=None, keepdims=False)",
          "documentation": {
            "description": "Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).\n.. warning::\n`ptp` preserves the data type of the array. This means the\nreturn value for an input of signed integers with n bits\n(e.g. `np.int8`, `np.int16`, etc) is also a signed integer\nwith n bits.  In that case, peak-to-peak values greater than\n``2**(n-1)-1`` will be returned as negative values. An example\nwith a work-around is shown below.",
            "parameters": {
              "axis": {
                "type": "{None, int}, optional",
                "description": "Axis along which to find the peaks.  If None (default) the\nflattened array is used."
              },
              "out": {
                "type": "{None, array_like}, optional",
                "description": "Alternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output\nbut the type will be cast if necessary."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used to fill in the masked values."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array."
              }
            },
            "returns": "-------\nptp : ndarray.\nA new array holding the result, unless ``out`` was\nspecified, in which case a reference to ``out`` is returned.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.MaskedArray([[4, 9, 2, 10],\n...                        [6, 9, 7, 12]])\n>>> x.ptp(axis=1)\nmasked_array(data=[8, 6],\nmask=False,\nfill_value=999999)\n>>> x.ptp(axis=0)\nmasked_array(data=[2, 0, 5, 2],\nmask=False,\nfill_value=999999)\n>>> x.ptp()\n10\nThis example shows that a negative value can be returned when\nthe input is an array of signed integers.\n>>> y = np.ma.MaskedArray([[1, 127],\n...                        [0, 127],\n...                        [-1, 127],\n...                        [-2, 127]], dtype=np.int8)\n>>> y.ptp(axis=1)\nmasked_array(data=[ 126,  127, -128, -127],\nmask=False,\nfill_value=999999,\ndtype=int8)\nA work-around is to use the `view()` method to view the result as\nunsigned integers with the same bit width:\n>>> y.ptp(axis=1).view(np.uint8)\nmasked_array(data=[126, 127, 128, 129],\nmask=False,\nfill_value=999999,\ndtype=uint8)"
          }
        },
        {
          "name": "put",
          "signature": "put(self, indices, values, mode='raise')",
          "documentation": {
            "description": "Set storage-indexed locations to corresponding values.\nSets self._data.flat[n] = values[n] for each n in indices.\nIf `values` is shorter than `indices` then it will repeat.\nIf `values` has some masked values, the initial mask is updated\nin consequence, else the corresponding values are unmasked.",
            "parameters": {
              "indices": {
                "type": "1-D array_like",
                "description": "Target indices, interpreted as integers."
              },
              "values": {
                "type": "array_like",
                "description": "Values to place in self._data copy at target indices."
              },
              "mode": {
                "type": "{'raise', 'wrap', 'clip'}, optional",
                "description": "Specifies how out-of-bounds indices will behave.\n'raise' : raise an error.\n'wrap' : wrap around.\n'clip' : clip to the range."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\n`values` can be a scalar or length 1 array.",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.put([0,4,8],[10,20,30])\n>>> x\nmasked_array(\ndata=[[10, --, 3],\n[--, 20, --],\n[7, --, 30]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.put(4,999)\n>>> x\nmasked_array(\ndata=[[10, --, 3],\n[--, 999, --],\n[7, --, 30]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)"
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(self, order='C')",
          "documentation": {
            "description": "",
            "parameters": {
              "order": {
                "type": "{'C', 'F', 'A', 'K'}, optional",
                "description": "The elements of `a` are read using this index order. 'C' means to\nindex the elements in C-like order, with the last axis index\nchanging fastest, back to the first axis index changing slowest.\n'F' means to index the elements in Fortran-like index order, with\nthe first index changing fastest, and the last index changing\nslowest. Note that the 'C' and 'F' options take no account of the\nmemory layout of the underlying array, and only refer to the order\nof axis indexing.  'A' means to read the elements in Fortran-like\nindex order if `m` is Fortran *contiguous* in memory, C-like order\notherwise.  'K' means to read the elements in the order they occur\nin memory, except for reversing the data when strides are negative.\nBy default, 'C' index order is used.\n(Masked arrays currently use 'A' on the data when 'K' is passed.)"
              }
            },
            "returns": "-------\nMaskedArray\nOutput view is of shape ``(self.size,)`` (or\n``(np.ma.product(self.shape),)``).",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\nmask=[False,  True, False,  True, False,  True, False,  True,\nFalse],\nfill_value=999999)"
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(self, *args, **params)",
          "documentation": {
            "description": "a.repeat(repeats, axis=None)\nRepeat elements of an array.\nRefer to `numpy.repeat` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.repeat : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(self, *s, **kwargs)",
          "documentation": {
            "description": "Give a new shape to the array without changing its data.",
            "parameters": {
              "shape": {
                "type": "int or tuple of ints",
                "description": "The new shape should be compatible with the original shape. If an\ninteger is supplied, then the result will be a 1-D array of that\nlength."
              },
              "order": {
                "type": "{'C', 'F'}, optional",
                "description": "Determines whether the array data should be viewed as in C\n(row-major) or FORTRAN (column-major) order."
              }
            },
            "returns": "The result is a view on the original array; if this is not possible, a\nValueError is raised.\n-------\nreshaped_array : array\nA new view on the array.",
            "raises": "",
            "see_also": "--------\nreshape : Equivalent function in the masked array module.\nnumpy.ndarray.reshape : Equivalent method on ndarray object.\nnumpy.reshape : Equivalent function in the NumPy module.",
            "notes": "-----\nThe reshaping operation cannot guarantee that a copy will not be made,\nto modify the shape in place, use ``a.shape = s``",
            "examples": "--------\n>>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n>>> x\nmasked_array(\ndata=[[--, 2],\n[3, --]],\nmask=[[ True, False],\n[False,  True]],\nfill_value=999999)\n>>> x = x.reshape((4,1))\n>>> x\nmasked_array(\ndata=[[--],\n[2],\n[3],\n[--]],\nmask=[[ True],\n[False],\n[False],\n[ True]],\nfill_value=999999)"
          }
        },
        {
          "name": "resize",
          "signature": "resize(self, newshape, refcheck=True, order=False)",
          "documentation": {
            "description": ".. warning::\nThis method does nothing, except raise a ValueError exception. A\nmasked array does not own its data and therefore cannot safely be\nresized in place. Use the `numpy.ma.resize` function instead.\nThis method is difficult to implement safely and may be deprecated in\nfuture releases of NumPy.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(self, decimals=0, out=None)",
          "documentation": {
            "description": "Return each element rounded to the given number of decimals.\nRefer to `numpy.around` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.round : corresponding function for ndarrays\nnumpy.around : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "a.searchsorted(v, side='left', sorter=None)\nFind indices where elements of v should be inserted in a to maintain order.\nFor full documentation, see `numpy.searchsorted`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.searchsorted : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_fill_value",
          "signature": "fill_value(self, value=None)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "a.setfield(val, dtype, offset=0)\nPut a value into a specified place in a field defined by a data-type.\nPlace `val` into `a`'s field defined by `dtype` and beginning `offset`\nbytes into the field.",
            "parameters": {
              "val": {
                "type": "object",
                "description": "Value to be placed in field."
              },
              "dtype": {
                "type": "dtype object",
                "description": "Data-type of the field in which to place `val`."
              },
              "offset": {
                "type": "int, optional",
                "description": "The number of bytes into the field at which to place `val`."
              }
            },
            "returns": "-------\nNone",
            "raises": "",
            "see_also": "--------\ngetfield",
            "notes": "",
            "examples": "--------\n>>> x = np.eye(3)\n>>> x.getfield(np.float64)\narray([[1.,  0.,  0.],\n[0.,  1.,  0.],\n[0.,  0.,  1.]])\n>>> x.setfield(3, np.int32)\n>>> x.getfield(np.int32)\narray([[3, 3, 3],\n[3, 3, 3],\n[3, 3, 3]], dtype=int32)\n>>> x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n[1.5e-323, 1.0e+000, 1.5e-323],\n[1.5e-323, 1.5e-323, 1.0e+000]])\n>>> x.setfield(np.eye(3), np.int32)\n>>> x\narray([[1.,  0.,  0.],\n[0.,  1.,  0.],\n[0.,  0.,  1.]])"
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "a.setflags(write=None, align=None, uic=None)\nSet array flags WRITEABLE, ALIGNED, WRITEBACKIFCOPY,\nrespectively.\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by `a` (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and flag can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)",
            "parameters": {
              "write": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` can be written to."
              },
              "align": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is aligned properly for its type."
              },
              "uic": {
                "type": "bool, optional",
                "description": "Describes whether or not `a` is a copy of another \"base\" array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\nArray flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, WRITEABLE, and ALIGNED.\nWRITEABLE (W) the data area can be written to;\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.",
            "examples": "--------\n>>> y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n>>> y\narray([[3, 1, 7],\n[2, 0, 0],\n[8, 5, 9]])\n>>> y.flags\nC_CONTIGUOUS : True\nF_CONTIGUOUS : False\nOWNDATA : True\nWRITEABLE : True\nALIGNED : True\nWRITEBACKIFCOPY : False\n>>> y.setflags(write=0, align=0)\n>>> y.flags\nC_CONTIGUOUS : True\nF_CONTIGUOUS : False\nOWNDATA : True\nWRITEABLE : False\nALIGNED : False\nWRITEBACKIFCOPY : False\n>>> y.setflags(uic=1)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: cannot set WRITEBACKIFCOPY flag to True"
          }
        },
        {
          "name": "shrink_mask",
          "signature": "shrink_mask(self)",
          "documentation": {
            "description": "Reduce a mask to nomask when possible.",
            "parameters": {},
            "returns": "-------\nNone",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n>>> x.mask\narray([[False, False],\n[False, False]])\n>>> x.shrink_mask()\nmasked_array(\ndata=[[1, 2],\n[3, 4]],\nmask=False,\nfill_value=999999)\n>>> x.mask\nFalse"
          }
        },
        {
          "name": "soften_mask",
          "signature": "soften_mask(self)",
          "documentation": {
            "description": "Force the mask to soft (default), allowing unmasking by assignment.\nWhether the mask of a masked array is hard or soft is determined by\nits `~ma.MaskedArray.hardmask` property. `soften_mask` sets\n`~ma.MaskedArray.hardmask` to ``False`` (and returns the modified\nself).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nma.MaskedArray.hardmask\nma.MaskedArray.harden_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(self, axis=-1, kind=None, order=None, endwith=True, fill_value=None)",
          "documentation": {
            "description": "Sort the array, in-place",
            "parameters": {
              "a": {
                "type": "array_like",
                "description": "Array to be sorted."
              },
              "axis": {
                "type": "int, optional",
                "description": "Axis along which to sort. If None, the array is flattened before\nsorting. The default is -1, which sorts along the last axis."
              },
              "kind": {
                "type": "{'quicksort', 'mergesort', 'heapsort', 'stable'}, optional",
                "description": "The sorting algorithm used."
              },
              "order": {
                "type": "list, optional",
                "description": "When `a` is a structured array, this argument specifies which fields\nto compare first, second, and so on.  This list does not need to\ninclude all of the fields."
              },
              "endwith": {
                "type": "{True, False}, optional",
                "description": "Whether missing values (if any) should be treated as the largest values\n(True) or the smallest values (False)\nWhen the array contains unmasked values sorting at the same extremes of the\ndatatype, the ordering of these values and the masked values is\nundefined."
              },
              "fill_value": {
                "type": "scalar or None, optional",
                "description": "Value used internally for the masked values.\nIf ``fill_value`` is not None, it supersedes ``endwith``."
              }
            },
            "returns": "-------\nsorted_array : ndarray\nArray of the same type and shape as `a`.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.sort : Method to sort an array in-place.\nargsort : Indirect sort.\nlexsort : Indirect stable sort on multiple keys.\nsearchsorted : Find elements in a sorted array.",
            "notes": "-----\nSee ``sort`` for notes on the different sorting algorithms.",
            "examples": "--------\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Default\n>>> a.sort()\n>>> a\nmasked_array(data=[1, 3, 5, --, --],\nmask=[False, False, False,  True,  True],\nfill_value=999999)\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # Put missing values in the front\n>>> a.sort(endwith=False)\n>>> a\nmasked_array(data=[--, --, 1, 3, 5],\nmask=[ True,  True, False, False, False],\nfill_value=999999)\n>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n>>> # fill_value takes over endwith\n>>> a.sort(endwith=False, fill_value=3)\n>>> a\nmasked_array(data=[1, --, --, 3, 5],\nmask=[False,  True,  True, False, False],\nfill_value=999999)"
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(self, *args, **params)",
          "documentation": {
            "description": "a.squeeze(axis=None)\nRemove axes of length one from `a`.\nRefer to `numpy.squeeze` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.squeeze : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "Masked entries are ignored.\nRefer to `numpy.std` for full documentation.",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.std : corresponding function for ndarrays\nnumpy.std : Equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the sum of the array elements over the given axis.\nMasked elements are set to 0 internally.\nRefer to `numpy.sum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.sum : corresponding function for ndarrays\nnumpy.sum : equivalent function",
            "notes": "",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.sum()\n25\n>>> x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\nmask=[False, False, False],\nfill_value=999999)\n>>> x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\nmask=[False, False, False],\nfill_value=999999)\n>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n<class 'numpy.int64'>"
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(self, *args, **params)",
          "documentation": {
            "description": "a.swapaxes(axis1, axis2)\nReturn a view of the array with `axis1` and `axis2` interchanged.\nRefer to `numpy.swapaxes` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.swapaxes : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(self, indices, axis=None, out=None, mode='raise')",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(self, fill_value=None, order='C')",
          "documentation": {
            "description": "Return the array data as a string containing the raw bytes in the array.\nThe array is filled with a fill value before the string conversion.\n.. versionadded:: 1.9.0",
            "parameters": {
              "fill_value": {
                "type": "scalar, optional",
                "description": "Value used to fill in the masked values. Default is None, in which\ncase `MaskedArray.fill_value` is used."
              },
              "order": {
                "type": "{'C','F','A'}, optional",
                "description": "Order of the data item in the copy. Default is 'C'.\n- 'C'   -- C order (row major).\n- 'F'   -- Fortran order (column major).\n- 'A'   -- Any, current order of array.\n- None  -- Same as 'A'."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.tobytes\ntolist, tofile",
            "notes": "-----\nAs for `ndarray.tobytes`, information about the shape, dtype, etc.,\nbut also about `fill_value`, will be lost.",
            "examples": "--------\n>>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n>>> x.tobytes()\nb'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(self, fid, sep='', format='%s')",
          "documentation": {
            "description": "Save a masked array to a file in binary format.\n.. warning::\nThis function is not implemented yet.",
            "parameters": {},
            "returns": "",
            "raises": "------\nNotImplementedError\nWhen `tofile` is called.",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "toflex",
          "signature": "toflex(self)",
          "documentation": {
            "description": "Transforms a masked array into a flexible-type array.\nThe flexible type array that is returned will have two fields:\n* the ``_data`` field stores the ``_data`` part of the array.\n* the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "-------\nrecord : ndarray\nA new flexible-type `ndarray` with two fields: the first element\ncontaining a value, the second element containing the corresponding\nmask boolean. The returned record shape matches self.shape.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nA side-effect of transforming a masked array into a flexible `ndarray` is\nthat meta information (``fill_value``, ...) will be lost.",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n[(4,  True), (5, False), (6,  True)],\n[(7, False), (8,  True), (9, False)]],\ndtype=[('_data', '<i8'), ('_mask', '?')])"
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(self)",
          "documentation": {
            "description": "Transforms the mvoid object into a tuple.\nMasked fields are replaced by None.",
            "parameters": {},
            "returns": "-------\nreturned_tuple\nTuple of fields",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "torecords",
          "signature": "toflex(self)",
          "documentation": {
            "description": "Transforms a masked array into a flexible-type array.\nThe flexible type array that is returned will have two fields:\n* the ``_data`` field stores the ``_data`` part of the array.\n* the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "-------\nrecord : ndarray\nA new flexible-type `ndarray` with two fields: the first element\ncontaining a value, the second element containing the corresponding\nmask boolean. The returned record shape matches self.shape.",
            "raises": "",
            "see_also": "",
            "notes": "-----\nA side-effect of transforming a masked array into a flexible `ndarray` is\nthat meta information (``fill_value``, ...) will be lost.",
            "examples": "--------\n>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n>>> x\nmasked_array(\ndata=[[1, --, 3],\n[--, 5, --],\n[7, --, 9]],\nmask=[[False,  True, False],\n[ True, False,  True],\n[False,  True, False]],\nfill_value=999999)\n>>> x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n[(4,  True), (5, False), (6,  True)],\n[(7, False), (8,  True), (9, False)]],\ndtype=[('_data', '<i8'), ('_mask', '?')])"
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(self, fill_value=None, order='C')",
          "documentation": {
            "description": "A compatibility alias for `tobytes`, with exactly the same behavior.\nDespite its name, it returns `bytes` not `str`\\ s.\n.. deprecated:: 1.19.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)",
          "documentation": {
            "description": "a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\nReturn the sum along diagonals of the array.\nRefer to `numpy.trace` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.trace : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(self, *args, **params)",
          "documentation": {
            "description": "a.transpose(*axes)",
            "parameters": {
              "axes": {
                "type": "None, tuple of ints, or `n` ints",
                "description": "* None or no argument: reverses the order of the axes.\n* tuple of ints: `i` in the `j`-th place in the tuple means that the\narray's `i`-th axis becomes the transposed array's `j`-th axis.\n* `n` ints: same as an n-tuple of the same ints (this form is\nintended simply as a \"convenience\" alternative to the tuple form)."
              }
            },
            "returns": "Refer to `numpy.transpose` for full documentation.\n-------\np : ndarray\nView of the array with its axes suitably permuted.",
            "raises": "",
            "see_also": "--------\ntranspose : Equivalent function.\nndarray.T : Array property returning the array transposed.\nndarray.reshape : Give a new shape to an array without changing its data.",
            "notes": "",
            "examples": "--------\n>>> a = np.array([[1, 2], [3, 4]])\n>>> a\narray([[1, 2],\n[3, 4]])\n>>> a.transpose()\narray([[1, 3],\n[2, 4]])\n>>> a.transpose((1, 0))\narray([[1, 3],\n[2, 4]])\n>>> a.transpose(1, 0)\narray([[1, 3],\n[2, 4]])\n>>> a = np.array([1, 2, 3, 4])\n>>> a\narray([1, 2, 3, 4])\n>>> a.transpose()\narray([1, 2, 3, 4])"
          }
        },
        {
          "name": "unshare_mask",
          "signature": "unshare_mask(self)",
          "documentation": {
            "description": "Copy the mask and set the `sharedmask` flag to ``False``.\nWhether the mask is shared between masked arrays can be seen from\nthe `sharedmask` property. `unshare_mask` ensures the mask is not\nshared. A copy of the mask is only made if it was shared.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "--------\nsharedmask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "documentation": {
            "description": "Compute the variance along the specified axis.",
            "parameters": {
              "a": {
                "type": "array_like",
                "description": "Array containing numbers whose variance is desired.  If `a` is not an\narray, a conversion is attempted."
              },
              "axis": {
                "type": "None or int or tuple of ints, optional",
                "description": "Axis or axes along which the variance is computed.  The default is to\ncompute the variance of the flattened array.\n.. versionadded:: 1.7.0\nIf this is a tuple of ints, a variance is performed over multiple axes,\ninstead of a single axis or all the axes as before."
              },
              "dtype": {
                "type": "data-type, optional",
                "description": "Type to use in computing the variance.  For arrays of integer type\nthe default is `float64`; for arrays of float types it is the same as\nthe array type."
              },
              "out": {
                "type": "ndarray, optional",
                "description": "Alternate output array in which to place the result.  It must have\nthe same shape as the expected output, but the type is cast if\nnecessary."
              },
              "ddof": {
                "type": "int, optional",
                "description": "\"Delta Degrees of Freedom\": the divisor used in the calculation is\n``N - ddof``, where ``N`` represents the number of elements. By\ndefault `ddof` is zero."
              },
              "keepdims": {
                "type": "bool, optional",
                "description": "If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then `keepdims` will not be\npassed through to the `var` method of sub-classes of\n`ndarray`, however any non-default value will be.  If the\nsub-class' method does not implement `keepdims` any\nexceptions will be raised."
              },
              "where": {
                "type": "array_like of bool, optional",
                "description": "Elements to include in the variance. See `~numpy.ufunc.reduce` for\ndetails.\n.. versionadded:: 1.20.0"
              }
            },
            "returns": "distribution.  The variance is computed for the flattened array by\ndefault, otherwise over the specified axis.\n-------\nvariance : ndarray, see dtype parameter above\nIf ``out=None``, returns a new array containing the variance;\notherwise, a reference to the output array is returned.",
            "raises": "",
            "see_also": "--------\nstd, mean, nanmean, nanstd, nanvar\n:ref:`ufuncs-output-type`",
            "notes": "-----\nThe variance is the average of the squared deviations from the mean,\ni.e.,  ``var = mean(x)``, where ``x = abs(a - a.mean())**2``.\nThe mean is typically calculated as ``x.sum() / N``, where ``N = len(x)``.\nIf, however, `ddof` is specified, the divisor ``N - ddof`` is used\ninstead.  In standard statistical practice, ``ddof=1`` provides an\nunbiased estimator of the variance of a hypothetical infinite population.\n``ddof=0`` provides a maximum likelihood estimate of the variance for\nnormally distributed variables.\nNote that for complex numbers, the absolute value is taken before\nsquaring, so that the result is always real and nonnegative.\nFor floating-point input, the variance is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for `float32` (see example\nbelow).  Specifying a higher-accuracy accumulator using the ``dtype``\nkeyword can alleviate this issue.",
            "examples": "--------\n>>> a = np.array([[1, 2], [3, 4]])\n>>> np.var(a)\n1.25\n>>> np.var(a, axis=0)\narray([1.,  1.])\n>>> np.var(a, axis=1)\narray([0.25,  0.25])\nIn single precision, var() can be inaccurate:\n>>> a = np.zeros((2, 512*512), dtype=np.float32)\n>>> a[0, :] = 1.0\n>>> a[1, :] = 0.1\n>>> np.var(a)\n0.20250003\nComputing the variance in float64 is more accurate:\n>>> np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n>>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\nSpecifying a where argument:\n>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])\n>>> np.var(a)\n6.833333333333333 # may vary\n>>> np.var(a, where=[[True], [True], [False]])\n4.0"
          }
        },
        {
          "name": "view",
          "signature": "view(self, dtype=None, type=None, fill_value=None)",
          "documentation": {
            "description": "Return a view of the MaskedArray data.",
            "parameters": {
              "dtype": {
                "type": "data-type or ndarray sub-class, optional",
                "description": "Data-type descriptor of the returned view, e.g., float32 or int16.\nThe default, None, results in the view having the same data-type\nas `a`. As with ``ndarray.view``, dtype can also be specified as\nan ndarray sub-class, which then specifies the type of the\nreturned object (this is equivalent to setting the ``type``\nparameter)."
              },
              "type": {
                "type": "Python type, optional",
                "description": "Type of the returned view, either ndarray or a subclass.  The\ndefault None results in type preservation."
              },
              "fill_value": {
                "type": "scalar, optional",
                "description": "The value to use for invalid entries (None by default).\nIf None, then this argument is inferred from the passed `dtype`, or\nin its absence the original array, as discussed in the notes below."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "--------\nnumpy.ndarray.view : Equivalent method on ndarray object.",
            "notes": "-----\n``a.view()`` is used two different ways:\n``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view\nof the array's memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\n``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just\nreturns an instance of `ndarray_subclass` that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\nIf `fill_value` is not specified, but `dtype` is specified (and is not\nan ndarray sub-class), the `fill_value` of the MaskedArray will be\nreset. If neither `fill_value` nor `dtype` are specified (or if\n`dtype` is an ndarray sub-class), then the fill value is preserved.\nFinally, if `fill_value` is specified, but `dtype` is not, the fill\nvalue is set to the specified value.\nFor ``a.view(some_dtype)``, if ``some_dtype`` has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of ``a`` (shown\nby ``print(a)``). It also depends on exactly how ``a`` is stored in\nmemory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.",
            "examples": ""
          }
        }
      ]
    }
  ]
}