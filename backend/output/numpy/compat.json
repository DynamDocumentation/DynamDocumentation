{
  "description": "Compatibility module.\n\nThis module contains duplicated code from Python itself or 3rd party\nextensions, which may be included for the following reasons:\n\n  * compatibility\n  * we may only need a small subset of the copied library/module",
  "functions": [
    {
      "name": "asbytes",
      "signature": "asbytes(s)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "asbytes_nested",
      "signature": "asbytes_nested(x)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "asstr",
      "signature": "asstr(s)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "asunicode",
      "signature": "asunicode(s)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "asunicode_nested",
      "signature": "asunicode_nested(x)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "formatargspec",
      "signature": "formatargspec(args, varargs=None, varkw=None, defaults=None, formatarg=<class 'str'>, formatvarargs=<function <lambda> at 0x73fad4714b80>, formatvarkw=<function <lambda> at 0x73fad4714c20>, formatvalue=<function <lambda> at 0x73fad4714cc0>, join=<function joinseq at 0x73fad4714a40>)",
      "documentation": {
        "description": "Format an argument spec from the 4 values returned by getargspec.\nThe first four arguments are (args, varargs, varkw, defaults).  The\nother four arguments are the corresponding optional formatting functions\nthat are called to turn names and values into strings.  The ninth\nargument is an optional function to format the sequence of arguments.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "getargspec",
      "signature": "getargspec(func)",
      "documentation": {
        "description": "Get the names and default values of a function's arguments.\nA tuple of four things is returned: (args, varargs, varkw, defaults).\n'args' is a list of the argument names (it may contain nested lists).\n'varargs' and 'varkw' are the names of the * and ** arguments or None.\n'defaults' is an n-tuple of the default values of the last n arguments.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "getexception",
      "signature": "getexception()",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "is_pathlib_path",
      "signature": "is_pathlib_path(obj)",
      "documentation": {
        "description": "Check whether obj is a `pathlib.Path` object.\nPrefer using ``isinstance(obj, os.PathLike)`` instead of this function.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "isfileobj",
      "signature": "isfileobj(f)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "npy_load_module",
      "signature": "npy_load_module(name, fn, info=None)",
      "documentation": {
        "description": "Load a module. Uses ``load_module`` which will be deprecated in python\n3.12. An alternative that uses ``exec_module`` is in\nnumpy.distutils.misc_util.exec_mod_from_location\n.. versionadded:: 1.11.2",
        "parameters": {
          "name": {
            "type": "str",
            "description": "Full module name."
          },
          "fn": {
            "type": "str",
            "description": "Path to module file."
          },
          "info": {
            "type": "tuple, optional",
            "description": "Only here for backward compatibility with Python 2.*."
          }
        },
        "returns": "-------\nmod : module",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "open_latin1",
      "signature": "open_latin1(filename, mode='r')",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "os_fspath",
      "signature": "fspath(path)",
      "documentation": {
        "description": "Return the file system path representation of the object.\nIf the object is str or bytes, then allow it to pass through as-is. If the\nobject defines __fspath__(), then return the result of that method. All other\ntypes raise a TypeError.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sixu",
      "signature": "sixu(s)",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": [
    {
      "name": "Path",
      "documentation": {
        "description": "PurePath subclass that can make system calls.\nPath represents a filesystem path but unlike PurePath, also offers\nmethods to do system calls on path objects. Depending on your system,\ninstantiating a Path will return either a PosixPath or a WindowsPath\nobject. You can also instantiate a PosixPath or WindowsPath directly,\nbut cannot instantiate a WindowsPath on a POSIX system or vice versa.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "absolute",
          "signature": "absolute(self)",
          "documentation": {
            "description": "Return an absolute version of this path by prepending the current\nworking directory. No normalization or symlink resolution is performed.\nUse resolve() to get the canonical path to a file.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "as_posix",
          "signature": "as_posix(self)",
          "documentation": {
            "description": "Return the string representation of the path with forward (/)\nslashes.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "as_uri",
          "signature": "as_uri(self)",
          "documentation": {
            "description": "Return the path as a 'file' URI.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "chmod",
          "signature": "chmod(self, mode, *, follow_symlinks=True)",
          "documentation": {
            "description": "Change the permissions of the path, like os.chmod().",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cwd",
          "signature": "cwd()",
          "documentation": {
            "description": "Return a new path pointing to the current working directory.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "exists",
          "signature": "exists(self, *, follow_symlinks=True)",
          "documentation": {
            "description": "Whether this path exists.\nThis method normally follows symlinks; to check whether a symlink exists,\nadd the argument follow_symlinks=False.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "expanduser",
          "signature": "expanduser(self)",
          "documentation": {
            "description": "Return a new path with expanded ~ and ~user constructs\n(as returned by os.path.expanduser)",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "glob",
          "signature": "glob(self, pattern, *, case_sensitive=None)",
          "documentation": {
            "description": "Iterate over this subtree and yield all existing files (of any\nkind, including directories) matching the given relative pattern.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "group",
          "signature": "group(self)",
          "documentation": {
            "description": "Return the group name of the file gid.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "hardlink_to",
          "signature": "hardlink_to(self, target)",
          "documentation": {
            "description": "Make this path a hard link pointing to the same file as *target*.\nNote the order of arguments (self, target) is the reverse of os.link's.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "home",
          "signature": "home()",
          "documentation": {
            "description": "Return a new path pointing to the user's home directory (as\nreturned by os.path.expanduser('~')).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_absolute",
          "signature": "is_absolute(self)",
          "documentation": {
            "description": "True if the path is absolute (has both a root and, if applicable,\na drive).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_block_device",
          "signature": "is_block_device(self)",
          "documentation": {
            "description": "Whether this path is a block device.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_char_device",
          "signature": "is_char_device(self)",
          "documentation": {
            "description": "Whether this path is a character device.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_dir",
          "signature": "is_dir(self)",
          "documentation": {
            "description": "Whether this path is a directory.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_fifo",
          "signature": "is_fifo(self)",
          "documentation": {
            "description": "Whether this path is a FIFO.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_file",
          "signature": "is_file(self)",
          "documentation": {
            "description": "Whether this path is a regular file (also True for symlinks pointing\nto regular files).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_junction",
          "signature": "is_junction(self)",
          "documentation": {
            "description": "Whether this path is a junction.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_mount",
          "signature": "is_mount(self)",
          "documentation": {
            "description": "Check if this path is a mount point",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_relative_to",
          "signature": "is_relative_to(self, other, /, *_deprecated)",
          "documentation": {
            "description": "Return True if the path is relative to another path or False.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_reserved",
          "signature": "is_reserved(self)",
          "documentation": {
            "description": "Return True if the path contains one of the special names reserved\nby the system, if any.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_socket",
          "signature": "is_socket(self)",
          "documentation": {
            "description": "Whether this path is a socket.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_symlink",
          "signature": "is_symlink(self)",
          "documentation": {
            "description": "Whether this path is a symbolic link.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "iterdir",
          "signature": "iterdir(self)",
          "documentation": {
            "description": "Yield path objects of the directory contents.\nThe children are yielded in arbitrary order, and the\nspecial entries '.' and '..' are not included.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "joinpath",
          "signature": "joinpath(self, *pathsegments)",
          "documentation": {
            "description": "Combine this path with one or several arguments, and return a\nnew path representing either a subpath (if all arguments are relative\npaths) or a totally different path (if one of the arguments is\nanchored).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lchmod",
          "signature": "lchmod(self, mode)",
          "documentation": {
            "description": "Like chmod(), except if the path points to a symlink, the symlink's\npermissions are changed, rather than its target's.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lstat",
          "signature": "lstat(self)",
          "documentation": {
            "description": "Like stat(), except if the path points to a symlink, the symlink's\nstatus information is returned, rather than its target's.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "match",
          "signature": "match(self, path_pattern, *, case_sensitive=None)",
          "documentation": {
            "description": "Return True if this path matches the given pattern.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mkdir",
          "signature": "mkdir(self, mode=511, parents=False, exist_ok=False)",
          "documentation": {
            "description": "Create a new directory at this given path.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "open",
          "signature": "open(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)",
          "documentation": {
            "description": "Open the file pointed by this path and return a file object, as\nthe built-in open() function does.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "owner",
          "signature": "owner(self)",
          "documentation": {
            "description": "Return the login name of the file owner.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "read_bytes",
          "signature": "read_bytes(self)",
          "documentation": {
            "description": "Open the file in bytes mode, read it, and close the file.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "read_text",
          "signature": "read_text(self, encoding=None, errors=None)",
          "documentation": {
            "description": "Open the file in text mode, read it, and close the file.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "readlink",
          "signature": "readlink(self)",
          "documentation": {
            "description": "Return the path to which the symbolic link points.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "relative_to",
          "signature": "relative_to(self, other, /, *_deprecated, walk_up=False)",
          "documentation": {
            "description": "Return the relative path to another path identified by the passed\narguments.  If the operation is not possible (because this is not\nrelated to the other path), raise ValueError.\nThe *walk_up* parameter controls whether `..` may be used to resolve\nthe path.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rename",
          "signature": "rename(self, target)",
          "documentation": {
            "description": "Rename this path to the target path.\nThe target path may be absolute or relative. Relative paths are\ninterpreted relative to the current working directory, *not* the\ndirectory of the Path object.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "replace",
          "signature": "replace(self, target)",
          "documentation": {
            "description": "Rename this path to the target path, overwriting if that path exists.\nThe target path may be absolute or relative. Relative paths are\ninterpreted relative to the current working directory, *not* the\ndirectory of the Path object.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resolve",
          "signature": "resolve(self, strict=False)",
          "documentation": {
            "description": "Make the path absolute, resolving all symlinks on the way and also\nnormalizing it.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rglob",
          "signature": "rglob(self, pattern, *, case_sensitive=None)",
          "documentation": {
            "description": "Recursively yield all existing files (of any kind, including\ndirectories) matching the given relative pattern, anywhere in\nthis subtree.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rmdir",
          "signature": "rmdir(self)",
          "documentation": {
            "description": "Remove this directory.  The directory must be empty.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "samefile",
          "signature": "samefile(self, other_path)",
          "documentation": {
            "description": "Return whether other_path is the same or not as this file\n(as returned by os.path.samefile()).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "stat",
          "signature": "stat(self, *, follow_symlinks=True)",
          "documentation": {
            "description": "Return the result of the stat() system call on this path, like\nos.stat() does.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "symlink_to",
          "signature": "symlink_to(self, target, target_is_directory=False)",
          "documentation": {
            "description": "Make this path a symlink pointing to the target path.\nNote the order of arguments (link, target) is the reverse of os.symlink.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "touch",
          "signature": "touch(self, mode=438, exist_ok=True)",
          "documentation": {
            "description": "Create this file with the given access mode, if it doesn't exist.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unlink",
          "signature": "unlink(self, missing_ok=False)",
          "documentation": {
            "description": "Remove this file or link.\nIf the path is a directory, use rmdir() instead.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "walk",
          "signature": "walk(self, top_down=True, on_error=None, follow_symlinks=False)",
          "documentation": {
            "description": "Walk the directory tree from this directory, similar to os.walk().",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_name",
          "signature": "with_name(self, name)",
          "documentation": {
            "description": "Return a new path with the file name changed.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_segments",
          "signature": "with_segments(self, *pathsegments)",
          "documentation": {
            "description": "Construct a new path object from any number of path-like objects.\nSubclasses may override this method to customize how new path objects\nare created from methods like `iterdir()`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_stem",
          "signature": "with_stem(self, stem)",
          "documentation": {
            "description": "Return a new path with the stem changed.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_suffix",
          "signature": "with_suffix(self, suffix)",
          "documentation": {
            "description": "Return a new path with the file suffix changed.  If the path\nhas no suffix, add given suffix.  If the given suffix is an empty\nstring, remove the suffix from the path.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "write_bytes",
          "signature": "write_bytes(self, data)",
          "documentation": {
            "description": "Open the file in bytes mode, write to it, and close the file.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "write_text",
          "signature": "write_text(self, data, encoding=None, errors=None, newline=None)",
          "documentation": {
            "description": "Open the file in text mode, write to it, and close the file.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "basestring",
      "documentation": {
        "description": "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "capitalize",
          "signature": "capitalize(self, /)",
          "documentation": {
            "description": "Return a capitalized version of the string.\nMore specifically, make the first character have upper case and the rest lower\ncase.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "casefold",
          "signature": "casefold(self, /)",
          "documentation": {
            "description": "Return a version of the string suitable for caseless comparisons.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "center",
          "signature": "center(self, width, fillchar=' ', /)",
          "documentation": {
            "description": "Return a centered string of length width.\nPadding is done using the specified fill character (default is a space).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "count",
          "signature": "count(...)",
          "documentation": {
            "description": "S.count(sub[, start[, end]]) -> int\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "encode",
          "signature": "encode(self, /, encoding='utf-8', errors='strict')",
          "documentation": {
            "description": "Encode the string using the codec registered for encoding.\nencoding\nThe encoding in which to encode the string.\nerrors\nThe error handling scheme to use for encoding errors.\nThe default is 'strict' meaning that encoding errors raise a\nUnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "endswith",
          "signature": "endswith(...)",
          "documentation": {
            "description": "S.endswith(suffix[, start[, end]]) -> bool\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "expandtabs",
          "signature": "expandtabs(self, /, tabsize=8)",
          "documentation": {
            "description": "Return a copy where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "find",
          "signature": "find(...)",
          "documentation": {
            "description": "S.find(sub[, start[, end]]) -> int\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\nReturn -1 on failure.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "format",
          "signature": "format(...)",
          "documentation": {
            "description": "S.format(*args, **kwargs) -> str\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "format_map",
          "signature": "format_map(...)",
          "documentation": {
            "description": "S.format_map(mapping) -> str\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "index",
          "signature": "index(...)",
          "documentation": {
            "description": "S.index(sub[, start[, end]]) -> int\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isalnum",
          "signature": "isalnum(self, /)",
          "documentation": {
            "description": "Return True if the string is an alpha-numeric string, False otherwise.\nA string is alpha-numeric if all characters in the string are alpha-numeric and\nthere is at least one character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isalpha",
          "signature": "isalpha(self, /)",
          "documentation": {
            "description": "Return True if the string is an alphabetic string, False otherwise.\nA string is alphabetic if all characters in the string are alphabetic and there\nis at least one character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isascii",
          "signature": "isascii(self, /)",
          "documentation": {
            "description": "Return True if all characters in the string are ASCII, False otherwise.\nASCII characters have code points in the range U+0000-U+007F.\nEmpty string is ASCII too.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isdecimal",
          "signature": "isdecimal(self, /)",
          "documentation": {
            "description": "Return True if the string is a decimal string, False otherwise.\nA string is a decimal string if all characters in the string are decimal and\nthere is at least one character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isdigit",
          "signature": "isdigit(self, /)",
          "documentation": {
            "description": "Return True if the string is a digit string, False otherwise.\nA string is a digit string if all characters in the string are digits and there\nis at least one character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isidentifier",
          "signature": "isidentifier(self, /)",
          "documentation": {
            "description": "Return True if the string is a valid Python identifier, False otherwise.\nCall keyword.iskeyword(s) to test whether string s is a reserved identifier,\nsuch as \"def\" or \"class\".",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "islower",
          "signature": "islower(self, /)",
          "documentation": {
            "description": "Return True if the string is a lowercase string, False otherwise.\nA string is lowercase if all cased characters in the string are lowercase and\nthere is at least one cased character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isnumeric",
          "signature": "isnumeric(self, /)",
          "documentation": {
            "description": "Return True if the string is a numeric string, False otherwise.\nA string is numeric if all characters in the string are numeric and there is at\nleast one character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isprintable",
          "signature": "isprintable(self, /)",
          "documentation": {
            "description": "Return True if the string is printable, False otherwise.\nA string is printable if all of its characters are considered printable in\nrepr() or if it is empty.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isspace",
          "signature": "isspace(self, /)",
          "documentation": {
            "description": "Return True if the string is a whitespace string, False otherwise.\nA string is whitespace if all characters in the string are whitespace and there\nis at least one character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "istitle",
          "signature": "istitle(self, /)",
          "documentation": {
            "description": "Return True if the string is a title-cased string, False otherwise.\nIn a title-cased string, upper- and title-case characters may only\nfollow uncased characters and lowercase characters only cased ones.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isupper",
          "signature": "isupper(self, /)",
          "documentation": {
            "description": "Return True if the string is an uppercase string, False otherwise.\nA string is uppercase if all cased characters in the string are uppercase and\nthere is at least one cased character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "join",
          "signature": "join(self, iterable, /)",
          "documentation": {
            "description": "Concatenate any number of strings.\nThe string whose method is called is inserted in between each given string.\nThe result is returned as a new string.\nExample: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ljust",
          "signature": "ljust(self, width, fillchar=' ', /)",
          "documentation": {
            "description": "Return a left-justified string of length width.\nPadding is done using the specified fill character (default is a space).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lower",
          "signature": "lower(self, /)",
          "documentation": {
            "description": "Return a copy of the string converted to lowercase.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lstrip",
          "signature": "lstrip(self, chars=None, /)",
          "documentation": {
            "description": "Return a copy of the string with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "maketrans",
          "signature": "maketrans(...)",
          "documentation": {
            "description": "Return a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "partition",
          "signature": "partition(self, sep, /)",
          "documentation": {
            "description": "Partition the string into three parts using the given separator.\nThis will search for the separator in the string.  If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\nIf the separator is not found, returns a 3-tuple containing the original string\nand two empty strings.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "removeprefix",
          "signature": "removeprefix(self, prefix, /)",
          "documentation": {
            "description": "Return a str with the given prefix string removed if present.\nIf the string starts with the prefix string, return string[len(prefix):].\nOtherwise, return a copy of the original string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "removesuffix",
          "signature": "removesuffix(self, suffix, /)",
          "documentation": {
            "description": "Return a str with the given suffix string removed if present.\nIf the string ends with the suffix string and that suffix is not empty,\nreturn string[:-len(suffix)]. Otherwise, return a copy of the original\nstring.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "replace",
          "signature": "replace(self, old, new, count=-1, /)",
          "documentation": {
            "description": "Return a copy with all occurrences of substring old replaced by new.\ncount\nMaximum number of occurrences to replace.\n-1 (the default value) means replace all occurrences.\nIf the optional argument count is given, only the first count occurrences are\nreplaced.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rfind",
          "signature": "rfind(...)",
          "documentation": {
            "description": "S.rfind(sub[, start[, end]]) -> int\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\nReturn -1 on failure.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rindex",
          "signature": "rindex(...)",
          "documentation": {
            "description": "S.rindex(sub[, start[, end]]) -> int\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rjust",
          "signature": "rjust(self, width, fillchar=' ', /)",
          "documentation": {
            "description": "Return a right-justified string of length width.\nPadding is done using the specified fill character (default is a space).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rpartition",
          "signature": "rpartition(self, sep, /)",
          "documentation": {
            "description": "Partition the string into three parts using the given separator.\nThis will search for the separator in the string, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\nIf the separator is not found, returns a 3-tuple containing two empty strings\nand the original string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rsplit",
          "signature": "rsplit(self, /, sep=None, maxsplit=-1)",
          "documentation": {
            "description": "Return a list of the substrings in the string, using sep as the separator string.\nsep\nThe separator used to split the string.\nWhen set to None (the default value), will split on any whitespace\ncharacter (including \\n \\r \\t \\f and spaces) and will discard\nempty strings from the result.\nmaxsplit\nMaximum number of splits.\n-1 (the default value) means no limit.\nSplitting starts at the end of the string and works to the front.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rstrip",
          "signature": "rstrip(self, chars=None, /)",
          "documentation": {
            "description": "Return a copy of the string with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, /, sep=None, maxsplit=-1)",
          "documentation": {
            "description": "Return a list of the substrings in the string, using sep as the separator string.\nsep\nThe separator used to split the string.\nWhen set to None (the default value), will split on any whitespace\ncharacter (including \\n \\r \\t \\f and spaces) and will discard\nempty strings from the result.\nmaxsplit\nMaximum number of splits.\n-1 (the default value) means no limit.\nSplitting starts at the front of the string and works to the end.\nNote, str.split() is mainly useful for data that has been intentionally\ndelimited.  With natural text that includes punctuation, consider using\nthe regular expression module.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "splitlines",
          "signature": "splitlines(self, /, keepends=False)",
          "documentation": {
            "description": "Return a list of the lines in the string, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends is given and\ntrue.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "startswith",
          "signature": "startswith(...)",
          "documentation": {
            "description": "S.startswith(prefix[, start[, end]]) -> bool\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "strip",
          "signature": "strip(self, chars=None, /)",
          "documentation": {
            "description": "Return a copy of the string with leading and trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapcase",
          "signature": "swapcase(self, /)",
          "documentation": {
            "description": "Convert uppercase characters to lowercase and lowercase characters to uppercase.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "title",
          "signature": "title(self, /)",
          "documentation": {
            "description": "Return a version of the string where each word is titlecased.\nMore specifically, words start with uppercased characters and all remaining\ncased characters have lower case.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "translate",
          "signature": "translate(self, table, /)",
          "documentation": {
            "description": "Replace each character in the string using the given translation table.\ntable\nTranslation table, which must be a mapping of Unicode ordinals to\nUnicode ordinals, strings, or None.\nThe table must implement lookup/indexing via __getitem__, for instance a\ndictionary or list.  If this operation raises LookupError, the character is\nleft untouched.  Characters mapped to None are deleted.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "upper",
          "signature": "upper(self, /)",
          "documentation": {
            "description": "Return a copy of the string converted to uppercase.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "zfill",
          "signature": "zfill(self, width, /)",
          "documentation": {
            "description": "Pad a numeric string with zeros on the left, to fill a field of the given width.\nThe string is never truncated.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "bytes",
      "documentation": {
        "description": "bytes(iterable_of_ints) -> bytes\nbytes(string, encoding[, errors]) -> bytes\nbytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\nbytes(int) -> bytes object of size given by the parameter initialized with null bytes\nbytes() -> empty bytes object\nConstruct an immutable array of bytes from:\n- an iterable yielding integers in range(256)\n- a text string encoded using the specified encoding\n- any object implementing the buffer API.\n- an integer",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "capitalize",
          "signature": "capitalize(...)",
          "documentation": {
            "description": "B.capitalize() -> copy of B\nReturn a copy of B with only its first character capitalized (ASCII)\nand the rest lower-cased.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "center",
          "signature": "center(self, width, fillchar=b' ', /)",
          "documentation": {
            "description": "Return a centered string of length width.\nPadding is done using the specified fill character.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "count",
          "signature": "count(...)",
          "documentation": {
            "description": "B.count(sub[, start[, end]]) -> int\nReturn the number of non-overlapping occurrences of subsection sub in\nbytes B[start:end].  Optional arguments start and end are interpreted\nas in slice notation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "decode",
          "signature": "decode(self, /, encoding='utf-8', errors='strict')",
          "documentation": {
            "description": "Decode the bytes using the codec registered for encoding.\nencoding\nThe encoding with which to decode the bytes.\nerrors\nThe error handling scheme to use for the handling of decoding errors.\nThe default is 'strict' meaning that decoding errors raise a\nUnicodeDecodeError. Other possible values are 'ignore' and 'replace'\nas well as any other name registered with codecs.register_error that\ncan handle UnicodeDecodeErrors.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "endswith",
          "signature": "endswith(...)",
          "documentation": {
            "description": "B.endswith(suffix[, start[, end]]) -> bool\nReturn True if B ends with the specified suffix, False otherwise.\nWith optional start, test B beginning at that position.\nWith optional end, stop comparing B at that position.\nsuffix can also be a tuple of bytes to try.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "expandtabs",
          "signature": "expandtabs(self, /, tabsize=8)",
          "documentation": {
            "description": "Return a copy where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "find",
          "signature": "find(...)",
          "documentation": {
            "description": "B.find(sub[, start[, end]]) -> int\nReturn the lowest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\nReturn -1 on failure.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fromhex",
          "signature": "fromhex(string, /)",
          "documentation": {
            "description": "Create a bytes object from a string of hexadecimal numbers.\nSpaces between two numbers are accepted.\nExample: bytes.fromhex('B9 01EF') -> b'\\\\xb9\\\\x01\\\\xef'.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "hex",
          "signature": "hex(...)",
          "documentation": {
            "description": "Create a string of hexadecimal numbers from a bytes object.\nsep\nAn optional single character or byte to separate hex bytes.\nbytes_per_sep\nHow many bytes between separators.  Positive values count from the\nright, negative values count from the left.\nExample:\n>>> value = b'\\xb9\\x01\\xef'\n>>> value.hex()\n'b901ef'\n>>> value.hex(':')\n'b9:01:ef'\n>>> value.hex(':', 2)\n'b9:01ef'\n>>> value.hex(':', -2)\n'b901:ef'",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "index",
          "signature": "index(...)",
          "documentation": {
            "description": "B.index(sub[, start[, end]]) -> int\nReturn the lowest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isalnum",
          "signature": "isalnum(...)",
          "documentation": {
            "description": "B.isalnum() -> bool\nReturn True if all characters in B are alphanumeric\nand there is at least one character in B, False otherwise.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isalpha",
          "signature": "isalpha(...)",
          "documentation": {
            "description": "B.isalpha() -> bool\nReturn True if all characters in B are alphabetic\nand there is at least one character in B, False otherwise.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isascii",
          "signature": "isascii(...)",
          "documentation": {
            "description": "B.isascii() -> bool\nReturn True if B is empty or all characters in B are ASCII,\nFalse otherwise.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isdigit",
          "signature": "isdigit(...)",
          "documentation": {
            "description": "B.isdigit() -> bool\nReturn True if all characters in B are digits\nand there is at least one character in B, False otherwise.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "islower",
          "signature": "islower(...)",
          "documentation": {
            "description": "B.islower() -> bool\nReturn True if all cased characters in B are lowercase and there is\nat least one cased character in B, False otherwise.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isspace",
          "signature": "isspace(...)",
          "documentation": {
            "description": "B.isspace() -> bool\nReturn True if all characters in B are whitespace\nand there is at least one character in B, False otherwise.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "istitle",
          "signature": "istitle(...)",
          "documentation": {
            "description": "B.istitle() -> bool\nReturn True if B is a titlecased string and there is at least one\ncharacter in B, i.e. uppercase characters may only follow uncased\ncharacters and lowercase characters only cased ones. Return False\notherwise.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isupper",
          "signature": "isupper(...)",
          "documentation": {
            "description": "B.isupper() -> bool\nReturn True if all cased characters in B are uppercase and there is\nat least one cased character in B, False otherwise.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "join",
          "signature": "join(self, iterable_of_bytes, /)",
          "documentation": {
            "description": "Concatenate any number of bytes objects.\nThe bytes whose method is called is inserted in between each pair.\nThe result is returned as a new bytes object.\nExample: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ljust",
          "signature": "ljust(self, width, fillchar=b' ', /)",
          "documentation": {
            "description": "Return a left-justified string of length width.\nPadding is done using the specified fill character.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lower",
          "signature": "lower(...)",
          "documentation": {
            "description": "B.lower() -> copy of B\nReturn a copy of B with all ASCII characters converted to lowercase.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lstrip",
          "signature": "lstrip(self, bytes=None, /)",
          "documentation": {
            "description": "Strip leading bytes contained in the argument.\nIf the argument is omitted or None, strip leading  ASCII whitespace.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "maketrans",
          "signature": "maketrans(frm, to, /)",
          "documentation": {
            "description": "Return a translation table useable for the bytes or bytearray translate method.\nThe returned table will be one where each byte in frm is mapped to the byte at\nthe same position in to.\nThe bytes objects frm and to must be of the same length.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "partition",
          "signature": "partition(self, sep, /)",
          "documentation": {
            "description": "Partition the bytes into three parts using the given separator.\nThis will search for the separator sep in the bytes. If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\nIf the separator is not found, returns a 3-tuple containing the original bytes\nobject and two empty bytes objects.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "removeprefix",
          "signature": "removeprefix(self, prefix, /)",
          "documentation": {
            "description": "Return a bytes object with the given prefix string removed if present.\nIf the bytes starts with the prefix string, return bytes[len(prefix):].\nOtherwise, return a copy of the original bytes.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "removesuffix",
          "signature": "removesuffix(self, suffix, /)",
          "documentation": {
            "description": "Return a bytes object with the given suffix string removed if present.\nIf the bytes ends with the suffix string and that suffix is not empty,\nreturn bytes[:-len(prefix)].  Otherwise, return a copy of the original\nbytes.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "replace",
          "signature": "replace(self, old, new, count=-1, /)",
          "documentation": {
            "description": "Return a copy with all occurrences of substring old replaced by new.\ncount\nMaximum number of occurrences to replace.\n-1 (the default value) means replace all occurrences.\nIf the optional argument count is given, only the first count occurrences are\nreplaced.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rfind",
          "signature": "rfind(...)",
          "documentation": {
            "description": "B.rfind(sub[, start[, end]]) -> int\nReturn the highest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\nReturn -1 on failure.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rindex",
          "signature": "rindex(...)",
          "documentation": {
            "description": "B.rindex(sub[, start[, end]]) -> int\nReturn the highest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\nRaise ValueError when the subsection is not found.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rjust",
          "signature": "rjust(self, width, fillchar=b' ', /)",
          "documentation": {
            "description": "Return a right-justified string of length width.\nPadding is done using the specified fill character.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rpartition",
          "signature": "rpartition(self, sep, /)",
          "documentation": {
            "description": "Partition the bytes into three parts using the given separator.\nThis will search for the separator sep in the bytes, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\nIf the separator is not found, returns a 3-tuple containing two empty bytes\nobjects and the original bytes object.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rsplit",
          "signature": "rsplit(self, /, sep=None, maxsplit=-1)",
          "documentation": {
            "description": "Return a list of the sections in the bytes, using sep as the delimiter.\nsep\nThe delimiter according which to split the bytes.\nNone (the default value) means split on ASCII whitespace characters\n(space, tab, return, newline, formfeed, vertical tab).\nmaxsplit\nMaximum number of splits to do.\n-1 (the default value) means no limit.\nSplitting is done starting at the end of the bytes and working to the front.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rstrip",
          "signature": "rstrip(self, bytes=None, /)",
          "documentation": {
            "description": "Strip trailing bytes contained in the argument.\nIf the argument is omitted or None, strip trailing ASCII whitespace.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, /, sep=None, maxsplit=-1)",
          "documentation": {
            "description": "Return a list of the sections in the bytes, using sep as the delimiter.\nsep\nThe delimiter according which to split the bytes.\nNone (the default value) means split on ASCII whitespace characters\n(space, tab, return, newline, formfeed, vertical tab).\nmaxsplit\nMaximum number of splits to do.\n-1 (the default value) means no limit.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "splitlines",
          "signature": "splitlines(self, /, keepends=False)",
          "documentation": {
            "description": "Return a list of the lines in the bytes, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends is given and\ntrue.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "startswith",
          "signature": "startswith(...)",
          "documentation": {
            "description": "B.startswith(prefix[, start[, end]]) -> bool\nReturn True if B starts with the specified prefix, False otherwise.\nWith optional start, test B beginning at that position.\nWith optional end, stop comparing B at that position.\nprefix can also be a tuple of bytes to try.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "strip",
          "signature": "strip(self, bytes=None, /)",
          "documentation": {
            "description": "Strip leading and trailing bytes contained in the argument.\nIf the argument is omitted or None, strip leading and trailing ASCII whitespace.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapcase",
          "signature": "swapcase(...)",
          "documentation": {
            "description": "B.swapcase() -> copy of B\nReturn a copy of B with uppercase ASCII characters converted\nto lowercase ASCII and vice versa.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "title",
          "signature": "title(...)",
          "documentation": {
            "description": "B.title() -> copy of B\nReturn a titlecased version of B, i.e. ASCII words start with uppercase\ncharacters, all remaining cased characters have lowercase.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "translate",
          "signature": "translate(self, table, /, delete=b'')",
          "documentation": {
            "description": "Return a copy with each character mapped by the given translation table.\ntable\nTranslation table, which must be a bytes object of length 256.\nAll characters occurring in the optional argument delete are removed.\nThe remaining characters are mapped through the given translation table.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "upper",
          "signature": "upper(...)",
          "documentation": {
            "description": "B.upper() -> copy of B\nReturn a copy of B with all ASCII characters converted to uppercase.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "zfill",
          "signature": "zfill(self, width, /)",
          "documentation": {
            "description": "Pad a numeric string with zeros on the left, to fill a field of the given width.\nThe original string is never truncated.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "contextlib_nullcontext",
      "documentation": {
        "description": "Context manager that does no additional processing.\nUsed as a stand-in for a normal context manager, when a particular\nblock of code is only sometimes used with a normal context manager:\ncm = optional_cm if condition else nullcontext()\nwith cm:\n# Perform operation, using optional_cm if condition is True\n.. note::\nPrefer using `contextlib.nullcontext` instead of this context manager.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "long",
      "documentation": {
        "description": "int([x]) -> integer\nint(x, base=10) -> integer\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "as_integer_ratio",
          "signature": "as_integer_ratio(self, /)",
          "documentation": {
            "description": "Return a pair of integers, whose ratio is equal to the original int.\nThe ratio is in lowest terms and has a positive denominator.\n>>> (10).as_integer_ratio()\n(10, 1)\n>>> (-10).as_integer_ratio()\n(-10, 1)\n>>> (0).as_integer_ratio()\n(0, 1)",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bit_count",
          "signature": "bit_count(self, /)",
          "documentation": {
            "description": "Number of ones in the binary representation of the absolute value of self.\nAlso known as the population count.\n>>> bin(13)\n'0b1101'\n>>> (13).bit_count()\n3",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "bit_length",
          "signature": "bit_length(self, /)",
          "documentation": {
            "description": "Number of bits necessary to represent self in binary.\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "from_bytes",
          "signature": "from_bytes(bytes, byteorder='big', *, signed=False)",
          "documentation": {
            "description": "Return the integer represented by the given array of bytes.\nbytes\nHolds the array of bytes to convert.  The argument must either\nsupport the buffer protocol or be an iterable object producing bytes.\nBytes and bytearray are examples of built-in objects that support the\nbuffer protocol.\nbyteorder\nThe byte order used to represent the integer.  If byteorder is 'big',\nthe most significant byte is at the beginning of the byte array.  If\nbyteorder is 'little', the most significant byte is at the end of the\nbyte array.  To request the native byte order of the host system, use\n`sys.byteorder' as the byte order value.  Default is to use 'big'.\nsigned\nIndicates whether two's complement is used to represent the integer.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "is_integer",
          "signature": "is_integer(self, /)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "to_bytes",
          "signature": "to_bytes(self, /, length=1, byteorder='big', *, signed=False)",
          "documentation": {
            "description": "Return an array of bytes representing an integer.\nlength\nLength of bytes object to use.  An OverflowError is raised if the\ninteger is not representable with the given number of bytes.  Default\nis length 1.\nbyteorder\nThe byte order used to represent the integer.  If byteorder is 'big',\nthe most significant byte is at the beginning of the byte array.  If\nbyteorder is 'little', the most significant byte is at the end of the\nbyte array.  To request the native byte order of the host system, use\n`sys.byteorder' as the byte order value.  Default is to use 'big'.\nsigned\nDetermines whether two's complement is used to represent the integer.\nIf signed is False and a negative integer is given, an OverflowError\nis raised.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "os_PathLike",
      "documentation": {
        "description": "Abstract base class for implementing the file system path protocol.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": []
    },
    {
      "name": "unicode",
      "documentation": {
        "description": "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "capitalize",
          "signature": "capitalize(self, /)",
          "documentation": {
            "description": "Return a capitalized version of the string.\nMore specifically, make the first character have upper case and the rest lower\ncase.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "casefold",
          "signature": "casefold(self, /)",
          "documentation": {
            "description": "Return a version of the string suitable for caseless comparisons.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "center",
          "signature": "center(self, width, fillchar=' ', /)",
          "documentation": {
            "description": "Return a centered string of length width.\nPadding is done using the specified fill character (default is a space).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "count",
          "signature": "count(...)",
          "documentation": {
            "description": "S.count(sub[, start[, end]]) -> int\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "encode",
          "signature": "encode(self, /, encoding='utf-8', errors='strict')",
          "documentation": {
            "description": "Encode the string using the codec registered for encoding.\nencoding\nThe encoding in which to encode the string.\nerrors\nThe error handling scheme to use for encoding errors.\nThe default is 'strict' meaning that encoding errors raise a\nUnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "endswith",
          "signature": "endswith(...)",
          "documentation": {
            "description": "S.endswith(suffix[, start[, end]]) -> bool\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "expandtabs",
          "signature": "expandtabs(self, /, tabsize=8)",
          "documentation": {
            "description": "Return a copy where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "find",
          "signature": "find(...)",
          "documentation": {
            "description": "S.find(sub[, start[, end]]) -> int\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\nReturn -1 on failure.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "format",
          "signature": "format(...)",
          "documentation": {
            "description": "S.format(*args, **kwargs) -> str\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "format_map",
          "signature": "format_map(...)",
          "documentation": {
            "description": "S.format_map(mapping) -> str\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "index",
          "signature": "index(...)",
          "documentation": {
            "description": "S.index(sub[, start[, end]]) -> int\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isalnum",
          "signature": "isalnum(self, /)",
          "documentation": {
            "description": "Return True if the string is an alpha-numeric string, False otherwise.\nA string is alpha-numeric if all characters in the string are alpha-numeric and\nthere is at least one character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isalpha",
          "signature": "isalpha(self, /)",
          "documentation": {
            "description": "Return True if the string is an alphabetic string, False otherwise.\nA string is alphabetic if all characters in the string are alphabetic and there\nis at least one character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isascii",
          "signature": "isascii(self, /)",
          "documentation": {
            "description": "Return True if all characters in the string are ASCII, False otherwise.\nASCII characters have code points in the range U+0000-U+007F.\nEmpty string is ASCII too.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isdecimal",
          "signature": "isdecimal(self, /)",
          "documentation": {
            "description": "Return True if the string is a decimal string, False otherwise.\nA string is a decimal string if all characters in the string are decimal and\nthere is at least one character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isdigit",
          "signature": "isdigit(self, /)",
          "documentation": {
            "description": "Return True if the string is a digit string, False otherwise.\nA string is a digit string if all characters in the string are digits and there\nis at least one character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isidentifier",
          "signature": "isidentifier(self, /)",
          "documentation": {
            "description": "Return True if the string is a valid Python identifier, False otherwise.\nCall keyword.iskeyword(s) to test whether string s is a reserved identifier,\nsuch as \"def\" or \"class\".",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "islower",
          "signature": "islower(self, /)",
          "documentation": {
            "description": "Return True if the string is a lowercase string, False otherwise.\nA string is lowercase if all cased characters in the string are lowercase and\nthere is at least one cased character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isnumeric",
          "signature": "isnumeric(self, /)",
          "documentation": {
            "description": "Return True if the string is a numeric string, False otherwise.\nA string is numeric if all characters in the string are numeric and there is at\nleast one character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isprintable",
          "signature": "isprintable(self, /)",
          "documentation": {
            "description": "Return True if the string is printable, False otherwise.\nA string is printable if all of its characters are considered printable in\nrepr() or if it is empty.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isspace",
          "signature": "isspace(self, /)",
          "documentation": {
            "description": "Return True if the string is a whitespace string, False otherwise.\nA string is whitespace if all characters in the string are whitespace and there\nis at least one character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "istitle",
          "signature": "istitle(self, /)",
          "documentation": {
            "description": "Return True if the string is a title-cased string, False otherwise.\nIn a title-cased string, upper- and title-case characters may only\nfollow uncased characters and lowercase characters only cased ones.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "isupper",
          "signature": "isupper(self, /)",
          "documentation": {
            "description": "Return True if the string is an uppercase string, False otherwise.\nA string is uppercase if all cased characters in the string are uppercase and\nthere is at least one cased character in the string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "join",
          "signature": "join(self, iterable, /)",
          "documentation": {
            "description": "Concatenate any number of strings.\nThe string whose method is called is inserted in between each given string.\nThe result is returned as a new string.\nExample: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ljust",
          "signature": "ljust(self, width, fillchar=' ', /)",
          "documentation": {
            "description": "Return a left-justified string of length width.\nPadding is done using the specified fill character (default is a space).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lower",
          "signature": "lower(self, /)",
          "documentation": {
            "description": "Return a copy of the string converted to lowercase.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "lstrip",
          "signature": "lstrip(self, chars=None, /)",
          "documentation": {
            "description": "Return a copy of the string with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "maketrans",
          "signature": "maketrans(...)",
          "documentation": {
            "description": "Return a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "partition",
          "signature": "partition(self, sep, /)",
          "documentation": {
            "description": "Partition the string into three parts using the given separator.\nThis will search for the separator in the string.  If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\nIf the separator is not found, returns a 3-tuple containing the original string\nand two empty strings.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "removeprefix",
          "signature": "removeprefix(self, prefix, /)",
          "documentation": {
            "description": "Return a str with the given prefix string removed if present.\nIf the string starts with the prefix string, return string[len(prefix):].\nOtherwise, return a copy of the original string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "removesuffix",
          "signature": "removesuffix(self, suffix, /)",
          "documentation": {
            "description": "Return a str with the given suffix string removed if present.\nIf the string ends with the suffix string and that suffix is not empty,\nreturn string[:-len(suffix)]. Otherwise, return a copy of the original\nstring.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "replace",
          "signature": "replace(self, old, new, count=-1, /)",
          "documentation": {
            "description": "Return a copy with all occurrences of substring old replaced by new.\ncount\nMaximum number of occurrences to replace.\n-1 (the default value) means replace all occurrences.\nIf the optional argument count is given, only the first count occurrences are\nreplaced.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rfind",
          "signature": "rfind(...)",
          "documentation": {
            "description": "S.rfind(sub[, start[, end]]) -> int\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\nReturn -1 on failure.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rindex",
          "signature": "rindex(...)",
          "documentation": {
            "description": "S.rindex(sub[, start[, end]]) -> int\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rjust",
          "signature": "rjust(self, width, fillchar=' ', /)",
          "documentation": {
            "description": "Return a right-justified string of length width.\nPadding is done using the specified fill character (default is a space).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rpartition",
          "signature": "rpartition(self, sep, /)",
          "documentation": {
            "description": "Partition the string into three parts using the given separator.\nThis will search for the separator in the string, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\nIf the separator is not found, returns a 3-tuple containing two empty strings\nand the original string.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rsplit",
          "signature": "rsplit(self, /, sep=None, maxsplit=-1)",
          "documentation": {
            "description": "Return a list of the substrings in the string, using sep as the separator string.\nsep\nThe separator used to split the string.\nWhen set to None (the default value), will split on any whitespace\ncharacter (including \\n \\r \\t \\f and spaces) and will discard\nempty strings from the result.\nmaxsplit\nMaximum number of splits.\n-1 (the default value) means no limit.\nSplitting starts at the end of the string and works to the front.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "rstrip",
          "signature": "rstrip(self, chars=None, /)",
          "documentation": {
            "description": "Return a copy of the string with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, /, sep=None, maxsplit=-1)",
          "documentation": {
            "description": "Return a list of the substrings in the string, using sep as the separator string.\nsep\nThe separator used to split the string.\nWhen set to None (the default value), will split on any whitespace\ncharacter (including \\n \\r \\t \\f and spaces) and will discard\nempty strings from the result.\nmaxsplit\nMaximum number of splits.\n-1 (the default value) means no limit.\nSplitting starts at the front of the string and works to the end.\nNote, str.split() is mainly useful for data that has been intentionally\ndelimited.  With natural text that includes punctuation, consider using\nthe regular expression module.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "splitlines",
          "signature": "splitlines(self, /, keepends=False)",
          "documentation": {
            "description": "Return a list of the lines in the string, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends is given and\ntrue.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "startswith",
          "signature": "startswith(...)",
          "documentation": {
            "description": "S.startswith(prefix[, start[, end]]) -> bool\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "strip",
          "signature": "strip(self, chars=None, /)",
          "documentation": {
            "description": "Return a copy of the string with leading and trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapcase",
          "signature": "swapcase(self, /)",
          "documentation": {
            "description": "Convert uppercase characters to lowercase and lowercase characters to uppercase.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "title",
          "signature": "title(self, /)",
          "documentation": {
            "description": "Return a version of the string where each word is titlecased.\nMore specifically, words start with uppercased characters and all remaining\ncased characters have lower case.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "translate",
          "signature": "translate(self, table, /)",
          "documentation": {
            "description": "Replace each character in the string using the given translation table.\ntable\nTranslation table, which must be a mapping of Unicode ordinals to\nUnicode ordinals, strings, or None.\nThe table must implement lookup/indexing via __getitem__, for instance a\ndictionary or list.  If this operation raises LookupError, the character is\nleft untouched.  Characters mapped to None are deleted.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "upper",
          "signature": "upper(self, /)",
          "documentation": {
            "description": "Return a copy of the string converted to uppercase.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "zfill",
          "signature": "zfill(self, width, /)",
          "documentation": {
            "description": "Pad a numeric string with zeros on the left, to fill a field of the given width.\nThe string is never truncated.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    }
  ]
}