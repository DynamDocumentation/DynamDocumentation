{
  "description": "Methods for scaling, centering, normalization, binarization, and more.",
  "functions": [
    {
      "name": "add_dummy_feature",
      "signature": "add_dummy_feature(X, value=1.0)",
      "documentation": {
        "description": "Augment dataset with an additional dummy feature.\n\n    This is useful for fitting an intercept term with implementations which\n    cannot otherwise fit it directly.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        Data.\n\n    value : float\n        Value to use for the dummy feature.\n\n    Returns\n    -------\n    X : {ndarray, sparse matrix} of shape (n_samples, n_features + 1)\n        Same data with dummy feature added as first column.",
        "parameters": {
          "X": {
            "type": "{ndarray, sparse matrix} of shape (n_samples, n_features + 1)",
            "description": ""
          },
          "value": {
            "type": "float",
            "description": ""
          },
          "Value": {
            "type": "to use for the dummy feature.",
            "description": "Returns\n-------"
          },
          "Same": {
            "type": "data with dummy feature added as first column.",
            "description": "Examples\n--------\n>>> from sklearn.preprocessing import add_dummy_feature\n>>> add_dummy_feature([[0, 1], [1, 0]])\narray([[1., 0., 1.],\n[1., 1., 0.]])"
          }
        },
        "returns": "-------\n    X : {ndarray, sparse matrix} of shape (n_samples, n_features + 1)\n        Same data with dummy feature added as first column.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import add_dummy_feature\n    >>> add_dummy_feature([[0, 1], [1, 0]])\n    array([[1., 0., 1.],\n           [1., 1., 0.]])",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n    >>> from sklearn.preprocessing import add_dummy_feature\n    >>> add_dummy_feature([[0, 1], [1, 0]])\n    array([[1., 0., 1.],\n           [1., 1., 0.]])"
      }
    },
    {
      "name": "binarize",
      "signature": "binarize(X, *, threshold=0.0, copy=True)",
      "documentation": {
        "description": "Boolean thresholding of array-like or scipy.sparse matrix.\n\n    Read more in the :ref:`User Guide <preprocessing_binarization>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The data to binarize, element by element.\n        scipy.sparse matrices should be in CSR or CSC format to avoid an\n        un-necessary copy.\n\n    threshold : float, default=0.0\n        Feature values below or equal to this are replaced by 0, above it by 1.\n        Threshold may not be less than 0 for operations on sparse matrices.\n\n    copy : bool, default=True\n        If False, try to avoid a copy and binarize in place.\n        This is not guaranteed to always work in place; e.g. if the data is\n        a numpy array with an object dtype, a copy will be returned even with\n        copy=False.\n\n    Returns\n    -------\n    X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        The transformed data.\n\n    See Also\n    --------\n    Binarizer : Performs binarization using the Transformer API\n        (e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`).",
        "parameters": {
          "X": {
            "type": "{array",
            "description": "like, sparse matrix} of shape (n_samples, n_features)"
          },
          "The": {
            "type": "transformed data.",
            "description": ""
          },
          "threshold": {
            "type": "float, default=0.0",
            "description": ""
          },
          "Feature": {
            "type": "values below or equal to this are replaced by 0, above it by 1.",
            "description": ""
          },
          "Threshold": {
            "type": "may not be less than 0 for operations on sparse matrices.",
            "description": ""
          },
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "If": {
            "type": "False, try to avoid a copy and binarize in place.",
            "description": ""
          },
          "This": {
            "type": "is not guaranteed to always work in place; e.g. if the data is",
            "description": ""
          },
          "a": {
            "type": "numpy array with an object dtype, a copy will be returned even with",
            "description": "copy=False.\nReturns\n-------"
          },
          "X_tr": {
            "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "Binarizer": {
            "type": "Performs binarization using the Transformer API",
            "description": "(e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`).\nExamples\n--------\n>>> from sklearn.preprocessing import binarize\n>>> X = [[0.4, 0.6, 0.5], [0.6, 0.1, 0.2]]\n>>> binarize(X, threshold=0.5)\narray([[0., 1., 0.],\n[1., 0., 0.]])"
          }
        },
        "returns": "-------\n    X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        The transformed data.\n\n    See Also\n    --------\n    Binarizer : Performs binarization using the Transformer API\n        (e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`).\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import binarize\n    >>> X = [[0.4, 0.6, 0.5], [0.6, 0.1, 0.2]]\n    >>> binarize(X, threshold=0.5)\n    array([[0., 1., 0.],\n           [1., 0., 0.]])",
        "raises": "",
        "see_also": "--------\n    Binarizer : Performs binarization using the Transformer API\n        (e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`).\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import binarize\n    >>> X = [[0.4, 0.6, 0.5], [0.6, 0.1, 0.2]]\n    >>> binarize(X, threshold=0.5)\n    array([[0., 1., 0.],\n           [1., 0., 0.]])",
        "notes": "",
        "examples": "--------\n    >>> from sklearn.preprocessing import binarize\n    >>> X = [[0.4, 0.6, 0.5], [0.6, 0.1, 0.2]]\n    >>> binarize(X, threshold=0.5)\n    array([[0., 1., 0.],\n           [1., 0., 0.]])"
      }
    },
    {
      "name": "label_binarize",
      "signature": "label_binarize(y, *, classes, neg_label=0, pos_label=1, sparse_output=False)",
      "documentation": {
        "description": "Binarize labels in a one-vs-all fashion.\n\n    Several regression and binary classification algorithms are\n    available in scikit-learn. A simple way to extend these algorithms\n    to the multi-class classification case is to use the so-called\n    one-vs-all scheme.\n\n    This function makes it possible to compute this transformation for a\n    fixed set of class labels known ahead of time.\n\n    Parameters\n    ----------\n    y : array-like or sparse matrix\n        Sequence of integer labels or multilabel data to encode.\n\n    classes : array-like of shape (n_classes,)\n        Uniquely holds the label for each class.\n\n    neg_label : int, default=0\n        Value with which negative labels must be encoded.\n\n    pos_label : int, default=1\n        Value with which positive labels must be encoded.\n\n    sparse_output : bool, default=False,\n        Set to true if output binary array is desired in CSR sparse format.\n\n    Returns\n    -------\n    Y : {ndarray, sparse matrix} of shape (n_samples, n_classes)\n        Shape will be (n_samples, 1) for binary problems. Sparse matrix will\n        be of CSR format.\n\n    See Also\n    --------\n    LabelBinarizer : Class used to wrap the functionality of label_binarize and\n        allow for fitting to classes independently of the transform operation.",
        "parameters": {
          "y": {
            "type": "array",
            "description": "like or sparse matrix"
          },
          "Sequence": {
            "type": "of integer labels or multilabel data to encode.",
            "description": ""
          },
          "classes": {
            "type": "array",
            "description": "like of shape (n_classes,)"
          },
          "Uniquely": {
            "type": "holds the label for each class.",
            "description": ""
          },
          "neg_label": {
            "type": "int, default=0",
            "description": ""
          },
          "Value": {
            "type": "with which positive labels must be encoded.",
            "description": ""
          },
          "pos_label": {
            "type": "int, default=1",
            "description": ""
          },
          "sparse_output": {
            "type": "bool, default=False,",
            "description": ""
          },
          "Set": {
            "type": "to true if output binary array is desired in CSR sparse format.",
            "description": "Returns\n-------"
          },
          "Y": {
            "type": "{ndarray, sparse matrix} of shape (n_samples, n_classes)",
            "description": ""
          },
          "Shape": {
            "type": "will be (n_samples, 1) for binary problems. Sparse matrix will",
            "description": ""
          },
          "be": {
            "type": "of CSR format.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "LabelBinarizer": {
            "type": "Class used to wrap the functionality of label_binarize and",
            "description": ""
          },
          "allow": {
            "type": "for fitting to classes independently of the transform operation.",
            "description": "Examples\n--------\n>>> from sklearn.preprocessing import label_binarize\n>>> label_binarize([1, 6], classes=[1, 2, 4, 6])\narray([[1, 0, 0, 0],\n[0, 0, 0, 1]])"
          },
          "The": {
            "type": "class ordering is preserved:",
            "description": ">>> label_binarize([1, 6], classes=[1, 6, 4, 2])\narray([[1, 0, 0, 0],\n[0, 1, 0, 0]])"
          },
          "Binary": {
            "type": "targets transform to a column vector",
            "description": ">>> label_binarize(['yes', 'no', 'no', 'yes'], classes=['no', 'yes'])\narray([[1],\n[0],\n[0],\n[1]])"
          }
        },
        "returns": "-------\n    Y : {ndarray, sparse matrix} of shape (n_samples, n_classes)\n        Shape will be (n_samples, 1) for binary problems. Sparse matrix will\n        be of CSR format.\n\n    See Also\n    --------\n    LabelBinarizer : Class used to wrap the functionality of label_binarize and\n        allow for fitting to classes independently of the transform operation.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import label_binarize\n    >>> label_binarize([1, 6], classes=[1, 2, 4, 6])\n    array([[1, 0, 0, 0],\n           [0, 0, 0, 1]])\n\n    The class ordering is preserved:\n\n    >>> label_binarize([1, 6], classes=[1, 6, 4, 2])\n    array([[1, 0, 0, 0],\n           [0, 1, 0, 0]])\n\n    Binary targets transform to a column vector\n\n    >>> label_binarize(['yes', 'no', 'no', 'yes'], classes=['no', 'yes'])\n    array([[1],\n           [0],\n           [0],\n           [1]])",
        "raises": "",
        "see_also": "--------\n    LabelBinarizer : Class used to wrap the functionality of label_binarize and\n        allow for fitting to classes independently of the transform operation.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import label_binarize\n    >>> label_binarize([1, 6], classes=[1, 2, 4, 6])\n    array([[1, 0, 0, 0],\n           [0, 0, 0, 1]])\n\n    The class ordering is preserved:\n\n    >>> label_binarize([1, 6], classes=[1, 6, 4, 2])\n    array([[1, 0, 0, 0],\n           [0, 1, 0, 0]])\n\n    Binary targets transform to a column vector\n\n    >>> label_binarize(['yes', 'no', 'no', 'yes'], classes=['no', 'yes'])\n    array([[1],\n           [0],\n           [0],\n           [1]])",
        "notes": "",
        "examples": "--------\n    >>> from sklearn.preprocessing import label_binarize\n    >>> label_binarize([1, 6], classes=[1, 2, 4, 6])\n    array([[1, 0, 0, 0],\n           [0, 0, 0, 1]])\n\n    The class ordering is preserved:\n\n    >>> label_binarize([1, 6], classes=[1, 6, 4, 2])\n    array([[1, 0, 0, 0],\n           [0, 1, 0, 0]])\n\n    Binary targets transform to a column vector\n\n    >>> label_binarize(['yes', 'no', 'no', 'yes'], classes=['no', 'yes'])\n    array([[1],\n           [0],\n           [0],\n           [1]])"
      }
    },
    {
      "name": "maxabs_scale",
      "signature": "maxabs_scale(X, *, axis=0, copy=True)",
      "documentation": {
        "description": "Scale each feature to the [-1, 1] range without breaking the sparsity.\n\n    This estimator scales each feature individually such\n    that the maximal absolute value of each feature in the\n    training set will be 1.0.\n\n    This scaler can also be applied to sparse CSR or CSC matrices.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The data.\n\n    axis : {0, 1}, default=0\n        Axis used to scale along. If 0, independently scale each feature,\n        otherwise (if 1) scale each sample.\n\n    copy : bool, default=True\n        If False, try to avoid a copy and scale in place.\n        This is not guaranteed to always work in place; e.g. if the data is\n        a numpy array with an int dtype, a copy will be returned even with\n        copy=False.\n\n    Returns\n    -------\n    X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        The transformed data.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.maxabs_scale` unless you know\n        what you are doing. A common mistake is to apply it to the entire data\n        *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.MaxAbsScaler` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking: `pipe = make_pipeline(MaxAbsScaler(), LogisticRegression())`.\n\n    See Also\n    --------\n    MaxAbsScaler : Performs scaling to the [-1, 1] range using\n        the Transformer API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded to compute the statistics,\n    and maintained during the data transformation.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.",
        "parameters": {
          "X": {
            "type": "{array",
            "description": "like, sparse matrix} of shape (n_samples, n_features)"
          },
          "The": {
            "type": "transformed data.",
            "description": ".. warning:: Risk of data leak"
          },
          "axis": {
            "type": "{0, 1}, default=0",
            "description": ""
          },
          "Axis": {
            "type": "used to scale along. If 0, independently scale each feature,",
            "description": ""
          },
          "otherwise": {
            "type": "if 1",
            "description": "scale each sample."
          },
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "If": {
            "type": "False, try to avoid a copy and scale in place.",
            "description": ""
          },
          "This": {
            "type": "is not guaranteed to always work in place; e.g. if the data is",
            "description": ""
          },
          "a": {
            "type": "numpy array with an int dtype, a copy will be returned even with",
            "description": "copy=False.\nReturns\n-------"
          },
          "X_tr": {
            "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
            "description": ""
          },
          "Do": {
            "type": "not use :func:`~sklearn.preprocessing.maxabs_scale` unless you know",
            "description": ""
          },
          "what": {
            "type": "you are doing. A common mistake is to apply it to the entire data",
            "description": "*before* splitting into training and test sets. This will bias the"
          },
          "model": {
            "type": "evaluation because information would have leaked from the test",
            "description": ""
          },
          "set": {
            "type": "to the training set.",
            "description": ""
          },
          "In": {
            "type": "general, we recommend using",
            "description": ":class:`~sklearn.preprocessing.MaxAbsScaler` within a\n:ref:`Pipeline <pipeline>` in order to prevent most risks of data"
          },
          "leaking": {
            "type": "`pipe = make_pipeline(MaxAbsScaler(), LogisticRegression())`.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "MaxAbsScaler": {
            "type": "Performs scaling to the [",
            "description": "1, 1] range using"
          },
          "the": {
            "type": "Transformer API (e.g. as part of a preprocessing",
            "description": ":class:`~sklearn.pipeline.Pipeline`).\nNotes\n-----"
          },
          "NaNs": {
            "type": "are treated as missing values: disregarded to compute the statistics,",
            "description": ""
          },
          "and": {
            "type": "maintained during the data transformation.",
            "description": ""
          },
          "For": {
            "type": "a comparison of the different scalers, transformers, and normalizers,",
            "description": ""
          },
          "see": {
            "type": ":ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.",
            "description": "Examples\n--------\n>>> from sklearn.preprocessing import maxabs_scale\n>>> X = [[-2, 1, 2], [-1, 0, 1]]\n>>> maxabs_scale(X, axis=0)  # scale each column independently\narray([[-1. ,  1. ,  1. ],\n[-0.5,  0. ,  0.5]])\n>>> maxabs_scale(X, axis=1)  # scale each row independently\narray([[-1. ,  0.5,  1. ],\n[-1. ,  0. ,  1. ]])"
          }
        },
        "returns": "-------\n    X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        The transformed data.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.maxabs_scale` unless you know\n        what you are doing. A common mistake is to apply it to the entire data\n        *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.MaxAbsScaler` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking: `pipe = make_pipeline(MaxAbsScaler(), LogisticRegression())`.\n\n    See Also\n    --------\n    MaxAbsScaler : Performs scaling to the [-1, 1] range using\n        the Transformer API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded to compute the statistics,\n    and maintained during the data transformation.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import maxabs_scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> maxabs_scale(X, axis=0)  # scale each column independently\n    array([[-1. ,  1. ,  1. ],\n           [-0.5,  0. ,  0.5]])\n    >>> maxabs_scale(X, axis=1)  # scale each row independently\n    array([[-1. ,  0.5,  1. ],\n           [-1. ,  0. ,  1. ]])",
        "raises": "",
        "see_also": "--------\n    MaxAbsScaler : Performs scaling to the [-1, 1] range using\n        the Transformer API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded to compute the statistics,\n    and maintained during the data transformation.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import maxabs_scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> maxabs_scale(X, axis=0)  # scale each column independently\n    array([[-1. ,  1. ,  1. ],\n           [-0.5,  0. ,  0.5]])\n    >>> maxabs_scale(X, axis=1)  # scale each row independently\n    array([[-1. ,  0.5,  1. ],\n           [-1. ,  0. ,  1. ]])",
        "notes": "-----\n    NaNs are treated as missing values: disregarded to compute the statistics,\n    and maintained during the data transformation.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import maxabs_scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> maxabs_scale(X, axis=0)  # scale each column independently\n    array([[-1. ,  1. ,  1. ],\n           [-0.5,  0. ,  0.5]])\n    >>> maxabs_scale(X, axis=1)  # scale each row independently\n    array([[-1. ,  0.5,  1. ],\n           [-1. ,  0. ,  1. ]])",
        "examples": "--------\n    >>> from sklearn.preprocessing import maxabs_scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> maxabs_scale(X, axis=0)  # scale each column independently\n    array([[-1. ,  1. ,  1. ],\n           [-0.5,  0. ,  0.5]])\n    >>> maxabs_scale(X, axis=1)  # scale each row independently\n    array([[-1. ,  0.5,  1. ],\n           [-1. ,  0. ,  1. ]])"
      }
    },
    {
      "name": "minmax_scale",
      "signature": "minmax_scale(X, feature_range=(0, 1), *, axis=0, copy=True)",
      "documentation": {
        "description": "Transform features by scaling each feature to a given range.\n\n    This estimator scales and translates each feature individually such\n    that it is in the given range on the training set, i.e. between\n    zero and one.\n\n    The transformation is given by (when ``axis=0``)::\n\n        X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0))\n        X_scaled = X_std * (max - min) + min\n\n    where min, max = feature_range.\n\n    The transformation is calculated as (when ``axis=0``)::\n\n       X_scaled = scale * X + min - X.min(axis=0) * scale\n       where scale = (max - min) / (X.max(axis=0) - X.min(axis=0))\n\n    This transformation is often used as an alternative to zero mean,\n    unit variance scaling.\n\n    Read more in the :ref:`User Guide <preprocessing_scaler>`.\n\n    .. versionadded:: 0.17\n       *minmax_scale* function interface\n       to :class:`~sklearn.preprocessing.MinMaxScaler`.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_samples, n_features)\n        The data.\n\n    feature_range : tuple (min, max), default=(0, 1)\n        Desired range of transformed data.\n\n    axis : {0, 1}, default=0\n        Axis used to scale along. If 0, independently scale each feature,\n        otherwise (if 1) scale each sample.\n\n    copy : bool, default=True\n        If False, try to avoid a copy and scale in place.\n        This is not guaranteed to always work in place; e.g. if the data is\n        a numpy array with an int dtype, a copy will be returned even with\n        copy=False.\n\n    Returns\n    -------\n    X_tr : ndarray of shape (n_samples, n_features)\n        The transformed data.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.minmax_scale` unless you know\n        what you are doing. A common mistake is to apply it to the entire data\n        *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.MinMaxScaler` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking: `pipe = make_pipeline(MinMaxScaler(), LogisticRegression())`.\n\n    See Also\n    --------\n    MinMaxScaler : Performs scaling to a given range using the Transformer\n        API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.",
        "parameters": {
          "X": {
            "type": "array",
            "description": "like of shape (n_samples, n_features)"
          },
          "The": {
            "type": "transformed data.",
            "description": ".. warning:: Risk of data leak"
          },
          "feature_range": {
            "type": "tuple (min, max), default=(0, 1)",
            "description": ""
          },
          "Desired": {
            "type": "range of transformed data.",
            "description": ""
          },
          "axis": {
            "type": "{0, 1}, default=0",
            "description": ""
          },
          "Axis": {
            "type": "used to scale along. If 0, independently scale each feature,",
            "description": ""
          },
          "otherwise": {
            "type": "if 1",
            "description": "scale each sample."
          },
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "If": {
            "type": "False, try to avoid a copy and scale in place.",
            "description": ""
          },
          "This": {
            "type": "is not guaranteed to always work in place; e.g. if the data is",
            "description": ""
          },
          "a": {
            "type": "numpy array with an int dtype, a copy will be returned even with",
            "description": "copy=False.\nReturns\n-------"
          },
          "X_tr": {
            "type": "ndarray of shape (n_samples, n_features)",
            "description": ""
          },
          "Do": {
            "type": "not use :func:`~sklearn.preprocessing.minmax_scale` unless you know",
            "description": ""
          },
          "what": {
            "type": "you are doing. A common mistake is to apply it to the entire data",
            "description": "*before* splitting into training and test sets. This will bias the"
          },
          "model": {
            "type": "evaluation because information would have leaked from the test",
            "description": ""
          },
          "set": {
            "type": "to the training set.",
            "description": ""
          },
          "In": {
            "type": "general, we recommend using",
            "description": ":class:`~sklearn.preprocessing.MinMaxScaler` within a\n:ref:`Pipeline <pipeline>` in order to prevent most risks of data"
          },
          "leaking": {
            "type": "`pipe = make_pipeline(MinMaxScaler(), LogisticRegression())`.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "MinMaxScaler": {
            "type": "Performs scaling to a given range using the Transformer",
            "description": ""
          },
          "API": {
            "type": "(e.g. as part of a preprocessing",
            "description": ":class:`~sklearn.pipeline.Pipeline`).\nNotes\n-----"
          },
          "For": {
            "type": "a comparison of the different scalers, transformers, and normalizers,",
            "description": ""
          },
          "see": {
            "type": ":ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.",
            "description": "Examples\n--------\n>>> from sklearn.preprocessing import minmax_scale\n>>> X = [[-2, 1, 2], [-1, 0, 1]]\n>>> minmax_scale(X, axis=0)  # scale each column independently\narray([[0., 1., 1.],\n[1., 0., 0.]])\n>>> minmax_scale(X, axis=1)  # scale each row independently\narray([[0.  , 0.75, 1.  ],\n[0.  , 0.5 , 1.  ]])"
          }
        },
        "returns": "-------\n    X_tr : ndarray of shape (n_samples, n_features)\n        The transformed data.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.minmax_scale` unless you know\n        what you are doing. A common mistake is to apply it to the entire data\n        *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.MinMaxScaler` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking: `pipe = make_pipeline(MinMaxScaler(), LogisticRegression())`.\n\n    See Also\n    --------\n    MinMaxScaler : Performs scaling to a given range using the Transformer\n        API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import minmax_scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> minmax_scale(X, axis=0)  # scale each column independently\n    array([[0., 1., 1.],\n           [1., 0., 0.]])\n    >>> minmax_scale(X, axis=1)  # scale each row independently\n    array([[0.  , 0.75, 1.  ],\n           [0.  , 0.5 , 1.  ]])",
        "raises": "",
        "see_also": "--------\n    MinMaxScaler : Performs scaling to a given range using the Transformer\n        API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import minmax_scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> minmax_scale(X, axis=0)  # scale each column independently\n    array([[0., 1., 1.],\n           [1., 0., 0.]])\n    >>> minmax_scale(X, axis=1)  # scale each row independently\n    array([[0.  , 0.75, 1.  ],\n           [0.  , 0.5 , 1.  ]])",
        "notes": "-----\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import minmax_scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> minmax_scale(X, axis=0)  # scale each column independently\n    array([[0., 1., 1.],\n           [1., 0., 0.]])\n    >>> minmax_scale(X, axis=1)  # scale each row independently\n    array([[0.  , 0.75, 1.  ],\n           [0.  , 0.5 , 1.  ]])",
        "examples": "--------\n    >>> from sklearn.preprocessing import minmax_scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> minmax_scale(X, axis=0)  # scale each column independently\n    array([[0., 1., 1.],\n           [1., 0., 0.]])\n    >>> minmax_scale(X, axis=1)  # scale each row independently\n    array([[0.  , 0.75, 1.  ],\n           [0.  , 0.5 , 1.  ]])"
      }
    },
    {
      "name": "normalize",
      "signature": "normalize(X, norm='l2', *, axis=1, copy=True, return_norm=False)",
      "documentation": {
        "description": "Scale input vectors individually to unit norm (vector length).\n\n    Read more in the :ref:`User Guide <preprocessing_normalization>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The data to normalize, element by element.\n        scipy.sparse matrices should be in CSR format to avoid an\n        un-necessary copy.\n\n    norm : {'l1', 'l2', 'max'}, default='l2'\n        The norm to use to normalize each non zero sample (or each non-zero\n        feature if axis is 0).\n\n    axis : {0, 1}, default=1\n        Define axis used to normalize the data along. If 1, independently\n        normalize each sample, otherwise (if 0) normalize each feature.\n\n    copy : bool, default=True\n        If False, try to avoid a copy and normalize in place.\n        This is not guaranteed to always work in place; e.g. if the data is\n        a numpy array with an int dtype, a copy will be returned even with\n        copy=False.\n\n    return_norm : bool, default=False\n        Whether to return the computed norms.\n\n    Returns\n    -------\n    X : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        Normalized input X.\n\n    norms : ndarray of shape (n_samples, ) if axis=1 else (n_features, )\n        An array of norms along given axis for X.\n        When X is sparse, a NotImplementedError will be raised\n        for norm 'l1' or 'l2'.\n\n    See Also\n    --------\n    Normalizer : Performs normalization using the Transformer API\n        (e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.",
        "parameters": {
          "X": {
            "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
            "description": ""
          },
          "The": {
            "type": "norm to use to normalize each non zero sample (or each non-zero",
            "description": ""
          },
          "norm": {
            "type": "{'l1', 'l2', 'max'}, default='l2'",
            "description": ""
          },
          "feature": {
            "type": "if axis is 0).",
            "description": ""
          },
          "axis": {
            "type": "{0, 1}, default=1",
            "description": ""
          },
          "Define": {
            "type": "axis used to normalize the data along. If 1, independently",
            "description": ""
          },
          "normalize": {
            "type": "each sample, otherwise (if 0) normalize each feature.",
            "description": ""
          },
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "If": {
            "type": "False, try to avoid a copy and normalize in place.",
            "description": ""
          },
          "This": {
            "type": "is not guaranteed to always work in place; e.g. if the data is",
            "description": ""
          },
          "a": {
            "type": "numpy array with an int dtype, a copy will be returned even with",
            "description": "copy=False."
          },
          "return_norm": {
            "type": "bool, default=False",
            "description": ""
          },
          "Whether": {
            "type": "to return the computed norms.",
            "description": "Returns\n-------"
          },
          "Normalized": {
            "type": "input X.",
            "description": ""
          },
          "norms": {
            "type": "ndarray of shape (n_samples, ) if axis=1 else (n_features, )",
            "description": ""
          },
          "An": {
            "type": "array of norms along given axis for X.",
            "description": ""
          },
          "When": {
            "type": "X is sparse, a NotImplementedError will be raised",
            "description": ""
          },
          "for": {
            "type": "norm 'l1' or 'l2'.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "Normalizer": {
            "type": "Performs normalization using the Transformer API",
            "description": "(e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`).\nNotes\n-----"
          },
          "For": {
            "type": "a comparison of the different scalers, transformers, and normalizers,",
            "description": ""
          },
          "see": {
            "type": ":ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.",
            "description": "Examples\n--------\n>>> from sklearn.preprocessing import normalize\n>>> X = [[-2, 1, 2], [-1, 0, 1]]\n>>> normalize(X, norm=\"l1\")  # L1 normalization each row independently\narray([[-0.4,  0.2,  0.4],\n[-0.5,  0. ,  0.5]])\n>>> normalize(X, norm=\"l2\")  # L2 normalization each row independently\narray([[-0.66...,  0.33...,  0.66...],\n[-0.70...,  0.     ,  0.70...]])"
          }
        },
        "returns": "-------\n    X : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        Normalized input X.\n\n    norms : ndarray of shape (n_samples, ) if axis=1 else (n_features, )\n        An array of norms along given axis for X.\n        When X is sparse, a NotImplementedError will be raised\n        for norm 'l1' or 'l2'.\n\n    See Also\n    --------\n    Normalizer : Performs normalization using the Transformer API\n        (e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import normalize\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> normalize(X, norm=\"l1\")  # L1 normalization each row independently\n    array([[-0.4,  0.2,  0.4],\n           [-0.5,  0. ,  0.5]])\n    >>> normalize(X, norm=\"l2\")  # L2 normalization each row independently\n    array([[-0.66...,  0.33...,  0.66...],\n           [-0.70...,  0.     ,  0.70...]])",
        "raises": "",
        "see_also": "--------\n    Normalizer : Performs normalization using the Transformer API\n        (e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import normalize\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> normalize(X, norm=\"l1\")  # L1 normalization each row independently\n    array([[-0.4,  0.2,  0.4],\n           [-0.5,  0. ,  0.5]])\n    >>> normalize(X, norm=\"l2\")  # L2 normalization each row independently\n    array([[-0.66...,  0.33...,  0.66...],\n           [-0.70...,  0.     ,  0.70...]])",
        "notes": "-----\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import normalize\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> normalize(X, norm=\"l1\")  # L1 normalization each row independently\n    array([[-0.4,  0.2,  0.4],\n           [-0.5,  0. ,  0.5]])\n    >>> normalize(X, norm=\"l2\")  # L2 normalization each row independently\n    array([[-0.66...,  0.33...,  0.66...],\n           [-0.70...,  0.     ,  0.70...]])",
        "examples": "--------\n    >>> from sklearn.preprocessing import normalize\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> normalize(X, norm=\"l1\")  # L1 normalization each row independently\n    array([[-0.4,  0.2,  0.4],\n           [-0.5,  0. ,  0.5]])\n    >>> normalize(X, norm=\"l2\")  # L2 normalization each row independently\n    array([[-0.66...,  0.33...,  0.66...],\n           [-0.70...,  0.     ,  0.70...]])"
      }
    },
    {
      "name": "power_transform",
      "signature": "power_transform(X, method='yeo-johnson', *, standardize=True, copy=True)",
      "documentation": {
        "description": "Parametric, monotonic transformation to make data more Gaussian-like.\n\n    Power transforms are a family of parametric, monotonic transformations\n    that are applied to make data more Gaussian-like. This is useful for\n    modeling issues related to heteroscedasticity (non-constant variance),\n    or other situations where normality is desired.\n\n    Currently, power_transform supports the Box-Cox transform and the\n    Yeo-Johnson transform. The optimal parameter for stabilizing variance and\n    minimizing skewness is estimated through maximum likelihood.\n\n    Box-Cox requires input data to be strictly positive, while Yeo-Johnson\n    supports both positive or negative data.\n\n    By default, zero-mean, unit-variance normalization is applied to the\n    transformed data.\n\n    Read more in the :ref:`User Guide <preprocessing_transformer>`.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_samples, n_features)\n        The data to be transformed using a power transformation.\n\n    method : {'yeo-johnson', 'box-cox'}, default='yeo-johnson'\n        The power transform method. Available methods are:\n\n        - 'yeo-johnson' [1]_, works with positive and negative values\n        - 'box-cox' [2]_, only works with strictly positive values\n\n        .. versionchanged:: 0.23\n            The default value of the `method` parameter changed from\n            'box-cox' to 'yeo-johnson' in 0.23.\n\n    standardize : bool, default=True\n        Set to True to apply zero-mean, unit-variance normalization to the\n        transformed output.\n\n    copy : bool, default=True\n        If False, try to avoid a copy and transform in place.\n        This is not guaranteed to always work in place; e.g. if the data is\n        a numpy array with an int dtype, a copy will be returned even with\n        copy=False.\n\n    Returns\n    -------\n    X_trans : ndarray of shape (n_samples, n_features)\n        The transformed data.\n\n    See Also\n    --------\n    PowerTransformer : Equivalent transformation with the\n        Transformer API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n\n    quantile_transform : Maps data to a standard normal distribution with\n        the parameter `output_distribution='normal'`.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in ``fit``, and maintained\n    in ``transform``.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    References\n    ----------\n\n    .. [1] I.K. Yeo and R.A. Johnson, \"A new family of power transformations to\n           improve normality or symmetry.\" Biometrika, 87(4), pp.954-959,\n           (2000).\n\n    .. [2] G.E.P. Box and D.R. Cox, \"An Analysis of Transformations\", Journal\n           of the Royal Statistical Society B, 26, 211-252 (1964).",
        "parameters": {
          "X": {
            "type": "array",
            "description": "like of shape (n_samples, n_features)"
          },
          "The": {
            "type": "transformed data.",
            "description": ""
          },
          "method": {
            "type": "{'yeo",
            "description": "johnson', 'box-cox'}, default='yeo-johnson'"
          },
          "standardize": {
            "type": "bool, default=True",
            "description": ""
          },
          "Set": {
            "type": "to True to apply zero-mean, unit-variance normalization to the",
            "description": ""
          },
          "transformed": {
            "type": "output.",
            "description": ""
          },
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "If": {
            "type": "False, try to avoid a copy and transform in place.",
            "description": ""
          },
          "This": {
            "type": "is not guaranteed to always work in place; e.g. if the data is",
            "description": ""
          },
          "a": {
            "type": "numpy array with an int dtype, a copy will be returned even with",
            "description": "copy=False.\nReturns\n-------"
          },
          "X_trans": {
            "type": "ndarray of shape (n_samples, n_features)",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "PowerTransformer": {
            "type": "Equivalent transformation with the",
            "description": ""
          },
          "Transformer": {
            "type": "API (e.g. as part of a preprocessing",
            "description": ":class:`~sklearn.pipeline.Pipeline`)."
          },
          "quantile_transform": {
            "type": "Maps data to a standard normal distribution with",
            "description": ""
          },
          "the": {
            "type": "parameter `output_distribution='normal'`.",
            "description": "Notes\n-----"
          },
          "NaNs": {
            "type": "are treated as missing values: disregarded in ``fit``, and maintained",
            "description": ""
          },
          "in": {
            "type": "``transform``.",
            "description": ""
          },
          "For": {
            "type": "a comparison of the different scalers, transformers, and normalizers,",
            "description": ""
          },
          "see": {
            "type": ":ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.",
            "description": "References\n----------\n.. [1] I.K. Yeo and R.A. Johnson, \"A new family of power transformations to"
          },
          "improve": {
            "type": "normality or symmetry.\" Biometrika, 87(4), pp.954-959,",
            "description": "(2000).\n.. [2] G.E.P. Box and D.R. Cox, \"An Analysis of Transformations\", Journal"
          },
          "of": {
            "type": "the Royal Statistical Society B, 26, 211-252 (1964).",
            "description": "Examples\n--------\n>>> import numpy as np\n>>> from sklearn.preprocessing import power_transform\n>>> data = [[1, 2], [3, 2], [4, 5]]\n>>> print(power_transform(data, method='box-cox'))\n[[-1.332... -0.707...]\n[ 0.256... -0.707...]\n[ 1.076...  1.414...]]\n.. warning:: Risk of data leak."
          },
          "Do": {
            "type": "not use :func:`~sklearn.preprocessing.power_transform` unless you",
            "description": ""
          },
          "know": {
            "type": "what you are doing. A common mistake is to apply it to the entire",
            "description": ""
          },
          "data": {
            "type": "*before* splitting into training and test sets. This will bias the",
            "description": ""
          },
          "model": {
            "type": "evaluation because information would have leaked from the test",
            "description": ""
          },
          "set": {
            "type": "to the training set.",
            "description": ""
          },
          "In": {
            "type": "general, we recommend using",
            "description": ":class:`~sklearn.preprocessing.PowerTransformer` within a\n:ref:`Pipeline <pipeline>` in order to prevent most risks of data\nleaking, e.g.: `pipe = make_pipeline(PowerTransformer(),"
          },
          "LogisticRegression": {
            "type": "",
            "description": ")`."
          }
        },
        "returns": "-------\n    X_trans : ndarray of shape (n_samples, n_features)\n        The transformed data.\n\n    See Also\n    --------\n    PowerTransformer : Equivalent transformation with the\n        Transformer API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n\n    quantile_transform : Maps data to a standard normal distribution with\n        the parameter `output_distribution='normal'`.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in ``fit``, and maintained\n    in ``transform``.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    References\n    ----------\n\n    .. [1] I.K. Yeo and R.A. Johnson, \"A new family of power transformations to\n           improve normality or symmetry.\" Biometrika, 87(4), pp.954-959,\n           (2000).\n\n    .. [2] G.E.P. Box and D.R. Cox, \"An Analysis of Transformations\", Journal\n           of the Royal Statistical Society B, 26, 211-252 (1964).\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import power_transform\n    >>> data = [[1, 2], [3, 2], [4, 5]]\n    >>> print(power_transform(data, method='box-cox'))\n    [[-1.332... -0.707...]\n     [ 0.256... -0.707...]\n     [ 1.076...  1.414...]]\n\n    .. warning:: Risk of data leak.\n        Do not use :func:`~sklearn.preprocessing.power_transform` unless you\n        know what you are doing. A common mistake is to apply it to the entire\n        data *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.PowerTransformer` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking, e.g.: `pipe = make_pipeline(PowerTransformer(),\n        LogisticRegression())`.",
        "raises": "",
        "see_also": "--------\n    PowerTransformer : Equivalent transformation with the\n        Transformer API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n\n    quantile_transform : Maps data to a standard normal distribution with\n        the parameter `output_distribution='normal'`.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in ``fit``, and maintained\n    in ``transform``.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    References\n    ----------\n\n    .. [1] I.K. Yeo and R.A. Johnson, \"A new family of power transformations to\n           improve normality or symmetry.\" Biometrika, 87(4), pp.954-959,\n           (2000).\n\n    .. [2] G.E.P. Box and D.R. Cox, \"An Analysis of Transformations\", Journal\n           of the Royal Statistical Society B, 26, 211-252 (1964).\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import power_transform\n    >>> data = [[1, 2], [3, 2], [4, 5]]\n    >>> print(power_transform(data, method='box-cox'))\n    [[-1.332... -0.707...]\n     [ 0.256... -0.707...]\n     [ 1.076...  1.414...]]\n\n    .. warning:: Risk of data leak.\n        Do not use :func:`~sklearn.preprocessing.power_transform` unless you\n        know what you are doing. A common mistake is to apply it to the entire\n        data *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.PowerTransformer` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking, e.g.: `pipe = make_pipeline(PowerTransformer(),\n        LogisticRegression())`.",
        "notes": "-----\n    NaNs are treated as missing values: disregarded in ``fit``, and maintained\n    in ``transform``.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    References\n    ----------\n\n    .. [1] I.K. Yeo and R.A. Johnson, \"A new family of power transformations to\n           improve normality or symmetry.\" Biometrika, 87(4), pp.954-959,\n           (2000).\n\n    .. [2] G.E.P. Box and D.R. Cox, \"An Analysis of Transformations\", Journal\n           of the Royal Statistical Society B, 26, 211-252 (1964).\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import power_transform\n    >>> data = [[1, 2], [3, 2], [4, 5]]\n    >>> print(power_transform(data, method='box-cox'))\n    [[-1.332... -0.707...]\n     [ 0.256... -0.707...]\n     [ 1.076...  1.414...]]\n\n    .. warning:: Risk of data leak.\n        Do not use :func:`~sklearn.preprocessing.power_transform` unless you\n        know what you are doing. A common mistake is to apply it to the entire\n        data *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.PowerTransformer` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking, e.g.: `pipe = make_pipeline(PowerTransformer(),\n        LogisticRegression())`.",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import power_transform\n    >>> data = [[1, 2], [3, 2], [4, 5]]\n    >>> print(power_transform(data, method='box-cox'))\n    [[-1.332... -0.707...]\n     [ 0.256... -0.707...]\n     [ 1.076...  1.414...]]\n\n    .. warning:: Risk of data leak.\n        Do not use :func:`~sklearn.preprocessing.power_transform` unless you\n        know what you are doing. A common mistake is to apply it to the entire\n        data *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.PowerTransformer` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking, e.g.: `pipe = make_pipeline(PowerTransformer(),\n        LogisticRegression())`."
      }
    },
    {
      "name": "quantile_transform",
      "signature": "quantile_transform(X, *, axis=0, n_quantiles=1000, output_distribution='uniform', ignore_implicit_zeros=False, subsample=100000, random_state=None, copy=True)",
      "documentation": {
        "description": "Transform features using quantiles information.\n\n    This method transforms the features to follow a uniform or a normal\n    distribution. Therefore, for a given feature, this transformation tends\n    to spread out the most frequent values. It also reduces the impact of\n    (marginal) outliers: this is therefore a robust preprocessing scheme.\n\n    The transformation is applied on each feature independently. First an\n    estimate of the cumulative distribution function of a feature is\n    used to map the original values to a uniform distribution. The obtained\n    values are then mapped to the desired output distribution using the\n    associated quantile function. Features values of new/unseen data that fall\n    below or above the fitted range will be mapped to the bounds of the output\n    distribution. Note that this transform is non-linear. It may distort linear\n    correlations between variables measured at the same scale but renders\n    variables measured at different scales more directly comparable.\n\n    Read more in the :ref:`User Guide <preprocessing_transformer>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The data to transform.\n\n    axis : int, default=0\n        Axis used to compute the means and standard deviations along. If 0,\n        transform each feature, otherwise (if 1) transform each sample.\n\n    n_quantiles : int, default=1000 or n_samples\n        Number of quantiles to be computed. It corresponds to the number\n        of landmarks used to discretize the cumulative distribution function.\n        If n_quantiles is larger than the number of samples, n_quantiles is set\n        to the number of samples as a larger number of quantiles does not give\n        a better approximation of the cumulative distribution function\n        estimator.\n\n    output_distribution : {'uniform', 'normal'}, default='uniform'\n        Marginal distribution for the transformed data. The choices are\n        'uniform' (default) or 'normal'.\n\n    ignore_implicit_zeros : bool, default=False\n        Only applies to sparse matrices. If True, the sparse entries of the\n        matrix are discarded to compute the quantile statistics. If False,\n        these entries are treated as zeros.\n\n    subsample : int or None, default=1e5\n        Maximum number of samples used to estimate the quantiles for\n        computational efficiency. Note that the subsampling procedure may\n        differ for value-identical sparse and dense matrices.\n        Disable subsampling by setting `subsample=None`.\n\n        .. versionadded:: 1.5\n           The option `None` to disable subsampling was added.\n\n    random_state : int, RandomState instance or None, default=None\n        Determines random number generation for subsampling and smoothing\n        noise.\n        Please see ``subsample`` for more details.\n        Pass an int for reproducible results across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    copy : bool, default=True\n        If False, try to avoid a copy and transform in place.\n        This is not guaranteed to always work in place; e.g. if the data is\n        a numpy array with an int dtype, a copy will be returned even with\n        copy=False.\n\n        .. versionchanged:: 0.23\n            The default value of `copy` changed from False to True in 0.23.\n\n    Returns\n    -------\n    Xt : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        The transformed data.\n\n    See Also\n    --------\n    QuantileTransformer : Performs quantile-based scaling using the\n        Transformer API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n    power_transform : Maps data to a normal distribution using a\n        power transformation.\n    scale : Performs standardization that is faster, but less robust\n        to outliers.\n    robust_scale : Performs robust standardization that removes the influence\n        of outliers but does not put outliers and inliers on the same scale.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.quantile_transform` unless\n        you know what you are doing. A common mistake is to apply it\n        to the entire data *before* splitting into training and\n        test sets. This will bias the model evaluation because\n        information would have leaked from the test set to the\n        training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.QuantileTransformer` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking:`pipe = make_pipeline(QuantileTransformer(),\n        LogisticRegression())`.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.",
        "parameters": {
          "X": {
            "type": "{array",
            "description": "like, sparse matrix} of shape (n_samples, n_features)"
          },
          "The": {
            "type": "transformed data.",
            "description": ""
          },
          "axis": {
            "type": "int, default=0",
            "description": ""
          },
          "Axis": {
            "type": "used to compute the means and standard deviations along. If 0,",
            "description": ""
          },
          "transform": {
            "type": "each feature, otherwise (if 1) transform each sample.",
            "description": ""
          },
          "n_quantiles": {
            "type": "int, default=1000 or n_samples",
            "description": ""
          },
          "Number": {
            "type": "of quantiles to be computed. It corresponds to the number",
            "description": ""
          },
          "of": {
            "type": "outliers but does not put outliers and inliers on the same scale.",
            "description": "Notes\n-----"
          },
          "If": {
            "type": "False, try to avoid a copy and transform in place.",
            "description": ""
          },
          "to": {
            "type": "the entire data *before* splitting into training and",
            "description": ""
          },
          "a": {
            "type": "numpy array with an int dtype, a copy will be returned even with",
            "description": "copy=False.\n.. versionchanged:: 0.23"
          },
          "output_distribution": {
            "type": "{'uniform', 'normal'}, default='uniform'",
            "description": ""
          },
          "Marginal": {
            "type": "distribution for the transformed data. The choices are",
            "description": "'uniform' (default) or 'normal'."
          },
          "ignore_implicit_zeros": {
            "type": "bool, default=False",
            "description": ""
          },
          "Only": {
            "type": "applies to sparse matrices. If True, the sparse entries of the",
            "description": ""
          },
          "matrix": {
            "type": "are discarded to compute the quantile statistics. If False,",
            "description": ""
          },
          "these": {
            "type": "entries are treated as zeros.",
            "description": ""
          },
          "subsample": {
            "type": "int or None, default=1e5",
            "description": ""
          },
          "Maximum": {
            "type": "number of samples used to estimate the quantiles for",
            "description": ""
          },
          "computational": {
            "type": "efficiency. Note that the subsampling procedure may",
            "description": ""
          },
          "differ": {
            "type": "for value-identical sparse and dense matrices.",
            "description": ""
          },
          "Disable": {
            "type": "subsampling by setting `subsample=None`.",
            "description": ".. versionadded:: 1.5"
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Determines": {
            "type": "random number generation for subsampling and smoothing",
            "description": "noise."
          },
          "Please": {
            "type": "see ``subsample`` for more details.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible results across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "This": {
            "type": "is not guaranteed to always work in place; e.g. if the data is",
            "description": ""
          },
          "Xt": {
            "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
            "description": ""
          },
          "QuantileTransformer": {
            "type": "Performs quantile",
            "description": "based scaling using the"
          },
          "Transformer": {
            "type": "API (e.g. as part of a preprocessing",
            "description": ":class:`~sklearn.pipeline.Pipeline`)."
          },
          "power_transform": {
            "type": "Maps data to a normal distribution using a",
            "description": ""
          },
          "power": {
            "type": "transformation.",
            "description": ""
          },
          "scale": {
            "type": "Performs standardization that is faster, but less robust",
            "description": ""
          },
          "robust_scale": {
            "type": "Performs robust standardization that removes the influence",
            "description": ""
          },
          "NaNs": {
            "type": "are treated as missing values: disregarded in fit, and maintained in",
            "description": "transform.\n.. warning:: Risk of data leak"
          },
          "Do": {
            "type": "not use :func:`~sklearn.preprocessing.quantile_transform` unless",
            "description": ""
          },
          "you": {
            "type": "know what you are doing. A common mistake is to apply it",
            "description": ""
          },
          "test": {
            "type": "sets. This will bias the model evaluation because",
            "description": ""
          },
          "information": {
            "type": "would have leaked from the test set to the",
            "description": ""
          },
          "training": {
            "type": "set.",
            "description": ""
          },
          "In": {
            "type": "general, we recommend using",
            "description": ":class:`~sklearn.preprocessing.QuantileTransformer` within a\n:ref:`Pipeline <pipeline>` in order to prevent most risks of data"
          },
          "leaking": {
            "type": "`pipe = make_pipeline(QuantileTransformer(),",
            "description": ""
          },
          "LogisticRegression": {
            "type": "",
            "description": ")`."
          },
          "For": {
            "type": "a comparison of the different scalers, transformers, and normalizers,",
            "description": ""
          },
          "see": {
            "type": ":ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.",
            "description": "Examples\n--------\n>>> import numpy as np\n>>> from sklearn.preprocessing import quantile_transform\n>>> rng = np.random.RandomState(0)\n>>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)\n>>> quantile_transform(X, n_quantiles=10, random_state=0, copy=True)"
          },
          "array": {
            "type": "[...]",
            "description": ""
          }
        },
        "returns": "-------\n    Xt : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        The transformed data.\n\n    See Also\n    --------\n    QuantileTransformer : Performs quantile-based scaling using the\n        Transformer API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n    power_transform : Maps data to a normal distribution using a\n        power transformation.\n    scale : Performs standardization that is faster, but less robust\n        to outliers.\n    robust_scale : Performs robust standardization that removes the influence\n        of outliers but does not put outliers and inliers on the same scale.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.quantile_transform` unless\n        you know what you are doing. A common mistake is to apply it\n        to the entire data *before* splitting into training and\n        test sets. This will bias the model evaluation because\n        information would have leaked from the test set to the\n        training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.QuantileTransformer` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking:`pipe = make_pipeline(QuantileTransformer(),\n        LogisticRegression())`.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import quantile_transform\n    >>> rng = np.random.RandomState(0)\n    >>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)\n    >>> quantile_transform(X, n_quantiles=10, random_state=0, copy=True)\n    array([...])",
        "raises": "",
        "see_also": "--------\n    QuantileTransformer : Performs quantile-based scaling using the\n        Transformer API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n    power_transform : Maps data to a normal distribution using a\n        power transformation.\n    scale : Performs standardization that is faster, but less robust\n        to outliers.\n    robust_scale : Performs robust standardization that removes the influence\n        of outliers but does not put outliers and inliers on the same scale.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.quantile_transform` unless\n        you know what you are doing. A common mistake is to apply it\n        to the entire data *before* splitting into training and\n        test sets. This will bias the model evaluation because\n        information would have leaked from the test set to the\n        training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.QuantileTransformer` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking:`pipe = make_pipeline(QuantileTransformer(),\n        LogisticRegression())`.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import quantile_transform\n    >>> rng = np.random.RandomState(0)\n    >>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)\n    >>> quantile_transform(X, n_quantiles=10, random_state=0, copy=True)\n    array([...])",
        "notes": "-----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.quantile_transform` unless\n        you know what you are doing. A common mistake is to apply it\n        to the entire data *before* splitting into training and\n        test sets. This will bias the model evaluation because\n        information would have leaked from the test set to the\n        training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.QuantileTransformer` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking:`pipe = make_pipeline(QuantileTransformer(),\n        LogisticRegression())`.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import quantile_transform\n    >>> rng = np.random.RandomState(0)\n    >>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)\n    >>> quantile_transform(X, n_quantiles=10, random_state=0, copy=True)\n    array([...])",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import quantile_transform\n    >>> rng = np.random.RandomState(0)\n    >>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)\n    >>> quantile_transform(X, n_quantiles=10, random_state=0, copy=True)\n    array([...])"
      }
    },
    {
      "name": "robust_scale",
      "signature": "robust_scale(X, *, axis=0, with_centering=True, with_scaling=True, quantile_range=(25.0, 75.0), copy=True, unit_variance=False)",
      "documentation": {
        "description": "Standardize a dataset along any axis.\n\n    Center to the median and component wise scale\n    according to the interquartile range.\n\n    Read more in the :ref:`User Guide <preprocessing_scaler>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_sample, n_features)\n        The data to center and scale.\n\n    axis : int, default=0\n        Axis used to compute the medians and IQR along. If 0,\n        independently scale each feature, otherwise (if 1) scale\n        each sample.\n\n    with_centering : bool, default=True\n        If `True`, center the data before scaling.\n\n    with_scaling : bool, default=True\n        If `True`, scale the data to unit variance (or equivalently,\n        unit standard deviation).\n\n    quantile_range : tuple (q_min, q_max), 0.0 < q_min < q_max < 100.0,        default=(25.0, 75.0)\n        Quantile range used to calculate `scale_`. By default this is equal to\n        the IQR, i.e., `q_min` is the first quantile and `q_max` is the third\n        quantile.\n\n        .. versionadded:: 0.18\n\n    copy : bool, default=True\n        If False, try to avoid a copy and scale in place.\n        This is not guaranteed to always work in place; e.g. if the data is\n        a numpy array with an int dtype, a copy will be returned even with\n        copy=False.\n\n    unit_variance : bool, default=False\n        If `True`, scale data so that normally distributed features have a\n        variance of 1. In general, if the difference between the x-values of\n        `q_max` and `q_min` for a standard normal distribution is greater\n        than 1, the dataset will be scaled down. If less than 1, the dataset\n        will be scaled up.\n\n        .. versionadded:: 0.24\n\n    Returns\n    -------\n    X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        The transformed data.\n\n    See Also\n    --------\n    RobustScaler : Performs centering and scaling using the Transformer API\n        (e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    This implementation will refuse to center scipy.sparse matrices\n    since it would make them non-sparse and would potentially crash the\n    program with memory exhaustion problems.\n\n    Instead the caller is expected to either set explicitly\n    `with_centering=False` (in that case, only variance scaling will be\n    performed on the features of the CSR matrix) or to call `X.toarray()`\n    if he/she expects the materialized dense array to fit in memory.\n\n    To avoid memory copy the caller should pass a CSR matrix.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.robust_scale` unless you know\n        what you are doing. A common mistake is to apply it to the entire data\n        *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.RobustScaler` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking: `pipe = make_pipeline(RobustScaler(), LogisticRegression())`.",
        "parameters": {
          "X": {
            "type": "{array",
            "description": "like, sparse matrix} of shape (n_sample, n_features)"
          },
          "The": {
            "type": "transformed data.",
            "description": ""
          },
          "axis": {
            "type": "int, default=0",
            "description": ""
          },
          "Axis": {
            "type": "used to compute the medians and IQR along. If 0,",
            "description": ""
          },
          "independently": {
            "type": "scale each feature, otherwise (if 1) scale",
            "description": ""
          },
          "each": {
            "type": "sample.",
            "description": ""
          },
          "with_centering": {
            "type": "bool, default=True",
            "description": ""
          },
          "If": {
            "type": "`True`, scale data so that normally distributed features have a",
            "description": ""
          },
          "with_scaling": {
            "type": "bool, default=True",
            "description": ""
          },
          "unit": {
            "type": "standard deviation).",
            "description": ""
          },
          "quantile_range": {
            "type": "tuple (q_min, q_max), 0.0 < q_min < q_max < 100.0,        default=(25.0, 75.0)",
            "description": ""
          },
          "Quantile": {
            "type": "range used to calculate `scale_`. By default this is equal to",
            "description": ""
          },
          "the": {
            "type": "IQR, i.e., `q_min` is the first quantile and `q_max` is the third",
            "description": "quantile.\n.. versionadded:: 0.18"
          },
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "This": {
            "type": "implementation will refuse to center scipy.sparse matrices",
            "description": ""
          },
          "a": {
            "type": "numpy array with an int dtype, a copy will be returned even with",
            "description": "copy=False."
          },
          "unit_variance": {
            "type": "bool, default=False",
            "description": ""
          },
          "variance": {
            "type": "of 1. In general, if the difference between the x-values of",
            "description": "`q_max` and `q_min` for a standard normal distribution is greater"
          },
          "than": {
            "type": "1, the dataset will be scaled down. If less than 1, the dataset",
            "description": ""
          },
          "will": {
            "type": "be scaled up.",
            "description": ".. versionadded:: 0.24\nReturns\n-------"
          },
          "X_tr": {
            "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "RobustScaler": {
            "type": "Performs centering and scaling using the Transformer API",
            "description": "(e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`).\nNotes\n-----"
          },
          "since": {
            "type": "it would make them non-sparse and would potentially crash the",
            "description": ""
          },
          "program": {
            "type": "with memory exhaustion problems.",
            "description": ""
          },
          "Instead": {
            "type": "the caller is expected to either set explicitly",
            "description": "`with_centering=False` (in that case, only variance scaling will be"
          },
          "performed": {
            "type": "on the features of the CSR matrix) or to call `X.toarray()`",
            "description": ""
          },
          "if": {
            "type": "he/she expects the materialized dense array to fit in memory.",
            "description": ""
          },
          "To": {
            "type": "avoid memory copy the caller should pass a CSR matrix.",
            "description": ""
          },
          "For": {
            "type": "a comparison of the different scalers, transformers, and normalizers,",
            "description": ""
          },
          "see": {
            "type": ":ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.",
            "description": ".. warning:: Risk of data leak"
          },
          "Do": {
            "type": "not use :func:`~sklearn.preprocessing.robust_scale` unless you know",
            "description": ""
          },
          "what": {
            "type": "you are doing. A common mistake is to apply it to the entire data",
            "description": "*before* splitting into training and test sets. This will bias the"
          },
          "model": {
            "type": "evaluation because information would have leaked from the test",
            "description": ""
          },
          "set": {
            "type": "to the training set.",
            "description": ""
          },
          "In": {
            "type": "general, we recommend using",
            "description": ":class:`~sklearn.preprocessing.RobustScaler` within a\n:ref:`Pipeline <pipeline>` in order to prevent most risks of data"
          },
          "leaking": {
            "type": "`pipe = make_pipeline(RobustScaler(), LogisticRegression())`.",
            "description": "Examples\n--------\n>>> from sklearn.preprocessing import robust_scale\n>>> X = [[-2, 1, 2], [-1, 0, 1]]\n>>> robust_scale(X, axis=0)  # scale each column independently\narray([[-1.,  1.,  1.],\n[ 1., -1., -1.]])\n>>> robust_scale(X, axis=1)  # scale each row independently\narray([[-1.5,  0. ,  0.5],\n[-1. ,  0. ,  1. ]])"
          }
        },
        "returns": "-------\n    X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        The transformed data.\n\n    See Also\n    --------\n    RobustScaler : Performs centering and scaling using the Transformer API\n        (e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    This implementation will refuse to center scipy.sparse matrices\n    since it would make them non-sparse and would potentially crash the\n    program with memory exhaustion problems.\n\n    Instead the caller is expected to either set explicitly\n    `with_centering=False` (in that case, only variance scaling will be\n    performed on the features of the CSR matrix) or to call `X.toarray()`\n    if he/she expects the materialized dense array to fit in memory.\n\n    To avoid memory copy the caller should pass a CSR matrix.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.robust_scale` unless you know\n        what you are doing. A common mistake is to apply it to the entire data\n        *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.RobustScaler` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking: `pipe = make_pipeline(RobustScaler(), LogisticRegression())`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import robust_scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> robust_scale(X, axis=0)  # scale each column independently\n    array([[-1.,  1.,  1.],\n           [ 1., -1., -1.]])\n    >>> robust_scale(X, axis=1)  # scale each row independently\n    array([[-1.5,  0. ,  0.5],\n           [-1. ,  0. ,  1. ]])",
        "raises": "",
        "see_also": "--------\n    RobustScaler : Performs centering and scaling using the Transformer API\n        (e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    This implementation will refuse to center scipy.sparse matrices\n    since it would make them non-sparse and would potentially crash the\n    program with memory exhaustion problems.\n\n    Instead the caller is expected to either set explicitly\n    `with_centering=False` (in that case, only variance scaling will be\n    performed on the features of the CSR matrix) or to call `X.toarray()`\n    if he/she expects the materialized dense array to fit in memory.\n\n    To avoid memory copy the caller should pass a CSR matrix.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.robust_scale` unless you know\n        what you are doing. A common mistake is to apply it to the entire data\n        *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.RobustScaler` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking: `pipe = make_pipeline(RobustScaler(), LogisticRegression())`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import robust_scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> robust_scale(X, axis=0)  # scale each column independently\n    array([[-1.,  1.,  1.],\n           [ 1., -1., -1.]])\n    >>> robust_scale(X, axis=1)  # scale each row independently\n    array([[-1.5,  0. ,  0.5],\n           [-1. ,  0. ,  1. ]])",
        "notes": "-----\n    This implementation will refuse to center scipy.sparse matrices\n    since it would make them non-sparse and would potentially crash the\n    program with memory exhaustion problems.\n\n    Instead the caller is expected to either set explicitly\n    `with_centering=False` (in that case, only variance scaling will be\n    performed on the features of the CSR matrix) or to call `X.toarray()`\n    if he/she expects the materialized dense array to fit in memory.\n\n    To avoid memory copy the caller should pass a CSR matrix.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.robust_scale` unless you know\n        what you are doing. A common mistake is to apply it to the entire data\n        *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.RobustScaler` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking: `pipe = make_pipeline(RobustScaler(), LogisticRegression())`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import robust_scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> robust_scale(X, axis=0)  # scale each column independently\n    array([[-1.,  1.,  1.],\n           [ 1., -1., -1.]])\n    >>> robust_scale(X, axis=1)  # scale each row independently\n    array([[-1.5,  0. ,  0.5],\n           [-1. ,  0. ,  1. ]])",
        "examples": "--------\n    >>> from sklearn.preprocessing import robust_scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> robust_scale(X, axis=0)  # scale each column independently\n    array([[-1.,  1.,  1.],\n           [ 1., -1., -1.]])\n    >>> robust_scale(X, axis=1)  # scale each row independently\n    array([[-1.5,  0. ,  0.5],\n           [-1. ,  0. ,  1. ]])"
      }
    },
    {
      "name": "scale",
      "signature": "scale(X, *, axis=0, with_mean=True, with_std=True, copy=True)",
      "documentation": {
        "description": "Standardize a dataset along any axis.\n\n    Center to the mean and component wise scale to unit variance.\n\n    Read more in the :ref:`User Guide <preprocessing_scaler>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The data to center and scale.\n\n    axis : {0, 1}, default=0\n        Axis used to compute the means and standard deviations along. If 0,\n        independently standardize each feature, otherwise (if 1) standardize\n        each sample.\n\n    with_mean : bool, default=True\n        If True, center the data before scaling.\n\n    with_std : bool, default=True\n        If True, scale the data to unit variance (or equivalently,\n        unit standard deviation).\n\n    copy : bool, default=True\n        If False, try to avoid a copy and scale in place.\n        This is not guaranteed to always work in place; e.g. if the data is\n        a numpy array with an int dtype, a copy will be returned even with\n        copy=False.\n\n    Returns\n    -------\n    X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        The transformed data.\n\n    See Also\n    --------\n    StandardScaler : Performs scaling to unit variance using the Transformer\n        API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    This implementation will refuse to center scipy.sparse matrices\n    since it would make them non-sparse and would potentially crash the\n    program with memory exhaustion problems.\n\n    Instead the caller is expected to either set explicitly\n    `with_mean=False` (in that case, only variance scaling will be\n    performed on the features of the CSC matrix) or to call `X.toarray()`\n    if he/she expects the materialized dense array to fit in memory.\n\n    To avoid memory copy the caller should pass a CSC matrix.\n\n    NaNs are treated as missing values: disregarded to compute the statistics,\n    and maintained during the data transformation.\n\n    We use a biased estimator for the standard deviation, equivalent to\n    `numpy.std(x, ddof=0)`. Note that the choice of `ddof` is unlikely to\n    affect model performance.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.scale` unless you know\n        what you are doing. A common mistake is to apply it to the entire data\n        *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.StandardScaler` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking: `pipe = make_pipeline(StandardScaler(), LogisticRegression())`.",
        "parameters": {
          "X": {
            "type": "{array",
            "description": "like, sparse matrix} of shape (n_samples, n_features)"
          },
          "The": {
            "type": "transformed data.",
            "description": ""
          },
          "axis": {
            "type": "{0, 1}, default=0",
            "description": ""
          },
          "Axis": {
            "type": "used to compute the means and standard deviations along. If 0,",
            "description": ""
          },
          "independently": {
            "type": "standardize each feature, otherwise (if 1) standardize",
            "description": ""
          },
          "each": {
            "type": "sample.",
            "description": ""
          },
          "with_mean": {
            "type": "bool, default=True",
            "description": ""
          },
          "If": {
            "type": "False, try to avoid a copy and scale in place.",
            "description": ""
          },
          "with_std": {
            "type": "bool, default=True",
            "description": ""
          },
          "unit": {
            "type": "standard deviation).",
            "description": ""
          },
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "This": {
            "type": "implementation will refuse to center scipy.sparse matrices",
            "description": ""
          },
          "a": {
            "type": "numpy array with an int dtype, a copy will be returned even with",
            "description": "copy=False.\nReturns\n-------"
          },
          "X_tr": {
            "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "StandardScaler": {
            "type": "Performs scaling to unit variance using the Transformer",
            "description": ""
          },
          "API": {
            "type": "(e.g. as part of a preprocessing",
            "description": ":class:`~sklearn.pipeline.Pipeline`).\nNotes\n-----"
          },
          "since": {
            "type": "it would make them non-sparse and would potentially crash the",
            "description": ""
          },
          "program": {
            "type": "with memory exhaustion problems.",
            "description": ""
          },
          "Instead": {
            "type": "the caller is expected to either set explicitly",
            "description": "`with_mean=False` (in that case, only variance scaling will be"
          },
          "performed": {
            "type": "on the features of the CSC matrix) or to call `X.toarray()`",
            "description": ""
          },
          "if": {
            "type": "he/she expects the materialized dense array to fit in memory.",
            "description": ""
          },
          "To": {
            "type": "avoid memory copy the caller should pass a CSC matrix.",
            "description": ""
          },
          "NaNs": {
            "type": "are treated as missing values: disregarded to compute the statistics,",
            "description": ""
          },
          "and": {
            "type": "maintained during the data transformation.",
            "description": ""
          },
          "We": {
            "type": "use a biased estimator for the standard deviation, equivalent to",
            "description": "`numpy.std(x, ddof=0)`. Note that the choice of `ddof` is unlikely to"
          },
          "affect": {
            "type": "model performance.",
            "description": ""
          },
          "For": {
            "type": "a comparison of the different scalers, transformers, and normalizers,",
            "description": ""
          },
          "see": {
            "type": ":ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.",
            "description": ".. warning:: Risk of data leak"
          },
          "Do": {
            "type": "not use :func:`~sklearn.preprocessing.scale` unless you know",
            "description": ""
          },
          "what": {
            "type": "you are doing. A common mistake is to apply it to the entire data",
            "description": "*before* splitting into training and test sets. This will bias the"
          },
          "model": {
            "type": "evaluation because information would have leaked from the test",
            "description": ""
          },
          "set": {
            "type": "to the training set.",
            "description": ""
          },
          "In": {
            "type": "general, we recommend using",
            "description": ":class:`~sklearn.preprocessing.StandardScaler` within a\n:ref:`Pipeline <pipeline>` in order to prevent most risks of data"
          },
          "leaking": {
            "type": "`pipe = make_pipeline(StandardScaler(), LogisticRegression())`.",
            "description": "Examples\n--------\n>>> from sklearn.preprocessing import scale\n>>> X = [[-2, 1, 2], [-1, 0, 1]]\n>>> scale(X, axis=0)  # scaling each column independently\narray([[-1.,  1.,  1.],\n[ 1., -1., -1.]])\n>>> scale(X, axis=1)  # scaling each row independently\narray([[-1.37...,  0.39...,  0.98...],\n[-1.22...,  0.     ,  1.22...]])"
          }
        },
        "returns": "-------\n    X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n        The transformed data.\n\n    See Also\n    --------\n    StandardScaler : Performs scaling to unit variance using the Transformer\n        API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    This implementation will refuse to center scipy.sparse matrices\n    since it would make them non-sparse and would potentially crash the\n    program with memory exhaustion problems.\n\n    Instead the caller is expected to either set explicitly\n    `with_mean=False` (in that case, only variance scaling will be\n    performed on the features of the CSC matrix) or to call `X.toarray()`\n    if he/she expects the materialized dense array to fit in memory.\n\n    To avoid memory copy the caller should pass a CSC matrix.\n\n    NaNs are treated as missing values: disregarded to compute the statistics,\n    and maintained during the data transformation.\n\n    We use a biased estimator for the standard deviation, equivalent to\n    `numpy.std(x, ddof=0)`. Note that the choice of `ddof` is unlikely to\n    affect model performance.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.scale` unless you know\n        what you are doing. A common mistake is to apply it to the entire data\n        *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.StandardScaler` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking: `pipe = make_pipeline(StandardScaler(), LogisticRegression())`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> scale(X, axis=0)  # scaling each column independently\n    array([[-1.,  1.,  1.],\n           [ 1., -1., -1.]])\n    >>> scale(X, axis=1)  # scaling each row independently\n    array([[-1.37...,  0.39...,  0.98...],\n           [-1.22...,  0.     ,  1.22...]])",
        "raises": "",
        "see_also": "--------\n    StandardScaler : Performs scaling to unit variance using the Transformer\n        API (e.g. as part of a preprocessing\n        :class:`~sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    This implementation will refuse to center scipy.sparse matrices\n    since it would make them non-sparse and would potentially crash the\n    program with memory exhaustion problems.\n\n    Instead the caller is expected to either set explicitly\n    `with_mean=False` (in that case, only variance scaling will be\n    performed on the features of the CSC matrix) or to call `X.toarray()`\n    if he/she expects the materialized dense array to fit in memory.\n\n    To avoid memory copy the caller should pass a CSC matrix.\n\n    NaNs are treated as missing values: disregarded to compute the statistics,\n    and maintained during the data transformation.\n\n    We use a biased estimator for the standard deviation, equivalent to\n    `numpy.std(x, ddof=0)`. Note that the choice of `ddof` is unlikely to\n    affect model performance.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.scale` unless you know\n        what you are doing. A common mistake is to apply it to the entire data\n        *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.StandardScaler` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking: `pipe = make_pipeline(StandardScaler(), LogisticRegression())`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> scale(X, axis=0)  # scaling each column independently\n    array([[-1.,  1.,  1.],\n           [ 1., -1., -1.]])\n    >>> scale(X, axis=1)  # scaling each row independently\n    array([[-1.37...,  0.39...,  0.98...],\n           [-1.22...,  0.     ,  1.22...]])",
        "notes": "-----\n    This implementation will refuse to center scipy.sparse matrices\n    since it would make them non-sparse and would potentially crash the\n    program with memory exhaustion problems.\n\n    Instead the caller is expected to either set explicitly\n    `with_mean=False` (in that case, only variance scaling will be\n    performed on the features of the CSC matrix) or to call `X.toarray()`\n    if he/she expects the materialized dense array to fit in memory.\n\n    To avoid memory copy the caller should pass a CSC matrix.\n\n    NaNs are treated as missing values: disregarded to compute the statistics,\n    and maintained during the data transformation.\n\n    We use a biased estimator for the standard deviation, equivalent to\n    `numpy.std(x, ddof=0)`. Note that the choice of `ddof` is unlikely to\n    affect model performance.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`.\n\n    .. warning:: Risk of data leak\n\n        Do not use :func:`~sklearn.preprocessing.scale` unless you know\n        what you are doing. A common mistake is to apply it to the entire data\n        *before* splitting into training and test sets. This will bias the\n        model evaluation because information would have leaked from the test\n        set to the training set.\n        In general, we recommend using\n        :class:`~sklearn.preprocessing.StandardScaler` within a\n        :ref:`Pipeline <pipeline>` in order to prevent most risks of data\n        leaking: `pipe = make_pipeline(StandardScaler(), LogisticRegression())`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> scale(X, axis=0)  # scaling each column independently\n    array([[-1.,  1.,  1.],\n           [ 1., -1., -1.]])\n    >>> scale(X, axis=1)  # scaling each row independently\n    array([[-1.37...,  0.39...,  0.98...],\n           [-1.22...,  0.     ,  1.22...]])",
        "examples": "--------\n    >>> from sklearn.preprocessing import scale\n    >>> X = [[-2, 1, 2], [-1, 0, 1]]\n    >>> scale(X, axis=0)  # scaling each column independently\n    array([[-1.,  1.,  1.],\n           [ 1., -1., -1.]])\n    >>> scale(X, axis=1)  # scaling each row independently\n    array([[-1.37...,  0.39...,  0.98...],\n           [-1.22...,  0.     ,  1.22...]])"
      }
    }
  ],
  "classes": [
    {
      "name": "Binarizer",
      "documentation": {
        "description": "Binarize data (set feature values to 0 or 1) according to a threshold.\n\n    Values greater than the threshold map to 1, while values less than\n    or equal to the threshold map to 0. With the default threshold of 0,\n    only positive values map to 1.\n\n    Binarization is a common operation on text count data where the\n    analyst can decide to only consider the presence or absence of a\n    feature rather than a quantified number of occurrences for instance.\n\n    It can also be used as a pre-processing step for estimators that\n    consider boolean random variables (e.g. modelled using the Bernoulli\n    distribution in a Bayesian setting).\n\n    Read more in the :ref:`User Guide <preprocessing_binarization>`.\n\n    Parameters\n    ----------\n    threshold : float, default=0.0\n        Feature values below or equal to this are replaced by 0, above it by 1.\n        Threshold may not be less than 0 for operations on sparse matrices.\n\n    copy : bool, default=True\n        Set to False to perform inplace binarization and avoid a copy (if\n        the input is already a numpy array or a scipy.sparse CSR matrix).\n\n    Attributes\n    ----------\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    binarize : Equivalent function without the estimator API.\n    KBinsDiscretizer : Bin continuous data into intervals.\n    OneHotEncoder : Encode categorical features as a one-hot numeric array.\n\n    Notes\n    -----\n    If the input is a sparse matrix, only the non-zero values are subject\n    to update by the :class:`Binarizer` class.\n\n    This estimator is :term:`stateless` and does not need to be fitted.\n    However, we recommend to call :meth:`fit_transform` instead of\n    :meth:`transform`, as parameter validation is only performed in\n    :meth:`fit`.",
        "parameters": {
          "threshold": {
            "type": "float, default=0.0",
            "description": ""
          },
          "Feature": {
            "type": "values below or equal to this are replaced by 0, above it by 1.",
            "description": ""
          },
          "Threshold": {
            "type": "may not be less than 0 for operations on sparse matrices.",
            "description": ""
          },
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "Set": {
            "type": "to False to perform inplace binarization and avoid a copy (if",
            "description": ""
          },
          "the": {
            "type": "input is already a numpy array or a scipy.sparse CSR matrix).",
            "description": "Attributes\n----------"
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 0.24"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "binarize": {
            "type": "Equivalent function without the estimator API.",
            "description": ""
          },
          "KBinsDiscretizer": {
            "type": "Bin continuous data into intervals.",
            "description": ""
          },
          "OneHotEncoder": {
            "type": "Encode categorical features as a one",
            "description": "hot numeric array.\nNotes\n-----"
          },
          "If": {
            "type": "the input is a sparse matrix, only the non-zero values are subject",
            "description": ""
          },
          "to": {
            "type": "update by the :class:`Binarizer` class.",
            "description": ""
          },
          "This": {
            "type": "estimator is :term:`stateless` and does not need to be fitted.",
            "description": "However, we recommend to call :meth:`fit_transform` instead of\n:meth:`transform`, as parameter validation is only performed in\n:meth:`fit`.\nExamples\n--------\n>>> from sklearn.preprocessing import Binarizer\n>>> X = [[ 1., -1.,  2.],\n...      [ 2.,  0.,  0.],\n...      [ 0.,  1., -1.]]\n>>> transformer = Binarizer().fit(X)  # fit does nothing.\n>>> transformer"
          },
          "Binarizer": {
            "type": "",
            "description": ">>> transformer.transform(X)\narray([[1., 0., 1.],\n[1., 0., 0.],\n[0., 1., 0.]])"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    binarize : Equivalent function without the estimator API.\n    KBinsDiscretizer : Bin continuous data into intervals.\n    OneHotEncoder : Encode categorical features as a one-hot numeric array.\n\n    Notes\n    -----\n    If the input is a sparse matrix, only the non-zero values are subject\n    to update by the :class:`Binarizer` class.\n\n    This estimator is :term:`stateless` and does not need to be fitted.\n    However, we recommend to call :meth:`fit_transform` instead of\n    :meth:`transform`, as parameter validation is only performed in\n    :meth:`fit`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import Binarizer\n    >>> X = [[ 1., -1.,  2.],\n    ...      [ 2.,  0.,  0.],\n    ...      [ 0.,  1., -1.]]\n    >>> transformer = Binarizer().fit(X)  # fit does nothing.\n    >>> transformer\n    Binarizer()\n    >>> transformer.transform(X)\n    array([[1., 0., 1.],\n           [1., 0., 0.],\n           [0., 1., 0.]])",
        "notes": "-----\n    If the input is a sparse matrix, only the non-zero values are subject\n    to update by the :class:`Binarizer` class.\n\n    This estimator is :term:`stateless` and does not need to be fitted.\n    However, we recommend to call :meth:`fit_transform` instead of\n    :meth:`transform`, as parameter validation is only performed in\n    :meth:`fit`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import Binarizer\n    >>> X = [[ 1., -1.,  2.],\n    ...      [ 2.,  0.,  0.],\n    ...      [ 0.,  1., -1.]]\n    >>> transformer = Binarizer().fit(X)  # fit does nothing.\n    >>> transformer\n    Binarizer()\n    >>> transformer.transform(X)\n    array([[1., 0., 1.],\n           [1., 0., 0.],\n           [0., 1., 0.]])",
        "examples": "--------\n    >>> from sklearn.preprocessing import Binarizer\n    >>> X = [[ 1., -1.,  2.],\n    ...      [ 2.,  0.,  0.],\n    ...      [ 0.,  1., -1.]]\n    >>> transformer = Binarizer().fit(X)  # fit does nothing.\n    >>> transformer\n    Binarizer()\n    >>> transformer.transform(X)\n    array([[1., 0., 1.],\n           [1., 0., 0.],\n           [0., 1., 0.]])"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None)",
          "documentation": {
            "description": "Only validates estimator's parameters.\n\n        This method allows to: (i) validate the estimator's parameters and\n        (ii) be consistent with the scikit-learn transformer API.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data.\n\n        y : None\n            Ignored.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored.\nReturns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "transformer.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted transformer.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input features.\n\n            - If `input_features` is `None`, then `feature_names_in_` is\n              used as feature names in. If `feature_names_in_` is not defined,\n              then the following input feature names are generated:\n              `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            - If `input_features` is an array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "features.",
                "description": "- If `input_features` is `None`, then `feature_names_in_` is"
              },
              "used": {
                "type": "as feature names in. If `feature_names_in_` is not defined,",
                "description": ""
              },
              "then": {
                "type": "the following input feature names are generated:",
                "description": "`[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Same": {
                "type": "as input features.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Same as input features.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_transform_request",
          "signature": "set_transform_request(self: sklearn.preprocessing._data.Binarizer, *, copy: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.preprocessing._data.Binarizer",
          "documentation": {
            "description": "Request metadata passed to the ``transform`` method.",
            "parameters": {
              "copy": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``copy`` parameter in ``transform``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``transform`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``transform``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        copy : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``copy`` parameter in ``transform``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X, copy=None)",
          "documentation": {
            "description": "Binarize each element of X.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data to binarize, element by element.\n            scipy.sparse matrices should be in CSR format to avoid an\n            un-necessary copy.\n\n        copy : bool\n            Copy the input X or not.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data to binarize, element by element.",
                "description": "scipy.sparse matrices should be in CSR format to avoid an\nun-necessary copy."
              },
              "copy": {
                "type": "bool",
                "description": ""
              },
              "Copy": {
                "type": "the input X or not.",
                "description": "Returns\n-------"
              },
              "X_tr": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "FunctionTransformer",
      "documentation": {
        "description": "Constructs a transformer from an arbitrary callable.\n\n    A FunctionTransformer forwards its X (and optionally y) arguments to a\n    user-defined function or function object and returns the result of this\n    function. This is useful for stateless transformations such as taking the\n    log of frequencies, doing custom scaling, etc.\n\n    Note: If a lambda is used as the function, then the resulting\n    transformer will not be pickleable.\n\n    .. versionadded:: 0.17\n\n    Read more in the :ref:`User Guide <function_transformer>`.\n\n    Parameters\n    ----------\n    func : callable, default=None\n        The callable to use for the transformation. This will be passed\n        the same arguments as transform, with args and kwargs forwarded.\n        If func is None, then func will be the identity function.\n\n    inverse_func : callable, default=None\n        The callable to use for the inverse transformation. This will be\n        passed the same arguments as inverse transform, with args and\n        kwargs forwarded. If inverse_func is None, then inverse_func\n        will be the identity function.\n\n    validate : bool, default=False\n        Indicate that the input X array should be checked before calling\n        ``func``. The possibilities are:\n\n        - If False, there is no input validation.\n        - If True, then X will be converted to a 2-dimensional NumPy array or\n          sparse matrix. If the conversion is not possible an exception is\n          raised.\n\n        .. versionchanged:: 0.22\n           The default of ``validate`` changed from True to False.\n\n    accept_sparse : bool, default=False\n        Indicate that func accepts a sparse matrix as input. If validate is\n        False, this has no effect. Otherwise, if accept_sparse is false,\n        sparse matrix inputs will cause an exception to be raised.\n\n    check_inverse : bool, default=True\n       Whether to check that or ``func`` followed by ``inverse_func`` leads to\n       the original inputs. It can be used for a sanity check, raising a\n       warning when the condition is not fulfilled.\n\n       .. versionadded:: 0.20\n\n    feature_names_out : callable, 'one-to-one' or None, default=None\n        Determines the list of feature names that will be returned by the\n        `get_feature_names_out` method. If it is 'one-to-one', then the output\n        feature names will be equal to the input feature names. If it is a\n        callable, then it must take two positional arguments: this\n        `FunctionTransformer` (`self`) and an array-like of input feature names\n        (`input_features`). It must return an array-like of output feature\n        names. The `get_feature_names_out` method is only defined if\n        `feature_names_out` is not None.\n\n        See ``get_feature_names_out`` for more details.\n\n        .. versionadded:: 1.1\n\n    kw_args : dict, default=None\n        Dictionary of additional keyword arguments to pass to func.\n\n        .. versionadded:: 0.18\n\n    inv_kw_args : dict, default=None\n        Dictionary of additional keyword arguments to pass to inverse_func.\n\n        .. versionadded:: 0.18\n\n    Attributes\n    ----------\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X` has feature\n        names that are all strings.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    MaxAbsScaler : Scale each feature by its maximum absolute value.\n    StandardScaler : Standardize features by removing the mean and\n        scaling to unit variance.\n    LabelBinarizer : Binarize labels in a one-vs-all fashion.\n    MultiLabelBinarizer : Transform between iterable of iterables\n        and a multilabel format.\n\n    Notes\n    -----\n    If `func` returns an output with a `columns` attribute, then the columns is enforced\n    to be consistent with the output of `get_feature_names_out`.",
        "parameters": {
          "func": {
            "type": "callable, default=None",
            "description": ""
          },
          "The": {
            "type": "default of ``validate`` changed from True to False.",
            "description": ""
          },
          "the": {
            "type": "original inputs. It can be used for a sanity check, raising a",
            "description": ""
          },
          "If": {
            "type": "`func` returns an output with a `columns` attribute, then the columns is enforced",
            "description": ""
          },
          "inverse_func": {
            "type": "callable, default=None",
            "description": ""
          },
          "passed": {
            "type": "the same arguments as inverse transform, with args and",
            "description": ""
          },
          "kwargs": {
            "type": "forwarded. If inverse_func is None, then inverse_func",
            "description": ""
          },
          "will": {
            "type": "be the identity function.",
            "description": ""
          },
          "validate": {
            "type": "bool, default=False",
            "description": ""
          },
          "Indicate": {
            "type": "that func accepts a sparse matrix as input. If validate is",
            "description": "False, this has no effect. Otherwise, if accept_sparse is false,"
          },
          "sparse": {
            "type": "matrix inputs will cause an exception to be raised.",
            "description": ""
          },
          "accept_sparse": {
            "type": "bool, default=False",
            "description": ""
          },
          "check_inverse": {
            "type": "bool, default=True",
            "description": ""
          },
          "Whether": {
            "type": "to check that or ``func`` followed by ``inverse_func`` leads to",
            "description": ""
          },
          "warning": {
            "type": "when the condition is not fulfilled.",
            "description": ".. versionadded:: 0.20"
          },
          "feature_names_out": {
            "type": "callable, 'one",
            "description": "to-one' or None, default=None"
          },
          "Determines": {
            "type": "the list of feature names that will be returned by the",
            "description": "`get_feature_names_out` method. If it is 'one-to-one', then the output"
          },
          "feature": {
            "type": "names will be equal to the input feature names. If it is a",
            "description": "callable, then it must take two positional arguments: this\n`FunctionTransformer` (`self`) and an array-like of input feature names\n(`input_features`). It must return an array-like of output feature\nnames. The `get_feature_names_out` method is only defined if\n`feature_names_out` is not None."
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "kw_args": {
            "type": "dict, default=None",
            "description": ""
          },
          "Dictionary": {
            "type": "of additional keyword arguments to pass to inverse_func.",
            "description": ".. versionadded:: 0.18\nAttributes\n----------"
          },
          "inv_kw_args": {
            "type": "dict, default=None",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 0.24"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X` has feature",
            "description": ""
          },
          "names": {
            "type": "that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "MaxAbsScaler": {
            "type": "Scale each feature by its maximum absolute value.",
            "description": ""
          },
          "StandardScaler": {
            "type": "Standardize features by removing the mean and",
            "description": ""
          },
          "scaling": {
            "type": "to unit variance.",
            "description": ""
          },
          "LabelBinarizer": {
            "type": "Binarize labels in a one",
            "description": "vs-all fashion."
          },
          "MultiLabelBinarizer": {
            "type": "Transform between iterable of iterables",
            "description": ""
          },
          "and": {
            "type": "a multilabel format.",
            "description": "Notes\n-----"
          },
          "to": {
            "type": "be consistent with the output of `get_feature_names_out`.",
            "description": "Examples\n--------\n>>> import numpy as np\n>>> from sklearn.preprocessing import FunctionTransformer\n>>> transformer = FunctionTransformer(np.log1p)\n>>> X = np.array([[0, 1], [2, 3]])\n>>> transformer.transform(X)\narray([[0.       , 0.6931...],\n[1.0986..., 1.3862...]])"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    MaxAbsScaler : Scale each feature by its maximum absolute value.\n    StandardScaler : Standardize features by removing the mean and\n        scaling to unit variance.\n    LabelBinarizer : Binarize labels in a one-vs-all fashion.\n    MultiLabelBinarizer : Transform between iterable of iterables\n        and a multilabel format.\n\n    Notes\n    -----\n    If `func` returns an output with a `columns` attribute, then the columns is enforced\n    to be consistent with the output of `get_feature_names_out`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import FunctionTransformer\n    >>> transformer = FunctionTransformer(np.log1p)\n    >>> X = np.array([[0, 1], [2, 3]])\n    >>> transformer.transform(X)\n    array([[0.       , 0.6931...],\n           [1.0986..., 1.3862...]])",
        "notes": "If a lambda is used as the function, then the resulting\n    transformer will not be pickleable.\n\n    .. versionadded:: 0.17\n\n    Read more in the :ref:`User Guide <function_transformer>`.\n\n    Parameters\n    ----------\n    func : callable, default=None\n        The callable to use for the transformation. This will be passed\n        the same arguments as transform, with args and kwargs forwarded.\n        If func is None, then func will be the identity function.\n\n    inverse_func : callable, default=None\n        The callable to use for the inverse transformation. This will be\n        passed the same arguments as inverse transform, with args and\n        kwargs forwarded. If inverse_func is None, then inverse_func\n        will be the identity function.\n\n    validate : bool, default=False\n        Indicate that the input X array should be checked before calling\n        ``func``. The possibilities are:\n\n        - If False, there is no input validation.\n        - If True, then X will be converted to a 2-dimensional NumPy array or\n          sparse matrix. If the conversion is not possible an exception is\n          raised.\n\n        .. versionchanged:: 0.22\n           The default of ``validate`` changed from True to False.\n\n    accept_sparse : bool, default=False\n        Indicate that func accepts a sparse matrix as input. If validate is\n        False, this has no effect. Otherwise, if accept_sparse is false,\n        sparse matrix inputs will cause an exception to be raised.\n\n    check_inverse : bool, default=True\n       Whether to check that or ``func`` followed by ``inverse_func`` leads to\n       the original inputs. It can be used for a sanity check, raising a\n       warning when the condition is not fulfilled.\n\n       .. versionadded:: 0.20\n\n    feature_names_out : callable, 'one-to-one' or None, default=None\n        Determines the list of feature names that will be returned by the\n        `get_feature_names_out` method. If it is 'one-to-one', then the output\n        feature names will be equal to the input feature names. If it is a\n        callable, then it must take two positional arguments: this\n        `FunctionTransformer` (`self`) and an array-like of input feature names\n        (`input_features`). It must return an array-like of output feature\n        names. The `get_feature_names_out` method is only defined if\n        `feature_names_out` is not None.\n\n        See ``get_feature_names_out`` for more details.\n\n        .. versionadded:: 1.1\n\n    kw_args : dict, default=None\n        Dictionary of additional keyword arguments to pass to func.\n\n        .. versionadded:: 0.18\n\n    inv_kw_args : dict, default=None\n        Dictionary of additional keyword arguments to pass to inverse_func.\n\n        .. versionadded:: 0.18\n\n    Attributes\n    ----------\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X` has feature\n        names that are all strings.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    MaxAbsScaler : Scale each feature by its maximum absolute value.\n    StandardScaler : Standardize features by removing the mean and\n        scaling to unit variance.\n    LabelBinarizer : Binarize labels in a one-vs-all fashion.\n    MultiLabelBinarizer : Transform between iterable of iterables\n        and a multilabel format.\n\n    Notes\n    -----\n    If `func` returns an output with a `columns` attribute, then the columns is enforced\n    to be consistent with the output of `get_feature_names_out`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import FunctionTransformer\n    >>> transformer = FunctionTransformer(np.log1p)\n    >>> X = np.array([[0, 1], [2, 3]])\n    >>> transformer.transform(X)\n    array([[0.       , 0.6931...],\n           [1.0986..., 1.3862...]])",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import FunctionTransformer\n    >>> transformer = FunctionTransformer(np.log1p)\n    >>> X = np.array([[0, 1], [2, 3]])\n    >>> transformer.transform(X)\n    array([[0.       , 0.6931...],\n           [1.0986..., 1.3862...]])"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None)",
          "documentation": {
            "description": "Fit transformer by checking X.\n\n        If ``validate`` is ``True``, ``X`` will be checked.\n\n        Parameters\n        ----------\n        X : {array-like, sparse-matrix} of shape (n_samples, n_features)                 if `validate=True` else any object that `func` can handle\n            Input array.\n\n        y : Ignored\n            Not used, present here for API consistency by convention.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse-matrix} of shape (n_samples, n_features)                 if `validate=True` else any object that `func` can handle"
              },
              "Input": {
                "type": "array.",
                "description": ""
              },
              "y": {
                "type": "Ignored",
                "description": ""
              },
              "Not": {
                "type": "used, present here for API consistency by convention.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "FunctionTransformer": {
                "type": "class instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            FunctionTransformer class instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        This method is only defined if `feature_names_out` is not None.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input feature names.\n\n            - If `input_features` is None, then `feature_names_in_` is\n              used as the input feature names. If `feature_names_in_` is not\n              defined, then names are generated:\n              `[x0, x1, ..., x(n_features_in_ - 1)]`.\n            - If `input_features` is array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "feature names.",
                "description": "- If `input_features` is None, then `feature_names_in_` is"
              },
              "used": {
                "type": "as the input feature names. If `feature_names_in_` is not",
                "description": "defined, then names are generated:\n`[x0, x1, ..., x(n_features_in_ - 1)]`.\n- If `input_features` is array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Transformed": {
                "type": "feature names.",
                "description": "- If `feature_names_out` is 'one-to-one', the input feature names"
              },
              "are": {
                "type": "returned (see `input_features` above). This requires",
                "description": "`feature_names_in_` and/or `n_features_in_` to be defined, which"
              },
              "is": {
                "type": "done automatically if `validate=True`. Alternatively, you can",
                "description": ""
              },
              "set": {
                "type": "them in `func`.",
                "description": "- If `feature_names_out` is a callable, then it is called with two\narguments, `self` and `input_features`, and its return value is"
              },
              "returned": {
                "type": "by this method.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Transformed feature names.\n\n            - If `feature_names_out` is 'one-to-one', the input feature names\n              are returned (see `input_features` above). This requires\n              `feature_names_in_` and/or `n_features_in_` to be defined, which\n              is done automatically if `validate=True`. Alternatively, you can\n              set them in `func`.\n            - If `feature_names_out` is a callable, then it is called with two\n              arguments, `self` and `input_features`, and its return value is\n              returned by this method.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X)",
          "documentation": {
            "description": "Transform X using the inverse function.\n\n        Parameters\n        ----------\n        X : {array-like, sparse-matrix} of shape (n_samples, n_features)                 if `validate=True` else any object that `inverse_func` can handle\n            Input array.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse-matrix} of shape (n_samples, n_features)                 if `validate=True` else any object that `inverse_func` can handle"
              },
              "Input": {
                "type": "array.",
                "description": "Returns\n-------"
              },
              "X_out": {
                "type": "array",
                "description": "like, shape (n_samples, n_features)"
              },
              "Transformed": {
                "type": "input.",
                "description": ""
              }
            },
            "returns": "-------\n        X_out : array-like, shape (n_samples, n_features)\n            Transformed input.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Transform X using the forward function.\n\n        Parameters\n        ----------\n        X : {array-like, sparse-matrix} of shape (n_samples, n_features)                 if `validate=True` else any object that `func` can handle\n            Input array.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse-matrix} of shape (n_samples, n_features)                 if `validate=True` else any object that `func` can handle"
              },
              "Input": {
                "type": "array.",
                "description": "Returns\n-------"
              },
              "X_out": {
                "type": "array",
                "description": "like, shape (n_samples, n_features)"
              },
              "Transformed": {
                "type": "input.",
                "description": ""
              }
            },
            "returns": "-------\n        X_out : array-like, shape (n_samples, n_features)\n            Transformed input.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "KBinsDiscretizer",
      "documentation": {
        "description": "Bin continuous data into intervals.\n\n    Read more in the :ref:`User Guide <preprocessing_discretization>`.\n\n    .. versionadded:: 0.20\n\n    Parameters\n    ----------\n    n_bins : int or array-like of shape (n_features,), default=5\n        The number of bins to produce. Raises ValueError if ``n_bins < 2``.\n\n    encode : {'onehot', 'onehot-dense', 'ordinal'}, default='onehot'\n        Method used to encode the transformed result.\n\n        - 'onehot': Encode the transformed result with one-hot encoding\n          and return a sparse matrix. Ignored features are always\n          stacked to the right.\n        - 'onehot-dense': Encode the transformed result with one-hot encoding\n          and return a dense array. Ignored features are always\n          stacked to the right.\n        - 'ordinal': Return the bin identifier encoded as an integer value.\n\n    strategy : {'uniform', 'quantile', 'kmeans'}, default='quantile'\n        Strategy used to define the widths of the bins.\n\n        - 'uniform': All bins in each feature have identical widths.\n        - 'quantile': All bins in each feature have the same number of points.\n        - 'kmeans': Values in each bin have the same nearest center of a 1D\n          k-means cluster.\n\n        For an example of the different strategies see:\n        :ref:`sphx_glr_auto_examples_preprocessing_plot_discretization_strategies.py`.\n\n    dtype : {np.float32, np.float64}, default=None\n        The desired data-type for the output. If None, output dtype is\n        consistent with input dtype. Only np.float32 and np.float64 are\n        supported.\n\n        .. versionadded:: 0.24\n\n    subsample : int or None, default=200_000\n        Maximum number of samples, used to fit the model, for computational\n        efficiency.\n        `subsample=None` means that all the training samples are used when\n        computing the quantiles that determine the binning thresholds.\n        Since quantile computation relies on sorting each column of `X` and\n        that sorting has an `n log(n)` time complexity,\n        it is recommended to use subsampling on datasets with a\n        very large number of samples.\n\n        .. versionchanged:: 1.3\n            The default value of `subsample` changed from `None` to `200_000` when\n            `strategy=\"quantile\"`.\n\n        .. versionchanged:: 1.5\n            The default value of `subsample` changed from `None` to `200_000` when\n            `strategy=\"uniform\"` or `strategy=\"kmeans\"`.\n\n    random_state : int, RandomState instance or None, default=None\n        Determines random number generation for subsampling.\n        Pass an int for reproducible results across multiple function calls.\n        See the `subsample` parameter for more details.\n        See :term:`Glossary <random_state>`.\n\n        .. versionadded:: 1.1\n\n    Attributes\n    ----------\n    bin_edges_ : ndarray of ndarray of shape (n_features,)\n        The edges of each bin. Contain arrays of varying shapes ``(n_bins_, )``\n        Ignored features will have empty arrays.\n\n    n_bins_ : ndarray of shape (n_features,), dtype=np.int64\n        Number of bins per feature. Bins whose width are too small\n        (i.e., <= 1e-8) are removed with a warning.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    Binarizer : Class used to bin values as ``0`` or\n        ``1`` based on a parameter ``threshold``.\n\n    Notes\n    -----\n\n    For a visualization of discretization on different datasets refer to\n    :ref:`sphx_glr_auto_examples_preprocessing_plot_discretization_classification.py`.\n    On the effect of discretization on linear models see:\n    :ref:`sphx_glr_auto_examples_preprocessing_plot_discretization.py`.\n\n    In bin edges for feature ``i``, the first and last values are used only for\n    ``inverse_transform``. During transform, bin edges are extended to::\n\n      np.concatenate([-np.inf, bin_edges_[i][1:-1], np.inf])\n\n    You can combine ``KBinsDiscretizer`` with\n    :class:`~sklearn.compose.ColumnTransformer` if you only want to preprocess\n    part of the features.\n\n    ``KBinsDiscretizer`` might produce constant features (e.g., when\n    ``encode = 'onehot'`` and certain bins do not contain any data).\n    These features can be removed with feature selection algorithms\n    (e.g., :class:`~sklearn.feature_selection.VarianceThreshold`).",
        "parameters": {
          "n_bins": {
            "type": "int or array",
            "description": "like of shape (n_features,), default=5"
          },
          "The": {
            "type": "edges of each bin. Contain arrays of varying shapes ``(n_bins_, )``",
            "description": ""
          },
          "encode": {
            "type": "{'onehot', 'onehot",
            "description": "dense', 'ordinal'}, default='onehot'"
          },
          "Method": {
            "type": "used to encode the transformed result.",
            "description": "- 'onehot': Encode the transformed result with one-hot encoding"
          },
          "and": {
            "type": "return a dense array. Ignored features are always",
            "description": ""
          },
          "stacked": {
            "type": "to the right.",
            "description": "- 'ordinal': Return the bin identifier encoded as an integer value."
          },
          "strategy": {
            "type": "{'uniform', 'quantile', 'kmeans'}, default='quantile'",
            "description": ""
          },
          "Strategy": {
            "type": "used to define the widths of the bins.",
            "description": "- 'uniform': All bins in each feature have identical widths.\n- 'quantile': All bins in each feature have the same number of points.\n- 'kmeans': Values in each bin have the same nearest center of a 1D\nk-means cluster."
          },
          "For": {
            "type": "a visualization of discretization on different datasets refer to",
            "description": ":ref:`sphx_glr_auto_examples_preprocessing_plot_discretization_classification.py`."
          },
          "dtype": {
            "type": "{np.float32, np.float64}, default=None",
            "description": ""
          },
          "consistent": {
            "type": "with input dtype. Only np.float32 and np.float64 are",
            "description": "supported.\n.. versionadded:: 0.24"
          },
          "subsample": {
            "type": "int or None, default=200_000",
            "description": ""
          },
          "Maximum": {
            "type": "number of samples, used to fit the model, for computational",
            "description": "efficiency.\n`subsample=None` means that all the training samples are used when"
          },
          "computing": {
            "type": "the quantiles that determine the binning thresholds.",
            "description": ""
          },
          "Since": {
            "type": "quantile computation relies on sorting each column of `X` and",
            "description": ""
          },
          "that": {
            "type": "sorting has an `n log(n)` time complexity,",
            "description": ""
          },
          "it": {
            "type": "is recommended to use subsampling on datasets with a",
            "description": ""
          },
          "very": {
            "type": "large number of samples.",
            "description": ".. versionchanged:: 1.3"
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Determines": {
            "type": "random number generation for subsampling.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible results across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "bin_edges_": {
            "type": "ndarray of ndarray of shape (n_features,)",
            "description": ""
          },
          "Ignored": {
            "type": "features will have empty arrays.",
            "description": ""
          },
          "n_bins_": {
            "type": "ndarray of shape (n_features,), dtype=np.int64",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 0.24"
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "Binarizer": {
            "type": "Class used to bin values as ``0`` or",
            "description": "``1`` based on a parameter ``threshold``.\nNotes\n-----"
          },
          "On": {
            "type": "the effect of discretization on linear models see:",
            "description": ":ref:`sphx_glr_auto_examples_preprocessing_plot_discretization.py`."
          },
          "In": {
            "type": "bin edges for feature ``i``, the first and last values are used only for",
            "description": "``inverse_transform``. During transform, bin edges are extended to::\nnp.concatenate([-np.inf, bin_edges_[i][1:-1], np.inf])"
          },
          "You": {
            "type": "can combine ``KBinsDiscretizer`` with",
            "description": ":class:`~sklearn.compose.ColumnTransformer` if you only want to preprocess"
          },
          "part": {
            "type": "of the features.",
            "description": "``KBinsDiscretizer`` might produce constant features (e.g., when\n``encode = 'onehot'`` and certain bins do not contain any data)."
          },
          "These": {
            "type": "features can be removed with feature selection algorithms",
            "description": "(e.g., :class:`~sklearn.feature_selection.VarianceThreshold`).\nExamples\n--------\n>>> from sklearn.preprocessing import KBinsDiscretizer\n>>> X = [[-2, 1, -4,   -1],\n...      [-1, 2, -3, -0.5],\n...      [ 0, 3, -2,  0.5],\n...      [ 1, 4, -1,    2]]\n>>> est = KBinsDiscretizer(\n...     n_bins=3, encode='ordinal', strategy='uniform'\n... )\n>>> est.fit(X)"
          },
          "KBinsDiscretizer": {
            "type": "...",
            "description": ">>> Xt = est.transform(X)\n>>> Xt  # doctest: +SKIP\narray([[ 0., 0., 0., 0.],\n[ 1., 1., 1., 0.],\n[ 2., 2., 2., 1.],\n[ 2., 2., 2., 2.]])"
          },
          "Sometimes": {
            "type": "it may be useful to convert the data back into the original",
            "description": ""
          },
          "feature": {
            "type": "space. The ``inverse_transform`` function converts the binned",
            "description": ""
          },
          "data": {
            "type": "into the original feature space. Each value will be equal to the mean",
            "description": ""
          },
          "of": {
            "type": "the two bin edges.",
            "description": ">>> est.bin_edges_[0]"
          },
          "array": {
            "type": "[-2., -1.,  0.,  1.]",
            "description": ">>> est.inverse_transform(Xt)\narray([[-1.5,  1.5, -3.5, -0.5],\n[-0.5,  2.5, -2.5, -0.5],\n[ 0.5,  3.5, -1.5,  0.5],\n[ 0.5,  3.5, -1.5,  1.5]])"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    Binarizer : Class used to bin values as ``0`` or\n        ``1`` based on a parameter ``threshold``.\n\n    Notes\n    -----\n\n    For a visualization of discretization on different datasets refer to\n    :ref:`sphx_glr_auto_examples_preprocessing_plot_discretization_classification.py`.\n    On the effect of discretization on linear models see:\n    :ref:`sphx_glr_auto_examples_preprocessing_plot_discretization.py`.\n\n    In bin edges for feature ``i``, the first and last values are used only for\n    ``inverse_transform``. During transform, bin edges are extended to::\n\n      np.concatenate([-np.inf, bin_edges_[i][1:-1], np.inf])\n\n    You can combine ``KBinsDiscretizer`` with\n    :class:`~sklearn.compose.ColumnTransformer` if you only want to preprocess\n    part of the features.\n\n    ``KBinsDiscretizer`` might produce constant features (e.g., when\n    ``encode = 'onehot'`` and certain bins do not contain any data).\n    These features can be removed with feature selection algorithms\n    (e.g., :class:`~sklearn.feature_selection.VarianceThreshold`).\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import KBinsDiscretizer\n    >>> X = [[-2, 1, -4,   -1],\n    ...      [-1, 2, -3, -0.5],\n    ...      [ 0, 3, -2,  0.5],\n    ...      [ 1, 4, -1,    2]]\n    >>> est = KBinsDiscretizer(\n    ...     n_bins=3, encode='ordinal', strategy='uniform'\n    ... )\n    >>> est.fit(X)\n    KBinsDiscretizer(...)\n    >>> Xt = est.transform(X)\n    >>> Xt  # doctest: +SKIP\n    array([[ 0., 0., 0., 0.],\n           [ 1., 1., 1., 0.],\n           [ 2., 2., 2., 1.],\n           [ 2., 2., 2., 2.]])\n\n    Sometimes it may be useful to convert the data back into the original\n    feature space. The ``inverse_transform`` function converts the binned\n    data into the original feature space. Each value will be equal to the mean\n    of the two bin edges.\n\n    >>> est.bin_edges_[0]\n    array([-2., -1.,  0.,  1.])\n    >>> est.inverse_transform(Xt)\n    array([[-1.5,  1.5, -3.5, -0.5],\n           [-0.5,  2.5, -2.5, -0.5],\n           [ 0.5,  3.5, -1.5,  0.5],\n           [ 0.5,  3.5, -1.5,  1.5]])",
        "notes": "-----\n\n    For a visualization of discretization on different datasets refer to\n    :ref:`sphx_glr_auto_examples_preprocessing_plot_discretization_classification.py`.\n    On the effect of discretization on linear models see:\n    :ref:`sphx_glr_auto_examples_preprocessing_plot_discretization.py`.\n\n    In bin edges for feature ``i``, the first and last values are used only for\n    ``inverse_transform``. During transform, bin edges are extended to::\n\n      np.concatenate([-np.inf, bin_edges_[i][1:-1], np.inf])\n\n    You can combine ``KBinsDiscretizer`` with\n    :class:`~sklearn.compose.ColumnTransformer` if you only want to preprocess\n    part of the features.\n\n    ``KBinsDiscretizer`` might produce constant features (e.g., when\n    ``encode = 'onehot'`` and certain bins do not contain any data).\n    These features can be removed with feature selection algorithms\n    (e.g., :class:`~sklearn.feature_selection.VarianceThreshold`).\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import KBinsDiscretizer\n    >>> X = [[-2, 1, -4,   -1],\n    ...      [-1, 2, -3, -0.5],\n    ...      [ 0, 3, -2,  0.5],\n    ...      [ 1, 4, -1,    2]]\n    >>> est = KBinsDiscretizer(\n    ...     n_bins=3, encode='ordinal', strategy='uniform'\n    ... )\n    >>> est.fit(X)\n    KBinsDiscretizer(...)\n    >>> Xt = est.transform(X)\n    >>> Xt  # doctest: +SKIP\n    array([[ 0., 0., 0., 0.],\n           [ 1., 1., 1., 0.],\n           [ 2., 2., 2., 1.],\n           [ 2., 2., 2., 2.]])\n\n    Sometimes it may be useful to convert the data back into the original\n    feature space. The ``inverse_transform`` function converts the binned\n    data into the original feature space. Each value will be equal to the mean\n    of the two bin edges.\n\n    >>> est.bin_edges_[0]\n    array([-2., -1.,  0.,  1.])\n    >>> est.inverse_transform(Xt)\n    array([[-1.5,  1.5, -3.5, -0.5],\n           [-0.5,  2.5, -2.5, -0.5],\n           [ 0.5,  3.5, -1.5,  0.5],\n           [ 0.5,  3.5, -1.5,  1.5]])",
        "examples": "--------\n    >>> from sklearn.preprocessing import KBinsDiscretizer\n    >>> X = [[-2, 1, -4,   -1],\n    ...      [-1, 2, -3, -0.5],\n    ...      [ 0, 3, -2,  0.5],\n    ...      [ 1, 4, -1,    2]]\n    >>> est = KBinsDiscretizer(\n    ...     n_bins=3, encode='ordinal', strategy='uniform'\n    ... )\n    >>> est.fit(X)\n    KBinsDiscretizer(...)\n    >>> Xt = est.transform(X)\n    >>> Xt  # doctest: +SKIP\n    array([[ 0., 0., 0., 0.],\n           [ 1., 1., 1., 0.],\n           [ 2., 2., 2., 1.],\n           [ 2., 2., 2., 2.]])\n\n    Sometimes it may be useful to convert the data back into the original\n    feature space. The ``inverse_transform`` function converts the binned\n    data into the original feature space. Each value will be equal to the mean\n    of the two bin edges.\n\n    >>> est.bin_edges_[0]\n    array([-2., -1.,  0.,  1.])\n    >>> est.inverse_transform(Xt)\n    array([[-1.5,  1.5, -3.5, -0.5],\n           [-0.5,  2.5, -2.5, -0.5],\n           [ 0.5,  3.5, -1.5,  0.5],\n           [ 0.5,  3.5, -1.5,  1.5]])"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None, sample_weight=None)",
          "documentation": {
            "description": "Fit the estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Data to be discretized.\n\n        y : None\n            Ignored. This parameter exists only for compatibility with\n            :class:`~sklearn.pipeline.Pipeline`.\n\n        sample_weight : ndarray of shape (n_samples,)\n            Contains weight values to be associated with each sample.\n            Cannot be used when `strategy` is set to `\"uniform\"`.\n\n            .. versionadded:: 1.3",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Data": {
                "type": "to be discretized.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored. This parameter exists only for compatibility with\n:class:`~sklearn.pipeline.Pipeline`."
              },
              "sample_weight": {
                "type": "ndarray of shape (n_samples,)",
                "description": ""
              },
              "Contains": {
                "type": "weight values to be associated with each sample.",
                "description": ""
              },
              "Cannot": {
                "type": "be used when `strategy` is set to `\"uniform\"`.",
                "description": ".. versionadded:: 1.3\nReturns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Returns": {
                "type": "the instance itself.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input features.\n\n            - If `input_features` is `None`, then `feature_names_in_` is\n              used as feature names in. If `feature_names_in_` is not defined,\n              then the following input feature names are generated:\n              `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            - If `input_features` is an array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "features.",
                "description": "- If `input_features` is `None`, then `feature_names_in_` is"
              },
              "used": {
                "type": "as feature names in. If `feature_names_in_` is not defined,",
                "description": ""
              },
              "then": {
                "type": "the following input feature names are generated:",
                "description": "`[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Transformed": {
                "type": "feature names.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Transformed feature names.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X=None, *, Xt=None)",
          "documentation": {
            "description": "Transform discretized data back to original feature space.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Transformed": {
                "type": "data in the binned space.",
                "description": ".. deprecated:: 1.5\n`Xt` was deprecated in 1.5 and will be removed in 1.7. Use `X` instead.\nReturns\n-------"
              },
              "Xt": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Xinv": {
                "type": "ndarray, dtype={np.float32, np.float64}",
                "description": ""
              },
              "Data": {
                "type": "in the original feature space.",
                "description": ""
              }
            },
            "returns": "-------\n        Xinv : ndarray, dtype={np.float32, np.float64}\n            Data in the original feature space.",
            "raises": "",
            "see_also": "",
            "notes": "that this function does not regenerate the original data\n        due to discretization rounding.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Transformed data in the binned space.\n\n        Xt : array-like of shape (n_samples, n_features)\n            Transformed data in the binned space.\n\n            .. deprecated:: 1.5\n                `Xt` was deprecated in 1.5 and will be removed in 1.7. Use `X` instead.\n\n        Returns\n        -------\n        Xinv : ndarray, dtype={np.float32, np.float64}\n            Data in the original feature space.",
            "examples": ""
          }
        },
        {
          "name": "set_fit_request",
          "signature": "set_fit_request(self: sklearn.preprocessing._discretization.KBinsDiscretizer, *, sample_weight: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.preprocessing._discretization.KBinsDiscretizer",
          "documentation": {
            "description": "Request metadata passed to the ``fit`` method.",
            "parameters": {
              "sample_weight": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``sample_weight`` parameter in ``fit``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``fit`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``fit``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        sample_weight : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``sample_weight`` parameter in ``fit``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Discretize the data.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Data to be discretized.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Data": {
                "type": "in the binned space. Will be a sparse matrix if",
                "description": "`self.encode='onehot'` and ndarray otherwise."
              },
              "Xt": {
                "type": "{ndarray, sparse matrix}, dtype={np.float32, np.float64}",
                "description": ""
              }
            },
            "returns": "-------\n        Xt : {ndarray, sparse matrix}, dtype={np.float32, np.float64}\n            Data in the binned space. Will be a sparse matrix if\n            `self.encode='onehot'` and ndarray otherwise.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "KernelCenterer",
      "documentation": {
        "description": "Center an arbitrary kernel matrix :math:`K`.\n\n    Let define a kernel :math:`K` such that:\n\n    .. math::\n        K(X, Y) = \\phi(X) . \\phi(Y)^{T}\n\n    :math:`\\phi(X)` is a function mapping of rows of :math:`X` to a\n    Hilbert space and :math:`K` is of shape `(n_samples, n_samples)`.\n\n    This class allows to compute :math:`\\tilde{K}(X, Y)` such that:\n\n    .. math::\n        \\tilde{K(X, Y)} = \\tilde{\\phi}(X) . \\tilde{\\phi}(Y)^{T}\n\n    :math:`\\tilde{\\phi}(X)` is the centered mapped data in the Hilbert\n    space.\n\n    `KernelCenterer` centers the features without explicitly computing the\n    mapping :math:`\\phi(\\cdot)`. Working with centered kernels is sometime\n    expected when dealing with algebra computation such as eigendecomposition\n    for :class:`~sklearn.decomposition.KernelPCA` for instance.\n\n    Read more in the :ref:`User Guide <kernel_centering>`.\n\n    Attributes\n    ----------\n    K_fit_rows_ : ndarray of shape (n_samples,)\n        Average of each column of kernel matrix.\n\n    K_fit_all_ : float\n        Average of kernel matrix.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    sklearn.kernel_approximation.Nystroem : Approximate a kernel map\n        using a subset of the training data.\n\n    References\n    ----------\n    .. [1] `Schölkopf, Bernhard, Alexander Smola, and Klaus-Robert Müller.\n       \"Nonlinear component analysis as a kernel eigenvalue problem.\"\n       Neural computation 10.5 (1998): 1299-1319.\n       <https://www.mlpack.org/papers/kpca.pdf>`_",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\n    sklearn.kernel_approximation.Nystroem : Approximate a kernel map\n        using a subset of the training data.\n\n    References\n    ----------\n    .. [1] `Schölkopf, Bernhard, Alexander Smola, and Klaus-Robert Müller.\n       \"Nonlinear component analysis as a kernel eigenvalue problem.\"\n       Neural computation 10.5 (1998): 1299-1319.\n       <https://www.mlpack.org/papers/kpca.pdf>`_\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import KernelCenterer\n    >>> from sklearn.metrics.pairwise import pairwise_kernels\n    >>> X = [[ 1., -2.,  2.],\n    ...      [ -2.,  1.,  3.],\n    ...      [ 4.,  1., -2.]]\n    >>> K = pairwise_kernels(X, metric='linear')\n    >>> K\n    array([[  9.,   2.,  -2.],\n           [  2.,  14., -13.],\n           [ -2., -13.,  21.]])\n    >>> transformer = KernelCenterer().fit(K)\n    >>> transformer\n    KernelCenterer()\n    >>> transformer.transform(K)\n    array([[  5.,   0.,  -5.],\n           [  0.,  14., -14.],\n           [ -5., -14.,  19.]])",
        "notes": "",
        "examples": "--------\n    >>> from sklearn.preprocessing import KernelCenterer\n    >>> from sklearn.metrics.pairwise import pairwise_kernels\n    >>> X = [[ 1., -2.,  2.],\n    ...      [ -2.,  1.,  3.],\n    ...      [ 4.,  1., -2.]]\n    >>> K = pairwise_kernels(X, metric='linear')\n    >>> K\n    array([[  9.,   2.,  -2.],\n           [  2.,  14., -13.],\n           [ -2., -13.,  21.]])\n    >>> transformer = KernelCenterer().fit(K)\n    >>> transformer\n    KernelCenterer()\n    >>> transformer.transform(K)\n    array([[  5.,   0.,  -5.],\n           [  0.,  14., -14.],\n           [ -5., -14.,  19.]])"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, K, y=None)",
          "documentation": {
            "description": "Fit KernelCenterer.\n\n        Parameters\n        ----------\n        K : ndarray of shape (n_samples, n_samples)\n            Kernel matrix.\n\n        y : None\n            Ignored.",
            "parameters": {
              "K": {
                "type": "ndarray of shape (n_samples, n_samples)",
                "description": ""
              },
              "Kernel": {
                "type": "matrix.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored.\nReturns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Returns": {
                "type": "the instance itself.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        The feature names out will prefixed by the lowercased class name. For\n        example, if the transformer outputs 3 features, then the feature names\n        out are: `[\"class_name0\", \"class_name1\", \"class_name2\"]`.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Only used to validate feature names with the names seen in `fit`.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Only": {
                "type": "used to validate feature names with the names seen in `fit`.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Transformed": {
                "type": "feature names.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Transformed feature names.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_transform_request",
          "signature": "set_transform_request(self: sklearn.preprocessing._data.KernelCenterer, *, copy: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.preprocessing._data.KernelCenterer",
          "documentation": {
            "description": "Request metadata passed to the ``transform`` method.",
            "parameters": {
              "copy": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``copy`` parameter in ``transform``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``transform`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``transform``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        copy : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``copy`` parameter in ``transform``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, K, copy=True)",
          "documentation": {
            "description": "Center kernel matrix.\n\n        Parameters\n        ----------\n        K : ndarray of shape (n_samples1, n_samples2)\n            Kernel matrix.\n\n        copy : bool, default=True\n            Set to False to perform inplace computation.",
            "parameters": {
              "K": {
                "type": "ndarray of shape (n_samples1, n_samples2)",
                "description": ""
              },
              "Kernel": {
                "type": "matrix.",
                "description": ""
              },
              "copy": {
                "type": "bool, default=True",
                "description": ""
              },
              "Set": {
                "type": "to False to perform inplace computation.",
                "description": "Returns\n-------"
              },
              "K_new": {
                "type": "ndarray of shape (n_samples1, n_samples2)",
                "description": ""
              },
              "Returns": {
                "type": "the instance itself.",
                "description": ""
              }
            },
            "returns": "-------\n        K_new : ndarray of shape (n_samples1, n_samples2)",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "LabelBinarizer",
      "documentation": {
        "description": "Binarize labels in a one-vs-all fashion.\n\n    Several regression and binary classification algorithms are\n    available in scikit-learn. A simple way to extend these algorithms\n    to the multi-class classification case is to use the so-called\n    one-vs-all scheme.\n\n    At learning time, this simply consists in learning one regressor\n    or binary classifier per class. In doing so, one needs to convert\n    multi-class labels to binary labels (belong or does not belong\n    to the class). `LabelBinarizer` makes this process easy with the\n    transform method.\n\n    At prediction time, one assigns the class for which the corresponding\n    model gave the greatest confidence. `LabelBinarizer` makes this easy\n    with the :meth:`inverse_transform` method.\n\n    Read more in the :ref:`User Guide <preprocessing_targets>`.\n\n    Parameters\n    ----------\n    neg_label : int, default=0\n        Value with which negative labels must be encoded.\n\n    pos_label : int, default=1\n        Value with which positive labels must be encoded.\n\n    sparse_output : bool, default=False\n        True if the returned array from transform is desired to be in sparse\n        CSR format.\n\n    Attributes\n    ----------\n    classes_ : ndarray of shape (n_classes,)\n        Holds the label for each class.\n\n    y_type_ : str\n        Represents the type of the target data as evaluated by\n        :func:`~sklearn.utils.multiclass.type_of_target`. Possible type are\n        'continuous', 'continuous-multioutput', 'binary', 'multiclass',\n        'multiclass-multioutput', 'multilabel-indicator', and 'unknown'.\n\n    sparse_input_ : bool\n        `True` if the input data to transform is given as a sparse matrix,\n         `False` otherwise.\n\n    See Also\n    --------\n    label_binarize : Function to perform the transform operation of\n        LabelBinarizer with fixed classes.\n    OneHotEncoder : Encode categorical features using a one-hot aka one-of-K\n        scheme.",
        "parameters": {
          "neg_label": {
            "type": "int, default=0",
            "description": ""
          },
          "Value": {
            "type": "with which positive labels must be encoded.",
            "description": ""
          },
          "pos_label": {
            "type": "int, default=1",
            "description": ""
          },
          "sparse_output": {
            "type": "bool, default=False",
            "description": ""
          },
          "True": {
            "type": "if the returned array from transform is desired to be in sparse",
            "description": ""
          },
          "CSR": {
            "type": "format.",
            "description": "Attributes\n----------"
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": ""
          },
          "Holds": {
            "type": "the label for each class.",
            "description": ""
          },
          "y_type_": {
            "type": "str",
            "description": ""
          },
          "Represents": {
            "type": "the type of the target data as evaluated by",
            "description": ":func:`~sklearn.utils.multiclass.type_of_target`. Possible type are\n'continuous', 'continuous-multioutput', 'binary', 'multiclass',\n'multiclass-multioutput', 'multilabel-indicator', and 'unknown'."
          },
          "sparse_input_": {
            "type": "bool",
            "description": "`True` if the input data to transform is given as a sparse matrix,\n`False` otherwise."
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "label_binarize": {
            "type": "Function to perform the transform operation of",
            "description": ""
          },
          "LabelBinarizer": {
            "type": "",
            "description": ">>> lb.classes_"
          },
          "OneHotEncoder": {
            "type": "Encode categorical features using a one",
            "description": "hot aka one-of-K\nscheme.\nExamples\n--------\n>>> from sklearn.preprocessing import LabelBinarizer\n>>> lb = LabelBinarizer()\n>>> lb.fit([1, 2, 6, 4, 2])"
          },
          "array": {
            "type": "[0, 1, 2]",
            "description": ">>> lb.transform([0, 1, 2, 1])\narray([[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1],\n[0, 1, 0]])"
          },
          "Binary": {
            "type": "targets transform to a column vector",
            "description": ">>> lb = LabelBinarizer()\n>>> lb.fit_transform(['yes', 'no', 'no', 'yes'])\narray([[1],\n[0],\n[0],\n[1]])"
          },
          "Passing": {
            "type": "a 2D matrix for multilabel classification",
            "description": ">>> import numpy as np\n>>> lb.fit(np.array([[0, 1, 1], [1, 0, 0]]))"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    label_binarize : Function to perform the transform operation of\n        LabelBinarizer with fixed classes.\n    OneHotEncoder : Encode categorical features using a one-hot aka one-of-K\n        scheme.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import LabelBinarizer\n    >>> lb = LabelBinarizer()\n    >>> lb.fit([1, 2, 6, 4, 2])\n    LabelBinarizer()\n    >>> lb.classes_\n    array([1, 2, 4, 6])\n    >>> lb.transform([1, 6])\n    array([[1, 0, 0, 0],\n           [0, 0, 0, 1]])\n\n    Binary targets transform to a column vector\n\n    >>> lb = LabelBinarizer()\n    >>> lb.fit_transform(['yes', 'no', 'no', 'yes'])\n    array([[1],\n           [0],\n           [0],\n           [1]])\n\n    Passing a 2D matrix for multilabel classification\n\n    >>> import numpy as np\n    >>> lb.fit(np.array([[0, 1, 1], [1, 0, 0]]))\n    LabelBinarizer()\n    >>> lb.classes_\n    array([0, 1, 2])\n    >>> lb.transform([0, 1, 2, 1])\n    array([[1, 0, 0],\n           [0, 1, 0],\n           [0, 0, 1],\n           [0, 1, 0]])",
        "notes": "",
        "examples": "--------\n    >>> from sklearn.preprocessing import LabelBinarizer\n    >>> lb = LabelBinarizer()\n    >>> lb.fit([1, 2, 6, 4, 2])\n    LabelBinarizer()\n    >>> lb.classes_\n    array([1, 2, 4, 6])\n    >>> lb.transform([1, 6])\n    array([[1, 0, 0, 0],\n           [0, 0, 0, 1]])\n\n    Binary targets transform to a column vector\n\n    >>> lb = LabelBinarizer()\n    >>> lb.fit_transform(['yes', 'no', 'no', 'yes'])\n    array([[1],\n           [0],\n           [0],\n           [1]])\n\n    Passing a 2D matrix for multilabel classification\n\n    >>> import numpy as np\n    >>> lb.fit(np.array([[0, 1, 1], [1, 0, 0]]))\n    LabelBinarizer()\n    >>> lb.classes_\n    array([0, 1, 2])\n    >>> lb.transform([0, 1, 2, 1])\n    array([[1, 0, 0],\n           [0, 1, 0],\n           [0, 0, 1],\n           [0, 1, 0]])"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, y)",
          "documentation": {
            "description": "Fit label binarizer.\n\n        Parameters\n        ----------\n        y : ndarray of shape (n_samples,) or (n_samples, n_classes)\n            Target values. The 2-d matrix should only contain 0 and 1,\n            represents multilabel classification.",
            "parameters": {
              "y": {
                "type": "ndarray of shape (n_samples,) or (n_samples, n_classes)",
                "description": ""
              },
              "Target": {
                "type": "values. The 2-d matrix should only contain 0 and 1,",
                "description": ""
              },
              "represents": {
                "type": "multilabel classification.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Returns": {
                "type": "the instance itself.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, y)",
          "documentation": {
            "description": "Fit label binarizer/transform multi-class labels to binary labels.\n\n        The output of transform is sometimes referred to as\n        the 1-of-K coding scheme.\n\n        Parameters\n        ----------\n        y : {ndarray, sparse matrix} of shape (n_samples,) or                 (n_samples, n_classes)\n            Target values. The 2-d matrix should only contain 0 and 1,\n            represents multilabel classification. Sparse matrix can be\n            CSR, CSC, COO, DOK, or LIL.",
            "parameters": {
              "y": {
                "type": "{ndarray, sparse matrix} of shape (n_samples,) or                 (n_samples, n_classes)",
                "description": ""
              },
              "Target": {
                "type": "values. The 2-d matrix should only contain 0 and 1,",
                "description": ""
              },
              "represents": {
                "type": "multilabel classification. Sparse matrix can be",
                "description": "CSR, CSC, COO, DOK, or LIL.\nReturns\n-------"
              },
              "Y": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_classes)",
                "description": ""
              },
              "Shape": {
                "type": "will be (n_samples, 1) for binary problems. Sparse matrix",
                "description": ""
              },
              "will": {
                "type": "be of CSR format.",
                "description": ""
              }
            },
            "returns": "-------\n        Y : {ndarray, sparse matrix} of shape (n_samples, n_classes)\n            Shape will be (n_samples, 1) for binary problems. Sparse matrix\n            will be of CSR format.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, Y, threshold=None)",
          "documentation": {
            "description": "Transform binary labels back to multi-class labels.\n\n        Parameters\n        ----------\n        Y : {ndarray, sparse matrix} of shape (n_samples, n_classes)\n            Target values. All sparse matrices are converted to CSR before\n            inverse transformation.\n\n        threshold : float, default=None\n            Threshold used in the binary and multi-label cases.\n\n            Use 0 when ``Y`` contains the output of :term:`decision_function`\n            (classifier).\n            Use 0.5 when ``Y`` contains the output of :term:`predict_proba`.\n\n            If None, the threshold is assumed to be half way between\n            neg_label and pos_label.\n\n        Returns\n        -------\n        y : {ndarray, sparse matrix} of shape (n_samples,)\n            Target values. Sparse matrix will be of CSR format.",
            "parameters": {
              "Y": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_classes)",
                "description": ""
              },
              "Target": {
                "type": "values. Sparse matrix will be of CSR format.",
                "description": "Notes\n-----"
              },
              "inverse": {
                "type": "transformation.",
                "description": ""
              },
              "threshold": {
                "type": "float, default=None",
                "description": ""
              },
              "Threshold": {
                "type": "used in the binary and multi-label cases.",
                "description": ""
              },
              "Use": {
                "type": "0.5 when ``Y`` contains the output of :term:`predict_proba`.",
                "description": ""
              },
              "If": {
                "type": "None, the threshold is assumed to be half way between",
                "description": ""
              },
              "neg_label": {
                "type": "and pos_label.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "{ndarray, sparse matrix} of shape (n_samples,)",
                "description": ""
              },
              "In": {
                "type": "the case when the binary labels are fractional",
                "description": "(probabilistic), :meth:`inverse_transform` chooses the class with the"
              },
              "greatest": {
                "type": "value. Typically, this allows to use the output of a",
                "description": ""
              },
              "linear": {
                "type": "model's :term:`decision_function` method directly as the input",
                "description": ""
              },
              "of": {
                "type": "meth:`inverse_transform`.",
                "description": ""
              }
            },
            "returns": "-------\n        y : {ndarray, sparse matrix} of shape (n_samples,)\n            Target values. Sparse matrix will be of CSR format.\n\n        Notes\n        -----\n        In the case when the binary labels are fractional\n        (probabilistic), :meth:`inverse_transform` chooses the class with the\n        greatest value. Typically, this allows to use the output of a\n        linear model's :term:`decision_function` method directly as the input\n        of :meth:`inverse_transform`.",
            "raises": "",
            "see_also": "",
            "notes": "-----\n        In the case when the binary labels are fractional\n        (probabilistic), :meth:`inverse_transform` chooses the class with the\n        greatest value. Typically, this allows to use the output of a\n        linear model's :term:`decision_function` method directly as the input\n        of :meth:`inverse_transform`.",
            "examples": ""
          }
        },
        {
          "name": "set_inverse_transform_request",
          "signature": "set_inverse_transform_request(self: sklearn.preprocessing._label.LabelBinarizer, *, threshold: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.preprocessing._label.LabelBinarizer",
          "documentation": {
            "description": "Request metadata passed to the ``inverse_transform`` method.",
            "parameters": {
              "threshold": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``threshold`` parameter in ``inverse_transform``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``inverse_transform`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``inverse_transform``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        threshold : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``threshold`` parameter in ``inverse_transform``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, y)",
          "documentation": {
            "description": "Transform multi-class labels to binary labels.\n\n        The output of transform is sometimes referred to by some authors as\n        the 1-of-K coding scheme.\n\n        Parameters\n        ----------\n        y : {array, sparse matrix} of shape (n_samples,) or                 (n_samples, n_classes)\n            Target values. The 2-d matrix should only contain 0 and 1,\n            represents multilabel classification. Sparse matrix can be\n            CSR, CSC, COO, DOK, or LIL.",
            "parameters": {
              "y": {
                "type": "{array, sparse matrix} of shape (n_samples,) or                 (n_samples, n_classes)",
                "description": ""
              },
              "Target": {
                "type": "values. The 2-d matrix should only contain 0 and 1,",
                "description": ""
              },
              "represents": {
                "type": "multilabel classification. Sparse matrix can be",
                "description": "CSR, CSC, COO, DOK, or LIL.\nReturns\n-------"
              },
              "Y": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_classes)",
                "description": ""
              },
              "Shape": {
                "type": "will be (n_samples, 1) for binary problems. Sparse matrix",
                "description": ""
              },
              "will": {
                "type": "be of CSR format.",
                "description": ""
              }
            },
            "returns": "-------\n        Y : {ndarray, sparse matrix} of shape (n_samples, n_classes)\n            Shape will be (n_samples, 1) for binary problems. Sparse matrix\n            will be of CSR format.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "LabelEncoder",
      "documentation": {
        "description": "Encode target labels with value between 0 and n_classes-1.\n\n    This transformer should be used to encode target values, *i.e.* `y`, and\n    not the input `X`.\n\n    Read more in the :ref:`User Guide <preprocessing_targets>`.\n\n    .. versionadded:: 0.12\n\n    Attributes\n    ----------\n    classes_ : ndarray of shape (n_classes,)\n        Holds the label for each class.\n\n    See Also\n    --------\n    OrdinalEncoder : Encode categorical features using an ordinal encoding\n        scheme.\n    OneHotEncoder : Encode categorical features as a one-hot numeric array.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\n    OrdinalEncoder : Encode categorical features using an ordinal encoding\n        scheme.\n    OneHotEncoder : Encode categorical features as a one-hot numeric array.\n\n    Examples\n    --------\n    `LabelEncoder` can be used to normalize labels.\n\n    >>> from sklearn.preprocessing import LabelEncoder\n    >>> le = LabelEncoder()\n    >>> le.fit([1, 2, 2, 6])\n    LabelEncoder()\n    >>> le.classes_\n    array([1, 2, 6])\n    >>> le.transform([1, 1, 2, 6])\n    array([0, 0, 1, 2]...)\n    >>> le.inverse_transform([0, 0, 1, 2])\n    array([1, 1, 2, 6])\n\n    It can also be used to transform non-numerical labels (as long as they are\n    hashable and comparable) to numerical labels.\n\n    >>> le = LabelEncoder()\n    >>> le.fit([\"paris\", \"paris\", \"tokyo\", \"amsterdam\"])\n    LabelEncoder()\n    >>> list(le.classes_)\n    [np.str_('amsterdam'), np.str_('paris'), np.str_('tokyo')]\n    >>> le.transform([\"tokyo\", \"tokyo\", \"paris\"])\n    array([2, 2, 1]...)\n    >>> list(le.inverse_transform([2, 2, 1]))\n    [np.str_('tokyo'), np.str_('tokyo'), np.str_('paris')]",
        "notes": "",
        "examples": "--------\n    `LabelEncoder` can be used to normalize labels.\n\n    >>> from sklearn.preprocessing import LabelEncoder\n    >>> le = LabelEncoder()\n    >>> le.fit([1, 2, 2, 6])\n    LabelEncoder()\n    >>> le.classes_\n    array([1, 2, 6])\n    >>> le.transform([1, 1, 2, 6])\n    array([0, 0, 1, 2]...)\n    >>> le.inverse_transform([0, 0, 1, 2])\n    array([1, 1, 2, 6])\n\n    It can also be used to transform non-numerical labels (as long as they are\n    hashable and comparable) to numerical labels.\n\n    >>> le = LabelEncoder()\n    >>> le.fit([\"paris\", \"paris\", \"tokyo\", \"amsterdam\"])\n    LabelEncoder()\n    >>> list(le.classes_)\n    [np.str_('amsterdam'), np.str_('paris'), np.str_('tokyo')]\n    >>> le.transform([\"tokyo\", \"tokyo\", \"paris\"])\n    array([2, 2, 1]...)\n    >>> list(le.inverse_transform([2, 2, 1]))\n    [np.str_('tokyo'), np.str_('tokyo'), np.str_('paris')]"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, y)",
          "documentation": {
            "description": "Fit label encoder.\n\n        Parameters\n        ----------\n        y : array-like of shape (n_samples,)\n            Target values.",
            "parameters": {
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Target": {
                "type": "values.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "returns an instance of self.",
                "description": ""
              },
              "Fitted": {
                "type": "label encoder.",
                "description": ""
              }
            },
            "returns": "-------\n        self : returns an instance of self.\n            Fitted label encoder.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, y)",
          "documentation": {
            "description": "Fit label encoder and return encoded labels.\n\n        Parameters\n        ----------\n        y : array-like of shape (n_samples,)\n            Target values.",
            "parameters": {
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Target": {
                "type": "values.",
                "description": "Returns\n-------"
              },
              "Encoded": {
                "type": "labels.",
                "description": ""
              }
            },
            "returns": "-------\n        y : array-like of shape (n_samples,)\n            Encoded labels.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, y)",
          "documentation": {
            "description": "Transform labels back to original encoding.\n\n        Parameters\n        ----------\n        y : array-like of shape (n_samples,)\n            Target values.",
            "parameters": {
              "y": {
                "type": "ndarray of shape (n_samples,)",
                "description": ""
              },
              "Target": {
                "type": "values.",
                "description": "Returns\n-------"
              },
              "Original": {
                "type": "encoding.",
                "description": ""
              }
            },
            "returns": "-------\n        y : ndarray of shape (n_samples,)\n            Original encoding.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, y)",
          "documentation": {
            "description": "Transform labels to normalized encoding.\n\n        Parameters\n        ----------\n        y : array-like of shape (n_samples,)\n            Target values.",
            "parameters": {
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Target": {
                "type": "values.",
                "description": "Returns\n-------"
              },
              "Labels": {
                "type": "as normalized encodings.",
                "description": ""
              }
            },
            "returns": "-------\n        y : array-like of shape (n_samples,)\n            Labels as normalized encodings.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "MaxAbsScaler",
      "documentation": {
        "description": "Scale each feature by its maximum absolute value.\n\n    This estimator scales and translates each feature individually such\n    that the maximal absolute value of each feature in the\n    training set will be 1.0. It does not shift/center the data, and\n    thus does not destroy any sparsity.\n\n    This scaler can also be applied to sparse CSR or CSC matrices.\n\n    `MaxAbsScaler` doesn't reduce the effect of outliers; it only linearly\n    scales them down. For an example visualization, refer to :ref:`Compare\n    MaxAbsScaler with other scalers <plot_all_scaling_max_abs_scaler_section>`.\n\n    .. versionadded:: 0.17\n\n    Parameters\n    ----------\n    copy : bool, default=True\n        Set to False to perform inplace scaling and avoid a copy (if the input\n        is already a numpy array).\n\n    Attributes\n    ----------\n    scale_ : ndarray of shape (n_features,)\n        Per feature relative scaling of the data.\n\n        .. versionadded:: 0.17\n           *scale_* attribute.\n\n    max_abs_ : ndarray of shape (n_features,)\n        Per feature maximum absolute value.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    n_samples_seen_ : int\n        The number of samples processed by the estimator. Will be reset on\n        new calls to fit, but increments across ``partial_fit`` calls.\n\n    See Also\n    --------\n    maxabs_scale : Equivalent function without the estimator API.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.",
        "parameters": {
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "Set": {
            "type": "to False to perform inplace scaling and avoid a copy (if the input",
            "description": ""
          },
          "is": {
            "type": "already a numpy array).",
            "description": "Attributes\n----------"
          },
          "scale_": {
            "type": "ndarray of shape (n_features,)",
            "description": ""
          },
          "Per": {
            "type": "feature maximum absolute value.",
            "description": ""
          },
          "max_abs_": {
            "type": "ndarray of shape (n_features,)",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 0.24"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "n_samples_seen_": {
            "type": "int",
            "description": ""
          },
          "The": {
            "type": "number of samples processed by the estimator. Will be reset on",
            "description": ""
          },
          "new": {
            "type": "calls to fit, but increments across ``partial_fit`` calls.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "maxabs_scale": {
            "type": "Equivalent function without the estimator API.",
            "description": "Notes\n-----"
          },
          "NaNs": {
            "type": "are treated as missing values: disregarded in fit, and maintained in",
            "description": "transform.\nExamples\n--------\n>>> from sklearn.preprocessing import MaxAbsScaler\n>>> X = [[ 1., -1.,  2.],\n...      [ 2.,  0.,  0.],\n...      [ 0.,  1., -1.]]\n>>> transformer = MaxAbsScaler().fit(X)\n>>> transformer"
          },
          "MaxAbsScaler": {
            "type": "",
            "description": ">>> transformer.transform(X)\narray([[ 0.5, -1. ,  1. ],\n[ 1. ,  0. ,  0. ],\n[ 0. ,  1. , -0.5]])"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    maxabs_scale : Equivalent function without the estimator API.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import MaxAbsScaler\n    >>> X = [[ 1., -1.,  2.],\n    ...      [ 2.,  0.,  0.],\n    ...      [ 0.,  1., -1.]]\n    >>> transformer = MaxAbsScaler().fit(X)\n    >>> transformer\n    MaxAbsScaler()\n    >>> transformer.transform(X)\n    array([[ 0.5, -1. ,  1. ],\n           [ 1. ,  0. ,  0. ],\n           [ 0. ,  1. , -0.5]])",
        "notes": "-----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import MaxAbsScaler\n    >>> X = [[ 1., -1.,  2.],\n    ...      [ 2.,  0.,  0.],\n    ...      [ 0.,  1., -1.]]\n    >>> transformer = MaxAbsScaler().fit(X)\n    >>> transformer\n    MaxAbsScaler()\n    >>> transformer.transform(X)\n    array([[ 0.5, -1. ,  1. ],\n           [ 1. ,  0. ,  0. ],\n           [ 0. ,  1. , -0.5]])",
        "examples": "--------\n    >>> from sklearn.preprocessing import MaxAbsScaler\n    >>> X = [[ 1., -1.,  2.],\n    ...      [ 2.,  0.,  0.],\n    ...      [ 0.,  1., -1.]]\n    >>> transformer = MaxAbsScaler().fit(X)\n    >>> transformer\n    MaxAbsScaler()\n    >>> transformer.transform(X)\n    array([[ 0.5, -1. ,  1. ],\n           [ 1. ,  0. ,  0. ],\n           [ 0. ,  1. , -0.5]])"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None)",
          "documentation": {
            "description": "Compute the maximum absolute value to be used for later scaling.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data used to compute the per-feature minimum and maximum\n            used for later scaling along the features axis.\n\n        y : None\n            Ignored.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data used to compute the per-feature minimum and maximum",
                "description": ""
              },
              "used": {
                "type": "for later scaling along the features axis.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored.\nReturns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "scaler.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted scaler.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input features.\n\n            - If `input_features` is `None`, then `feature_names_in_` is\n              used as feature names in. If `feature_names_in_` is not defined,\n              then the following input feature names are generated:\n              `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            - If `input_features` is an array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "features.",
                "description": "- If `input_features` is `None`, then `feature_names_in_` is"
              },
              "used": {
                "type": "as feature names in. If `feature_names_in_` is not defined,",
                "description": ""
              },
              "then": {
                "type": "the following input feature names are generated:",
                "description": "`[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Same": {
                "type": "as input features.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Same as input features.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X)",
          "documentation": {
            "description": "Scale back the data to the original representation.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data that should be transformed back.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data that should be transformed back.",
                "description": "Returns\n-------"
              },
              "X_tr": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "partial_fit",
          "signature": "partial_fit(self, X, y=None)",
          "documentation": {
            "description": "Online computation of max absolute value of X for later scaling.\n\n        All of X is processed as a single batch. This is intended for cases\n        when :meth:`fit` is not feasible due to very large number of\n        `n_samples` or because X is read from a continuous stream.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data used to compute the mean and standard deviation\n            used for later scaling along the features axis.\n\n        y : None\n            Ignored.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data used to compute the mean and standard deviation",
                "description": ""
              },
              "used": {
                "type": "for later scaling along the features axis.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored.\nReturns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "scaler.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted scaler.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Scale the data.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data that should be scaled.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data that should be scaled.",
                "description": "Returns\n-------"
              },
              "X_tr": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "MinMaxScaler",
      "documentation": {
        "description": "Transform features by scaling each feature to a given range.\n\n    This estimator scales and translates each feature individually such\n    that it is in the given range on the training set, e.g. between\n    zero and one.\n\n    The transformation is given by::\n\n        X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0))\n        X_scaled = X_std * (max - min) + min\n\n    where min, max = feature_range.\n\n    This transformation is often used as an alternative to zero mean,\n    unit variance scaling.\n\n    `MinMaxScaler` doesn't reduce the effect of outliers, but it linearly\n    scales them down into a fixed range, where the largest occurring data point\n    corresponds to the maximum value and the smallest one corresponds to the\n    minimum value. For an example visualization, refer to :ref:`Compare\n    MinMaxScaler with other scalers <plot_all_scaling_minmax_scaler_section>`.\n\n    Read more in the :ref:`User Guide <preprocessing_scaler>`.\n\n    Parameters\n    ----------\n    feature_range : tuple (min, max), default=(0, 1)\n        Desired range of transformed data.\n\n    copy : bool, default=True\n        Set to False to perform inplace row normalization and avoid a\n        copy (if the input is already a numpy array).\n\n    clip : bool, default=False\n        Set to True to clip transformed values of held-out data to\n        provided `feature range`.\n\n        .. versionadded:: 0.24\n\n    Attributes\n    ----------\n    min_ : ndarray of shape (n_features,)\n        Per feature adjustment for minimum. Equivalent to\n        ``min - X.min(axis=0) * self.scale_``\n\n    scale_ : ndarray of shape (n_features,)\n        Per feature relative scaling of the data. Equivalent to\n        ``(max - min) / (X.max(axis=0) - X.min(axis=0))``\n\n        .. versionadded:: 0.17\n           *scale_* attribute.\n\n    data_min_ : ndarray of shape (n_features,)\n        Per feature minimum seen in the data\n\n        .. versionadded:: 0.17\n           *data_min_*\n\n    data_max_ : ndarray of shape (n_features,)\n        Per feature maximum seen in the data\n\n        .. versionadded:: 0.17\n           *data_max_*\n\n    data_range_ : ndarray of shape (n_features,)\n        Per feature range ``(data_max_ - data_min_)`` seen in the data\n\n        .. versionadded:: 0.17\n           *data_range_*\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    n_samples_seen_ : int\n        The number of samples processed by the estimator.\n        It will be reset on new calls to fit, but increments across\n        ``partial_fit`` calls.\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    minmax_scale : Equivalent function without the estimator API.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.",
        "parameters": {
          "feature_range": {
            "type": "tuple (min, max), default=(0, 1)",
            "description": ""
          },
          "Desired": {
            "type": "range of transformed data.",
            "description": ""
          },
          "copy": {
            "type": "if the input is already a numpy array",
            "description": "."
          },
          "Set": {
            "type": "to True to clip transformed values of held-out data to",
            "description": ""
          },
          "clip": {
            "type": "bool, default=False",
            "description": ""
          },
          "provided": {
            "type": "`feature range`.",
            "description": ".. versionadded:: 0.24\nAttributes\n----------"
          },
          "min_": {
            "type": "ndarray of shape (n_features,)",
            "description": ""
          },
          "Per": {
            "type": "feature range ``(data_max_ - data_min_)`` seen in the data",
            "description": ".. versionadded:: 0.17\n*data_range_*"
          },
          "scale_": {
            "type": "ndarray of shape (n_features,)",
            "description": ""
          },
          "data_min_": {
            "type": "ndarray of shape (n_features,)",
            "description": ""
          },
          "data_max_": {
            "type": "ndarray of shape (n_features,)",
            "description": ""
          },
          "data_range_": {
            "type": "ndarray of shape (n_features,)",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 0.24"
          },
          "n_samples_seen_": {
            "type": "int",
            "description": ""
          },
          "The": {
            "type": "number of samples processed by the estimator.",
            "description": ""
          },
          "It": {
            "type": "will be reset on new calls to fit, but increments across",
            "description": "``partial_fit`` calls."
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "minmax_scale": {
            "type": "Equivalent function without the estimator API.",
            "description": "Notes\n-----"
          },
          "NaNs": {
            "type": "are treated as missing values: disregarded in fit, and maintained in",
            "description": "transform.\nExamples\n--------\n>>> from sklearn.preprocessing import MinMaxScaler\n>>> data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]]\n>>> scaler = MinMaxScaler()\n>>> print(scaler.fit(data))"
          },
          "MinMaxScaler": {
            "type": "",
            "description": ">>> print(scaler.data_max_)\n[ 1. 18.]\n>>> print(scaler.transform(data))\n[[0.   0.  ]\n[0.25 0.25]\n[0.5  0.5 ]\n[1.   1.  ]]\n>>> print(scaler.transform([[2, 2]]))\n[[1.5 0. ]]"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    minmax_scale : Equivalent function without the estimator API.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import MinMaxScaler\n    >>> data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]]\n    >>> scaler = MinMaxScaler()\n    >>> print(scaler.fit(data))\n    MinMaxScaler()\n    >>> print(scaler.data_max_)\n    [ 1. 18.]\n    >>> print(scaler.transform(data))\n    [[0.   0.  ]\n     [0.25 0.25]\n     [0.5  0.5 ]\n     [1.   1.  ]]\n    >>> print(scaler.transform([[2, 2]]))\n    [[1.5 0. ]]",
        "notes": "-----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import MinMaxScaler\n    >>> data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]]\n    >>> scaler = MinMaxScaler()\n    >>> print(scaler.fit(data))\n    MinMaxScaler()\n    >>> print(scaler.data_max_)\n    [ 1. 18.]\n    >>> print(scaler.transform(data))\n    [[0.   0.  ]\n     [0.25 0.25]\n     [0.5  0.5 ]\n     [1.   1.  ]]\n    >>> print(scaler.transform([[2, 2]]))\n    [[1.5 0. ]]",
        "examples": "--------\n    >>> from sklearn.preprocessing import MinMaxScaler\n    >>> data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]]\n    >>> scaler = MinMaxScaler()\n    >>> print(scaler.fit(data))\n    MinMaxScaler()\n    >>> print(scaler.data_max_)\n    [ 1. 18.]\n    >>> print(scaler.transform(data))\n    [[0.   0.  ]\n     [0.25 0.25]\n     [0.5  0.5 ]\n     [1.   1.  ]]\n    >>> print(scaler.transform([[2, 2]]))\n    [[1.5 0. ]]"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None)",
          "documentation": {
            "description": "Compute the minimum and maximum to be used for later scaling.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data used to compute the per-feature minimum and maximum\n            used for later scaling along the features axis.\n\n        y : None\n            Ignored.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data used to compute the per-feature minimum and maximum",
                "description": ""
              },
              "used": {
                "type": "for later scaling along the features axis.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored.\nReturns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "scaler.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted scaler.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input features.\n\n            - If `input_features` is `None`, then `feature_names_in_` is\n              used as feature names in. If `feature_names_in_` is not defined,\n              then the following input feature names are generated:\n              `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            - If `input_features` is an array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "features.",
                "description": "- If `input_features` is `None`, then `feature_names_in_` is"
              },
              "used": {
                "type": "as feature names in. If `feature_names_in_` is not defined,",
                "description": ""
              },
              "then": {
                "type": "the following input feature names are generated:",
                "description": "`[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Same": {
                "type": "as input features.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Same as input features.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X)",
          "documentation": {
            "description": "Undo the scaling of X according to feature_range.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input data that will be transformed. It cannot be sparse.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "data that will be transformed. It cannot be sparse.",
                "description": "Returns\n-------"
              },
              "Xt": {
                "type": "ndarray of shape (n_samples, n_features)",
                "description": ""
              },
              "Transformed": {
                "type": "data.",
                "description": ""
              }
            },
            "returns": "-------\n        Xt : ndarray of shape (n_samples, n_features)\n            Transformed data.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "partial_fit",
          "signature": "partial_fit(self, X, y=None)",
          "documentation": {
            "description": "Online computation of min and max on X for later scaling.\n\n        All of X is processed as a single batch. This is intended for cases\n        when :meth:`fit` is not feasible due to very large number of\n        `n_samples` or because X is read from a continuous stream.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data used to compute the mean and standard deviation\n            used for later scaling along the features axis.\n\n        y : None\n            Ignored.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data used to compute the mean and standard deviation",
                "description": ""
              },
              "used": {
                "type": "for later scaling along the features axis.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored.\nReturns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "scaler.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted scaler.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Scale features of X according to feature_range.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input data that will be transformed.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "data that will be transformed.",
                "description": "Returns\n-------"
              },
              "Xt": {
                "type": "ndarray of shape (n_samples, n_features)",
                "description": ""
              },
              "Transformed": {
                "type": "data.",
                "description": ""
              }
            },
            "returns": "-------\n        Xt : ndarray of shape (n_samples, n_features)\n            Transformed data.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "MultiLabelBinarizer",
      "documentation": {
        "description": "Transform between iterable of iterables and a multilabel format.\n\n    Although a list of sets or tuples is a very intuitive format for multilabel\n    data, it is unwieldy to process. This transformer converts between this\n    intuitive format and the supported multilabel format: a (samples x classes)\n    binary matrix indicating the presence of a class label.\n\n    Parameters\n    ----------\n    classes : array-like of shape (n_classes,), default=None\n        Indicates an ordering for the class labels.\n        All entries should be unique (cannot contain duplicate classes).\n\n    sparse_output : bool, default=False\n        Set to True if output binary array is desired in CSR sparse format.\n\n    Attributes\n    ----------\n    classes_ : ndarray of shape (n_classes,)\n        A copy of the `classes` parameter when provided.\n        Otherwise it corresponds to the sorted set of classes found\n        when fitting.\n\n    See Also\n    --------\n    OneHotEncoder : Encode categorical features using a one-hot aka one-of-K\n        scheme.",
        "parameters": {
          "classes": {
            "type": "array",
            "description": "like of shape (n_classes,), default=None"
          },
          "Indicates": {
            "type": "an ordering for the class labels.",
            "description": ""
          },
          "All": {
            "type": "entries should be unique (cannot contain duplicate classes).",
            "description": ""
          },
          "sparse_output": {
            "type": "bool, default=False",
            "description": ""
          },
          "Set": {
            "type": "to True if output binary array is desired in CSR sparse format.",
            "description": "Attributes\n----------"
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": ""
          },
          "A": {
            "type": "common mistake is to pass in a list, which leads to the following issue:",
            "description": ">>> mlb = MultiLabelBinarizer()\n>>> mlb.fit(['sci-fi', 'thriller', 'comedy'])"
          },
          "Otherwise": {
            "type": "it corresponds to the sorted set of classes found",
            "description": ""
          },
          "when": {
            "type": "fitting.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "OneHotEncoder": {
            "type": "Encode categorical features using a one",
            "description": "hot aka one-of-K\nscheme.\nExamples\n--------\n>>> from sklearn.preprocessing import MultiLabelBinarizer\n>>> mlb = MultiLabelBinarizer()\n>>> mlb.fit_transform([(1, 2), (3,)])\narray([[1, 1, 0],\n[0, 0, 1]])\n>>> mlb.classes_"
          },
          "array": {
            "type": "['comedy', 'sci-fi', 'thriller'], dtype=object",
            "description": ""
          },
          "MultiLabelBinarizer": {
            "type": "",
            "description": ">>> mlb.classes_"
          },
          "To": {
            "type": "correct this, the list of labels should be passed in as:",
            "description": ">>> mlb = MultiLabelBinarizer()\n>>> mlb.fit([['sci-fi', 'thriller', 'comedy']])"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    OneHotEncoder : Encode categorical features using a one-hot aka one-of-K\n        scheme.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import MultiLabelBinarizer\n    >>> mlb = MultiLabelBinarizer()\n    >>> mlb.fit_transform([(1, 2), (3,)])\n    array([[1, 1, 0],\n           [0, 0, 1]])\n    >>> mlb.classes_\n    array([1, 2, 3])\n\n    >>> mlb.fit_transform([{'sci-fi', 'thriller'}, {'comedy'}])\n    array([[0, 1, 1],\n           [1, 0, 0]])\n    >>> list(mlb.classes_)\n    ['comedy', 'sci-fi', 'thriller']\n\n    A common mistake is to pass in a list, which leads to the following issue:\n\n    >>> mlb = MultiLabelBinarizer()\n    >>> mlb.fit(['sci-fi', 'thriller', 'comedy'])\n    MultiLabelBinarizer()\n    >>> mlb.classes_\n    array(['-', 'c', 'd', 'e', 'f', 'h', 'i', 'l', 'm', 'o', 'r', 's', 't',\n        'y'], dtype=object)\n\n    To correct this, the list of labels should be passed in as:\n\n    >>> mlb = MultiLabelBinarizer()\n    >>> mlb.fit([['sci-fi', 'thriller', 'comedy']])\n    MultiLabelBinarizer()\n    >>> mlb.classes_\n    array(['comedy', 'sci-fi', 'thriller'], dtype=object)",
        "notes": "",
        "examples": "--------\n    >>> from sklearn.preprocessing import MultiLabelBinarizer\n    >>> mlb = MultiLabelBinarizer()\n    >>> mlb.fit_transform([(1, 2), (3,)])\n    array([[1, 1, 0],\n           [0, 0, 1]])\n    >>> mlb.classes_\n    array([1, 2, 3])\n\n    >>> mlb.fit_transform([{'sci-fi', 'thriller'}, {'comedy'}])\n    array([[0, 1, 1],\n           [1, 0, 0]])\n    >>> list(mlb.classes_)\n    ['comedy', 'sci-fi', 'thriller']\n\n    A common mistake is to pass in a list, which leads to the following issue:\n\n    >>> mlb = MultiLabelBinarizer()\n    >>> mlb.fit(['sci-fi', 'thriller', 'comedy'])\n    MultiLabelBinarizer()\n    >>> mlb.classes_\n    array(['-', 'c', 'd', 'e', 'f', 'h', 'i', 'l', 'm', 'o', 'r', 's', 't',\n        'y'], dtype=object)\n\n    To correct this, the list of labels should be passed in as:\n\n    >>> mlb = MultiLabelBinarizer()\n    >>> mlb.fit([['sci-fi', 'thriller', 'comedy']])\n    MultiLabelBinarizer()\n    >>> mlb.classes_\n    array(['comedy', 'sci-fi', 'thriller'], dtype=object)"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, y)",
          "documentation": {
            "description": "Fit the label sets binarizer, storing :term:`classes_`.\n\n        Parameters\n        ----------\n        y : iterable of iterables\n            A set of labels (any orderable and hashable object) for each\n            sample. If the `classes` parameter is set, `y` will not be\n            iterated.",
            "parameters": {
              "y": {
                "type": "iterable of iterables",
                "description": ""
              },
              "A": {
                "type": "set of labels (any orderable and hashable object) for each",
                "description": "sample. If the `classes` parameter is set, `y` will not be\niterated.\nReturns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "estimator.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted estimator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, y)",
          "documentation": {
            "description": "Fit the label sets binarizer and transform the given label sets.\n\n        Parameters\n        ----------\n        y : iterable of iterables\n            A set of labels (any orderable and hashable object) for each\n            sample. If the `classes` parameter is set, `y` will not be\n            iterated.",
            "parameters": {
              "y": {
                "type": "iterable of iterables",
                "description": ""
              },
              "A": {
                "type": "matrix such that `y_indicator[i, j] = 1` iff `classes_[j]`",
                "description": ""
              },
              "y_indicator": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_classes)",
                "description": ""
              },
              "is": {
                "type": "in `y[i]`, and 0 otherwise. Sparse matrix will be of CSR",
                "description": "format."
              }
            },
            "returns": "-------\n        y_indicator : {ndarray, sparse matrix} of shape (n_samples, n_classes)\n            A matrix such that `y_indicator[i, j] = 1` iff `classes_[j]`\n            is in `y[i]`, and 0 otherwise. Sparse matrix will be of CSR\n            format.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, yt)",
          "documentation": {
            "description": "Transform the given indicator matrix into label sets.\n\n        Parameters\n        ----------\n        yt : {ndarray, sparse matrix} of shape (n_samples, n_classes)\n            A matrix containing only 1s ands 0s.",
            "parameters": {
              "yt": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_classes)",
                "description": ""
              },
              "A": {
                "type": "matrix containing only 1s ands 0s.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "list of tuples",
                "description": ""
              },
              "The": {
                "type": "set of labels for each sample such that `y[i]` consists of",
                "description": "`classes_[j]` for each `yt[i, j] == 1`."
              }
            },
            "returns": "-------\n        y : list of tuples\n            The set of labels for each sample such that `y[i]` consists of\n            `classes_[j]` for each `yt[i, j] == 1`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, y)",
          "documentation": {
            "description": "Transform the given label sets.\n\n        Parameters\n        ----------\n        y : iterable of iterables\n            A set of labels (any orderable and hashable object) for each\n            sample. If the `classes` parameter is set, `y` will not be\n            iterated.",
            "parameters": {
              "y": {
                "type": "iterable of iterables",
                "description": ""
              },
              "A": {
                "type": "matrix such that `y_indicator[i, j] = 1` iff `classes_[j]` is in",
                "description": "`y[i]`, and 0 otherwise."
              },
              "y_indicator": {
                "type": "array or CSR matrix, shape (n_samples, n_classes)",
                "description": ""
              }
            },
            "returns": "-------\n        y_indicator : array or CSR matrix, shape (n_samples, n_classes)\n            A matrix such that `y_indicator[i, j] = 1` iff `classes_[j]` is in\n            `y[i]`, and 0 otherwise.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "Normalizer",
      "documentation": {
        "description": "Normalize samples individually to unit norm.\n\n    Each sample (i.e. each row of the data matrix) with at least one\n    non zero component is rescaled independently of other samples so\n    that its norm (l1, l2 or inf) equals one.\n\n    This transformer is able to work both with dense numpy arrays and\n    scipy.sparse matrix (use CSR format if you want to avoid the burden of\n    a copy / conversion).\n\n    Scaling inputs to unit norms is a common operation for text\n    classification or clustering for instance. For instance the dot\n    product of two l2-normalized TF-IDF vectors is the cosine similarity\n    of the vectors and is the base similarity metric for the Vector\n    Space Model commonly used by the Information Retrieval community.\n\n    For an example visualization, refer to :ref:`Compare Normalizer with other\n    scalers <plot_all_scaling_normalizer_section>`.\n\n    Read more in the :ref:`User Guide <preprocessing_normalization>`.\n\n    Parameters\n    ----------\n    norm : {'l1', 'l2', 'max'}, default='l2'\n        The norm to use to normalize each non zero sample. If norm='max'\n        is used, values will be rescaled by the maximum of the absolute\n        values.\n\n    copy : bool, default=True\n        Set to False to perform inplace row normalization and avoid a\n        copy (if the input is already a numpy array or a scipy.sparse\n        CSR matrix).\n\n    Attributes\n    ----------\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    normalize : Equivalent function without the estimator API.\n\n    Notes\n    -----\n    This estimator is :term:`stateless` and does not need to be fitted.\n    However, we recommend to call :meth:`fit_transform` instead of\n    :meth:`transform`, as parameter validation is only performed in\n    :meth:`fit`.",
        "parameters": {
          "norm": {
            "type": "{'l1', 'l2', 'max'}, default='l2'",
            "description": ""
          },
          "The": {
            "type": "norm to use to normalize each non zero sample. If norm='max'",
            "description": ""
          },
          "is": {
            "type": "used, values will be rescaled by the maximum of the absolute",
            "description": "values."
          },
          "copy": {
            "type": "(if the input is already a numpy array or a scipy.sparse",
            "description": ""
          },
          "Set": {
            "type": "to False to perform inplace row normalization and avoid a",
            "description": ""
          },
          "CSR": {
            "type": "matrix).",
            "description": "Attributes\n----------"
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 0.24"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "normalize": {
            "type": "Equivalent function without the estimator API.",
            "description": "Notes\n-----"
          },
          "This": {
            "type": "estimator is :term:`stateless` and does not need to be fitted.",
            "description": "However, we recommend to call :meth:`fit_transform` instead of\n:meth:`transform`, as parameter validation is only performed in\n:meth:`fit`.\nExamples\n--------\n>>> from sklearn.preprocessing import Normalizer\n>>> X = [[4, 1, 2, 2],\n...      [1, 3, 9, 3],\n...      [5, 7, 5, 1]]\n>>> transformer = Normalizer().fit(X)  # fit does nothing.\n>>> transformer"
          },
          "Normalizer": {
            "type": "",
            "description": ">>> transformer.transform(X)\narray([[0.8, 0.2, 0.4, 0.4],\n[0.1, 0.3, 0.9, 0.3],\n[0.5, 0.7, 0.5, 0.1]])"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    normalize : Equivalent function without the estimator API.\n\n    Notes\n    -----\n    This estimator is :term:`stateless` and does not need to be fitted.\n    However, we recommend to call :meth:`fit_transform` instead of\n    :meth:`transform`, as parameter validation is only performed in\n    :meth:`fit`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import Normalizer\n    >>> X = [[4, 1, 2, 2],\n    ...      [1, 3, 9, 3],\n    ...      [5, 7, 5, 1]]\n    >>> transformer = Normalizer().fit(X)  # fit does nothing.\n    >>> transformer\n    Normalizer()\n    >>> transformer.transform(X)\n    array([[0.8, 0.2, 0.4, 0.4],\n           [0.1, 0.3, 0.9, 0.3],\n           [0.5, 0.7, 0.5, 0.1]])",
        "notes": "-----\n    This estimator is :term:`stateless` and does not need to be fitted.\n    However, we recommend to call :meth:`fit_transform` instead of\n    :meth:`transform`, as parameter validation is only performed in\n    :meth:`fit`.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import Normalizer\n    >>> X = [[4, 1, 2, 2],\n    ...      [1, 3, 9, 3],\n    ...      [5, 7, 5, 1]]\n    >>> transformer = Normalizer().fit(X)  # fit does nothing.\n    >>> transformer\n    Normalizer()\n    >>> transformer.transform(X)\n    array([[0.8, 0.2, 0.4, 0.4],\n           [0.1, 0.3, 0.9, 0.3],\n           [0.5, 0.7, 0.5, 0.1]])",
        "examples": "--------\n    >>> from sklearn.preprocessing import Normalizer\n    >>> X = [[4, 1, 2, 2],\n    ...      [1, 3, 9, 3],\n    ...      [5, 7, 5, 1]]\n    >>> transformer = Normalizer().fit(X)  # fit does nothing.\n    >>> transformer\n    Normalizer()\n    >>> transformer.transform(X)\n    array([[0.8, 0.2, 0.4, 0.4],\n           [0.1, 0.3, 0.9, 0.3],\n           [0.5, 0.7, 0.5, 0.1]])"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None)",
          "documentation": {
            "description": "Only validates estimator's parameters.\n\n        This method allows to: (i) validate the estimator's parameters and\n        (ii) be consistent with the scikit-learn transformer API.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data to estimate the normalization parameters.\n\n        y : Ignored\n            Not used, present here for API consistency by convention.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data to estimate the normalization parameters.",
                "description": ""
              },
              "y": {
                "type": "Ignored",
                "description": ""
              },
              "Not": {
                "type": "used, present here for API consistency by convention.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "transformer.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted transformer.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input features.\n\n            - If `input_features` is `None`, then `feature_names_in_` is\n              used as feature names in. If `feature_names_in_` is not defined,\n              then the following input feature names are generated:\n              `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            - If `input_features` is an array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "features.",
                "description": "- If `input_features` is `None`, then `feature_names_in_` is"
              },
              "used": {
                "type": "as feature names in. If `feature_names_in_` is not defined,",
                "description": ""
              },
              "then": {
                "type": "the following input feature names are generated:",
                "description": "`[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Same": {
                "type": "as input features.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Same as input features.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_transform_request",
          "signature": "set_transform_request(self: sklearn.preprocessing._data.Normalizer, *, copy: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.preprocessing._data.Normalizer",
          "documentation": {
            "description": "Request metadata passed to the ``transform`` method.",
            "parameters": {
              "copy": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``copy`` parameter in ``transform``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``transform`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``transform``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        copy : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``copy`` parameter in ``transform``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X, copy=None)",
          "documentation": {
            "description": "Scale each non zero row of X to unit norm.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data to normalize, row by row. scipy.sparse matrices should be\n            in CSR format to avoid an un-necessary copy.\n\n        copy : bool, default=None\n            Copy the input X or not.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data to normalize, row by row. scipy.sparse matrices should be",
                "description": ""
              },
              "in": {
                "type": "CSR format to avoid an un-necessary copy.",
                "description": ""
              },
              "copy": {
                "type": "bool, default=None",
                "description": ""
              },
              "Copy": {
                "type": "the input X or not.",
                "description": "Returns\n-------"
              },
              "X_tr": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "OneHotEncoder",
      "documentation": {
        "description": "Encode categorical features as a one-hot numeric array.\n\n    The input to this transformer should be an array-like of integers or\n    strings, denoting the values taken on by categorical (discrete) features.\n    The features are encoded using a one-hot (aka 'one-of-K' or 'dummy')\n    encoding scheme. This creates a binary column for each category and\n    returns a sparse matrix or dense array (depending on the ``sparse_output``\n    parameter).\n\n    By default, the encoder derives the categories based on the unique values\n    in each feature. Alternatively, you can also specify the `categories`\n    manually.\n\n    This encoding is needed for feeding categorical data to many scikit-learn\n    estimators, notably linear models and SVMs with the standard kernels.\n\n    Note: a one-hot encoding of y labels should use a LabelBinarizer\n    instead.\n\n    Read more in the :ref:`User Guide <preprocessing_categorical_features>`.\n    For a comparison of different encoders, refer to:\n    :ref:`sphx_glr_auto_examples_preprocessing_plot_target_encoder.py`.\n\n    Parameters\n    ----------\n    categories : 'auto' or a list of array-like, default='auto'\n        Categories (unique values) per feature:\n\n        - 'auto' : Determine categories automatically from the training data.\n        - list : ``categories[i]`` holds the categories expected in the ith\n          column. The passed categories should not mix strings and numeric\n          values within a single feature, and should be sorted in case of\n          numeric values.\n\n        The used categories can be found in the ``categories_`` attribute.\n\n        .. versionadded:: 0.20\n\n    drop : {'first', 'if_binary'} or an array-like of shape (n_features,),             default=None\n        Specifies a methodology to use to drop one of the categories per\n        feature. This is useful in situations where perfectly collinear\n        features cause problems, such as when feeding the resulting data\n        into an unregularized linear regression model.\n\n        However, dropping one category breaks the symmetry of the original\n        representation and can therefore induce a bias in downstream models,\n        for instance for penalized linear classification or regression models.\n\n        - None : retain all features (the default).\n        - 'first' : drop the first category in each feature. If only one\n          category is present, the feature will be dropped entirely.\n        - 'if_binary' : drop the first category in each feature with two\n          categories. Features with 1 or more than 2 categories are\n          left intact.\n        - array : ``drop[i]`` is the category in feature ``X[:, i]`` that\n          should be dropped.\n\n        When `max_categories` or `min_frequency` is configured to group\n        infrequent categories, the dropping behavior is handled after the\n        grouping.\n\n        .. versionadded:: 0.21\n           The parameter `drop` was added in 0.21.\n\n        .. versionchanged:: 0.23\n           The option `drop='if_binary'` was added in 0.23.\n\n        .. versionchanged:: 1.1\n            Support for dropping infrequent categories.\n\n    sparse_output : bool, default=True\n        When ``True``, it returns a :class:`scipy.sparse.csr_matrix`,\n        i.e. a sparse matrix in \"Compressed Sparse Row\" (CSR) format.\n\n        .. versionadded:: 1.2\n           `sparse` was renamed to `sparse_output`\n\n    dtype : number type, default=np.float64\n        Desired dtype of output.\n\n    handle_unknown : {'error', 'ignore', 'infrequent_if_exist', 'warn'},                      default='error'\n        Specifies the way unknown categories are handled during :meth:`transform`.\n\n        - 'error' : Raise an error if an unknown category is present during transform.\n        - 'ignore' : When an unknown category is encountered during\n          transform, the resulting one-hot encoded columns for this feature\n          will be all zeros. In the inverse transform, an unknown category\n          will be denoted as None.\n        - 'infrequent_if_exist' : When an unknown category is encountered\n          during transform, the resulting one-hot encoded columns for this\n          feature will map to the infrequent category if it exists. The\n          infrequent category will be mapped to the last position in the\n          encoding. During inverse transform, an unknown category will be\n          mapped to the category denoted `'infrequent'` if it exists. If the\n          `'infrequent'` category does not exist, then :meth:`transform` and\n          :meth:`inverse_transform` will handle an unknown category as with\n          `handle_unknown='ignore'`. Infrequent categories exist based on\n          `min_frequency` and `max_categories`. Read more in the\n          :ref:`User Guide <encoder_infrequent_categories>`.\n        - 'warn' : When an unknown category is encountered during transform\n          a warning is issued, and the encoding then proceeds as described for\n          `handle_unknown=\"infrequent_if_exist\"`.\n\n        .. versionchanged:: 1.1\n            `'infrequent_if_exist'` was added to automatically handle unknown\n            categories and infrequent categories.\n\n        .. versionadded:: 1.6\n           The option `\"warn\"` was added in 1.6.\n\n    min_frequency : int or float, default=None\n        Specifies the minimum frequency below which a category will be\n        considered infrequent.\n\n        - If `int`, categories with a smaller cardinality will be considered\n          infrequent.\n\n        - If `float`, categories with a smaller cardinality than\n          `min_frequency * n_samples`  will be considered infrequent.\n\n        .. versionadded:: 1.1\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    max_categories : int, default=None\n        Specifies an upper limit to the number of output features for each input\n        feature when considering infrequent categories. If there are infrequent\n        categories, `max_categories` includes the category representing the\n        infrequent categories along with the frequent categories. If `None`,\n        there is no limit to the number of output features.\n\n        .. versionadded:: 1.1\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    feature_name_combiner : \"concat\" or callable, default=\"concat\"\n        Callable with signature `def callable(input_feature, category)` that returns a\n        string. This is used to create feature names to be returned by\n        :meth:`get_feature_names_out`.\n\n        `\"concat\"` concatenates encoded feature name and category with\n        `feature + \"_\" + str(category)`.E.g. feature X with values 1, 6, 7 create\n        feature names `X_1, X_6, X_7`.\n\n        .. versionadded:: 1.3\n\n    Attributes\n    ----------\n    categories_ : list of arrays\n        The categories of each feature determined during fitting\n        (in order of the features in X and corresponding with the output\n        of ``transform``). This includes the category specified in ``drop``\n        (if any).\n\n    drop_idx_ : array of shape (n_features,)\n        - ``drop_idx_[i]`` is the index in ``categories_[i]`` of the category\n          to be dropped for each feature.\n        - ``drop_idx_[i] = None`` if no category is to be dropped from the\n          feature with index ``i``, e.g. when `drop='if_binary'` and the\n          feature isn't binary.\n        - ``drop_idx_ = None`` if all the transformed features will be\n          retained.\n\n        If infrequent categories are enabled by setting `min_frequency` or\n        `max_categories` to a non-default value and `drop_idx[i]` corresponds\n        to a infrequent category, then the entire infrequent category is\n        dropped.\n\n        .. versionchanged:: 0.23\n           Added the possibility to contain `None` values.\n\n    infrequent_categories_ : list of ndarray\n        Defined only if infrequent categories are enabled by setting\n        `min_frequency` or `max_categories` to a non-default value.\n        `infrequent_categories_[i]` are the infrequent categories for feature\n        `i`. If the feature `i` has no infrequent categories\n        `infrequent_categories_[i]` is None.\n\n        .. versionadded:: 1.1\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 1.0\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    feature_name_combiner : callable or None\n        Callable with signature `def callable(input_feature, category)` that returns a\n        string. This is used to create feature names to be returned by\n        :meth:`get_feature_names_out`.\n\n        .. versionadded:: 1.3\n\n    See Also\n    --------\n    OrdinalEncoder : Performs an ordinal (integer)\n      encoding of the categorical features.\n    TargetEncoder : Encodes categorical features using the target.\n    sklearn.feature_extraction.DictVectorizer : Performs a one-hot encoding of\n      dictionary items (also handles string-valued features).\n    sklearn.feature_extraction.FeatureHasher : Performs an approximate one-hot\n      encoding of dictionary items or strings.\n    LabelBinarizer : Binarizes labels in a one-vs-all\n      fashion.\n    MultiLabelBinarizer : Transforms between iterable of\n      iterables and a multilabel format, e.g. a (samples x classes) binary\n      matrix indicating the presence of a class label.",
        "parameters": {
          "categories": {
            "type": "and infrequent categories.",
            "description": ".. versionadded:: 1.6"
          },
          "Categories": {
            "type": "unique values",
            "description": "per feature:\n- 'auto' : Determine categories automatically from the training data.\n- list : ``categories[i]`` holds the categories expected in the ith\ncolumn. The passed categories should not mix strings and numeric"
          },
          "values": {
            "type": "per feature and transform the data to a binary one-hot encoding.",
            "description": ">>> from sklearn.preprocessing import OneHotEncoder"
          },
          "numeric": {
            "type": "values.",
            "description": ""
          },
          "The": {
            "type": "categories of each feature determined during fitting",
            "description": "(in order of the features in X and corresponding with the output"
          },
          "drop": {
            "type": "{'first', 'if_binary'} or an array",
            "description": "like of shape (n_features,),             default=None"
          },
          "Specifies": {
            "type": "an upper limit to the number of output features for each input",
            "description": ""
          },
          "features": {
            "type": "cause problems, such as when feeding the resulting data",
            "description": ""
          },
          "into": {
            "type": "an unregularized linear regression model.",
            "description": "However, dropping one category breaks the symmetry of the original"
          },
          "representation": {
            "type": "and can therefore induce a bias in downstream models,",
            "description": ""
          },
          "for": {
            "type": "instance for penalized linear classification or regression models.",
            "description": "- None : retain all features (the default).\n- 'first' : drop the first category in each feature. If only one"
          },
          "category": {
            "type": "is present, the feature will be dropped entirely.",
            "description": "- 'if_binary' : drop the first category in each feature with two\ncategories. Features with 1 or more than 2 categories are"
          },
          "left": {
            "type": "intact.",
            "description": "- array : ``drop[i]`` is the category in feature ``X[:, i]`` that"
          },
          "should": {
            "type": "be dropped.",
            "description": ""
          },
          "When": {
            "type": "``True``, it returns a :class:`scipy.sparse.csr_matrix`,",
            "description": "i.e. a sparse matrix in \"Compressed Sparse Row\" (CSR) format.\n.. versionadded:: 1.2\n`sparse` was renamed to `sparse_output`"
          },
          "infrequent": {
            "type": "categories along with the frequent categories. If `None`,",
            "description": ""
          },
          "Support": {
            "type": "for dropping infrequent categories.",
            "description": ""
          },
          "sparse_output": {
            "type": "bool, default=True",
            "description": ""
          },
          "dtype": {
            "type": "number type, default=np.float64",
            "description": ""
          },
          "Desired": {
            "type": "dtype of output.",
            "description": ""
          },
          "handle_unknown": {
            "type": "{'error', 'ignore', 'infrequent_if_exist', 'warn'},                      default='error'",
            "description": ""
          },
          "will": {
            "type": "be denoted as None.",
            "description": "- 'infrequent_if_exist' : When an unknown category is encountered"
          },
          "during": {
            "type": "transform, the resulting one-hot encoded columns for this",
            "description": ""
          },
          "feature": {
            "type": "isn't binary.",
            "description": "- ``drop_idx_ = None`` if all the transformed features will be\nretained."
          },
          "mapped": {
            "type": "to the category denoted `'infrequent'` if it exists. If the",
            "description": "`'infrequent'` category does not exist, then :meth:`transform` and\n:meth:`inverse_transform` will handle an unknown category as with\n`handle_unknown='ignore'`. Infrequent categories exist based on\n`min_frequency` and `max_categories`. Read more in the\n:ref:`User Guide <encoder_infrequent_categories>`.\n- 'warn' : When an unknown category is encountered during transform"
          },
          "a": {
            "type": "warning is issued, and the encoding then proceeds as described for",
            "description": "`handle_unknown=\"infrequent_if_exist\"`.\n.. versionchanged:: 1.1\n`'infrequent_if_exist'` was added to automatically handle unknown"
          },
          "min_frequency": {
            "type": "int or float, default=None",
            "description": ""
          },
          "considered": {
            "type": "infrequent.",
            "description": "- If `int`, categories with a smaller cardinality will be considered\ninfrequent.\n- If `float`, categories with a smaller cardinality than\n`min_frequency * n_samples`  will be considered infrequent.\n.. versionadded:: 1.1"
          },
          "Read": {
            "type": "more in the :ref:`User Guide <encoder_infrequent_categories>`.",
            "description": ""
          },
          "max_categories": {
            "type": "int, default=None",
            "description": ""
          },
          "there": {
            "type": "is no limit to the number of output features.",
            "description": ".. versionadded:: 1.1"
          },
          "feature_name_combiner": {
            "type": "callable or None",
            "description": ""
          },
          "Callable": {
            "type": "with signature `def callable(input_feature, category)` that returns a",
            "description": "string. This is used to create feature names to be returned by\n:meth:`get_feature_names_out`.\n.. versionadded:: 1.3"
          },
          "categories_": {
            "type": "list of arrays",
            "description": ""
          },
          "of": {
            "type": "``transform``). This includes the category specified in ``drop``",
            "description": "(if any)."
          },
          "drop_idx_": {
            "type": "array of shape (n_features,)",
            "description": "- ``drop_idx_[i]`` is the index in ``categories_[i]`` of the category"
          },
          "to": {
            "type": "a infrequent category, then the entire infrequent category is",
            "description": "dropped.\n.. versionchanged:: 0.23"
          },
          "If": {
            "type": "infrequent categories are enabled by setting `min_frequency` or",
            "description": "`max_categories` to a non-default value and `drop_idx[i]` corresponds"
          },
          "Added": {
            "type": "the possibility to contain `None` values.",
            "description": ""
          },
          "infrequent_categories_": {
            "type": "list of ndarray",
            "description": ""
          },
          "Defined": {
            "type": "only if infrequent categories are enabled by setting",
            "description": "`min_frequency` or `max_categories` to a non-default value.\n`infrequent_categories_[i]` are the infrequent categories for feature\n`i`. If the feature `i` has no infrequent categories\n`infrequent_categories_[i]` is None.\n.. versionadded:: 1.1"
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 1.0"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "OrdinalEncoder": {
            "type": "Performs an ordinal (integer)",
            "description": ""
          },
          "encoding": {
            "type": "of dictionary items or strings.",
            "description": ""
          },
          "TargetEncoder": {
            "type": "Encodes categorical features using the target.",
            "description": "sklearn.feature_extraction.DictVectorizer : Performs a one-hot encoding of"
          },
          "dictionary": {
            "type": "items (also handles string-valued features).",
            "description": "sklearn.feature_extraction.FeatureHasher : Performs an approximate one-hot"
          },
          "LabelBinarizer": {
            "type": "Binarizes labels in a one",
            "description": "vs-all\nfashion."
          },
          "MultiLabelBinarizer": {
            "type": "Transforms between iterable of",
            "description": ""
          },
          "iterables": {
            "type": "and a multilabel format, e.g. a (samples x classes) binary",
            "description": ""
          },
          "matrix": {
            "type": "indicating the presence of a class label.",
            "description": "Examples\n--------"
          },
          "Given": {
            "type": "a dataset with two features, we let the encoder find the unique",
            "description": ""
          },
          "One": {
            "type": "can change the way feature names are created.",
            "description": ">>> def custom_combiner(feature, category):\n...     return str(feature) + \"_\" + type(category).__name__ + \"_\" + str(category)\n>>> custom_fnames_enc = OneHotEncoder(feature_name_combiner=custom_combiner).fit(X)\n>>> custom_fnames_enc.get_feature_names_out()\narray(['x0_str_Female', 'x0_str_Male', 'x1_int_1', 'x1_int_2', 'x1_int_3'],\ndtype=object)"
          },
          "OneHotEncoder": {
            "type": "handle_unknown='ignore'",
            "description": ">>> enc.categories_\n[array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n>>> enc.transform([['Female', 1], ['Male', 4]]).toarray()\narray([[1., 0., 1., 0., 0.],\n[0., 1., 0., 0., 0.]])\n>>> enc.inverse_transform([[0, 1, 1, 0, 0], [0, 0, 0, 1, 0]])\narray([['Male', 1],\n[None, 2]], dtype=object)\n>>> enc.get_feature_names_out(['gender', 'group'])"
          },
          "array": {
            "type": "['gender_Female', 'gender_Male', 'group_1', 'group_2', 'group_3'], ...",
            "description": ""
          },
          "Or": {
            "type": "drop a column for feature only having 2 categories:",
            "description": ">>> drop_binary_enc = OneHotEncoder(drop='if_binary').fit(X)\n>>> drop_binary_enc.transform([['Female', 1], ['Male', 2]]).toarray()\narray([[0., 1., 0., 0.],\n[1., 0., 1., 0.]])"
          },
          "Infrequent": {
            "type": "categories are enabled by setting `max_categories` or `min_frequency`.",
            "description": ">>> import numpy as np\n>>> X = np.array([[\"a\"] * 5 + [\"b\"] * 20 + [\"c\"] * 10 + [\"d\"] * 3], dtype=object).T\n>>> ohe = OneHotEncoder(max_categories=3, sparse_output=False).fit(X)\n>>> ohe.infrequent_categories_\n[array(['a', 'd'], dtype=object)]\n>>> ohe.transform([[\"a\"], [\"b\"]])\narray([[0., 0., 1.],\n[1., 0., 0.]])"
          }
        },
        "returns": "a sparse matrix or dense array (depending on the ``sparse_output``\n    parameter).\n\n    By default, the encoder derives the categories based on the unique values\n    in each feature. Alternatively, you can also specify the `categories`\n    manually.\n\n    This encoding is needed for feeding categorical data to many scikit-learn\n    estimators, notably linear models and SVMs with the standard kernels.\n\n    Note: a one-hot encoding of y labels should use a LabelBinarizer\n    instead.\n\n    Read more in the :ref:`User Guide <preprocessing_categorical_features>`.\n    For a comparison of different encoders, refer to:\n    :ref:`sphx_glr_auto_examples_preprocessing_plot_target_encoder.py`.\n\n    Parameters\n    ----------\n    categories : 'auto' or a list of array-like, default='auto'\n        Categories (unique values) per feature:\n\n        - 'auto' : Determine categories automatically from the training data.\n        - list : ``categories[i]`` holds the categories expected in the ith\n          column. The passed categories should not mix strings and numeric\n          values within a single feature, and should be sorted in case of\n          numeric values.\n\n        The used categories can be found in the ``categories_`` attribute.\n\n        .. versionadded:: 0.20\n\n    drop : {'first', 'if_binary'} or an array-like of shape (n_features,),             default=None\n        Specifies a methodology to use to drop one of the categories per\n        feature. This is useful in situations where perfectly collinear\n        features cause problems, such as when feeding the resulting data\n        into an unregularized linear regression model.\n\n        However, dropping one category breaks the symmetry of the original\n        representation and can therefore induce a bias in downstream models,\n        for instance for penalized linear classification or regression models.\n\n        - None : retain all features (the default).\n        - 'first' : drop the first category in each feature. If only one\n          category is present, the feature will be dropped entirely.\n        - 'if_binary' : drop the first category in each feature with two\n          categories. Features with 1 or more than 2 categories are\n          left intact.\n        - array : ``drop[i]`` is the category in feature ``X[:, i]`` that\n          should be dropped.\n\n        When `max_categories` or `min_frequency` is configured to group\n        infrequent categories, the dropping behavior is handled after the\n        grouping.\n\n        .. versionadded:: 0.21\n           The parameter `drop` was added in 0.21.\n\n        .. versionchanged:: 0.23\n           The option `drop='if_binary'` was added in 0.23.\n\n        .. versionchanged:: 1.1\n            Support for dropping infrequent categories.\n\n    sparse_output : bool, default=True\n        When ``True``, it returns a :class:`scipy.sparse.csr_matrix`,\n        i.e. a sparse matrix in \"Compressed Sparse Row\" (CSR) format.\n\n        .. versionadded:: 1.2\n           `sparse` was renamed to `sparse_output`\n\n    dtype : number type, default=np.float64\n        Desired dtype of output.\n\n    handle_unknown : {'error', 'ignore', 'infrequent_if_exist', 'warn'},                      default='error'\n        Specifies the way unknown categories are handled during :meth:`transform`.\n\n        - 'error' : Raise an error if an unknown category is present during transform.\n        - 'ignore' : When an unknown category is encountered during\n          transform, the resulting one-hot encoded columns for this feature\n          will be all zeros. In the inverse transform, an unknown category\n          will be denoted as None.\n        - 'infrequent_if_exist' : When an unknown category is encountered\n          during transform, the resulting one-hot encoded columns for this\n          feature will map to the infrequent category if it exists. The\n          infrequent category will be mapped to the last position in the\n          encoding. During inverse transform, an unknown category will be\n          mapped to the category denoted `'infrequent'` if it exists. If the\n          `'infrequent'` category does not exist, then :meth:`transform` and\n          :meth:`inverse_transform` will handle an unknown category as with\n          `handle_unknown='ignore'`. Infrequent categories exist based on\n          `min_frequency` and `max_categories`. Read more in the\n          :ref:`User Guide <encoder_infrequent_categories>`.\n        - 'warn' : When an unknown category is encountered during transform\n          a warning is issued, and the encoding then proceeds as described for\n          `handle_unknown=\"infrequent_if_exist\"`.\n\n        .. versionchanged:: 1.1\n            `'infrequent_if_exist'` was added to automatically handle unknown\n            categories and infrequent categories.\n\n        .. versionadded:: 1.6\n           The option `\"warn\"` was added in 1.6.\n\n    min_frequency : int or float, default=None\n        Specifies the minimum frequency below which a category will be\n        considered infrequent.\n\n        - If `int`, categories with a smaller cardinality will be considered\n          infrequent.\n\n        - If `float`, categories with a smaller cardinality than\n          `min_frequency * n_samples`  will be considered infrequent.\n\n        .. versionadded:: 1.1\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    max_categories : int, default=None\n        Specifies an upper limit to the number of output features for each input\n        feature when considering infrequent categories. If there are infrequent\n        categories, `max_categories` includes the category representing the\n        infrequent categories along with the frequent categories. If `None`,\n        there is no limit to the number of output features.\n\n        .. versionadded:: 1.1\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    feature_name_combiner : \"concat\" or callable, default=\"concat\"\n        Callable with signature `def callable(input_feature, category)` that returns a\n        string. This is used to create feature names to be returned by\n        :meth:`get_feature_names_out`.\n\n        `\"concat\"` concatenates encoded feature name and category with\n        `feature + \"_\" + str(category)`.E.g. feature X with values 1, 6, 7 create\n        feature names `X_1, X_6, X_7`.\n\n        .. versionadded:: 1.3\n\n    Attributes\n    ----------\n    categories_ : list of arrays\n        The categories of each feature determined during fitting\n        (in order of the features in X and corresponding with the output\n        of ``transform``). This includes the category specified in ``drop``\n        (if any).\n\n    drop_idx_ : array of shape (n_features,)\n        - ``drop_idx_[i]`` is the index in ``categories_[i]`` of the category\n          to be dropped for each feature.\n        - ``drop_idx_[i] = None`` if no category is to be dropped from the\n          feature with index ``i``, e.g. when `drop='if_binary'` and the\n          feature isn't binary.\n        - ``drop_idx_ = None`` if all the transformed features will be\n          retained.\n\n        If infrequent categories are enabled by setting `min_frequency` or\n        `max_categories` to a non-default value and `drop_idx[i]` corresponds\n        to a infrequent category, then the entire infrequent category is\n        dropped.\n\n        .. versionchanged:: 0.23\n           Added the possibility to contain `None` values.\n\n    infrequent_categories_ : list of ndarray\n        Defined only if infrequent categories are enabled by setting\n        `min_frequency` or `max_categories` to a non-default value.\n        `infrequent_categories_[i]` are the infrequent categories for feature\n        `i`. If the feature `i` has no infrequent categories\n        `infrequent_categories_[i]` is None.\n\n        .. versionadded:: 1.1\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 1.0\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    feature_name_combiner : callable or None\n        Callable with signature `def callable(input_feature, category)` that returns a\n        string. This is used to create feature names to be returned by\n        :meth:`get_feature_names_out`.\n\n        .. versionadded:: 1.3\n\n    See Also\n    --------\n    OrdinalEncoder : Performs an ordinal (integer)\n      encoding of the categorical features.\n    TargetEncoder : Encodes categorical features using the target.\n    sklearn.feature_extraction.DictVectorizer : Performs a one-hot encoding of\n      dictionary items (also handles string-valued features).\n    sklearn.feature_extraction.FeatureHasher : Performs an approximate one-hot\n      encoding of dictionary items or strings.\n    LabelBinarizer : Binarizes labels in a one-vs-all\n      fashion.\n    MultiLabelBinarizer : Transforms between iterable of\n      iterables and a multilabel format, e.g. a (samples x classes) binary\n      matrix indicating the presence of a class label.\n\n    Examples\n    --------\n    Given a dataset with two features, we let the encoder find the unique\n    values per feature and transform the data to a binary one-hot encoding.\n\n    >>> from sklearn.preprocessing import OneHotEncoder\n\n    One can discard categories not seen during `fit`:\n\n    >>> enc = OneHotEncoder(handle_unknown='ignore')\n    >>> X = [['Male', 1], ['Female', 3], ['Female', 2]]\n    >>> enc.fit(X)\n    OneHotEncoder(handle_unknown='ignore')\n    >>> enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> enc.transform([['Female', 1], ['Male', 4]]).toarray()\n    array([[1., 0., 1., 0., 0.],\n           [0., 1., 0., 0., 0.]])\n    >>> enc.inverse_transform([[0, 1, 1, 0, 0], [0, 0, 0, 1, 0]])\n    array([['Male', 1],\n           [None, 2]], dtype=object)\n    >>> enc.get_feature_names_out(['gender', 'group'])\n    array(['gender_Female', 'gender_Male', 'group_1', 'group_2', 'group_3'], ...)\n\n    One can always drop the first column for each feature:\n\n    >>> drop_enc = OneHotEncoder(drop='first').fit(X)\n    >>> drop_enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> drop_enc.transform([['Female', 1], ['Male', 2]]).toarray()\n    array([[0., 0., 0.],\n           [1., 1., 0.]])\n\n    Or drop a column for feature only having 2 categories:\n\n    >>> drop_binary_enc = OneHotEncoder(drop='if_binary').fit(X)\n    >>> drop_binary_enc.transform([['Female', 1], ['Male', 2]]).toarray()\n    array([[0., 1., 0., 0.],\n           [1., 0., 1., 0.]])\n\n    One can change the way feature names are created.\n\n    >>> def custom_combiner(feature, category):\n    ...     return str(feature) + \"_\" + type(category).__name__ + \"_\" + str(category)\n    >>> custom_fnames_enc = OneHotEncoder(feature_name_combiner=custom_combiner).fit(X)\n    >>> custom_fnames_enc.get_feature_names_out()\n    array(['x0_str_Female', 'x0_str_Male', 'x1_int_1', 'x1_int_2', 'x1_int_3'],\n          dtype=object)\n\n    Infrequent categories are enabled by setting `max_categories` or `min_frequency`.\n\n    >>> import numpy as np\n    >>> X = np.array([[\"a\"] * 5 + [\"b\"] * 20 + [\"c\"] * 10 + [\"d\"] * 3], dtype=object).T\n    >>> ohe = OneHotEncoder(max_categories=3, sparse_output=False).fit(X)\n    >>> ohe.infrequent_categories_\n    [array(['a', 'd'], dtype=object)]\n    >>> ohe.transform([[\"a\"], [\"b\"]])\n    array([[0., 0., 1.],\n           [1., 0., 0.]])",
        "raises": "",
        "see_also": "--------\n    OrdinalEncoder : Performs an ordinal (integer)\n      encoding of the categorical features.\n    TargetEncoder : Encodes categorical features using the target.\n    sklearn.feature_extraction.DictVectorizer : Performs a one-hot encoding of\n      dictionary items (also handles string-valued features).\n    sklearn.feature_extraction.FeatureHasher : Performs an approximate one-hot\n      encoding of dictionary items or strings.\n    LabelBinarizer : Binarizes labels in a one-vs-all\n      fashion.\n    MultiLabelBinarizer : Transforms between iterable of\n      iterables and a multilabel format, e.g. a (samples x classes) binary\n      matrix indicating the presence of a class label.\n\n    Examples\n    --------\n    Given a dataset with two features, we let the encoder find the unique\n    values per feature and transform the data to a binary one-hot encoding.\n\n    >>> from sklearn.preprocessing import OneHotEncoder\n\n    One can discard categories not seen during `fit`:\n\n    >>> enc = OneHotEncoder(handle_unknown='ignore')\n    >>> X = [['Male', 1], ['Female', 3], ['Female', 2]]\n    >>> enc.fit(X)\n    OneHotEncoder(handle_unknown='ignore')\n    >>> enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> enc.transform([['Female', 1], ['Male', 4]]).toarray()\n    array([[1., 0., 1., 0., 0.],\n           [0., 1., 0., 0., 0.]])\n    >>> enc.inverse_transform([[0, 1, 1, 0, 0], [0, 0, 0, 1, 0]])\n    array([['Male', 1],\n           [None, 2]], dtype=object)\n    >>> enc.get_feature_names_out(['gender', 'group'])\n    array(['gender_Female', 'gender_Male', 'group_1', 'group_2', 'group_3'], ...)\n\n    One can always drop the first column for each feature:\n\n    >>> drop_enc = OneHotEncoder(drop='first').fit(X)\n    >>> drop_enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> drop_enc.transform([['Female', 1], ['Male', 2]]).toarray()\n    array([[0., 0., 0.],\n           [1., 1., 0.]])\n\n    Or drop a column for feature only having 2 categories:\n\n    >>> drop_binary_enc = OneHotEncoder(drop='if_binary').fit(X)\n    >>> drop_binary_enc.transform([['Female', 1], ['Male', 2]]).toarray()\n    array([[0., 1., 0., 0.],\n           [1., 0., 1., 0.]])\n\n    One can change the way feature names are created.\n\n    >>> def custom_combiner(feature, category):\n    ...     return str(feature) + \"_\" + type(category).__name__ + \"_\" + str(category)\n    >>> custom_fnames_enc = OneHotEncoder(feature_name_combiner=custom_combiner).fit(X)\n    >>> custom_fnames_enc.get_feature_names_out()\n    array(['x0_str_Female', 'x0_str_Male', 'x1_int_1', 'x1_int_2', 'x1_int_3'],\n          dtype=object)\n\n    Infrequent categories are enabled by setting `max_categories` or `min_frequency`.\n\n    >>> import numpy as np\n    >>> X = np.array([[\"a\"] * 5 + [\"b\"] * 20 + [\"c\"] * 10 + [\"d\"] * 3], dtype=object).T\n    >>> ohe = OneHotEncoder(max_categories=3, sparse_output=False).fit(X)\n    >>> ohe.infrequent_categories_\n    [array(['a', 'd'], dtype=object)]\n    >>> ohe.transform([[\"a\"], [\"b\"]])\n    array([[0., 0., 1.],\n           [1., 0., 0.]])",
        "notes": "a one-hot encoding of y labels should use a LabelBinarizer\n    instead.\n\n    Read more in the :ref:`User Guide <preprocessing_categorical_features>`.\n    For a comparison of different encoders, refer to:\n    :ref:`sphx_glr_auto_examples_preprocessing_plot_target_encoder.py`.\n\n    Parameters\n    ----------\n    categories : 'auto' or a list of array-like, default='auto'\n        Categories (unique values) per feature:\n\n        - 'auto' : Determine categories automatically from the training data.\n        - list : ``categories[i]`` holds the categories expected in the ith\n          column. The passed categories should not mix strings and numeric\n          values within a single feature, and should be sorted in case of\n          numeric values.\n\n        The used categories can be found in the ``categories_`` attribute.\n\n        .. versionadded:: 0.20\n\n    drop : {'first', 'if_binary'} or an array-like of shape (n_features,),             default=None\n        Specifies a methodology to use to drop one of the categories per\n        feature. This is useful in situations where perfectly collinear\n        features cause problems, such as when feeding the resulting data\n        into an unregularized linear regression model.\n\n        However, dropping one category breaks the symmetry of the original\n        representation and can therefore induce a bias in downstream models,\n        for instance for penalized linear classification or regression models.\n\n        - None : retain all features (the default).\n        - 'first' : drop the first category in each feature. If only one\n          category is present, the feature will be dropped entirely.\n        - 'if_binary' : drop the first category in each feature with two\n          categories. Features with 1 or more than 2 categories are\n          left intact.\n        - array : ``drop[i]`` is the category in feature ``X[:, i]`` that\n          should be dropped.\n\n        When `max_categories` or `min_frequency` is configured to group\n        infrequent categories, the dropping behavior is handled after the\n        grouping.\n\n        .. versionadded:: 0.21\n           The parameter `drop` was added in 0.21.\n\n        .. versionchanged:: 0.23\n           The option `drop='if_binary'` was added in 0.23.\n\n        .. versionchanged:: 1.1\n            Support for dropping infrequent categories.\n\n    sparse_output : bool, default=True\n        When ``True``, it returns a :class:`scipy.sparse.csr_matrix`,\n        i.e. a sparse matrix in \"Compressed Sparse Row\" (CSR) format.\n\n        .. versionadded:: 1.2\n           `sparse` was renamed to `sparse_output`\n\n    dtype : number type, default=np.float64\n        Desired dtype of output.\n\n    handle_unknown : {'error', 'ignore', 'infrequent_if_exist', 'warn'},                      default='error'\n        Specifies the way unknown categories are handled during :meth:`transform`.\n\n        - 'error' : Raise an error if an unknown category is present during transform.\n        - 'ignore' : When an unknown category is encountered during\n          transform, the resulting one-hot encoded columns for this feature\n          will be all zeros. In the inverse transform, an unknown category\n          will be denoted as None.\n        - 'infrequent_if_exist' : When an unknown category is encountered\n          during transform, the resulting one-hot encoded columns for this\n          feature will map to the infrequent category if it exists. The\n          infrequent category will be mapped to the last position in the\n          encoding. During inverse transform, an unknown category will be\n          mapped to the category denoted `'infrequent'` if it exists. If the\n          `'infrequent'` category does not exist, then :meth:`transform` and\n          :meth:`inverse_transform` will handle an unknown category as with\n          `handle_unknown='ignore'`. Infrequent categories exist based on\n          `min_frequency` and `max_categories`. Read more in the\n          :ref:`User Guide <encoder_infrequent_categories>`.\n        - 'warn' : When an unknown category is encountered during transform\n          a warning is issued, and the encoding then proceeds as described for\n          `handle_unknown=\"infrequent_if_exist\"`.\n\n        .. versionchanged:: 1.1\n            `'infrequent_if_exist'` was added to automatically handle unknown\n            categories and infrequent categories.\n\n        .. versionadded:: 1.6\n           The option `\"warn\"` was added in 1.6.\n\n    min_frequency : int or float, default=None\n        Specifies the minimum frequency below which a category will be\n        considered infrequent.\n\n        - If `int`, categories with a smaller cardinality will be considered\n          infrequent.\n\n        - If `float`, categories with a smaller cardinality than\n          `min_frequency * n_samples`  will be considered infrequent.\n\n        .. versionadded:: 1.1\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    max_categories : int, default=None\n        Specifies an upper limit to the number of output features for each input\n        feature when considering infrequent categories. If there are infrequent\n        categories, `max_categories` includes the category representing the\n        infrequent categories along with the frequent categories. If `None`,\n        there is no limit to the number of output features.\n\n        .. versionadded:: 1.1\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    feature_name_combiner : \"concat\" or callable, default=\"concat\"\n        Callable with signature `def callable(input_feature, category)` that returns a\n        string. This is used to create feature names to be returned by\n        :meth:`get_feature_names_out`.\n\n        `\"concat\"` concatenates encoded feature name and category with\n        `feature + \"_\" + str(category)`.E.g. feature X with values 1, 6, 7 create\n        feature names `X_1, X_6, X_7`.\n\n        .. versionadded:: 1.3\n\n    Attributes\n    ----------\n    categories_ : list of arrays\n        The categories of each feature determined during fitting\n        (in order of the features in X and corresponding with the output\n        of ``transform``). This includes the category specified in ``drop``\n        (if any).\n\n    drop_idx_ : array of shape (n_features,)\n        - ``drop_idx_[i]`` is the index in ``categories_[i]`` of the category\n          to be dropped for each feature.\n        - ``drop_idx_[i] = None`` if no category is to be dropped from the\n          feature with index ``i``, e.g. when `drop='if_binary'` and the\n          feature isn't binary.\n        - ``drop_idx_ = None`` if all the transformed features will be\n          retained.\n\n        If infrequent categories are enabled by setting `min_frequency` or\n        `max_categories` to a non-default value and `drop_idx[i]` corresponds\n        to a infrequent category, then the entire infrequent category is\n        dropped.\n\n        .. versionchanged:: 0.23\n           Added the possibility to contain `None` values.\n\n    infrequent_categories_ : list of ndarray\n        Defined only if infrequent categories are enabled by setting\n        `min_frequency` or `max_categories` to a non-default value.\n        `infrequent_categories_[i]` are the infrequent categories for feature\n        `i`. If the feature `i` has no infrequent categories\n        `infrequent_categories_[i]` is None.\n\n        .. versionadded:: 1.1\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 1.0\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    feature_name_combiner : callable or None\n        Callable with signature `def callable(input_feature, category)` that returns a\n        string. This is used to create feature names to be returned by\n        :meth:`get_feature_names_out`.\n\n        .. versionadded:: 1.3\n\n    See Also\n    --------\n    OrdinalEncoder : Performs an ordinal (integer)\n      encoding of the categorical features.\n    TargetEncoder : Encodes categorical features using the target.\n    sklearn.feature_extraction.DictVectorizer : Performs a one-hot encoding of\n      dictionary items (also handles string-valued features).\n    sklearn.feature_extraction.FeatureHasher : Performs an approximate one-hot\n      encoding of dictionary items or strings.\n    LabelBinarizer : Binarizes labels in a one-vs-all\n      fashion.\n    MultiLabelBinarizer : Transforms between iterable of\n      iterables and a multilabel format, e.g. a (samples x classes) binary\n      matrix indicating the presence of a class label.\n\n    Examples\n    --------\n    Given a dataset with two features, we let the encoder find the unique\n    values per feature and transform the data to a binary one-hot encoding.\n\n    >>> from sklearn.preprocessing import OneHotEncoder\n\n    One can discard categories not seen during `fit`:\n\n    >>> enc = OneHotEncoder(handle_unknown='ignore')\n    >>> X = [['Male', 1], ['Female', 3], ['Female', 2]]\n    >>> enc.fit(X)\n    OneHotEncoder(handle_unknown='ignore')\n    >>> enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> enc.transform([['Female', 1], ['Male', 4]]).toarray()\n    array([[1., 0., 1., 0., 0.],\n           [0., 1., 0., 0., 0.]])\n    >>> enc.inverse_transform([[0, 1, 1, 0, 0], [0, 0, 0, 1, 0]])\n    array([['Male', 1],\n           [None, 2]], dtype=object)\n    >>> enc.get_feature_names_out(['gender', 'group'])\n    array(['gender_Female', 'gender_Male', 'group_1', 'group_2', 'group_3'], ...)\n\n    One can always drop the first column for each feature:\n\n    >>> drop_enc = OneHotEncoder(drop='first').fit(X)\n    >>> drop_enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> drop_enc.transform([['Female', 1], ['Male', 2]]).toarray()\n    array([[0., 0., 0.],\n           [1., 1., 0.]])\n\n    Or drop a column for feature only having 2 categories:\n\n    >>> drop_binary_enc = OneHotEncoder(drop='if_binary').fit(X)\n    >>> drop_binary_enc.transform([['Female', 1], ['Male', 2]]).toarray()\n    array([[0., 1., 0., 0.],\n           [1., 0., 1., 0.]])\n\n    One can change the way feature names are created.\n\n    >>> def custom_combiner(feature, category):\n    ...     return str(feature) + \"_\" + type(category).__name__ + \"_\" + str(category)\n    >>> custom_fnames_enc = OneHotEncoder(feature_name_combiner=custom_combiner).fit(X)\n    >>> custom_fnames_enc.get_feature_names_out()\n    array(['x0_str_Female', 'x0_str_Male', 'x1_int_1', 'x1_int_2', 'x1_int_3'],\n          dtype=object)\n\n    Infrequent categories are enabled by setting `max_categories` or `min_frequency`.\n\n    >>> import numpy as np\n    >>> X = np.array([[\"a\"] * 5 + [\"b\"] * 20 + [\"c\"] * 10 + [\"d\"] * 3], dtype=object).T\n    >>> ohe = OneHotEncoder(max_categories=3, sparse_output=False).fit(X)\n    >>> ohe.infrequent_categories_\n    [array(['a', 'd'], dtype=object)]\n    >>> ohe.transform([[\"a\"], [\"b\"]])\n    array([[0., 0., 1.],\n           [1., 0., 0.]])",
        "examples": "--------\n    Given a dataset with two features, we let the encoder find the unique\n    values per feature and transform the data to a binary one-hot encoding.\n\n    >>> from sklearn.preprocessing import OneHotEncoder\n\n    One can discard categories not seen during `fit`:\n\n    >>> enc = OneHotEncoder(handle_unknown='ignore')\n    >>> X = [['Male', 1], ['Female', 3], ['Female', 2]]\n    >>> enc.fit(X)\n    OneHotEncoder(handle_unknown='ignore')\n    >>> enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> enc.transform([['Female', 1], ['Male', 4]]).toarray()\n    array([[1., 0., 1., 0., 0.],\n           [0., 1., 0., 0., 0.]])\n    >>> enc.inverse_transform([[0, 1, 1, 0, 0], [0, 0, 0, 1, 0]])\n    array([['Male', 1],\n           [None, 2]], dtype=object)\n    >>> enc.get_feature_names_out(['gender', 'group'])\n    array(['gender_Female', 'gender_Male', 'group_1', 'group_2', 'group_3'], ...)\n\n    One can always drop the first column for each feature:\n\n    >>> drop_enc = OneHotEncoder(drop='first').fit(X)\n    >>> drop_enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> drop_enc.transform([['Female', 1], ['Male', 2]]).toarray()\n    array([[0., 0., 0.],\n           [1., 1., 0.]])\n\n    Or drop a column for feature only having 2 categories:\n\n    >>> drop_binary_enc = OneHotEncoder(drop='if_binary').fit(X)\n    >>> drop_binary_enc.transform([['Female', 1], ['Male', 2]]).toarray()\n    array([[0., 1., 0., 0.],\n           [1., 0., 1., 0.]])\n\n    One can change the way feature names are created.\n\n    >>> def custom_combiner(feature, category):\n    ...     return str(feature) + \"_\" + type(category).__name__ + \"_\" + str(category)\n    >>> custom_fnames_enc = OneHotEncoder(feature_name_combiner=custom_combiner).fit(X)\n    >>> custom_fnames_enc.get_feature_names_out()\n    array(['x0_str_Female', 'x0_str_Male', 'x1_int_1', 'x1_int_2', 'x1_int_3'],\n          dtype=object)\n\n    Infrequent categories are enabled by setting `max_categories` or `min_frequency`.\n\n    >>> import numpy as np\n    >>> X = np.array([[\"a\"] * 5 + [\"b\"] * 20 + [\"c\"] * 10 + [\"d\"] * 3], dtype=object).T\n    >>> ohe = OneHotEncoder(max_categories=3, sparse_output=False).fit(X)\n    >>> ohe.infrequent_categories_\n    [array(['a', 'd'], dtype=object)]\n    >>> ohe.transform([[\"a\"], [\"b\"]])\n    array([[0., 0., 1.],\n           [1., 0., 0.]])"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None)",
          "documentation": {
            "description": "Fit OneHotEncoder to X.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data to determine the categories of each feature.\n\n        y : None\n            Ignored. This parameter exists only for compatibility with\n            :class:`~sklearn.pipeline.Pipeline`.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data to determine the categories of each feature.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored. This parameter exists only for compatibility with\n:class:`~sklearn.pipeline.Pipeline`.\nReturns\n-------\nself"
              },
              "Fitted": {
                "type": "encoder.",
                "description": ""
              }
            },
            "returns": "-------\n        self\n            Fitted encoder.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input features.\n\n            - If `input_features` is `None`, then `feature_names_in_` is\n              used as feature names in. If `feature_names_in_` is not defined,\n              then the following input feature names are generated:\n              `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            - If `input_features` is an array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "features.",
                "description": "- If `input_features` is `None`, then `feature_names_in_` is"
              },
              "used": {
                "type": "as feature names in. If `feature_names_in_` is not defined,",
                "description": ""
              },
              "then": {
                "type": "the following input feature names are generated:",
                "description": "`[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Transformed": {
                "type": "feature names.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Transformed feature names.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X)",
          "documentation": {
            "description": "Convert the data back to the original representation.\n\n        When unknown categories are encountered (all zeros in the\n        one-hot encoding), ``None`` is used to represent this category. If the\n        feature with the unknown category has a dropped category, the dropped\n        category will be its inverse.\n\n        For a given input feature, if there is an infrequent category,\n        'infrequent_sklearn' will be used to represent the infrequent category.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape                 (n_samples, n_encoded_features)\n            The transformed data.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape                 (n_samples, n_encoded_features)"
              },
              "The": {
                "type": "transformed data.",
                "description": "Returns\n-------"
              },
              "X_tr": {
                "type": "ndarray of shape (n_samples, n_features)",
                "description": ""
              },
              "Inverse": {
                "type": "transformed array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_tr : ndarray of shape (n_samples, n_features)\n            Inverse transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Transform X using one-hot encoding.\n\n        If `sparse_output=True` (default), it returns an instance of\n        :class:`scipy.sparse._csr.csr_matrix` (CSR format).\n\n        If there are infrequent categories for a feature, set by specifying\n        `max_categories` or `min_frequency`, the infrequent categories are\n        grouped into a single category.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data to encode.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data to encode.",
                "description": "Returns\n-------"
              },
              "X_out": {
                "type": "{ndarray, sparse matrix} of shape                 (n_samples, n_encoded_features)",
                "description": ""
              },
              "Transformed": {
                "type": "input. If `sparse_output=True`, a sparse matrix will be",
                "description": "returned."
              }
            },
            "returns": "-------\n        X_out : {ndarray, sparse matrix} of shape                 (n_samples, n_encoded_features)\n            Transformed input. If `sparse_output=True`, a sparse matrix will be\n            returned.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "OrdinalEncoder",
      "documentation": {
        "description": "Encode categorical features as an integer array.\n\n    The input to this transformer should be an array-like of integers or\n    strings, denoting the values taken on by categorical (discrete) features.\n    The features are converted to ordinal integers. This results in\n    a single column of integers (0 to n_categories - 1) per feature.\n\n    Read more in the :ref:`User Guide <preprocessing_categorical_features>`.\n    For a comparison of different encoders, refer to:\n    :ref:`sphx_glr_auto_examples_preprocessing_plot_target_encoder.py`.\n\n    .. versionadded:: 0.20\n\n    Parameters\n    ----------\n    categories : 'auto' or a list of array-like, default='auto'\n        Categories (unique values) per feature:\n\n        - 'auto' : Determine categories automatically from the training data.\n        - list : ``categories[i]`` holds the categories expected in the ith\n          column. The passed categories should not mix strings and numeric\n          values, and should be sorted in case of numeric values.\n\n        The used categories can be found in the ``categories_`` attribute.\n\n    dtype : number type, default=np.float64\n        Desired dtype of output.\n\n    handle_unknown : {'error', 'use_encoded_value'}, default='error'\n        When set to 'error' an error will be raised in case an unknown\n        categorical feature is present during transform. When set to\n        'use_encoded_value', the encoded value of unknown categories will be\n        set to the value given for the parameter `unknown_value`. In\n        :meth:`inverse_transform`, an unknown category will be denoted as None.\n\n        .. versionadded:: 0.24\n\n    unknown_value : int or np.nan, default=None\n        When the parameter handle_unknown is set to 'use_encoded_value', this\n        parameter is required and will set the encoded value of unknown\n        categories. It has to be distinct from the values used to encode any of\n        the categories in `fit`. If set to np.nan, the `dtype` parameter must\n        be a float dtype.\n\n        .. versionadded:: 0.24\n\n    encoded_missing_value : int or np.nan, default=np.nan\n        Encoded value of missing categories. If set to `np.nan`, then the `dtype`\n        parameter must be a float dtype.\n\n        .. versionadded:: 1.1\n\n    min_frequency : int or float, default=None\n        Specifies the minimum frequency below which a category will be\n        considered infrequent.\n\n        - If `int`, categories with a smaller cardinality will be considered\n          infrequent.\n\n        - If `float`, categories with a smaller cardinality than\n          `min_frequency * n_samples`  will be considered infrequent.\n\n        .. versionadded:: 1.3\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    max_categories : int, default=None\n        Specifies an upper limit to the number of output categories for each input\n        feature when considering infrequent categories. If there are infrequent\n        categories, `max_categories` includes the category representing the\n        infrequent categories along with the frequent categories. If `None`,\n        there is no limit to the number of output features.\n\n        `max_categories` do **not** take into account missing or unknown\n        categories. Setting `unknown_value` or `encoded_missing_value` to an\n        integer will increase the number of unique integer codes by one each.\n        This can result in up to `max_categories + 2` integer codes.\n\n        .. versionadded:: 1.3\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    Attributes\n    ----------\n    categories_ : list of arrays\n        The categories of each feature determined during ``fit`` (in order of\n        the features in X and corresponding with the output of ``transform``).\n        This does not include categories that weren't seen during ``fit``.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 1.0\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    infrequent_categories_ : list of ndarray\n        Defined only if infrequent categories are enabled by setting\n        `min_frequency` or `max_categories` to a non-default value.\n        `infrequent_categories_[i]` are the infrequent categories for feature\n        `i`. If the feature `i` has no infrequent categories\n        `infrequent_categories_[i]` is None.\n\n        .. versionadded:: 1.3\n\n    See Also\n    --------\n    OneHotEncoder : Performs a one-hot encoding of categorical features. This encoding\n        is suitable for low to medium cardinality categorical variables, both in\n        supervised and unsupervised settings.\n    TargetEncoder : Encodes categorical features using supervised signal\n        in a classification or regression pipeline. This encoding is typically\n        suitable for high cardinality categorical variables.\n    LabelEncoder : Encodes target labels with values between 0 and\n        ``n_classes-1``.\n\n    Notes\n    -----\n    With a high proportion of `nan` values, inferring categories becomes slow with\n    Python versions before 3.10. The handling of `nan` values was improved\n    from Python 3.10 onwards, (c.f.\n    `bpo-43475 <https://github.com/python/cpython/issues/87641>`_).",
        "parameters": {
          "categories": {
            "type": "'auto' or a list of array",
            "description": "like, default='auto'"
          },
          "Categories": {
            "type": "unique values",
            "description": "per feature:\n- 'auto' : Determine categories automatically from the training data.\n- list : ``categories[i]`` holds the categories expected in the ith\ncolumn. The passed categories should not mix strings and numeric\nvalues, and should be sorted in case of numeric values."
          },
          "The": {
            "type": "categories of each feature determined during ``fit`` (in order of",
            "description": ""
          },
          "dtype": {
            "type": "number type, default=np.float64",
            "description": ""
          },
          "Desired": {
            "type": "dtype of output.",
            "description": ""
          },
          "handle_unknown": {
            "type": "{'error', 'use_encoded_value'}, default='error'",
            "description": ""
          },
          "When": {
            "type": "the parameter handle_unknown is set to 'use_encoded_value', this",
            "description": ""
          },
          "categorical": {
            "type": "feature is present during transform. When set to",
            "description": "'use_encoded_value', the encoded value of unknown categories will be"
          },
          "set": {
            "type": "to the value given for the parameter `unknown_value`. In",
            "description": ":meth:`inverse_transform`, an unknown category will be denoted as None.\n.. versionadded:: 0.24"
          },
          "unknown_value": {
            "type": "int or np.nan, default=None",
            "description": ""
          },
          "parameter": {
            "type": "must be a float dtype.",
            "description": ".. versionadded:: 1.1"
          },
          "the": {
            "type": "features in X and corresponding with the output of ``transform``).",
            "description": ""
          },
          "be": {
            "type": "a float dtype.",
            "description": ".. versionadded:: 0.24"
          },
          "encoded_missing_value": {
            "type": "int or np.nan, default=np.nan",
            "description": ""
          },
          "Encoded": {
            "type": "value of missing categories. If set to `np.nan`, then the `dtype`",
            "description": ""
          },
          "min_frequency": {
            "type": "int or float, default=None",
            "description": ""
          },
          "Specifies": {
            "type": "an upper limit to the number of output categories for each input",
            "description": ""
          },
          "considered": {
            "type": "infrequent.",
            "description": "- If `int`, categories with a smaller cardinality will be considered\ninfrequent.\n- If `float`, categories with a smaller cardinality than\n`min_frequency * n_samples`  will be considered infrequent.\n.. versionadded:: 1.3"
          },
          "Read": {
            "type": "more in the :ref:`User Guide <encoder_infrequent_categories>`.",
            "description": "Attributes\n----------"
          },
          "max_categories": {
            "type": "int, default=None",
            "description": ""
          },
          "feature": {
            "type": "when considering infrequent categories. If there are infrequent",
            "description": "categories, `max_categories` includes the category representing the"
          },
          "infrequent": {
            "type": "categories along with the frequent categories. If `None`,",
            "description": ""
          },
          "there": {
            "type": "is no limit to the number of output features.",
            "description": "`max_categories` do **not** take into account missing or unknown\ncategories. Setting `unknown_value` or `encoded_missing_value` to an"
          },
          "integer": {
            "type": "will increase the number of unique integer codes by one each.",
            "description": ""
          },
          "This": {
            "type": "does not include categories that weren't seen during ``fit``.",
            "description": ""
          },
          "categories_": {
            "type": "list of arrays",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 1.0"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "infrequent_categories_": {
            "type": "list of ndarray",
            "description": ""
          },
          "Defined": {
            "type": "only if infrequent categories are enabled by setting",
            "description": "`min_frequency` or `max_categories` to a non-default value.\n`infrequent_categories_[i]` are the infrequent categories for feature\n`i`. If the feature `i` has no infrequent categories\n`infrequent_categories_[i]` is None.\n.. versionadded:: 1.3"
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "OneHotEncoder": {
            "type": "Performs a one",
            "description": "hot encoding of categorical features. This encoding"
          },
          "is": {
            "type": "suitable for low to medium cardinality categorical variables, both in",
            "description": ""
          },
          "supervised": {
            "type": "and unsupervised settings.",
            "description": ""
          },
          "TargetEncoder": {
            "type": "Encodes categorical features using supervised signal",
            "description": ""
          },
          "in": {
            "type": "a classification or regression pipeline. This encoding is typically",
            "description": ""
          },
          "suitable": {
            "type": "for high cardinality categorical variables.",
            "description": ""
          },
          "LabelEncoder": {
            "type": "Encodes target labels with values between 0 and",
            "description": "``n_classes-1``.\nNotes\n-----"
          },
          "With": {
            "type": "a high proportion of `nan` values, inferring categories becomes slow with",
            "description": ""
          },
          "Python": {
            "type": "versions before 3.10. The handling of `nan` values was improved",
            "description": ""
          },
          "from": {
            "type": "Python 3.10 onwards, (c.f.",
            "description": "`bpo-43475 <https://github.com/python/cpython/issues/87641>`_).\nExamples\n--------"
          },
          "Given": {
            "type": "a dataset with two features, we let the encoder find the unique",
            "description": ""
          },
          "values": {
            "type": "are encoded as 3 and missing values are encoded as 4.",
            "description": ">>> X_train = np.array(\n...     [[\"a\"] * 5 + [\"b\"] * 20 + [\"c\"] * 10 + [\"d\"] * 3 + [np.nan]],\n...     dtype=object).T\n>>> enc = OrdinalEncoder(\n...     handle_unknown=\"use_encoded_value\", unknown_value=3,\n...     max_categories=3, encoded_missing_value=4)\n>>> _ = enc.fit(X_train)\n>>> X_test = np.array([[\"a\"], [\"b\"], [\"c\"], [\"d\"], [\"e\"], [np.nan]], dtype=object)\n>>> enc.transform(X_test)\narray([[2.],\n[0.],\n[1.],\n[2.],\n[3.],\n[4.]])"
          },
          "OrdinalEncoder": {
            "type": "",
            "description": ">>> enc.categories_\n[array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n>>> enc.transform([['Female', 3], ['Male', 1]])\narray([[0., 2.],\n[1., 0.]])\n>>> enc.inverse_transform([[1, 0], [0, 1]])\narray([['Male', 1],\n['Female', 2]], dtype=object)"
          },
          "By": {
            "type": "default, :class:`OrdinalEncoder` is lenient towards missing values by",
            "description": ""
          },
          "propagating": {
            "type": "them.",
            "description": ">>> import numpy as np\n>>> X = [['Male', 1], ['Female', 3], ['Female', np.nan]]\n>>> enc.fit_transform(X)\narray([[ 1.,  0.],\n[ 0.,  1.],\n[ 0., nan]])"
          },
          "You": {
            "type": "can use the parameter `encoded_missing_value` to encode missing values.",
            "description": ">>> enc.set_params(encoded_missing_value=-1).fit_transform(X)\narray([[ 1.,  0.],\n[ 0.,  1.],\n[ 0., -1.]])"
          },
          "Infrequent": {
            "type": "categories are enabled by setting `max_categories` or `min_frequency`.",
            "description": ""
          },
          "In": {
            "type": "the following example, \"a\" and \"d\" are considered infrequent and grouped",
            "description": ""
          },
          "together": {
            "type": "into a single category, \"b\" and \"c\" are their own categories, unknown",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    OneHotEncoder : Performs a one-hot encoding of categorical features. This encoding\n        is suitable for low to medium cardinality categorical variables, both in\n        supervised and unsupervised settings.\n    TargetEncoder : Encodes categorical features using supervised signal\n        in a classification or regression pipeline. This encoding is typically\n        suitable for high cardinality categorical variables.\n    LabelEncoder : Encodes target labels with values between 0 and\n        ``n_classes-1``.\n\n    Notes\n    -----\n    With a high proportion of `nan` values, inferring categories becomes slow with\n    Python versions before 3.10. The handling of `nan` values was improved\n    from Python 3.10 onwards, (c.f.\n    `bpo-43475 <https://github.com/python/cpython/issues/87641>`_).\n\n    Examples\n    --------\n    Given a dataset with two features, we let the encoder find the unique\n    values per feature and transform the data to an ordinal encoding.\n\n    >>> from sklearn.preprocessing import OrdinalEncoder\n    >>> enc = OrdinalEncoder()\n    >>> X = [['Male', 1], ['Female', 3], ['Female', 2]]\n    >>> enc.fit(X)\n    OrdinalEncoder()\n    >>> enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> enc.transform([['Female', 3], ['Male', 1]])\n    array([[0., 2.],\n           [1., 0.]])\n\n    >>> enc.inverse_transform([[1, 0], [0, 1]])\n    array([['Male', 1],\n           ['Female', 2]], dtype=object)\n\n    By default, :class:`OrdinalEncoder` is lenient towards missing values by\n    propagating them.\n\n    >>> import numpy as np\n    >>> X = [['Male', 1], ['Female', 3], ['Female', np.nan]]\n    >>> enc.fit_transform(X)\n    array([[ 1.,  0.],\n           [ 0.,  1.],\n           [ 0., nan]])\n\n    You can use the parameter `encoded_missing_value` to encode missing values.\n\n    >>> enc.set_params(encoded_missing_value=-1).fit_transform(X)\n    array([[ 1.,  0.],\n           [ 0.,  1.],\n           [ 0., -1.]])\n\n    Infrequent categories are enabled by setting `max_categories` or `min_frequency`.\n    In the following example, \"a\" and \"d\" are considered infrequent and grouped\n    together into a single category, \"b\" and \"c\" are their own categories, unknown\n    values are encoded as 3 and missing values are encoded as 4.\n\n    >>> X_train = np.array(\n    ...     [[\"a\"] * 5 + [\"b\"] * 20 + [\"c\"] * 10 + [\"d\"] * 3 + [np.nan]],\n    ...     dtype=object).T\n    >>> enc = OrdinalEncoder(\n    ...     handle_unknown=\"use_encoded_value\", unknown_value=3,\n    ...     max_categories=3, encoded_missing_value=4)\n    >>> _ = enc.fit(X_train)\n    >>> X_test = np.array([[\"a\"], [\"b\"], [\"c\"], [\"d\"], [\"e\"], [np.nan]], dtype=object)\n    >>> enc.transform(X_test)\n    array([[2.],\n           [0.],\n           [1.],\n           [2.],\n           [3.],\n           [4.]])",
        "notes": "-----\n    With a high proportion of `nan` values, inferring categories becomes slow with\n    Python versions before 3.10. The handling of `nan` values was improved\n    from Python 3.10 onwards, (c.f.\n    `bpo-43475 <https://github.com/python/cpython/issues/87641>`_).\n\n    Examples\n    --------\n    Given a dataset with two features, we let the encoder find the unique\n    values per feature and transform the data to an ordinal encoding.\n\n    >>> from sklearn.preprocessing import OrdinalEncoder\n    >>> enc = OrdinalEncoder()\n    >>> X = [['Male', 1], ['Female', 3], ['Female', 2]]\n    >>> enc.fit(X)\n    OrdinalEncoder()\n    >>> enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> enc.transform([['Female', 3], ['Male', 1]])\n    array([[0., 2.],\n           [1., 0.]])\n\n    >>> enc.inverse_transform([[1, 0], [0, 1]])\n    array([['Male', 1],\n           ['Female', 2]], dtype=object)\n\n    By default, :class:`OrdinalEncoder` is lenient towards missing values by\n    propagating them.\n\n    >>> import numpy as np\n    >>> X = [['Male', 1], ['Female', 3], ['Female', np.nan]]\n    >>> enc.fit_transform(X)\n    array([[ 1.,  0.],\n           [ 0.,  1.],\n           [ 0., nan]])\n\n    You can use the parameter `encoded_missing_value` to encode missing values.\n\n    >>> enc.set_params(encoded_missing_value=-1).fit_transform(X)\n    array([[ 1.,  0.],\n           [ 0.,  1.],\n           [ 0., -1.]])\n\n    Infrequent categories are enabled by setting `max_categories` or `min_frequency`.\n    In the following example, \"a\" and \"d\" are considered infrequent and grouped\n    together into a single category, \"b\" and \"c\" are their own categories, unknown\n    values are encoded as 3 and missing values are encoded as 4.\n\n    >>> X_train = np.array(\n    ...     [[\"a\"] * 5 + [\"b\"] * 20 + [\"c\"] * 10 + [\"d\"] * 3 + [np.nan]],\n    ...     dtype=object).T\n    >>> enc = OrdinalEncoder(\n    ...     handle_unknown=\"use_encoded_value\", unknown_value=3,\n    ...     max_categories=3, encoded_missing_value=4)\n    >>> _ = enc.fit(X_train)\n    >>> X_test = np.array([[\"a\"], [\"b\"], [\"c\"], [\"d\"], [\"e\"], [np.nan]], dtype=object)\n    >>> enc.transform(X_test)\n    array([[2.],\n           [0.],\n           [1.],\n           [2.],\n           [3.],\n           [4.]])",
        "examples": "--------\n    Given a dataset with two features, we let the encoder find the unique\n    values per feature and transform the data to an ordinal encoding.\n\n    >>> from sklearn.preprocessing import OrdinalEncoder\n    >>> enc = OrdinalEncoder()\n    >>> X = [['Male', 1], ['Female', 3], ['Female', 2]]\n    >>> enc.fit(X)\n    OrdinalEncoder()\n    >>> enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> enc.transform([['Female', 3], ['Male', 1]])\n    array([[0., 2.],\n           [1., 0.]])\n\n    >>> enc.inverse_transform([[1, 0], [0, 1]])\n    array([['Male', 1],\n           ['Female', 2]], dtype=object)\n\n    By default, :class:`OrdinalEncoder` is lenient towards missing values by\n    propagating them.\n\n    >>> import numpy as np\n    >>> X = [['Male', 1], ['Female', 3], ['Female', np.nan]]\n    >>> enc.fit_transform(X)\n    array([[ 1.,  0.],\n           [ 0.,  1.],\n           [ 0., nan]])\n\n    You can use the parameter `encoded_missing_value` to encode missing values.\n\n    >>> enc.set_params(encoded_missing_value=-1).fit_transform(X)\n    array([[ 1.,  0.],\n           [ 0.,  1.],\n           [ 0., -1.]])\n\n    Infrequent categories are enabled by setting `max_categories` or `min_frequency`.\n    In the following example, \"a\" and \"d\" are considered infrequent and grouped\n    together into a single category, \"b\" and \"c\" are their own categories, unknown\n    values are encoded as 3 and missing values are encoded as 4.\n\n    >>> X_train = np.array(\n    ...     [[\"a\"] * 5 + [\"b\"] * 20 + [\"c\"] * 10 + [\"d\"] * 3 + [np.nan]],\n    ...     dtype=object).T\n    >>> enc = OrdinalEncoder(\n    ...     handle_unknown=\"use_encoded_value\", unknown_value=3,\n    ...     max_categories=3, encoded_missing_value=4)\n    >>> _ = enc.fit(X_train)\n    >>> X_test = np.array([[\"a\"], [\"b\"], [\"c\"], [\"d\"], [\"e\"], [np.nan]], dtype=object)\n    >>> enc.transform(X_test)\n    array([[2.],\n           [0.],\n           [1.],\n           [2.],\n           [3.],\n           [4.]])"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None)",
          "documentation": {
            "description": "Fit the OrdinalEncoder to X.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data to determine the categories of each feature.\n\n        y : None\n            Ignored. This parameter exists only for compatibility with\n            :class:`~sklearn.pipeline.Pipeline`.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data to determine the categories of each feature.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored. This parameter exists only for compatibility with\n:class:`~sklearn.pipeline.Pipeline`.\nReturns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "encoder.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted encoder.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input features.\n\n            - If `input_features` is `None`, then `feature_names_in_` is\n              used as feature names in. If `feature_names_in_` is not defined,\n              then the following input feature names are generated:\n              `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            - If `input_features` is an array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "features.",
                "description": "- If `input_features` is `None`, then `feature_names_in_` is"
              },
              "used": {
                "type": "as feature names in. If `feature_names_in_` is not defined,",
                "description": ""
              },
              "then": {
                "type": "the following input feature names are generated:",
                "description": "`[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Same": {
                "type": "as input features.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Same as input features.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X)",
          "documentation": {
            "description": "Convert the data back to the original representation.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_encoded_features)\n            The transformed data.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_encoded_features)"
              },
              "The": {
                "type": "transformed data.",
                "description": "Returns\n-------"
              },
              "X_tr": {
                "type": "ndarray of shape (n_samples, n_features)",
                "description": ""
              },
              "Inverse": {
                "type": "transformed array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_tr : ndarray of shape (n_samples, n_features)\n            Inverse transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Transform X to ordinal codes.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data to encode.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data to encode.",
                "description": "Returns\n-------"
              },
              "X_out": {
                "type": "ndarray of shape (n_samples, n_features)",
                "description": ""
              },
              "Transformed": {
                "type": "input.",
                "description": ""
              }
            },
            "returns": "-------\n        X_out : ndarray of shape (n_samples, n_features)\n            Transformed input.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "PolynomialFeatures",
      "documentation": {
        "description": "Generate polynomial and interaction features.\n\n    Generate a new feature matrix consisting of all polynomial combinations\n    of the features with degree less than or equal to the specified degree.\n    For example, if an input sample is two dimensional and of the form\n    [a, b], the degree-2 polynomial features are [1, a, b, a^2, ab, b^2].\n\n    Read more in the :ref:`User Guide <polynomial_features>`.\n\n    Parameters\n    ----------\n    degree : int or tuple (min_degree, max_degree), default=2\n        If a single int is given, it specifies the maximal degree of the\n        polynomial features. If a tuple `(min_degree, max_degree)` is passed,\n        then `min_degree` is the minimum and `max_degree` is the maximum\n        polynomial degree of the generated features. Note that `min_degree=0`\n        and `min_degree=1` are equivalent as outputting the degree zero term is\n        determined by `include_bias`.\n\n    interaction_only : bool, default=False\n        If `True`, only interaction features are produced: features that are\n        products of at most `degree` *distinct* input features, i.e. terms with\n        power of 2 or higher of the same input feature are excluded:\n\n        - included: `x[0]`, `x[1]`, `x[0] * x[1]`, etc.\n        - excluded: `x[0] ** 2`, `x[0] ** 2 * x[1]`, etc.\n\n    include_bias : bool, default=True\n        If `True` (default), then include a bias column, the feature in which\n        all polynomial powers are zero (i.e. a column of ones - acts as an\n        intercept term in a linear model).\n\n    order : {'C', 'F'}, default='C'\n        Order of output array in the dense case. `'F'` order is faster to\n        compute, but may slow down subsequent estimators.\n\n        .. versionadded:: 0.21\n\n    Attributes\n    ----------\n    powers_ : ndarray of shape (`n_output_features_`, `n_features_in_`)\n        `powers_[i, j]` is the exponent of the jth input in the ith output.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    n_output_features_ : int\n        The total number of polynomial output features. The number of output\n        features is computed by iterating over all suitably sized combinations\n        of input features.\n\n    See Also\n    --------\n    SplineTransformer : Transformer that generates univariate B-spline bases\n        for features.\n\n    Notes\n    -----\n    Be aware that the number of features in the output array scales\n    polynomially in the number of features of the input array, and\n    exponentially in the degree. High degrees can cause overfitting.\n\n    See :ref:`examples/linear_model/plot_polynomial_interpolation.py\n    <sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py>`",
        "parameters": {
          "degree": {
            "type": "int or tuple (min_degree, max_degree), default=2",
            "description": ""
          },
          "If": {
            "type": "`True` (default), then include a bias column, the feature in which",
            "description": ""
          },
          "polynomial": {
            "type": "degree of the generated features. Note that `min_degree=0`",
            "description": ""
          },
          "then": {
            "type": "`min_degree` is the minimum and `max_degree` is the maximum",
            "description": ""
          },
          "and": {
            "type": "`min_degree=1` are equivalent as outputting the degree zero term is",
            "description": ""
          },
          "determined": {
            "type": "by `include_bias`.",
            "description": ""
          },
          "interaction_only": {
            "type": "bool, default=False",
            "description": ""
          },
          "products": {
            "type": "of at most `degree` *distinct* input features, i.e. terms with",
            "description": ""
          },
          "power": {
            "type": "of 2 or higher of the same input feature are excluded:",
            "description": "- included: `x[0]`, `x[1]`, `x[0] * x[1]`, etc.\n- excluded: `x[0] ** 2`, `x[0] ** 2 * x[1]`, etc."
          },
          "include_bias": {
            "type": "bool, default=True",
            "description": ""
          },
          "all": {
            "type": "polynomial powers are zero (i.e. a column of ones - acts as an",
            "description": ""
          },
          "intercept": {
            "type": "term in a linear model).",
            "description": ""
          },
          "order": {
            "type": "{'C', 'F'}, default='C'",
            "description": ""
          },
          "Order": {
            "type": "of output array in the dense case. `'F'` order is faster to",
            "description": "compute, but may slow down subsequent estimators.\n.. versionadded:: 0.21\nAttributes\n----------"
          },
          "powers_": {
            "type": "ndarray of shape (`n_output_features_`, `n_features_in_`)",
            "description": "`powers_[i, j]` is the exponent of the jth input in the ith output."
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 0.24"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "n_output_features_": {
            "type": "int",
            "description": ""
          },
          "The": {
            "type": "total number of polynomial output features. The number of output",
            "description": ""
          },
          "features": {
            "type": "is computed by iterating over all suitably sized combinations",
            "description": ""
          },
          "of": {
            "type": "input features.",
            "description": ""
          },
          "See": {
            "type": "ref:`examples/linear_model/plot_polynomial_interpolation.py",
            "description": "<sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py>`\nExamples\n--------\n>>> import numpy as np\n>>> from sklearn.preprocessing import PolynomialFeatures\n>>> X = np.arange(6).reshape(3, 2)\n>>> X\narray([[0, 1],\n[2, 3],\n[4, 5]])\n>>> poly = PolynomialFeatures(2)\n>>> poly.fit_transform(X)\narray([[ 1.,  0.,  1.,  0.,  0.,  1.],\n[ 1.,  2.,  3.,  4.,  6.,  9.],\n[ 1.,  4.,  5., 16., 20., 25.]])\n>>> poly = PolynomialFeatures(interaction_only=True)\n>>> poly.fit_transform(X)\narray([[ 1.,  0.,  1.,  0.],\n[ 1.,  2.,  3.,  6.],\n[ 1.,  4.,  5., 20.]])"
          },
          "SplineTransformer": {
            "type": "Transformer that generates univariate B",
            "description": "spline bases"
          },
          "for": {
            "type": "features.",
            "description": "Notes\n-----"
          },
          "Be": {
            "type": "aware that the number of features in the output array scales",
            "description": ""
          },
          "polynomially": {
            "type": "in the number of features of the input array, and",
            "description": ""
          },
          "exponentially": {
            "type": "in the degree. High degrees can cause overfitting.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    SplineTransformer : Transformer that generates univariate B-spline bases\n        for features.\n\n    Notes\n    -----\n    Be aware that the number of features in the output array scales\n    polynomially in the number of features of the input array, and\n    exponentially in the degree. High degrees can cause overfitting.\n\n    See :ref:`examples/linear_model/plot_polynomial_interpolation.py\n    <sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py>`\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import PolynomialFeatures\n    >>> X = np.arange(6).reshape(3, 2)\n    >>> X\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n    >>> poly = PolynomialFeatures(2)\n    >>> poly.fit_transform(X)\n    array([[ 1.,  0.,  1.,  0.,  0.,  1.],\n           [ 1.,  2.,  3.,  4.,  6.,  9.],\n           [ 1.,  4.,  5., 16., 20., 25.]])\n    >>> poly = PolynomialFeatures(interaction_only=True)\n    >>> poly.fit_transform(X)\n    array([[ 1.,  0.,  1.,  0.],\n           [ 1.,  2.,  3.,  6.],\n           [ 1.,  4.,  5., 20.]])",
        "notes": "-----\n    Be aware that the number of features in the output array scales\n    polynomially in the number of features of the input array, and\n    exponentially in the degree. High degrees can cause overfitting.\n\n    See :ref:`examples/linear_model/plot_polynomial_interpolation.py\n    <sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py>`\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import PolynomialFeatures\n    >>> X = np.arange(6).reshape(3, 2)\n    >>> X\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n    >>> poly = PolynomialFeatures(2)\n    >>> poly.fit_transform(X)\n    array([[ 1.,  0.,  1.,  0.,  0.,  1.],\n           [ 1.,  2.,  3.,  4.,  6.,  9.],\n           [ 1.,  4.,  5., 16., 20., 25.]])\n    >>> poly = PolynomialFeatures(interaction_only=True)\n    >>> poly.fit_transform(X)\n    array([[ 1.,  0.,  1.,  0.],\n           [ 1.,  2.,  3.,  6.],\n           [ 1.,  4.,  5., 20.]])",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import PolynomialFeatures\n    >>> X = np.arange(6).reshape(3, 2)\n    >>> X\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n    >>> poly = PolynomialFeatures(2)\n    >>> poly.fit_transform(X)\n    array([[ 1.,  0.,  1.,  0.,  0.,  1.],\n           [ 1.,  2.,  3.,  4.,  6.,  9.],\n           [ 1.,  4.,  5., 16., 20., 25.]])\n    >>> poly = PolynomialFeatures(interaction_only=True)\n    >>> poly.fit_transform(X)\n    array([[ 1.,  0.,  1.,  0.],\n           [ 1.,  2.,  3.,  6.],\n           [ 1.,  4.,  5., 20.]])"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None)",
          "documentation": {
            "description": "Compute number of output features.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data.\n\n        y : Ignored\n            Not used, present here for API consistency by convention.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data.",
                "description": ""
              },
              "y": {
                "type": "Ignored",
                "description": ""
              },
              "Not": {
                "type": "used, present here for API consistency by convention.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "transformer.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted transformer.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input features.\n\n            - If `input_features is None`, then `feature_names_in_` is\n              used as feature names in. If `feature_names_in_` is not defined,\n              then the following input feature names are generated:\n              `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            - If `input_features` is an array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "features.",
                "description": "- If `input_features is None`, then `feature_names_in_` is"
              },
              "used": {
                "type": "as feature names in. If `feature_names_in_` is not defined,",
                "description": ""
              },
              "then": {
                "type": "the following input feature names are generated:",
                "description": "`[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Transformed": {
                "type": "feature names.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Transformed feature names.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Transform data to polynomial features.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data to transform, row by row.\n\n            Prefer CSR over CSC for sparse input (for speed), but CSC is\n            required if the degree is 4 or higher. If the degree is less than\n            4 and the input format is CSC, it will be converted to CSR, have\n            its polynomial features generated, then converted back to CSC.\n\n            If the degree is 2 or 3, the method described in \"Leveraging\n            Sparsity to Speed Up Polynomial Feature Expansions of CSR Matrices\n            Using K-Simplex Numbers\" by Andrew Nystrom and John Hughes is\n            used, which is much faster than the method used on CSC input. For\n            this reason, a CSC input will be converted to CSR, and the output\n            will be converted back to CSC prior to being returned, hence the\n            preference of CSR.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "matrix of features, where `NP` is the number of polynomial",
                "description": ""
              },
              "Prefer": {
                "type": "CSR over CSC for sparse input (for speed), but CSC is",
                "description": ""
              },
              "required": {
                "type": "if the degree is 4 or higher. If the degree is less than",
                "description": ""
              },
              "4": {
                "type": "and the input format is CSC, it will be converted to CSR, have",
                "description": ""
              },
              "its": {
                "type": "polynomial features generated, then converted back to CSC.",
                "description": ""
              },
              "If": {
                "type": "the degree is 2 or 3, the method described in \"Leveraging",
                "description": ""
              },
              "Sparsity": {
                "type": "to Speed Up Polynomial Feature Expansions of CSR Matrices",
                "description": ""
              },
              "Using": {
                "type": "K-Simplex Numbers\" by Andrew Nystrom and John Hughes is",
                "description": "used, which is much faster than the method used on CSC input. For"
              },
              "this": {
                "type": "reason, a CSC input will be converted to CSR, and the output",
                "description": ""
              },
              "will": {
                "type": "be converted back to CSC prior to being returned, hence the",
                "description": ""
              },
              "preference": {
                "type": "of CSR.",
                "description": "Returns\n-------"
              },
              "XP": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, NP)",
                "description": ""
              },
              "features": {
                "type": "generated from the combination of inputs. If a sparse",
                "description": ""
              },
              "matrix": {
                "type": "is provided, it will be converted into a sparse",
                "description": "`csr_matrix`."
              }
            },
            "returns": "-------\n        XP : {ndarray, sparse matrix} of shape (n_samples, NP)\n            The matrix of features, where `NP` is the number of polynomial\n            features generated from the combination of inputs. If a sparse\n            matrix is provided, it will be converted into a sparse\n            `csr_matrix`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "PowerTransformer",
      "documentation": {
        "description": "Apply a power transform featurewise to make data more Gaussian-like.\n\n    Power transforms are a family of parametric, monotonic transformations\n    that are applied to make data more Gaussian-like. This is useful for\n    modeling issues related to heteroscedasticity (non-constant variance),\n    or other situations where normality is desired.\n\n    Currently, PowerTransformer supports the Box-Cox transform and the\n    Yeo-Johnson transform. The optimal parameter for stabilizing variance and\n    minimizing skewness is estimated through maximum likelihood.\n\n    Box-Cox requires input data to be strictly positive, while Yeo-Johnson\n    supports both positive or negative data.\n\n    By default, zero-mean, unit-variance normalization is applied to the\n    transformed data.\n\n    For an example visualization, refer to :ref:`Compare PowerTransformer with\n    other scalers <plot_all_scaling_power_transformer_section>`. To see the\n    effect of Box-Cox and Yeo-Johnson transformations on different\n    distributions, see:\n    :ref:`sphx_glr_auto_examples_preprocessing_plot_map_data_to_normal.py`.\n\n    Read more in the :ref:`User Guide <preprocessing_transformer>`.\n\n    .. versionadded:: 0.20\n\n    Parameters\n    ----------\n    method : {'yeo-johnson', 'box-cox'}, default='yeo-johnson'\n        The power transform method. Available methods are:\n\n        - 'yeo-johnson' [1]_, works with positive and negative values\n        - 'box-cox' [2]_, only works with strictly positive values\n\n    standardize : bool, default=True\n        Set to True to apply zero-mean, unit-variance normalization to the\n        transformed output.\n\n    copy : bool, default=True\n        Set to False to perform inplace computation during transformation.\n\n    Attributes\n    ----------\n    lambdas_ : ndarray of float of shape (n_features,)\n        The parameters of the power transformation for the selected features.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    power_transform : Equivalent function without the estimator API.\n\n    QuantileTransformer : Maps data to a standard normal distribution with\n        the parameter `output_distribution='normal'`.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in ``fit``, and maintained\n    in ``transform``.\n\n    References\n    ----------\n\n    .. [1] :doi:`I.K. Yeo and R.A. Johnson, \"A new family of power\n           transformations to improve normality or symmetry.\" Biometrika,\n           87(4), pp.954-959, (2000). <10.1093/biomet/87.4.954>`\n\n    .. [2] :doi:`G.E.P. Box and D.R. Cox, \"An Analysis of Transformations\",\n           Journal of the Royal Statistical Society B, 26, 211-252 (1964).\n           <10.1111/j.2517-6161.1964.tb00553.x>`",
        "parameters": {
          "method": {
            "type": "{'yeo",
            "description": "johnson', 'box-cox'}, default='yeo-johnson'"
          },
          "The": {
            "type": "parameters of the power transformation for the selected features.",
            "description": ""
          },
          "standardize": {
            "type": "bool, default=True",
            "description": ""
          },
          "Set": {
            "type": "to False to perform inplace computation during transformation.",
            "description": "Attributes\n----------"
          },
          "transformed": {
            "type": "output.",
            "description": ""
          },
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "lambdas_": {
            "type": "ndarray of float of shape (n_features,)",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 0.24"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "power_transform": {
            "type": "Equivalent function without the estimator API.",
            "description": ""
          },
          "QuantileTransformer": {
            "type": "Maps data to a standard normal distribution with",
            "description": ""
          },
          "the": {
            "type": "parameter `output_distribution='normal'`.",
            "description": "Notes\n-----"
          },
          "NaNs": {
            "type": "are treated as missing values: disregarded in ``fit``, and maintained",
            "description": ""
          },
          "in": {
            "type": "``transform``.",
            "description": "References\n----------\n.. [1] :doi:`I.K. Yeo and R.A. Johnson, \"A new family of power"
          },
          "transformations": {
            "type": "to improve normality or symmetry.\" Biometrika,",
            "description": ""
          },
          "87": {
            "type": "4",
            "description": ", pp.954-959, (2000). <10.1093/biomet/87.4.954>`\n.. [2] :doi:`G.E.P. Box and D.R. Cox, \"An Analysis of Transformations\","
          },
          "Journal": {
            "type": "of the Royal Statistical Society B, 26, 211-252 (1964).",
            "description": "<10.1111/j.2517-6161.1964.tb00553.x>`\nExamples\n--------\n>>> import numpy as np\n>>> from sklearn.preprocessing import PowerTransformer\n>>> pt = PowerTransformer()\n>>> data = [[1, 2], [3, 2], [4, 5]]\n>>> print(pt.fit(data))"
          },
          "PowerTransformer": {
            "type": "",
            "description": ">>> print(pt.lambdas_)\n[ 1.386... -3.100...]\n>>> print(pt.transform(data))\n[[-1.316... -0.707...]\n[ 0.209... -0.707...]\n[ 1.106...  1.414...]]"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    power_transform : Equivalent function without the estimator API.\n\n    QuantileTransformer : Maps data to a standard normal distribution with\n        the parameter `output_distribution='normal'`.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in ``fit``, and maintained\n    in ``transform``.\n\n    References\n    ----------\n\n    .. [1] :doi:`I.K. Yeo and R.A. Johnson, \"A new family of power\n           transformations to improve normality or symmetry.\" Biometrika,\n           87(4), pp.954-959, (2000). <10.1093/biomet/87.4.954>`\n\n    .. [2] :doi:`G.E.P. Box and D.R. Cox, \"An Analysis of Transformations\",\n           Journal of the Royal Statistical Society B, 26, 211-252 (1964).\n           <10.1111/j.2517-6161.1964.tb00553.x>`\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import PowerTransformer\n    >>> pt = PowerTransformer()\n    >>> data = [[1, 2], [3, 2], [4, 5]]\n    >>> print(pt.fit(data))\n    PowerTransformer()\n    >>> print(pt.lambdas_)\n    [ 1.386... -3.100...]\n    >>> print(pt.transform(data))\n    [[-1.316... -0.707...]\n     [ 0.209... -0.707...]\n     [ 1.106...  1.414...]]",
        "notes": "-----\n    NaNs are treated as missing values: disregarded in ``fit``, and maintained\n    in ``transform``.\n\n    References\n    ----------\n\n    .. [1] :doi:`I.K. Yeo and R.A. Johnson, \"A new family of power\n           transformations to improve normality or symmetry.\" Biometrika,\n           87(4), pp.954-959, (2000). <10.1093/biomet/87.4.954>`\n\n    .. [2] :doi:`G.E.P. Box and D.R. Cox, \"An Analysis of Transformations\",\n           Journal of the Royal Statistical Society B, 26, 211-252 (1964).\n           <10.1111/j.2517-6161.1964.tb00553.x>`\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import PowerTransformer\n    >>> pt = PowerTransformer()\n    >>> data = [[1, 2], [3, 2], [4, 5]]\n    >>> print(pt.fit(data))\n    PowerTransformer()\n    >>> print(pt.lambdas_)\n    [ 1.386... -3.100...]\n    >>> print(pt.transform(data))\n    [[-1.316... -0.707...]\n     [ 0.209... -0.707...]\n     [ 1.106...  1.414...]]",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import PowerTransformer\n    >>> pt = PowerTransformer()\n    >>> data = [[1, 2], [3, 2], [4, 5]]\n    >>> print(pt.fit(data))\n    PowerTransformer()\n    >>> print(pt.lambdas_)\n    [ 1.386... -3.100...]\n    >>> print(pt.transform(data))\n    [[-1.316... -0.707...]\n     [ 0.209... -0.707...]\n     [ 1.106...  1.414...]]"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None)",
          "documentation": {
            "description": "Estimate the optimal parameter lambda for each feature.\n\n        The optimal lambda parameter for minimizing skewness is estimated on\n        each feature independently using maximum likelihood.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data used to estimate the optimal transformation parameters.\n\n        y : None\n            Ignored.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data used to estimate the optimal transformation parameters.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored.\nReturns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "transformer.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted transformer.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None)",
          "documentation": {
            "description": "Fit `PowerTransformer` to `X`, then transform `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data used to estimate the optimal transformation parameters\n            and to be transformed using a power transformation.\n\n        y : Ignored\n            Not used, present for API consistency by convention.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data used to estimate the optimal transformation parameters",
                "description": ""
              },
              "and": {
                "type": "to be transformed using a power transformation.",
                "description": ""
              },
              "y": {
                "type": "Ignored",
                "description": ""
              },
              "Not": {
                "type": "used, present for API consistency by convention.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray of shape (n_samples, n_features)",
                "description": ""
              },
              "Transformed": {
                "type": "data.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray of shape (n_samples, n_features)\n            Transformed data.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input features.\n\n            - If `input_features` is `None`, then `feature_names_in_` is\n              used as feature names in. If `feature_names_in_` is not defined,\n              then the following input feature names are generated:\n              `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            - If `input_features` is an array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "features.",
                "description": "- If `input_features` is `None`, then `feature_names_in_` is"
              },
              "used": {
                "type": "as feature names in. If `feature_names_in_` is not defined,",
                "description": ""
              },
              "then": {
                "type": "the following input feature names are generated:",
                "description": "`[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Same": {
                "type": "as input features.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Same as input features.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X)",
          "documentation": {
            "description": "Apply the inverse power transformation using the fitted lambdas.\n\n        The inverse of the Box-Cox transformation is given by::\n\n            if lambda_ == 0:\n                X = exp(X_trans)\n            else:\n                X = (X_trans * lambda_ + 1) ** (1 / lambda_)\n\n        The inverse of the Yeo-Johnson transformation is given by::\n\n            if X >= 0 and lambda_ == 0:\n                X = exp(X_trans) - 1\n            elif X >= 0 and lambda_ != 0:\n                X = (X_trans * lambda_ + 1) ** (1 / lambda_) - 1\n            elif X < 0 and lambda_ != 2:\n                X = 1 - (-(2 - lambda_) * X_trans + 1) ** (1 / (2 - lambda_))\n            elif X < 0 and lambda_ == 2:\n                X = 1 - exp(-X_trans)\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The transformed data.",
            "parameters": {
              "X": {
                "type": "ndarray of shape (n_samples, n_features)",
                "description": ""
              },
              "The": {
                "type": "original data.",
                "description": ""
              }
            },
            "returns": "-------\n        X : ndarray of shape (n_samples, n_features)\n            The original data.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Apply the power transform to each feature using the fitted lambdas.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data to be transformed using a power transformation.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "transformed data.",
                "description": ""
              },
              "X_trans": {
                "type": "ndarray of shape (n_samples, n_features)",
                "description": ""
              }
            },
            "returns": "-------\n        X_trans : ndarray of shape (n_samples, n_features)\n            The transformed data.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "QuantileTransformer",
      "documentation": {
        "description": "Transform features using quantiles information.\n\n    This method transforms the features to follow a uniform or a normal\n    distribution. Therefore, for a given feature, this transformation tends\n    to spread out the most frequent values. It also reduces the impact of\n    (marginal) outliers: this is therefore a robust preprocessing scheme.\n\n    The transformation is applied on each feature independently. First an\n    estimate of the cumulative distribution function of a feature is\n    used to map the original values to a uniform distribution. The obtained\n    values are then mapped to the desired output distribution using the\n    associated quantile function. Features values of new/unseen data that fall\n    below or above the fitted range will be mapped to the bounds of the output\n    distribution. Note that this transform is non-linear. It may distort linear\n    correlations between variables measured at the same scale but renders\n    variables measured at different scales more directly comparable.\n\n    For example visualizations, refer to :ref:`Compare QuantileTransformer with\n    other scalers <plot_all_scaling_quantile_transformer_section>`.\n\n    Read more in the :ref:`User Guide <preprocessing_transformer>`.\n\n    .. versionadded:: 0.19\n\n    Parameters\n    ----------\n    n_quantiles : int, default=1000 or n_samples\n        Number of quantiles to be computed. It corresponds to the number\n        of landmarks used to discretize the cumulative distribution function.\n        If n_quantiles is larger than the number of samples, n_quantiles is set\n        to the number of samples as a larger number of quantiles does not give\n        a better approximation of the cumulative distribution function\n        estimator.\n\n    output_distribution : {'uniform', 'normal'}, default='uniform'\n        Marginal distribution for the transformed data. The choices are\n        'uniform' (default) or 'normal'.\n\n    ignore_implicit_zeros : bool, default=False\n        Only applies to sparse matrices. If True, the sparse entries of the\n        matrix are discarded to compute the quantile statistics. If False,\n        these entries are treated as zeros.\n\n    subsample : int or None, default=10_000\n        Maximum number of samples used to estimate the quantiles for\n        computational efficiency. Note that the subsampling procedure may\n        differ for value-identical sparse and dense matrices.\n        Disable subsampling by setting `subsample=None`.\n\n        .. versionadded:: 1.5\n           The option `None` to disable subsampling was added.\n\n    random_state : int, RandomState instance or None, default=None\n        Determines random number generation for subsampling and smoothing\n        noise.\n        Please see ``subsample`` for more details.\n        Pass an int for reproducible results across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    copy : bool, default=True\n        Set to False to perform inplace transformation and avoid a copy (if the\n        input is already a numpy array).\n\n    Attributes\n    ----------\n    n_quantiles_ : int\n        The actual number of quantiles used to discretize the cumulative\n        distribution function.\n\n    quantiles_ : ndarray of shape (n_quantiles, n_features)\n        The values corresponding the quantiles of reference.\n\n    references_ : ndarray of shape (n_quantiles, )\n        Quantiles of references.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    quantile_transform : Equivalent function without the estimator API.\n    PowerTransformer : Perform mapping to a normal distribution using a power\n        transform.\n    StandardScaler : Perform standardization that is faster, but less robust\n        to outliers.\n    RobustScaler : Perform robust standardization that removes the influence\n        of outliers but does not put outliers and inliers on the same scale.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.",
        "parameters": {
          "n_quantiles": {
            "type": "int, default=1000 or n_samples",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 0.24"
          },
          "of": {
            "type": "outliers but does not put outliers and inliers on the same scale.",
            "description": "Notes\n-----"
          },
          "If": {
            "type": "n_quantiles is larger than the number of samples, n_quantiles is set",
            "description": ""
          },
          "to": {
            "type": "outliers.",
            "description": ""
          },
          "a": {
            "type": "better approximation of the cumulative distribution function",
            "description": "estimator."
          },
          "output_distribution": {
            "type": "{'uniform', 'normal'}, default='uniform'",
            "description": ""
          },
          "Marginal": {
            "type": "distribution for the transformed data. The choices are",
            "description": "'uniform' (default) or 'normal'."
          },
          "ignore_implicit_zeros": {
            "type": "bool, default=False",
            "description": ""
          },
          "Only": {
            "type": "applies to sparse matrices. If True, the sparse entries of the",
            "description": ""
          },
          "matrix": {
            "type": "are discarded to compute the quantile statistics. If False,",
            "description": ""
          },
          "these": {
            "type": "entries are treated as zeros.",
            "description": ""
          },
          "subsample": {
            "type": "int or None, default=10_000",
            "description": ""
          },
          "Maximum": {
            "type": "number of samples used to estimate the quantiles for",
            "description": ""
          },
          "computational": {
            "type": "efficiency. Note that the subsampling procedure may",
            "description": ""
          },
          "differ": {
            "type": "for value-identical sparse and dense matrices.",
            "description": ""
          },
          "Disable": {
            "type": "subsampling by setting `subsample=None`.",
            "description": ".. versionadded:: 1.5"
          },
          "The": {
            "type": "values corresponding the quantiles of reference.",
            "description": ""
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Determines": {
            "type": "random number generation for subsampling and smoothing",
            "description": "noise."
          },
          "Please": {
            "type": "see ``subsample`` for more details.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible results across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "Set": {
            "type": "to False to perform inplace transformation and avoid a copy (if the",
            "description": ""
          },
          "input": {
            "type": "is already a numpy array).",
            "description": "Attributes\n----------"
          },
          "n_quantiles_": {
            "type": "int",
            "description": ""
          },
          "distribution": {
            "type": "function.",
            "description": ""
          },
          "quantiles_": {
            "type": "ndarray of shape (n_quantiles, n_features)",
            "description": ""
          },
          "references_": {
            "type": "ndarray of shape (n_quantiles, )",
            "description": ""
          },
          "Quantiles": {
            "type": "of references.",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "quantile_transform": {
            "type": "Equivalent function without the estimator API.",
            "description": ""
          },
          "PowerTransformer": {
            "type": "Perform mapping to a normal distribution using a power",
            "description": "transform."
          },
          "StandardScaler": {
            "type": "Perform standardization that is faster, but less robust",
            "description": ""
          },
          "RobustScaler": {
            "type": "Perform robust standardization that removes the influence",
            "description": ""
          },
          "NaNs": {
            "type": "are treated as missing values: disregarded in fit, and maintained in",
            "description": "transform.\nExamples\n--------\n>>> import numpy as np\n>>> from sklearn.preprocessing import QuantileTransformer\n>>> rng = np.random.RandomState(0)\n>>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)\n>>> qt = QuantileTransformer(n_quantiles=10, random_state=0)\n>>> qt.fit_transform(X)"
          },
          "array": {
            "type": "[...]",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    quantile_transform : Equivalent function without the estimator API.\n    PowerTransformer : Perform mapping to a normal distribution using a power\n        transform.\n    StandardScaler : Perform standardization that is faster, but less robust\n        to outliers.\n    RobustScaler : Perform robust standardization that removes the influence\n        of outliers but does not put outliers and inliers on the same scale.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import QuantileTransformer\n    >>> rng = np.random.RandomState(0)\n    >>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)\n    >>> qt = QuantileTransformer(n_quantiles=10, random_state=0)\n    >>> qt.fit_transform(X)\n    array([...])",
        "notes": "-----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import QuantileTransformer\n    >>> rng = np.random.RandomState(0)\n    >>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)\n    >>> qt = QuantileTransformer(n_quantiles=10, random_state=0)\n    >>> qt.fit_transform(X)\n    array([...])",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import QuantileTransformer\n    >>> rng = np.random.RandomState(0)\n    >>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)\n    >>> qt = QuantileTransformer(n_quantiles=10, random_state=0)\n    >>> qt.fit_transform(X)\n    array([...])"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None)",
          "documentation": {
            "description": "Compute the quantiles used for transforming.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data used to scale along the features axis. If a sparse\n            matrix is provided, it will be converted into a sparse\n            ``csc_matrix``. Additionally, the sparse matrix needs to be\n            nonnegative if `ignore_implicit_zeros` is False.\n\n        y : None\n            Ignored.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data used to scale along the features axis. If a sparse",
                "description": ""
              },
              "matrix": {
                "type": "is provided, it will be converted into a sparse",
                "description": "``csc_matrix``. Additionally, the sparse matrix needs to be"
              },
              "nonnegative": {
                "type": "if `ignore_implicit_zeros` is False.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored.\nReturns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "transformer.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n           Fitted transformer.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input features.\n\n            - If `input_features` is `None`, then `feature_names_in_` is\n              used as feature names in. If `feature_names_in_` is not defined,\n              then the following input feature names are generated:\n              `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            - If `input_features` is an array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "features.",
                "description": "- If `input_features` is `None`, then `feature_names_in_` is"
              },
              "used": {
                "type": "as feature names in. If `feature_names_in_` is not defined,",
                "description": ""
              },
              "then": {
                "type": "the following input feature names are generated:",
                "description": "`[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Same": {
                "type": "as input features.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Same as input features.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X)",
          "documentation": {
            "description": "Back-projection to the original space.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data used to scale along the features axis. If a sparse\n            matrix is provided, it will be converted into a sparse\n            ``csc_matrix``. Additionally, the sparse matrix needs to be\n            nonnegative if `ignore_implicit_zeros` is False.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "projected data.",
                "description": ""
              },
              "matrix": {
                "type": "is provided, it will be converted into a sparse",
                "description": "``csc_matrix``. Additionally, the sparse matrix needs to be"
              },
              "nonnegative": {
                "type": "if `ignore_implicit_zeros` is False.",
                "description": "Returns\n-------"
              },
              "Xt": {
                "type": "{ndarray, sparse matrix} of (n_samples, n_features)",
                "description": ""
              }
            },
            "returns": "-------\n        Xt : {ndarray, sparse matrix} of (n_samples, n_features)\n            The projected data.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Feature-wise transformation of the data.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data used to scale along the features axis. If a sparse\n            matrix is provided, it will be converted into a sparse\n            ``csc_matrix``. Additionally, the sparse matrix needs to be\n            nonnegative if `ignore_implicit_zeros` is False.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "projected data.",
                "description": ""
              },
              "matrix": {
                "type": "is provided, it will be converted into a sparse",
                "description": "``csc_matrix``. Additionally, the sparse matrix needs to be"
              },
              "nonnegative": {
                "type": "if `ignore_implicit_zeros` is False.",
                "description": "Returns\n-------"
              },
              "Xt": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
                "description": ""
              }
            },
            "returns": "-------\n        Xt : {ndarray, sparse matrix} of shape (n_samples, n_features)\n            The projected data.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "RobustScaler",
      "documentation": {
        "description": "Scale features using statistics that are robust to outliers.\n\n    This Scaler removes the median and scales the data according to\n    the quantile range (defaults to IQR: Interquartile Range).\n    The IQR is the range between the 1st quartile (25th quantile)\n    and the 3rd quartile (75th quantile).\n\n    Centering and scaling happen independently on each feature by\n    computing the relevant statistics on the samples in the training\n    set. Median and interquartile range are then stored to be used on\n    later data using the :meth:`transform` method.\n\n    Standardization of a dataset is a common preprocessing for many machine\n    learning estimators. Typically this is done by removing the mean and\n    scaling to unit variance. However, outliers can often influence the sample\n    mean / variance in a negative way. In such cases, using the median and the\n    interquartile range often give better results. For an example visualization\n    and comparison to other scalers, refer to :ref:`Compare RobustScaler with\n    other scalers <plot_all_scaling_robust_scaler_section>`.\n\n    .. versionadded:: 0.17\n\n    Read more in the :ref:`User Guide <preprocessing_scaler>`.\n\n    Parameters\n    ----------\n    with_centering : bool, default=True\n        If `True`, center the data before scaling.\n        This will cause :meth:`transform` to raise an exception when attempted\n        on sparse matrices, because centering them entails building a dense\n        matrix which in common use cases is likely to be too large to fit in\n        memory.\n\n    with_scaling : bool, default=True\n        If `True`, scale the data to interquartile range.\n\n    quantile_range : tuple (q_min, q_max), 0.0 < q_min < q_max < 100.0,         default=(25.0, 75.0)\n        Quantile range used to calculate `scale_`. By default this is equal to\n        the IQR, i.e., `q_min` is the first quantile and `q_max` is the third\n        quantile.\n\n        .. versionadded:: 0.18\n\n    copy : bool, default=True\n        If `False`, try to avoid a copy and do inplace scaling instead.\n        This is not guaranteed to always work inplace; e.g. if the data is\n        not a NumPy array or scipy.sparse CSR matrix, a copy may still be\n        returned.\n\n    unit_variance : bool, default=False\n        If `True`, scale data so that normally distributed features have a\n        variance of 1. In general, if the difference between the x-values of\n        `q_max` and `q_min` for a standard normal distribution is greater\n        than 1, the dataset will be scaled down. If less than 1, the dataset\n        will be scaled up.\n\n        .. versionadded:: 0.24\n\n    Attributes\n    ----------\n    center_ : array of floats\n        The median value for each feature in the training set.\n\n    scale_ : array of floats\n        The (scaled) interquartile range for each feature in the training set.\n\n        .. versionadded:: 0.17\n           *scale_* attribute.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    robust_scale : Equivalent function without the estimator API.\n    sklearn.decomposition.PCA : Further removes the linear correlation across\n        features with 'whiten=True'.\n\n    Notes\n    -----\n\n    https://en.wikipedia.org/wiki/Median\n    https://en.wikipedia.org/wiki/Interquartile_range",
        "parameters": {
          "with_centering": {
            "type": "bool, default=True",
            "description": ""
          },
          "If": {
            "type": "`True`, scale data so that normally distributed features have a",
            "description": ""
          },
          "This": {
            "type": "is not guaranteed to always work inplace; e.g. if the data is",
            "description": ""
          },
          "on": {
            "type": "sparse matrices, because centering them entails building a dense",
            "description": ""
          },
          "matrix": {
            "type": "which in common use cases is likely to be too large to fit in",
            "description": "memory."
          },
          "with_scaling": {
            "type": "bool, default=True",
            "description": ""
          },
          "quantile_range": {
            "type": "tuple (q_min, q_max), 0.0 < q_min < q_max < 100.0,         default=(25.0, 75.0)",
            "description": ""
          },
          "Quantile": {
            "type": "range used to calculate `scale_`. By default this is equal to",
            "description": ""
          },
          "the": {
            "type": "IQR, i.e., `q_min` is the first quantile and `q_max` is the third",
            "description": "quantile.\n.. versionadded:: 0.18"
          },
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "not": {
            "type": "a NumPy array or scipy.sparse CSR matrix, a copy may still be",
            "description": "returned."
          },
          "unit_variance": {
            "type": "bool, default=False",
            "description": ""
          },
          "variance": {
            "type": "of 1. In general, if the difference between the x-values of",
            "description": "`q_max` and `q_min` for a standard normal distribution is greater"
          },
          "than": {
            "type": "1, the dataset will be scaled down. If less than 1, the dataset",
            "description": ""
          },
          "will": {
            "type": "be scaled up.",
            "description": ".. versionadded:: 0.24\nAttributes\n----------"
          },
          "center_": {
            "type": "array of floats",
            "description": ""
          },
          "The": {
            "type": "scaled",
            "description": "interquartile range for each feature in the training set.\n.. versionadded:: 0.17\n*scale_* attribute."
          },
          "scale_": {
            "type": "array of floats",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 0.24"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "robust_scale": {
            "type": "Equivalent function without the estimator API.",
            "description": "sklearn.decomposition.PCA : Further removes the linear correlation across"
          },
          "features": {
            "type": "with 'whiten=True'.",
            "description": "Notes\n-----"
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Interquartile_range",
            "description": "Examples\n--------\n>>> from sklearn.preprocessing import RobustScaler\n>>> X = [[ 1., -2.,  2.],\n...      [ -2.,  1.,  3.],\n...      [ 4.,  1., -2.]]\n>>> transformer = RobustScaler().fit(X)\n>>> transformer"
          },
          "RobustScaler": {
            "type": "",
            "description": ">>> transformer.transform(X)\narray([[ 0. , -2. ,  0. ],\n[-1. ,  0. ,  0.4],\n[ 1. ,  0. , -1.6]])"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    robust_scale : Equivalent function without the estimator API.\n    sklearn.decomposition.PCA : Further removes the linear correlation across\n        features with 'whiten=True'.\n\n    Notes\n    -----\n\n    https://en.wikipedia.org/wiki/Median\n    https://en.wikipedia.org/wiki/Interquartile_range\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import RobustScaler\n    >>> X = [[ 1., -2.,  2.],\n    ...      [ -2.,  1.,  3.],\n    ...      [ 4.,  1., -2.]]\n    >>> transformer = RobustScaler().fit(X)\n    >>> transformer\n    RobustScaler()\n    >>> transformer.transform(X)\n    array([[ 0. , -2. ,  0. ],\n           [-1. ,  0. ,  0.4],\n           [ 1. ,  0. , -1.6]])",
        "notes": "-----\n\n    https://en.wikipedia.org/wiki/Median\n    https://en.wikipedia.org/wiki/Interquartile_range\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import RobustScaler\n    >>> X = [[ 1., -2.,  2.],\n    ...      [ -2.,  1.,  3.],\n    ...      [ 4.,  1., -2.]]\n    >>> transformer = RobustScaler().fit(X)\n    >>> transformer\n    RobustScaler()\n    >>> transformer.transform(X)\n    array([[ 0. , -2. ,  0. ],\n           [-1. ,  0. ,  0.4],\n           [ 1. ,  0. , -1.6]])",
        "examples": "--------\n    >>> from sklearn.preprocessing import RobustScaler\n    >>> X = [[ 1., -2.,  2.],\n    ...      [ -2.,  1.,  3.],\n    ...      [ 4.,  1., -2.]]\n    >>> transformer = RobustScaler().fit(X)\n    >>> transformer\n    RobustScaler()\n    >>> transformer.transform(X)\n    array([[ 0. , -2. ,  0. ],\n           [-1. ,  0. ,  0.4],\n           [ 1. ,  0. , -1.6]])"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None)",
          "documentation": {
            "description": "Compute the median and quantiles to be used for scaling.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data used to compute the median and quantiles\n            used for later scaling along the features axis.\n\n        y : Ignored\n            Not used, present here for API consistency by convention.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data used to compute the median and quantiles",
                "description": ""
              },
              "used": {
                "type": "for later scaling along the features axis.",
                "description": ""
              },
              "y": {
                "type": "Ignored",
                "description": ""
              },
              "Not": {
                "type": "used, present here for API consistency by convention.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "scaler.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted scaler.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input features.\n\n            - If `input_features` is `None`, then `feature_names_in_` is\n              used as feature names in. If `feature_names_in_` is not defined,\n              then the following input feature names are generated:\n              `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            - If `input_features` is an array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "features.",
                "description": "- If `input_features` is `None`, then `feature_names_in_` is"
              },
              "used": {
                "type": "as feature names in. If `feature_names_in_` is not defined,",
                "description": ""
              },
              "then": {
                "type": "the following input feature names are generated:",
                "description": "`[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Same": {
                "type": "as input features.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Same as input features.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X)",
          "documentation": {
            "description": "Scale back the data to the original representation.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The rescaled data to be transformed back.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "rescaled data to be transformed back.",
                "description": "Returns\n-------"
              },
              "X_tr": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Center and scale the data.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data used to scale along the specified axis.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data used to scale along the specified axis.",
                "description": "Returns\n-------"
              },
              "X_tr": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "SplineTransformer",
      "documentation": {
        "description": "Generate univariate B-spline bases for features.\n\n    Generate a new feature matrix consisting of\n    `n_splines=n_knots + degree - 1` (`n_knots - 1` for\n    `extrapolation=\"periodic\"`) spline basis functions\n    (B-splines) of polynomial order=`degree` for each feature.\n\n    In order to learn more about the SplineTransformer class go to:\n    :ref:`sphx_glr_auto_examples_applications_plot_cyclical_feature_engineering.py`\n\n    Read more in the :ref:`User Guide <spline_transformer>`.\n\n    .. versionadded:: 1.0\n\n    Parameters\n    ----------\n    n_knots : int, default=5\n        Number of knots of the splines if `knots` equals one of\n        {'uniform', 'quantile'}. Must be larger or equal 2. Ignored if `knots`\n        is array-like.\n\n    degree : int, default=3\n        The polynomial degree of the spline basis. Must be a non-negative\n        integer.\n\n    knots : {'uniform', 'quantile'} or array-like of shape         (n_knots, n_features), default='uniform'\n        Set knot positions such that first knot <= features <= last knot.\n\n        - If 'uniform', `n_knots` number of knots are distributed uniformly\n          from min to max values of the features.\n        - If 'quantile', they are distributed uniformly along the quantiles of\n          the features.\n        - If an array-like is given, it directly specifies the sorted knot\n          positions including the boundary knots. Note that, internally,\n          `degree` number of knots are added before the first knot, the same\n          after the last knot.\n\n    extrapolation : {'error', 'constant', 'linear', 'continue', 'periodic'},         default='constant'\n        If 'error', values outside the min and max values of the training\n        features raises a `ValueError`. If 'constant', the value of the\n        splines at minimum and maximum value of the features is used as\n        constant extrapolation. If 'linear', a linear extrapolation is used.\n        If 'continue', the splines are extrapolated as is, i.e. option\n        `extrapolate=True` in :class:`scipy.interpolate.BSpline`. If\n        'periodic', periodic splines with a periodicity equal to the distance\n        between the first and last knot are used. Periodic splines enforce\n        equal function values and derivatives at the first and last knot.\n        For example, this makes it possible to avoid introducing an arbitrary\n        jump between Dec 31st and Jan 1st in spline features derived from a\n        naturally periodic \"day-of-year\" input feature. In this case it is\n        recommended to manually set the knot values to control the period.\n\n    include_bias : bool, default=True\n        If False, then the last spline element inside the data range\n        of a feature is dropped. As B-splines sum to one over the spline basis\n        functions for each data point, they implicitly include a bias term,\n        i.e. a column of ones. It acts as an intercept term in a linear models.\n\n    order : {'C', 'F'}, default='C'\n        Order of output array in the dense case. `'F'` order is faster to compute, but\n        may slow down subsequent estimators.\n\n    sparse_output : bool, default=False\n        Will return sparse CSR matrix if set True else will return an array. This\n        option is only available with `scipy>=1.8`.\n\n        .. versionadded:: 1.2\n\n    Attributes\n    ----------\n    bsplines_ : list of shape (n_features,)\n        List of BSplines objects, one for each feature.\n\n    n_features_in_ : int\n        The total number of input features.\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    n_features_out_ : int\n        The total number of output features, which is computed as\n        `n_features * n_splines`, where `n_splines` is\n        the number of bases elements of the B-splines,\n        `n_knots + degree - 1` for non-periodic splines and\n        `n_knots - 1` for periodic ones.\n        If `include_bias=False`, then it is only\n        `n_features * (n_splines - 1)`.\n\n    See Also\n    --------\n    KBinsDiscretizer : Transformer that bins continuous data into intervals.\n\n    PolynomialFeatures : Transformer that generates polynomial and interaction\n        features.\n\n    Notes\n    -----\n    High degrees and a high number of knots can cause overfitting.\n\n    See :ref:`examples/linear_model/plot_polynomial_interpolation.py\n    <sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py>`.",
        "parameters": {
          "n_knots": {
            "type": "int, default=5",
            "description": ""
          },
          "Number": {
            "type": "of knots of the splines if `knots` equals one of",
            "description": "{'uniform', 'quantile'}. Must be larger or equal 2. Ignored if `knots`"
          },
          "is": {
            "type": "array-like.",
            "description": ""
          },
          "degree": {
            "type": "int, default=3",
            "description": ""
          },
          "The": {
            "type": "total number of output features, which is computed as",
            "description": "`n_features * n_splines`, where `n_splines` is"
          },
          "knots": {
            "type": "{'uniform', 'quantile'} or array",
            "description": "like of shape         (n_knots, n_features), default='uniform'"
          },
          "Set": {
            "type": "knot positions such that first knot <= features <= last knot.",
            "description": "- If 'uniform', `n_knots` number of knots are distributed uniformly"
          },
          "from": {
            "type": "min to max values of the features.",
            "description": "- If 'quantile', they are distributed uniformly along the quantiles of"
          },
          "the": {
            "type": "number of bases elements of the B-splines,",
            "description": "`n_knots + degree - 1` for non-periodic splines and\n`n_knots - 1` for periodic ones."
          },
          "positions": {
            "type": "including the boundary knots. Note that, internally,",
            "description": "`degree` number of knots are added before the first knot, the same"
          },
          "after": {
            "type": "the last knot.",
            "description": ""
          },
          "extrapolation": {
            "type": "{'error', 'constant', 'linear', 'continue', 'periodic'},         default='constant'",
            "description": ""
          },
          "If": {
            "type": "`include_bias=False`, then it is only",
            "description": "`n_features * (n_splines - 1)`."
          },
          "features": {
            "type": "raises a `ValueError`. If 'constant', the value of the",
            "description": ""
          },
          "splines": {
            "type": "at minimum and maximum value of the features is used as",
            "description": ""
          },
          "constant": {
            "type": "extrapolation. If 'linear', a linear extrapolation is used.",
            "description": ""
          },
          "between": {
            "type": "the first and last knot are used. Periodic splines enforce",
            "description": ""
          },
          "equal": {
            "type": "function values and derivatives at the first and last knot.",
            "description": ""
          },
          "For": {
            "type": "example, this makes it possible to avoid introducing an arbitrary",
            "description": ""
          },
          "jump": {
            "type": "between Dec 31st and Jan 1st in spline features derived from a",
            "description": ""
          },
          "naturally": {
            "type": "periodic \"day-of-year\" input feature. In this case it is",
            "description": ""
          },
          "recommended": {
            "type": "to manually set the knot values to control the period.",
            "description": ""
          },
          "include_bias": {
            "type": "bool, default=True",
            "description": ""
          },
          "of": {
            "type": "a feature is dropped. As B-splines sum to one over the spline basis",
            "description": ""
          },
          "functions": {
            "type": "for each data point, they implicitly include a bias term,",
            "description": "i.e. a column of ones. It acts as an intercept term in a linear models."
          },
          "order": {
            "type": "{'C', 'F'}, default='C'",
            "description": ""
          },
          "Order": {
            "type": "of output array in the dense case. `'F'` order is faster to compute, but",
            "description": ""
          },
          "may": {
            "type": "slow down subsequent estimators.",
            "description": ""
          },
          "sparse_output": {
            "type": "bool, default=False",
            "description": ""
          },
          "Will": {
            "type": "return sparse CSR matrix if set True else will return an array. This",
            "description": ""
          },
          "option": {
            "type": "is only available with `scipy>=1.8`.",
            "description": ".. versionadded:: 1.2\nAttributes\n----------"
          },
          "bsplines_": {
            "type": "list of shape (n_features,)",
            "description": ""
          },
          "List": {
            "type": "of BSplines objects, one for each feature.",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "n_features_out_": {
            "type": "int",
            "description": ""
          },
          "See": {
            "type": "ref:`examples/linear_model/plot_polynomial_interpolation.py",
            "description": "<sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py>`.\nExamples\n--------\n>>> import numpy as np\n>>> from sklearn.preprocessing import SplineTransformer\n>>> X = np.arange(6).reshape(6, 1)\n>>> spline = SplineTransformer(degree=2, n_knots=3)\n>>> spline.fit_transform(X)\narray([[0.5 , 0.5 , 0.  , 0.  ],\n[0.18, 0.74, 0.08, 0.  ],\n[0.02, 0.66, 0.32, 0.  ],\n[0.  , 0.32, 0.66, 0.02],\n[0.  , 0.08, 0.74, 0.18],\n[0.  , 0.  , 0.5 , 0.5 ]])"
          },
          "KBinsDiscretizer": {
            "type": "Transformer that bins continuous data into intervals.",
            "description": ""
          },
          "PolynomialFeatures": {
            "type": "Transformer that generates polynomial and interaction",
            "description": "features.\nNotes\n-----"
          },
          "High": {
            "type": "degrees and a high number of knots can cause overfitting.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    KBinsDiscretizer : Transformer that bins continuous data into intervals.\n\n    PolynomialFeatures : Transformer that generates polynomial and interaction\n        features.\n\n    Notes\n    -----\n    High degrees and a high number of knots can cause overfitting.\n\n    See :ref:`examples/linear_model/plot_polynomial_interpolation.py\n    <sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py>`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import SplineTransformer\n    >>> X = np.arange(6).reshape(6, 1)\n    >>> spline = SplineTransformer(degree=2, n_knots=3)\n    >>> spline.fit_transform(X)\n    array([[0.5 , 0.5 , 0.  , 0.  ],\n           [0.18, 0.74, 0.08, 0.  ],\n           [0.02, 0.66, 0.32, 0.  ],\n           [0.  , 0.32, 0.66, 0.02],\n           [0.  , 0.08, 0.74, 0.18],\n           [0.  , 0.  , 0.5 , 0.5 ]])",
        "notes": "-----\n    High degrees and a high number of knots can cause overfitting.\n\n    See :ref:`examples/linear_model/plot_polynomial_interpolation.py\n    <sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py>`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import SplineTransformer\n    >>> X = np.arange(6).reshape(6, 1)\n    >>> spline = SplineTransformer(degree=2, n_knots=3)\n    >>> spline.fit_transform(X)\n    array([[0.5 , 0.5 , 0.  , 0.  ],\n           [0.18, 0.74, 0.08, 0.  ],\n           [0.02, 0.66, 0.32, 0.  ],\n           [0.  , 0.32, 0.66, 0.02],\n           [0.  , 0.08, 0.74, 0.18],\n           [0.  , 0.  , 0.5 , 0.5 ]])",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import SplineTransformer\n    >>> X = np.arange(6).reshape(6, 1)\n    >>> spline = SplineTransformer(degree=2, n_knots=3)\n    >>> spline.fit_transform(X)\n    array([[0.5 , 0.5 , 0.  , 0.  ],\n           [0.18, 0.74, 0.08, 0.  ],\n           [0.02, 0.66, 0.32, 0.  ],\n           [0.  , 0.32, 0.66, 0.02],\n           [0.  , 0.08, 0.74, 0.18],\n           [0.  , 0.  , 0.5 , 0.5 ]])"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None, sample_weight=None)",
          "documentation": {
            "description": "Compute knot positions of splines.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data.\n\n        y : None\n            Ignored.\n\n        sample_weight : array-like of shape (n_samples,), default = None\n            Individual weights for each sample. Used to calculate quantiles if\n            `knots=\"quantile\"`. For `knots=\"uniform\"`, zero weighted\n            observations are ignored for finding the min and max of `X`.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored."
              },
              "sample_weight": {
                "type": "array",
                "description": "like of shape (n_samples,), default = None"
              },
              "Individual": {
                "type": "weights for each sample. Used to calculate quantiles if",
                "description": "`knots=\"quantile\"`. For `knots=\"uniform\"`, zero weighted"
              },
              "observations": {
                "type": "are ignored for finding the min and max of `X`.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "transformer.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted transformer.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input features.\n\n            - If `input_features` is `None`, then `feature_names_in_` is\n              used as feature names in. If `feature_names_in_` is not defined,\n              then the following input feature names are generated:\n              `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            - If `input_features` is an array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "features.",
                "description": "- If `input_features` is `None`, then `feature_names_in_` is"
              },
              "used": {
                "type": "as feature names in. If `feature_names_in_` is not defined,",
                "description": ""
              },
              "then": {
                "type": "the following input feature names are generated:",
                "description": "`[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Transformed": {
                "type": "feature names.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Transformed feature names.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_fit_request",
          "signature": "set_fit_request(self: sklearn.preprocessing._polynomial.SplineTransformer, *, sample_weight: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.preprocessing._polynomial.SplineTransformer",
          "documentation": {
            "description": "Request metadata passed to the ``fit`` method.",
            "parameters": {
              "sample_weight": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``sample_weight`` parameter in ``fit``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``fit`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``fit``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        sample_weight : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``sample_weight`` parameter in ``fit``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Transform each feature data to B-splines.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data to transform.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "matrix of features, where n_splines is the number of bases",
                "description": ""
              },
              "XBS": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features * n_splines)",
                "description": ""
              },
              "elements": {
                "type": "of the B-splines, n_knots + degree - 1.",
                "description": ""
              }
            },
            "returns": "-------\n        XBS : {ndarray, sparse matrix} of shape (n_samples, n_features * n_splines)\n            The matrix of features, where n_splines is the number of bases\n            elements of the B-splines, n_knots + degree - 1.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "StandardScaler",
      "documentation": {
        "description": "Standardize features by removing the mean and scaling to unit variance.\n\n    The standard score of a sample `x` is calculated as:\n\n    .. code-block:: text\n\n        z = (x - u) / s\n\n    where `u` is the mean of the training samples or zero if `with_mean=False`,\n    and `s` is the standard deviation of the training samples or one if\n    `with_std=False`.\n\n    Centering and scaling happen independently on each feature by computing\n    the relevant statistics on the samples in the training set. Mean and\n    standard deviation are then stored to be used on later data using\n    :meth:`transform`.\n\n    Standardization of a dataset is a common requirement for many\n    machine learning estimators: they might behave badly if the\n    individual features do not more or less look like standard normally\n    distributed data (e.g. Gaussian with 0 mean and unit variance).\n\n    For instance many elements used in the objective function of\n    a learning algorithm (such as the RBF kernel of Support Vector\n    Machines or the L1 and L2 regularizers of linear models) assume that\n    all features are centered around 0 and have variance in the same\n    order. If a feature has a variance that is orders of magnitude larger\n    than others, it might dominate the objective function and make the\n    estimator unable to learn from other features correctly as expected.\n\n    `StandardScaler` is sensitive to outliers, and the features may scale\n    differently from each other in the presence of outliers. For an example\n    visualization, refer to :ref:`Compare StandardScaler with other scalers\n    <plot_all_scaling_standard_scaler_section>`.\n\n    This scaler can also be applied to sparse CSR or CSC matrices by passing\n    `with_mean=False` to avoid breaking the sparsity structure of the data.\n\n    Read more in the :ref:`User Guide <preprocessing_scaler>`.\n\n    Parameters\n    ----------\n    copy : bool, default=True\n        If False, try to avoid a copy and do inplace scaling instead.\n        This is not guaranteed to always work inplace; e.g. if the data is\n        not a NumPy array or scipy.sparse CSR matrix, a copy may still be\n        returned.\n\n    with_mean : bool, default=True\n        If True, center the data before scaling.\n        This does not work (and will raise an exception) when attempted on\n        sparse matrices, because centering them entails building a dense\n        matrix which in common use cases is likely to be too large to fit in\n        memory.\n\n    with_std : bool, default=True\n        If True, scale the data to unit variance (or equivalently,\n        unit standard deviation).\n\n    Attributes\n    ----------\n    scale_ : ndarray of shape (n_features,) or None\n        Per feature relative scaling of the data to achieve zero mean and unit\n        variance. Generally this is calculated using `np.sqrt(var_)`. If a\n        variance is zero, we can't achieve unit variance, and the data is left\n        as-is, giving a scaling factor of 1. `scale_` is equal to `None`\n        when `with_std=False`.\n\n        .. versionadded:: 0.17\n           *scale_*\n\n    mean_ : ndarray of shape (n_features,) or None\n        The mean value for each feature in the training set.\n        Equal to ``None`` when ``with_mean=False`` and ``with_std=False``.\n\n    var_ : ndarray of shape (n_features,) or None\n        The variance for each feature in the training set. Used to compute\n        `scale_`. Equal to ``None`` when ``with_mean=False`` and\n        ``with_std=False``.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    n_samples_seen_ : int or ndarray of shape (n_features,)\n        The number of samples processed by the estimator for each feature.\n        If there are no missing samples, the ``n_samples_seen`` will be an\n        integer, otherwise it will be an array of dtype int. If\n        `sample_weights` are used it will be a float (if no missing data)\n        or an array of dtype float that sums the weights seen so far.\n        Will be reset on new calls to fit, but increments across\n        ``partial_fit`` calls.\n\n    See Also\n    --------\n    scale : Equivalent function without the estimator API.\n\n    :class:`~sklearn.decomposition.PCA` : Further removes the linear\n        correlation across features with 'whiten=True'.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    We use a biased estimator for the standard deviation, equivalent to\n    `numpy.std(x, ddof=0)`. Note that the choice of `ddof` is unlikely to\n    affect model performance.",
        "parameters": {
          "copy": {
            "type": "bool, default=True",
            "description": ""
          },
          "If": {
            "type": "there are no missing samples, the ``n_samples_seen`` will be an",
            "description": "integer, otherwise it will be an array of dtype int. If\n`sample_weights` are used it will be a float (if no missing data)"
          },
          "This": {
            "type": "does not work (and will raise an exception) when attempted on",
            "description": ""
          },
          "not": {
            "type": "a NumPy array or scipy.sparse CSR matrix, a copy may still be",
            "description": "returned."
          },
          "with_mean": {
            "type": "bool, default=True",
            "description": ""
          },
          "sparse": {
            "type": "matrices, because centering them entails building a dense",
            "description": ""
          },
          "matrix": {
            "type": "which in common use cases is likely to be too large to fit in",
            "description": "memory."
          },
          "with_std": {
            "type": "bool, default=True",
            "description": ""
          },
          "unit": {
            "type": "standard deviation).",
            "description": "Attributes\n----------"
          },
          "scale_": {
            "type": "ndarray of shape (n_features,) or None",
            "description": ""
          },
          "Per": {
            "type": "feature relative scaling of the data to achieve zero mean and unit",
            "description": "variance. Generally this is calculated using `np.sqrt(var_)`. If a"
          },
          "variance": {
            "type": "is zero, we can't achieve unit variance, and the data is left",
            "description": "as-is, giving a scaling factor of 1. `scale_` is equal to `None`"
          },
          "when": {
            "type": "`with_std=False`.",
            "description": ".. versionadded:: 0.17\n*scale_*"
          },
          "mean_": {
            "type": "ndarray of shape (n_features,) or None",
            "description": ""
          },
          "The": {
            "type": "number of samples processed by the estimator for each feature.",
            "description": ""
          },
          "Equal": {
            "type": "to ``None`` when ``with_mean=False`` and ``with_std=False``.",
            "description": ""
          },
          "var_": {
            "type": "ndarray of shape (n_features,) or None",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 0.24"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "n_samples_seen_": {
            "type": "int or ndarray of shape (n_features,)",
            "description": ""
          },
          "or": {
            "type": "an array of dtype float that sums the weights seen so far.",
            "description": ""
          },
          "Will": {
            "type": "be reset on new calls to fit, but increments across",
            "description": "``partial_fit`` calls."
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "scale": {
            "type": "Equivalent function without the estimator API.",
            "description": ":class:`~sklearn.decomposition.PCA` : Further removes the linear"
          },
          "correlation": {
            "type": "across features with 'whiten=True'.",
            "description": "Notes\n-----"
          },
          "NaNs": {
            "type": "are treated as missing values: disregarded in fit, and maintained in",
            "description": "transform."
          },
          "We": {
            "type": "use a biased estimator for the standard deviation, equivalent to",
            "description": "`numpy.std(x, ddof=0)`. Note that the choice of `ddof` is unlikely to"
          },
          "affect": {
            "type": "model performance.",
            "description": "Examples\n--------\n>>> from sklearn.preprocessing import StandardScaler\n>>> data = [[0, 0], [0, 0], [1, 1], [1, 1]]\n>>> scaler = StandardScaler()\n>>> print(scaler.fit(data))"
          },
          "StandardScaler": {
            "type": "",
            "description": ">>> print(scaler.mean_)\n[0.5 0.5]\n>>> print(scaler.transform(data))\n[[-1. -1.]\n[-1. -1.]\n[ 1.  1.]\n[ 1.  1.]]\n>>> print(scaler.transform([[2, 2]]))\n[[3. 3.]]"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    scale : Equivalent function without the estimator API.\n\n    :class:`~sklearn.decomposition.PCA` : Further removes the linear\n        correlation across features with 'whiten=True'.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    We use a biased estimator for the standard deviation, equivalent to\n    `numpy.std(x, ddof=0)`. Note that the choice of `ddof` is unlikely to\n    affect model performance.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import StandardScaler\n    >>> data = [[0, 0], [0, 0], [1, 1], [1, 1]]\n    >>> scaler = StandardScaler()\n    >>> print(scaler.fit(data))\n    StandardScaler()\n    >>> print(scaler.mean_)\n    [0.5 0.5]\n    >>> print(scaler.transform(data))\n    [[-1. -1.]\n     [-1. -1.]\n     [ 1.  1.]\n     [ 1.  1.]]\n    >>> print(scaler.transform([[2, 2]]))\n    [[3. 3.]]",
        "notes": "-----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    We use a biased estimator for the standard deviation, equivalent to\n    `numpy.std(x, ddof=0)`. Note that the choice of `ddof` is unlikely to\n    affect model performance.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import StandardScaler\n    >>> data = [[0, 0], [0, 0], [1, 1], [1, 1]]\n    >>> scaler = StandardScaler()\n    >>> print(scaler.fit(data))\n    StandardScaler()\n    >>> print(scaler.mean_)\n    [0.5 0.5]\n    >>> print(scaler.transform(data))\n    [[-1. -1.]\n     [-1. -1.]\n     [ 1.  1.]\n     [ 1.  1.]]\n    >>> print(scaler.transform([[2, 2]]))\n    [[3. 3.]]",
        "examples": "--------\n    >>> from sklearn.preprocessing import StandardScaler\n    >>> data = [[0, 0], [0, 0], [1, 1], [1, 1]]\n    >>> scaler = StandardScaler()\n    >>> print(scaler.fit(data))\n    StandardScaler()\n    >>> print(scaler.mean_)\n    [0.5 0.5]\n    >>> print(scaler.transform(data))\n    [[-1. -1.]\n     [-1. -1.]\n     [ 1.  1.]\n     [ 1.  1.]]\n    >>> print(scaler.transform([[2, 2]]))\n    [[3. 3.]]"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y=None, sample_weight=None)",
          "documentation": {
            "description": "Compute the mean and std to be used for later scaling.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data used to compute the mean and standard deviation\n            used for later scaling along the features axis.\n\n        y : None\n            Ignored.\n\n        sample_weight : array-like of shape (n_samples,), default=None\n            Individual weights for each sample.\n\n            .. versionadded:: 0.24\n               parameter *sample_weight* support to StandardScaler.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data used to compute the mean and standard deviation",
                "description": ""
              },
              "used": {
                "type": "for later scaling along the features axis.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored."
              },
              "sample_weight": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "Individual": {
                "type": "weights for each sample.",
                "description": ".. versionadded:: 0.24"
              },
              "parameter": {
                "type": "*sample_weight* support to StandardScaler.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "scaler.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted scaler.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y=None, **fit_params)",
          "documentation": {
            "description": "Fit to data, then transform it.\n\n        Fits transformer to `X` and `y` with optional parameters `fit_params`\n        and returns a transformed version of `X`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input samples.\n\n        y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None\n            Target values (None for unsupervised transformations).\n\n        **fit_params : dict\n            Additional fit parameters.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs),                 default=None"
              },
              "Target": {
                "type": "values (None for unsupervised transformations).",
                "description": "**fit_params : dict"
              },
              "Additional": {
                "type": "fit parameters.",
                "description": "Returns\n-------"
              },
              "X_new": {
                "type": "ndarray array of shape (n_samples, n_features_new)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_new : ndarray array of shape (n_samples, n_features_new)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Input features.\n\n            - If `input_features` is `None`, then `feature_names_in_` is\n              used as feature names in. If `feature_names_in_` is not defined,\n              then the following input feature names are generated:\n              `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            - If `input_features` is an array-like, then `input_features` must\n              match `feature_names_in_` if `feature_names_in_` is defined.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Input": {
                "type": "features.",
                "description": "- If `input_features` is `None`, then `feature_names_in_` is"
              },
              "used": {
                "type": "as feature names in. If `feature_names_in_` is not defined,",
                "description": ""
              },
              "then": {
                "type": "the following input feature names are generated:",
                "description": "`[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must"
              },
              "match": {
                "type": "`feature_names_in_` if `feature_names_in_` is defined.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Same": {
                "type": "as input features.",
                "description": ""
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Same as input features.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X, copy=None)",
          "documentation": {
            "description": "Scale back the data to the original representation.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data used to scale along the features axis.\n        copy : bool, default=None\n            Copy the input X or not.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data used to scale along the features axis.",
                "description": ""
              },
              "copy": {
                "type": "bool, default=None",
                "description": ""
              },
              "Copy": {
                "type": "the input X or not.",
                "description": "Returns\n-------"
              },
              "X_tr": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "partial_fit",
          "signature": "partial_fit(self, X, y=None, sample_weight=None)",
          "documentation": {
            "description": "Online computation of mean and std on X for later scaling.\n\n        All of X is processed as a single batch. This is intended for cases\n        when :meth:`fit` is not feasible due to very large number of\n        `n_samples` or because X is read from a continuous stream.\n\n        The algorithm for incremental mean and std is given in Equation 1.5a,b\n        in Chan, Tony F., Gene H. Golub, and Randall J. LeVeque. \"Algorithms\n        for computing the sample variance: Analysis and recommendations.\"\n        The American Statistician 37.3 (1983): 242-247:\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The data used to compute the mean and standard deviation\n            used for later scaling along the features axis.\n\n        y : None\n            Ignored.\n\n        sample_weight : array-like of shape (n_samples,), default=None\n            Individual weights for each sample.\n\n            .. versionadded:: 0.24\n               parameter *sample_weight* support to StandardScaler.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data used to compute the mean and standard deviation",
                "description": ""
              },
              "used": {
                "type": "for later scaling along the features axis.",
                "description": ""
              },
              "y": {
                "type": "None",
                "description": "Ignored."
              },
              "sample_weight": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "Individual": {
                "type": "weights for each sample.",
                "description": ".. versionadded:: 0.24"
              },
              "parameter": {
                "type": "*sample_weight* support to StandardScaler.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "scaler.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted scaler.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_fit_request",
          "signature": "set_fit_request(self: sklearn.preprocessing._data.StandardScaler, *, sample_weight: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.preprocessing._data.StandardScaler",
          "documentation": {
            "description": "Request metadata passed to the ``fit`` method.",
            "parameters": {
              "sample_weight": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``sample_weight`` parameter in ``fit``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``fit`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``fit``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        sample_weight : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``sample_weight`` parameter in ``fit``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "set_inverse_transform_request",
          "signature": "set_inverse_transform_request(self: sklearn.preprocessing._data.StandardScaler, *, copy: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.preprocessing._data.StandardScaler",
          "documentation": {
            "description": "Request metadata passed to the ``inverse_transform`` method.",
            "parameters": {
              "copy": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``copy`` parameter in ``inverse_transform``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``inverse_transform`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``inverse_transform``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        copy : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``copy`` parameter in ``inverse_transform``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_partial_fit_request",
          "signature": "set_partial_fit_request(self: sklearn.preprocessing._data.StandardScaler, *, sample_weight: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.preprocessing._data.StandardScaler",
          "documentation": {
            "description": "Request metadata passed to the ``partial_fit`` method.",
            "parameters": {
              "sample_weight": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``sample_weight`` parameter in ``partial_fit``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``partial_fit`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``partial_fit``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        sample_weight : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``sample_weight`` parameter in ``partial_fit``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "set_transform_request",
          "signature": "set_transform_request(self: sklearn.preprocessing._data.StandardScaler, *, copy: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.preprocessing._data.StandardScaler",
          "documentation": {
            "description": "Request metadata passed to the ``transform`` method.",
            "parameters": {
              "copy": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``copy`` parameter in ``transform``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``transform`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``transform``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        copy : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``copy`` parameter in ``transform``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X, copy=None)",
          "documentation": {
            "description": "Perform standardization by centering and scaling.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix of shape (n_samples, n_features)\n            The data used to scale along the features axis.\n        copy : bool, default=None\n            Copy the input X or not.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data used to scale along the features axis.",
                "description": ""
              },
              "copy": {
                "type": "bool, default=None",
                "description": ""
              },
              "Copy": {
                "type": "the input X or not.",
                "description": "Returns\n-------"
              },
              "X_tr": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
                "description": ""
              },
              "Transformed": {
                "type": "array.",
                "description": ""
              }
            },
            "returns": "-------\n        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features)\n            Transformed array.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "TargetEncoder",
      "documentation": {
        "description": "Target Encoder for regression and classification targets.\n\n    Each category is encoded based on a shrunk estimate of the average target\n    values for observations belonging to the category. The encoding scheme mixes\n    the global target mean with the target mean conditioned on the value of the\n    category (see [MIC]_).\n\n    When the target type is \"multiclass\", encodings are based\n    on the conditional probability estimate for each class. The target is first\n    binarized using the \"one-vs-all\" scheme via\n    :class:`~sklearn.preprocessing.LabelBinarizer`, then the average target\n    value for each class and each category is used for encoding, resulting in\n    `n_features` * `n_classes` encoded output features.\n\n    :class:`TargetEncoder` considers missing values, such as `np.nan` or `None`,\n    as another category and encodes them like any other category. Categories\n    that are not seen during :meth:`fit` are encoded with the target mean, i.e.\n    `target_mean_`.\n\n    For a demo on the importance of the `TargetEncoder` internal cross-fitting,\n    see\n    :ref:`sphx_glr_auto_examples_preprocessing_plot_target_encoder_cross_val.py`.\n    For a comparison of different encoders, refer to\n    :ref:`sphx_glr_auto_examples_preprocessing_plot_target_encoder.py`. Read\n    more in the :ref:`User Guide <target_encoder>`.\n\n    .. note::\n        `fit(X, y).transform(X)` does not equal `fit_transform(X, y)` because a\n        :term:`cross fitting` scheme is used in `fit_transform` for encoding.\n        See the :ref:`User Guide <target_encoder>` for details.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    categories : \"auto\" or list of shape (n_features,) of array-like, default=\"auto\"\n        Categories (unique values) per feature:\n\n        - `\"auto\"` : Determine categories automatically from the training data.\n        - list : `categories[i]` holds the categories expected in the i-th column. The\n          passed categories should not mix strings and numeric values within a single\n          feature, and should be sorted in case of numeric values.\n\n        The used categories are stored in the `categories_` fitted attribute.\n\n    target_type : {\"auto\", \"continuous\", \"binary\", \"multiclass\"}, default=\"auto\"\n        Type of target.\n\n        - `\"auto\"` : Type of target is inferred with\n          :func:`~sklearn.utils.multiclass.type_of_target`.\n        - `\"continuous\"` : Continuous target\n        - `\"binary\"` : Binary target\n        - `\"multiclass\"` : Multiclass target\n\n        .. note::\n            The type of target inferred with `\"auto\"` may not be the desired target\n            type used for modeling. For example, if the target consisted of integers\n            between 0 and 100, then :func:`~sklearn.utils.multiclass.type_of_target`\n            will infer the target as `\"multiclass\"`. In this case, setting\n            `target_type=\"continuous\"` will specify the target as a regression\n            problem. The `target_type_` attribute gives the target type used by the\n            encoder.\n\n        .. versionchanged:: 1.4\n           Added the option 'multiclass'.\n\n    smooth : \"auto\" or float, default=\"auto\"\n        The amount of mixing of the target mean conditioned on the value of the\n        category with the global target mean. A larger `smooth` value will put\n        more weight on the global target mean.\n        If `\"auto\"`, then `smooth` is set to an empirical Bayes estimate.\n\n    cv : int, default=5\n        Determines the number of folds in the :term:`cross fitting` strategy used in\n        :meth:`fit_transform`. For classification targets, `StratifiedKFold` is used\n        and for continuous targets, `KFold` is used.\n\n    shuffle : bool, default=True\n        Whether to shuffle the data in :meth:`fit_transform` before splitting into\n        folds. Note that the samples within each split will not be shuffled.\n\n    random_state : int, RandomState instance or None, default=None\n        When `shuffle` is True, `random_state` affects the ordering of the\n        indices, which controls the randomness of each fold. Otherwise, this\n        parameter has no effect.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    Attributes\n    ----------\n    encodings_ : list of shape (n_features,) or (n_features * n_classes) of                     ndarray\n        Encodings learnt on all of `X`.\n        For feature `i`, `encodings_[i]` are the encodings matching the\n        categories listed in `categories_[i]`. When `target_type_` is\n        \"multiclass\", the encoding for feature `i` and class `j` is stored in\n        `encodings_[j + (i * len(classes_))]`. E.g., for 2 features (f) and\n        3 classes (c), encodings are ordered:\n        f0_c0, f0_c1, f0_c2, f1_c0, f1_c1, f1_c2,\n\n    categories_ : list of shape (n_features,) of ndarray\n        The categories of each input feature determined during fitting or\n        specified in `categories`\n        (in order of the features in `X` and corresponding with the output\n        of :meth:`transform`).\n\n    target_type_ : str\n        Type of target.\n\n    target_mean_ : float\n        The overall mean of the target. This value is only used in :meth:`transform`\n        to encode categories.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n    classes_ : ndarray or None\n        If `target_type_` is 'binary' or 'multiclass', holds the label for each class,\n        otherwise `None`.\n\n    See Also\n    --------\n    OrdinalEncoder : Performs an ordinal (integer) encoding of the categorical features.\n        Contrary to TargetEncoder, this encoding is not supervised. Treating the\n        resulting encoding as a numerical features therefore lead arbitrarily\n        ordered values and therefore typically lead to lower predictive performance\n        when used as preprocessing for a classifier or regressor.\n    OneHotEncoder : Performs a one-hot encoding of categorical features. This\n        unsupervised encoding is better suited for low cardinality categorical\n        variables as it generate one new feature per unique category.\n\n    References\n    ----------\n    .. [MIC] :doi:`Micci-Barreca, Daniele. \"A preprocessing scheme for high-cardinality\n       categorical attributes in classification and prediction problems\"\n       SIGKDD Explor. Newsl. 3, 1 (July 2001), 27–32. <10.1145/507533.507538>`",
        "parameters": {
          "categories": {
            "type": "listed in `categories_[i]`. When `target_type_` is",
            "description": "\"multiclass\", the encoding for feature `i` and class `j` is stored in\n`encodings_[j + (i * len(classes_))]`. E.g., for 2 features (f) and"
          },
          "Categories": {
            "type": "unique values",
            "description": "per feature:\n- `\"auto\"` : Determine categories automatically from the training data.\n- list : `categories[i]` holds the categories expected in the i-th column. The"
          },
          "passed": {
            "type": "categories should not mix strings and numeric values within a single",
            "description": "feature, and should be sorted in case of numeric values."
          },
          "The": {
            "type": "overall mean of the target. This value is only used in :meth:`transform`",
            "description": ""
          },
          "target_type": {
            "type": "{\"auto\", \"continuous\", \"binary\", \"multiclass\"}, default=\"auto\"",
            "description": ""
          },
          "Type": {
            "type": "of target.",
            "description": ""
          },
          "type": {
            "type": "used for modeling. For example, if the target consisted of integers",
            "description": ""
          },
          "between": {
            "type": "0 and 100, then :func:`~sklearn.utils.multiclass.type_of_target`",
            "description": ""
          },
          "will": {
            "type": "infer the target as `\"multiclass\"`. In this case, setting",
            "description": "`target_type=\"continuous\"` will specify the target as a regression\nproblem. The `target_type_` attribute gives the target type used by the\nencoder.\n.. versionchanged:: 1.4"
          },
          "Added": {
            "type": "the option 'multiclass'.",
            "description": ""
          },
          "smooth": {
            "type": "\"auto\" or float, default=\"auto\"",
            "description": ""
          },
          "category": {
            "type": "with the global target mean. A larger `smooth` value will put",
            "description": ""
          },
          "more": {
            "type": "weight on the global target mean.",
            "description": ""
          },
          "If": {
            "type": "`target_type_` is 'binary' or 'multiclass', holds the label for each class,",
            "description": ""
          },
          "cv": {
            "type": "int, default=5",
            "description": ""
          },
          "Determines": {
            "type": "the number of folds in the :term:`cross fitting` strategy used in",
            "description": ":meth:`fit_transform`. For classification targets, `StratifiedKFold` is used"
          },
          "and": {
            "type": "for continuous targets, `KFold` is used.",
            "description": ""
          },
          "shuffle": {
            "type": "bool, default=True",
            "description": ""
          },
          "Whether": {
            "type": "to shuffle the data in :meth:`fit_transform` before splitting into",
            "description": "folds. Note that the samples within each split will not be shuffled."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "When": {
            "type": "`shuffle` is True, `random_state` affects the ordering of the",
            "description": "indices, which controls the randomness of each fold. Otherwise, this"
          },
          "parameter": {
            "type": "has no effect.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible output across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "encodings_": {
            "type": "list of shape (n_features,) or (n_features * n_classes) of                     ndarray",
            "description": ""
          },
          "Encodings": {
            "type": "learnt on all of `X`.",
            "description": ""
          },
          "For": {
            "type": "feature `i`, `encodings_[i]` are the encodings matching the",
            "description": ""
          },
          "3": {
            "type": "classes (c), encodings are ordered:",
            "description": "f0_c0, f0_c1, f0_c2, f1_c0, f1_c1, f1_c2,"
          },
          "categories_": {
            "type": "list of shape (n_features,) of ndarray",
            "description": ""
          },
          "specified": {
            "type": "in `categories`",
            "description": "(in order of the features in `X` and corresponding with the output"
          },
          "of": {
            "type": "meth:`transform`).",
            "description": ""
          },
          "target_type_": {
            "type": "str",
            "description": ""
          },
          "target_mean_": {
            "type": "float",
            "description": ""
          },
          "to": {
            "type": "encode categories.",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ""
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ""
          },
          "classes_": {
            "type": "ndarray or None",
            "description": ""
          },
          "otherwise": {
            "type": "`None`.",
            "description": ""
          },
          "OrdinalEncoder": {
            "type": "Performs an ordinal (integer) encoding of the categorical features.",
            "description": ""
          },
          "Contrary": {
            "type": "to TargetEncoder, this encoding is not supervised. Treating the",
            "description": ""
          },
          "resulting": {
            "type": "encoding as a numerical features therefore lead arbitrarily",
            "description": ""
          },
          "ordered": {
            "type": "values and therefore typically lead to lower predictive performance",
            "description": ""
          },
          "when": {
            "type": "used as preprocessing for a classifier or regressor.",
            "description": ""
          },
          "OneHotEncoder": {
            "type": "Performs a one",
            "description": "hot encoding of categorical features. This"
          },
          "unsupervised": {
            "type": "encoding is better suited for low cardinality categorical",
            "description": ""
          },
          "variables": {
            "type": "as it generate one new feature per unique category.",
            "description": "References\n----------\n.. [MIC] :doi:`Micci-Barreca, Daniele. \"A preprocessing scheme for high-cardinality"
          },
          "categorical": {
            "type": "attributes in classification and prediction problems\"",
            "description": ""
          },
          "SIGKDD": {
            "type": "Explor. Newsl. 3, 1 (July 2001), 27–32. <10.1145/507533.507538>`",
            "description": "Examples\n--------"
          },
          "With": {
            "type": "`smooth=\"auto\"`, the smoothing parameter is set to an empirical Bayes estimate:",
            "description": ">>> import numpy as np\n>>> from sklearn.preprocessing import TargetEncoder\n>>> X = np.array([[\"dog\"] * 20 + [\"cat\"] * 30 + [\"snake\"] * 38], dtype=object).T\n>>> y = [90.3] * 5 + [80.1] * 15 + [20.4] * 5 + [20.1] * 25 + [21.2] * 8 + [49] * 30\n>>> enc_auto = TargetEncoder(smooth=\"auto\")\n>>> X_trans = enc_auto.fit_transform(X, y)\n>>> # A high `smooth` parameter puts more weight on global mean on the categorical\n>>> # encodings:\n>>> enc_high_smooth = TargetEncoder(smooth=5000.0).fit(X, y)\n>>> enc_high_smooth.target_mean_\nnp.float64(44...)\n>>> enc_high_smooth.encodings_\n[array([44..., 44..., 44...])]\n>>> # On the other hand, a low `smooth` parameter puts more weight on target\n>>> # conditioned on the value of the categorical:\n>>> enc_low_smooth = TargetEncoder(smooth=1.0).fit(X, y)\n>>> enc_low_smooth.encodings_\n[array([20..., 80..., 43...])]"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    OrdinalEncoder : Performs an ordinal (integer) encoding of the categorical features.\n        Contrary to TargetEncoder, this encoding is not supervised. Treating the\n        resulting encoding as a numerical features therefore lead arbitrarily\n        ordered values and therefore typically lead to lower predictive performance\n        when used as preprocessing for a classifier or regressor.\n    OneHotEncoder : Performs a one-hot encoding of categorical features. This\n        unsupervised encoding is better suited for low cardinality categorical\n        variables as it generate one new feature per unique category.\n\n    References\n    ----------\n    .. [MIC] :doi:`Micci-Barreca, Daniele. \"A preprocessing scheme for high-cardinality\n       categorical attributes in classification and prediction problems\"\n       SIGKDD Explor. Newsl. 3, 1 (July 2001), 27–32. <10.1145/507533.507538>`\n\n    Examples\n    --------\n    With `smooth=\"auto\"`, the smoothing parameter is set to an empirical Bayes estimate:\n\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import TargetEncoder\n    >>> X = np.array([[\"dog\"] * 20 + [\"cat\"] * 30 + [\"snake\"] * 38], dtype=object).T\n    >>> y = [90.3] * 5 + [80.1] * 15 + [20.4] * 5 + [20.1] * 25 + [21.2] * 8 + [49] * 30\n    >>> enc_auto = TargetEncoder(smooth=\"auto\")\n    >>> X_trans = enc_auto.fit_transform(X, y)\n\n    >>> # A high `smooth` parameter puts more weight on global mean on the categorical\n    >>> # encodings:\n    >>> enc_high_smooth = TargetEncoder(smooth=5000.0).fit(X, y)\n    >>> enc_high_smooth.target_mean_\n    np.float64(44...)\n    >>> enc_high_smooth.encodings_\n    [array([44..., 44..., 44...])]\n\n    >>> # On the other hand, a low `smooth` parameter puts more weight on target\n    >>> # conditioned on the value of the categorical:\n    >>> enc_low_smooth = TargetEncoder(smooth=1.0).fit(X, y)\n    >>> enc_low_smooth.encodings_\n    [array([20..., 80..., 43...])]",
        "notes": "",
        "examples": "--------\n    With `smooth=\"auto\"`, the smoothing parameter is set to an empirical Bayes estimate:\n\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import TargetEncoder\n    >>> X = np.array([[\"dog\"] * 20 + [\"cat\"] * 30 + [\"snake\"] * 38], dtype=object).T\n    >>> y = [90.3] * 5 + [80.1] * 15 + [20.4] * 5 + [20.1] * 25 + [21.2] * 8 + [49] * 30\n    >>> enc_auto = TargetEncoder(smooth=\"auto\")\n    >>> X_trans = enc_auto.fit_transform(X, y)\n\n    >>> # A high `smooth` parameter puts more weight on global mean on the categorical\n    >>> # encodings:\n    >>> enc_high_smooth = TargetEncoder(smooth=5000.0).fit(X, y)\n    >>> enc_high_smooth.target_mean_\n    np.float64(44...)\n    >>> enc_high_smooth.encodings_\n    [array([44..., 44..., 44...])]\n\n    >>> # On the other hand, a low `smooth` parameter puts more weight on target\n    >>> # conditioned on the value of the categorical:\n    >>> enc_low_smooth = TargetEncoder(smooth=1.0).fit(X, y)\n    >>> enc_low_smooth.encodings_\n    [array([20..., 80..., 43...])]"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y)",
          "documentation": {
            "description": "Fit the :class:`TargetEncoder` to X and y.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data to determine the categories of each feature.\n\n        y : array-like of shape (n_samples,)\n            The target data used to encode the categories.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "target data used to encode the categories.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Fitted": {
                "type": "encoder.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object\n            Fitted encoder.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit_transform",
          "signature": "fit_transform(self, X, y)",
          "documentation": {
            "description": "Fit :class:`TargetEncoder` and transform X with the target encoding.\n\n        .. note::\n            `fit(X, y).transform(X)` does not equal `fit_transform(X, y)` because a\n            :term:`cross fitting` scheme is used in `fit_transform` for encoding.\n            See the :ref:`User Guide <target_encoder>`. for details.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data to determine the categories of each feature.\n\n        y : array-like of shape (n_samples,)\n            The target data used to encode the categories.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "target data used to encode the categories.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "X_trans": {
                "type": "ndarray of shape (n_samples, n_features) or                     (n_samples, (n_features * n_classes))",
                "description": ""
              },
              "Transformed": {
                "type": "input.",
                "description": ""
              }
            },
            "returns": "-------\n        X_trans : ndarray of shape (n_samples, n_features) or                     (n_samples, (n_features * n_classes))\n            Transformed input.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_feature_names_out",
          "signature": "get_feature_names_out(self, input_features=None)",
          "documentation": {
            "description": "Get output feature names for transformation.\n\n        Parameters\n        ----------\n        input_features : array-like of str or None, default=None\n            Not used, present here for API consistency by convention.",
            "parameters": {
              "input_features": {
                "type": "array",
                "description": "like of str or None, default=None"
              },
              "Not": {
                "type": "used, present here for API consistency by convention.",
                "description": "Returns\n-------"
              },
              "feature_names_out": {
                "type": "ndarray of str objects",
                "description": ""
              },
              "Transformed": {
                "type": "feature names. `feature_names_in_` is used unless it is",
                "description": ""
              },
              "not": {
                "type": "defined, in which case the following input feature names are",
                "description": ""
              },
              "generated": {
                "type": "`[\"x0\", \"x1\", ..., \"x(n_features_in_",
                "description": "1)\"]`."
              },
              "When": {
                "type": "`type_of_target_` is \"multiclass\" the names are of the format",
                "description": "'<feature_name>_<class_name>'."
              }
            },
            "returns": "-------\n        feature_names_out : ndarray of str objects\n            Transformed feature names. `feature_names_in_` is used unless it is\n            not defined, in which case the following input feature names are\n            generated: `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n            When `type_of_target_` is \"multiclass\" the names are of the format\n            '<feature_name>_<class_name>'.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_output",
          "signature": "set_output(self, *, transform=None)",
          "documentation": {
            "description": "Set output container.\n\n        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n        for an example on how to use the API.\n\n        Parameters\n        ----------\n        transform : {\"default\", \"pandas\", \"polars\"}, default=None\n            Configure output of `transform` and `fit_transform`.\n\n            - `\"default\"`: Default output format of a transformer\n            - `\"pandas\"`: DataFrame output\n            - `\"polars\"`: Polars output\n            - `None`: Transform configuration is unchanged\n\n            .. versionadded:: 1.4\n                `\"polars\"` option was added.",
            "parameters": {
              "transform": {
                "type": "{\"default\", \"pandas\", \"polars\"}, default=None",
                "description": ""
              },
              "Configure": {
                "type": "output of `transform` and `fit_transform`.",
                "description": "- `\"default\"`: Default output format of a transformer\n- `\"pandas\"`: DataFrame output\n- `\"polars\"`: Polars output\n- `None`: Transform configuration is unchanged\n.. versionadded:: 1.4\n`\"polars\"` option was added.\nReturns\n-------"
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "Estimator": {
                "type": "instance.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Transform X with the target encoding.\n\n        .. note::\n            `fit(X, y).transform(X)` does not equal `fit_transform(X, y)` because a\n            :term:`cross fitting` scheme is used in `fit_transform` for encoding.\n            See the :ref:`User Guide <target_encoder>`. for details.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data to determine the categories of each feature.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data to determine the categories of each feature.",
                "description": "Returns\n-------"
              },
              "X_trans": {
                "type": "ndarray of shape (n_samples, n_features) or                     (n_samples, (n_features * n_classes))",
                "description": ""
              },
              "Transformed": {
                "type": "input.",
                "description": ""
              }
            },
            "returns": "-------\n        X_trans : ndarray of shape (n_samples, n_features) or                     (n_samples, (n_features * n_classes))\n            Transformed input.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    }
  ]
}