{
  "description": "Semi-supervised learning algorithms.\n\nThese algorithms utilize small amounts of labeled data and large amounts of unlabeled\ndata for classification tasks.",
  "functions": [],
  "classes": [
    {
      "name": "LabelPropagation",
      "documentation": {
        "description": "Label Propagation classifier.\n\n    Read more in the :ref:`User Guide <label_propagation>`.\n\n    Parameters\n    ----------\n    kernel : {'knn', 'rbf'} or callable, default='rbf'\n        String identifier for kernel function to use or the kernel function\n        itself. Only 'rbf' and 'knn' strings are valid inputs. The function\n        passed should take two inputs, each of shape (n_samples, n_features),\n        and return a (n_samples, n_samples) shaped weight matrix.\n\n    gamma : float, default=20\n        Parameter for rbf kernel.\n\n    n_neighbors : int, default=7\n        Parameter for knn kernel which need to be strictly positive.\n\n    max_iter : int, default=1000\n        Change maximum number of iterations allowed.\n\n    tol : float, default=1e-3\n        Convergence tolerance: threshold to consider the system at steady\n        state.\n\n    n_jobs : int, default=None\n        The number of parallel jobs to run.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    Attributes\n    ----------\n    X_ : {array-like, sparse matrix} of shape (n_samples, n_features)\n        Input array.\n\n    classes_ : ndarray of shape (n_classes,)\n        The distinct labels used in classifying instances.\n\n    label_distributions_ : ndarray of shape (n_samples, n_classes)\n        Categorical distribution for each item.\n\n    transduction_ : ndarray of shape (n_samples)\n        Label assigned to each item during :term:`fit`.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    n_iter_ : int\n        Number of iterations run.\n\n    See Also\n    --------\n    LabelSpreading : Alternate label propagation strategy more robust to noise.\n\n    References\n    ----------\n    Xiaojin Zhu and Zoubin Ghahramani. Learning from labeled and unlabeled data\n    with label propagation. Technical Report CMU-CALD-02-107, Carnegie Mellon\n    University, 2002 http://pages.cs.wisc.edu/~jerryzhu/pub/CMU-CALD-02-107.pdf",
        "parameters": {
          "kernel": {
            "type": "{'knn', 'rbf'} or callable, default='rbf'",
            "description": ""
          },
          "String": {
            "type": "identifier for kernel function to use or the kernel function",
            "description": "itself. Only 'rbf' and 'knn' strings are valid inputs. The function"
          },
          "passed": {
            "type": "should take two inputs, each of shape (n_samples, n_features),",
            "description": ""
          },
          "and": {
            "type": "return a (n_samples, n_samples) shaped weight matrix.",
            "description": ""
          },
          "gamma": {
            "type": "float, default=20",
            "description": ""
          },
          "Parameter": {
            "type": "for knn kernel which need to be strictly positive.",
            "description": ""
          },
          "n_neighbors": {
            "type": "int, default=7",
            "description": ""
          },
          "max_iter": {
            "type": "int, default=1000",
            "description": ""
          },
          "Change": {
            "type": "maximum number of iterations allowed.",
            "description": ""
          },
          "tol": {
            "type": "float, default=1e",
            "description": "3"
          },
          "Convergence": {
            "type": "tolerance: threshold to consider the system at steady",
            "description": "state."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": ""
          },
          "The": {
            "type": "distinct labels used in classifying instances.",
            "description": ""
          },
          "for": {
            "type": "more details.",
            "description": "Attributes\n----------"
          },
          "X_": {
            "type": "{array",
            "description": "like, sparse matrix} of shape (n_samples, n_features)"
          },
          "Input": {
            "type": "array.",
            "description": ""
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": ""
          },
          "label_distributions_": {
            "type": "ndarray of shape (n_samples, n_classes)",
            "description": ""
          },
          "Categorical": {
            "type": "distribution for each item.",
            "description": ""
          },
          "transduction_": {
            "type": "ndarray of shape (n_samples)",
            "description": ""
          },
          "Label": {
            "type": "assigned to each item during :term:`fit`.",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of iterations run.",
            "description": ""
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "n_iter_": {
            "type": "int",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "LabelSpreading": {
            "type": "Alternate label propagation strategy more robust to noise.",
            "description": "References\n----------"
          },
          "Xiaojin": {
            "type": "Zhu and Zoubin Ghahramani. Learning from labeled and unlabeled data",
            "description": ""
          },
          "with": {
            "type": "label propagation. Technical Report CMU-CALD-02-107, Carnegie Mellon",
            "description": "University, 2002 http://pages.cs.wisc.edu/~jerryzhu/pub/CMU-CALD-02-107.pdf\nExamples\n--------\n>>> import numpy as np\n>>> from sklearn import datasets\n>>> from sklearn.semi_supervised import LabelPropagation\n>>> label_prop_model = LabelPropagation()\n>>> iris = datasets.load_iris()\n>>> rng = np.random.RandomState(42)\n>>> random_unlabeled_points = rng.rand(len(iris.target)) < 0.3\n>>> labels = np.copy(iris.target)\n>>> labels[random_unlabeled_points] = -1\n>>> label_prop_model.fit(iris.data, labels)"
          },
          "LabelPropagation": {
            "type": "...",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    LabelSpreading : Alternate label propagation strategy more robust to noise.\n\n    References\n    ----------\n    Xiaojin Zhu and Zoubin Ghahramani. Learning from labeled and unlabeled data\n    with label propagation. Technical Report CMU-CALD-02-107, Carnegie Mellon\n    University, 2002 http://pages.cs.wisc.edu/~jerryzhu/pub/CMU-CALD-02-107.pdf\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn import datasets\n    >>> from sklearn.semi_supervised import LabelPropagation\n    >>> label_prop_model = LabelPropagation()\n    >>> iris = datasets.load_iris()\n    >>> rng = np.random.RandomState(42)\n    >>> random_unlabeled_points = rng.rand(len(iris.target)) < 0.3\n    >>> labels = np.copy(iris.target)\n    >>> labels[random_unlabeled_points] = -1\n    >>> label_prop_model.fit(iris.data, labels)\n    LabelPropagation(...)",
        "notes": "",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn import datasets\n    >>> from sklearn.semi_supervised import LabelPropagation\n    >>> label_prop_model = LabelPropagation()\n    >>> iris = datasets.load_iris()\n    >>> rng = np.random.RandomState(42)\n    >>> random_unlabeled_points = rng.rand(len(iris.target)) < 0.3\n    >>> labels = np.copy(iris.target)\n    >>> labels[random_unlabeled_points] = -1\n    >>> label_prop_model.fit(iris.data, labels)\n    LabelPropagation(...)"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y)",
          "documentation": {
            "description": "Fit a semi-supervised label propagation model to X.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Training data, where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n\n        y : array-like of shape (n_samples,)\n            Target class values with unlabeled points marked as -1.\n            All unlabeled samples will be transductively assigned labels\n            internally, which are stored in `transduction_`.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Target": {
                "type": "class values with unlabeled points marked as -1.",
                "description": ""
              },
              "All": {
                "type": "unlabeled samples will be transductively assigned labels",
                "description": "internally, which are stored in `transduction_`.\nReturns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Returns": {
                "type": "the instance itself.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict",
          "signature": "predict(self, X)",
          "documentation": {
            "description": "Perform inductive inference across the model.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data matrix.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data matrix.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "ndarray of shape (n_samples,)",
                "description": ""
              },
              "Predictions": {
                "type": "for input data.",
                "description": ""
              }
            },
            "returns": "-------\n        y : ndarray of shape (n_samples,)\n            Predictions for input data.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_proba",
          "signature": "predict_proba(self, X)",
          "documentation": {
            "description": "Predict probability for each possible outcome.\n\n        Compute the probability estimates for each single sample in X\n        and each possible outcome seen during training (categorical\n        distribution).\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data matrix.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data matrix.",
                "description": "Returns\n-------"
              },
              "probabilities": {
                "type": "ndarray of shape (n_samples, n_classes)",
                "description": ""
              },
              "Normalized": {
                "type": "probability distributions across",
                "description": ""
              },
              "class": {
                "type": "labels.",
                "description": ""
              }
            },
            "returns": "-------\n        probabilities : ndarray of shape (n_samples, n_classes)\n            Normalized probability distributions across\n            class labels.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score",
          "signature": "score(self, X, y, sample_weight=None)",
          "documentation": {
            "description": "",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Test": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs)"
              },
              "True": {
                "type": "labels for `X`.",
                "description": ""
              },
              "sample_weight": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "Sample": {
                "type": "weights.",
                "description": "Returns\n-------"
              },
              "score": {
                "type": "float",
                "description": ""
              },
              "Mean": {
                "type": "accuracy of ``self.predict(X)`` w.r.t. `y`.",
                "description": ""
              }
            },
            "returns": "the mean accuracy on the given test data and labels.\n\n        In multi-label classification, this is the subset accuracy\n        which is a harsh metric since you require for each sample that\n        each label set be correctly predicted.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Test samples.\n\n        y : array-like of shape (n_samples,) or (n_samples, n_outputs)\n            True labels for `X`.\n\n        sample_weight : array-like of shape (n_samples,), default=None\n            Sample weights.\n\n        Returns\n        -------\n        score : float\n            Mean accuracy of ``self.predict(X)`` w.r.t. `y`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_score_request",
          "signature": "set_score_request(self: sklearn.semi_supervised._label_propagation.LabelPropagation, *, sample_weight: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.semi_supervised._label_propagation.LabelPropagation",
          "documentation": {
            "description": "Request metadata passed to the ``score`` method.",
            "parameters": {
              "sample_weight": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``sample_weight`` parameter in ``score``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``score`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``score``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        sample_weight : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``sample_weight`` parameter in ``score``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "LabelSpreading",
      "documentation": {
        "description": "LabelSpreading model for semi-supervised learning.\n\n    This model is similar to the basic Label Propagation algorithm,\n    but uses affinity matrix based on the normalized graph Laplacian\n    and soft clamping across the labels.\n\n    Read more in the :ref:`User Guide <label_propagation>`.\n\n    Parameters\n    ----------\n    kernel : {'knn', 'rbf'} or callable, default='rbf'\n        String identifier for kernel function to use or the kernel function\n        itself. Only 'rbf' and 'knn' strings are valid inputs. The function\n        passed should take two inputs, each of shape (n_samples, n_features),\n        and return a (n_samples, n_samples) shaped weight matrix.\n\n    gamma : float, default=20\n      Parameter for rbf kernel.\n\n    n_neighbors : int, default=7\n      Parameter for knn kernel which is a strictly positive integer.\n\n    alpha : float, default=0.2\n      Clamping factor. A value in (0, 1) that specifies the relative amount\n      that an instance should adopt the information from its neighbors as\n      opposed to its initial label.\n      alpha=0 means keeping the initial label information; alpha=1 means\n      replacing all initial information.\n\n    max_iter : int, default=30\n      Maximum number of iterations allowed.\n\n    tol : float, default=1e-3\n      Convergence tolerance: threshold to consider the system at steady\n      state.\n\n    n_jobs : int, default=None\n        The number of parallel jobs to run.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    Attributes\n    ----------\n    X_ : ndarray of shape (n_samples, n_features)\n        Input array.\n\n    classes_ : ndarray of shape (n_classes,)\n        The distinct labels used in classifying instances.\n\n    label_distributions_ : ndarray of shape (n_samples, n_classes)\n        Categorical distribution for each item.\n\n    transduction_ : ndarray of shape (n_samples,)\n        Label assigned to each item during :term:`fit`.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    n_iter_ : int\n        Number of iterations run.\n\n    See Also\n    --------\n    LabelPropagation : Unregularized graph based semi-supervised learning.\n\n    References\n    ----------\n    `Dengyong Zhou, Olivier Bousquet, Thomas Navin Lal, Jason Weston,\n    Bernhard Schoelkopf. Learning with local and global consistency (2004)\n    <https://citeseerx.ist.psu.edu/doc_view/pid/d74c37aabf2d5cae663007cbd8718175466aea8c>`_",
        "parameters": {
          "kernel": {
            "type": "{'knn', 'rbf'} or callable, default='rbf'",
            "description": ""
          },
          "String": {
            "type": "identifier for kernel function to use or the kernel function",
            "description": "itself. Only 'rbf' and 'knn' strings are valid inputs. The function"
          },
          "passed": {
            "type": "should take two inputs, each of shape (n_samples, n_features),",
            "description": ""
          },
          "and": {
            "type": "return a (n_samples, n_samples) shaped weight matrix.",
            "description": ""
          },
          "gamma": {
            "type": "float, default=20",
            "description": ""
          },
          "Parameter": {
            "type": "for knn kernel which is a strictly positive integer.",
            "description": ""
          },
          "n_neighbors": {
            "type": "int, default=7",
            "description": ""
          },
          "alpha": {
            "type": "float, default=0.2",
            "description": ""
          },
          "Clamping": {
            "type": "factor. A value in (0, 1) that specifies the relative amount",
            "description": ""
          },
          "that": {
            "type": "an instance should adopt the information from its neighbors as",
            "description": ""
          },
          "opposed": {
            "type": "to its initial label.",
            "description": "alpha=0 means keeping the initial label information; alpha=1 means"
          },
          "replacing": {
            "type": "all initial information.",
            "description": ""
          },
          "max_iter": {
            "type": "int, default=30",
            "description": ""
          },
          "Maximum": {
            "type": "number of iterations allowed.",
            "description": ""
          },
          "tol": {
            "type": "float, default=1e",
            "description": "3"
          },
          "Convergence": {
            "type": "tolerance: threshold to consider the system at steady",
            "description": "state."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": ""
          },
          "The": {
            "type": "distinct labels used in classifying instances.",
            "description": ""
          },
          "for": {
            "type": "more details.",
            "description": "Attributes\n----------"
          },
          "X_": {
            "type": "ndarray of shape (n_samples, n_features)",
            "description": ""
          },
          "Input": {
            "type": "array.",
            "description": ""
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": ""
          },
          "label_distributions_": {
            "type": "ndarray of shape (n_samples, n_classes)",
            "description": ""
          },
          "Categorical": {
            "type": "distribution for each item.",
            "description": ""
          },
          "transduction_": {
            "type": "ndarray of shape (n_samples,)",
            "description": ""
          },
          "Label": {
            "type": "assigned to each item during :term:`fit`.",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of iterations run.",
            "description": ""
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "n_iter_": {
            "type": "int",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "LabelPropagation": {
            "type": "Unregularized graph based semi",
            "description": "supervised learning.\nReferences\n----------\n`Dengyong Zhou, Olivier Bousquet, Thomas Navin Lal, Jason Weston,"
          },
          "Bernhard": {
            "type": "Schoelkopf. Learning with local and global consistency (2004)",
            "description": "<https://citeseerx.ist.psu.edu/doc_view/pid/d74c37aabf2d5cae663007cbd8718175466aea8c>`_\nExamples\n--------\n>>> import numpy as np\n>>> from sklearn import datasets\n>>> from sklearn.semi_supervised import LabelSpreading\n>>> label_prop_model = LabelSpreading()\n>>> iris = datasets.load_iris()\n>>> rng = np.random.RandomState(42)\n>>> random_unlabeled_points = rng.rand(len(iris.target)) < 0.3\n>>> labels = np.copy(iris.target)\n>>> labels[random_unlabeled_points] = -1\n>>> label_prop_model.fit(iris.data, labels)"
          },
          "LabelSpreading": {
            "type": "...",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    LabelPropagation : Unregularized graph based semi-supervised learning.\n\n    References\n    ----------\n    `Dengyong Zhou, Olivier Bousquet, Thomas Navin Lal, Jason Weston,\n    Bernhard Schoelkopf. Learning with local and global consistency (2004)\n    <https://citeseerx.ist.psu.edu/doc_view/pid/d74c37aabf2d5cae663007cbd8718175466aea8c>`_\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn import datasets\n    >>> from sklearn.semi_supervised import LabelSpreading\n    >>> label_prop_model = LabelSpreading()\n    >>> iris = datasets.load_iris()\n    >>> rng = np.random.RandomState(42)\n    >>> random_unlabeled_points = rng.rand(len(iris.target)) < 0.3\n    >>> labels = np.copy(iris.target)\n    >>> labels[random_unlabeled_points] = -1\n    >>> label_prop_model.fit(iris.data, labels)\n    LabelSpreading(...)",
        "notes": "",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn import datasets\n    >>> from sklearn.semi_supervised import LabelSpreading\n    >>> label_prop_model = LabelSpreading()\n    >>> iris = datasets.load_iris()\n    >>> rng = np.random.RandomState(42)\n    >>> random_unlabeled_points = rng.rand(len(iris.target)) < 0.3\n    >>> labels = np.copy(iris.target)\n    >>> labels[random_unlabeled_points] = -1\n    >>> label_prop_model.fit(iris.data, labels)\n    LabelSpreading(...)"
      },
      "methods": [
        {
          "name": "fit",
          "signature": "fit(self, X, y)",
          "documentation": {
            "description": "Fit a semi-supervised label propagation model to X.\n\n        The input samples (labeled and unlabeled) are provided by matrix X,\n        and target labels are provided by matrix y. We conventionally apply the\n        label -1 to unlabeled samples in matrix y in a semi-supervised\n        classification.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Training data, where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n\n        y : array-like of shape (n_samples,)\n            Target class values with unlabeled points marked as -1.\n            All unlabeled samples will be transductively assigned labels\n            internally, which are stored in `transduction_`.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Target": {
                "type": "class values with unlabeled points marked as -1.",
                "description": ""
              },
              "All": {
                "type": "unlabeled samples will be transductively assigned labels",
                "description": "internally, which are stored in `transduction_`.\nReturns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "Returns": {
                "type": "the instance itself.",
                "description": ""
              }
            },
            "returns": "-------\n        self : object",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict",
          "signature": "predict(self, X)",
          "documentation": {
            "description": "Perform inductive inference across the model.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data matrix.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data matrix.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "ndarray of shape (n_samples,)",
                "description": ""
              },
              "Predictions": {
                "type": "for input data.",
                "description": ""
              }
            },
            "returns": "-------\n        y : ndarray of shape (n_samples,)\n            Predictions for input data.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_proba",
          "signature": "predict_proba(self, X)",
          "documentation": {
            "description": "Predict probability for each possible outcome.\n\n        Compute the probability estimates for each single sample in X\n        and each possible outcome seen during training (categorical\n        distribution).\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            The data matrix.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "The": {
                "type": "data matrix.",
                "description": "Returns\n-------"
              },
              "probabilities": {
                "type": "ndarray of shape (n_samples, n_classes)",
                "description": ""
              },
              "Normalized": {
                "type": "probability distributions across",
                "description": ""
              },
              "class": {
                "type": "labels.",
                "description": ""
              }
            },
            "returns": "-------\n        probabilities : ndarray of shape (n_samples, n_classes)\n            Normalized probability distributions across\n            class labels.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score",
          "signature": "score(self, X, y, sample_weight=None)",
          "documentation": {
            "description": "",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Test": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs)"
              },
              "True": {
                "type": "labels for `X`.",
                "description": ""
              },
              "sample_weight": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "Sample": {
                "type": "weights.",
                "description": "Returns\n-------"
              },
              "score": {
                "type": "float",
                "description": ""
              },
              "Mean": {
                "type": "accuracy of ``self.predict(X)`` w.r.t. `y`.",
                "description": ""
              }
            },
            "returns": "the mean accuracy on the given test data and labels.\n\n        In multi-label classification, this is the subset accuracy\n        which is a harsh metric since you require for each sample that\n        each label set be correctly predicted.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Test samples.\n\n        y : array-like of shape (n_samples,) or (n_samples, n_outputs)\n            True labels for `X`.\n\n        sample_weight : array-like of shape (n_samples,), default=None\n            Sample weights.\n\n        Returns\n        -------\n        score : float\n            Mean accuracy of ``self.predict(X)`` w.r.t. `y`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_score_request",
          "signature": "set_score_request(self: sklearn.semi_supervised._label_propagation.LabelSpreading, *, sample_weight: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.semi_supervised._label_propagation.LabelSpreading",
          "documentation": {
            "description": "Request metadata passed to the ``score`` method.",
            "parameters": {
              "sample_weight": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``sample_weight`` parameter in ``score``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``score`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``score``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        sample_weight : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``sample_weight`` parameter in ``score``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "SelfTrainingClassifier",
      "documentation": {
        "description": "Self-training classifier.\n\n    This :term:`metaestimator` allows a given supervised classifier to function as a\n    semi-supervised classifier, allowing it to learn from unlabeled data. It\n    does this by iteratively predicting pseudo-labels for the unlabeled data\n    and adding them to the training set.\n\n    The classifier will continue iterating until either max_iter is reached, or\n    no pseudo-labels were added to the training set in the previous iteration.\n\n    Read more in the :ref:`User Guide <self_training>`.\n\n    Parameters\n    ----------\n    estimator : estimator object\n        An estimator object implementing `fit` and `predict_proba`.\n        Invoking the `fit` method will fit a clone of the passed estimator,\n        which will be stored in the `estimator_` attribute.\n\n        .. versionadded:: 1.6\n            `estimator` was added to replace `base_estimator`.\n\n    base_estimator : estimator object\n        An estimator object implementing `fit` and `predict_proba`.\n        Invoking the `fit` method will fit a clone of the passed estimator,\n        which will be stored in the `estimator_` attribute.\n\n        .. deprecated:: 1.6\n            `base_estimator` was deprecated in 1.6 and will be removed in 1.8.\n            Use `estimator` instead.\n\n    threshold : float, default=0.75\n        The decision threshold for use with `criterion='threshold'`.\n        Should be in [0, 1). When using the `'threshold'` criterion, a\n        :ref:`well calibrated classifier <calibration>` should be used.\n\n    criterion : {'threshold', 'k_best'}, default='threshold'\n        The selection criterion used to select which labels to add to the\n        training set. If `'threshold'`, pseudo-labels with prediction\n        probabilities above `threshold` are added to the dataset. If `'k_best'`,\n        the `k_best` pseudo-labels with highest prediction probabilities are\n        added to the dataset. When using the 'threshold' criterion, a\n        :ref:`well calibrated classifier <calibration>` should be used.\n\n    k_best : int, default=10\n        The amount of samples to add in each iteration. Only used when\n        `criterion='k_best'`.\n\n    max_iter : int or None, default=10\n        Maximum number of iterations allowed. Should be greater than or equal\n        to 0. If it is `None`, the classifier will continue to predict labels\n        until no new pseudo-labels are added, or all unlabeled samples have\n        been labeled.\n\n    verbose : bool, default=False\n        Enable verbose output.\n\n    Attributes\n    ----------\n    estimator_ : estimator object\n        The fitted estimator.\n\n    classes_ : ndarray or list of ndarray of shape (n_classes,)\n        Class labels for each output. (Taken from the trained\n        `estimator_`).\n\n    transduction_ : ndarray of shape (n_samples,)\n        The labels used for the final fit of the classifier, including\n        pseudo-labels added during fit.\n\n    labeled_iter_ : ndarray of shape (n_samples,)\n        The iteration in which each sample was labeled. When a sample has\n        iteration 0, the sample was already labeled in the original dataset.\n        When a sample has iteration -1, the sample was not labeled in any\n        iteration.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    n_iter_ : int\n        The number of rounds of self-training, that is the number of times the\n        base estimator is fitted on relabeled variants of the training set.\n\n    termination_condition_ : {'max_iter', 'no_change', 'all_labeled'}\n        The reason that fitting was stopped.\n\n        - `'max_iter'`: `n_iter_` reached `max_iter`.\n        - `'no_change'`: no new labels were predicted.\n        - `'all_labeled'`: all unlabeled samples were labeled before `max_iter`\n          was reached.\n\n    See Also\n    --------\n    LabelPropagation : Label propagation classifier.\n    LabelSpreading : Label spreading model for semi-supervised learning.\n\n    References\n    ----------\n    :doi:`David Yarowsky. 1995. Unsupervised word sense disambiguation rivaling\n    supervised methods. In Proceedings of the 33rd annual meeting on\n    Association for Computational Linguistics (ACL '95). Association for\n    Computational Linguistics, Stroudsburg, PA, USA, 189-196.\n    <10.3115/981658.981684>`",
        "parameters": {
          "estimator": {
            "type": "estimator object",
            "description": ""
          },
          "An": {
            "type": "estimator object implementing `fit` and `predict_proba`.",
            "description": ""
          },
          "Invoking": {
            "type": "the `fit` method will fit a clone of the passed estimator,",
            "description": ""
          },
          "which": {
            "type": "will be stored in the `estimator_` attribute.",
            "description": ".. deprecated:: 1.6\n`base_estimator` was deprecated in 1.6 and will be removed in 1.8."
          },
          "base_estimator": {
            "type": "estimator object",
            "description": ""
          },
          "Use": {
            "type": "`estimator` instead.",
            "description": ""
          },
          "threshold": {
            "type": "float, default=0.75",
            "description": ""
          },
          "The": {
            "type": "reason that fitting was stopped.",
            "description": "- `'max_iter'`: `n_iter_` reached `max_iter`.\n- `'no_change'`: no new labels were predicted.\n- `'all_labeled'`: all unlabeled samples were labeled before `max_iter`"
          },
          "Should": {
            "type": "be in [0, 1). When using the `'threshold'` criterion, a",
            "description": ":ref:`well calibrated classifier <calibration>` should be used."
          },
          "criterion": {
            "type": "{'threshold', 'k_best'}, default='threshold'",
            "description": ""
          },
          "training": {
            "type": "set. If `'threshold'`, pseudo-labels with prediction",
            "description": ""
          },
          "probabilities": {
            "type": "above `threshold` are added to the dataset. If `'k_best'`,",
            "description": ""
          },
          "the": {
            "type": "`k_best` pseudo-labels with highest prediction probabilities are",
            "description": ""
          },
          "added": {
            "type": "to the dataset. When using the 'threshold' criterion, a",
            "description": ":ref:`well calibrated classifier <calibration>` should be used."
          },
          "k_best": {
            "type": "int, default=10",
            "description": ""
          },
          "max_iter": {
            "type": "int or None, default=10",
            "description": ""
          },
          "Maximum": {
            "type": "number of iterations allowed. Should be greater than or equal",
            "description": ""
          },
          "to": {
            "type": "0. If it is `None`, the classifier will continue to predict labels",
            "description": ""
          },
          "until": {
            "type": "no new pseudo-labels are added, or all unlabeled samples have",
            "description": ""
          },
          "been": {
            "type": "labeled.",
            "description": ""
          },
          "verbose": {
            "type": "bool, default=False",
            "description": ""
          },
          "Enable": {
            "type": "verbose output.",
            "description": "Attributes\n----------"
          },
          "estimator_": {
            "type": "estimator object",
            "description": ""
          },
          "classes_": {
            "type": "ndarray or list of ndarray of shape (n_classes,)",
            "description": ""
          },
          "Class": {
            "type": "labels for each output. (Taken from the trained",
            "description": "`estimator_`)."
          },
          "transduction_": {
            "type": "ndarray of shape (n_samples,)",
            "description": ""
          },
          "labeled_iter_": {
            "type": "ndarray of shape (n_samples,)",
            "description": ""
          },
          "iteration": {
            "type": "0, the sample was already labeled in the original dataset.",
            "description": ""
          },
          "When": {
            "type": "a sample has iteration -1, the sample was not labeled in any",
            "description": "iteration."
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`.",
            "description": ".. versionadded:: 0.24"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Defined only when `X`",
            "description": ""
          },
          "has": {
            "type": "feature names that are all strings.",
            "description": ".. versionadded:: 1.0"
          },
          "n_iter_": {
            "type": "int",
            "description": ""
          },
          "base": {
            "type": "estimator is fitted on relabeled variants of the training set.",
            "description": ""
          },
          "termination_condition_": {
            "type": "{'max_iter', 'no_change', 'all_labeled'}",
            "description": ""
          },
          "was": {
            "type": "reached.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "LabelPropagation": {
            "type": "Label propagation classifier.",
            "description": ""
          },
          "LabelSpreading": {
            "type": "Label spreading model for semi",
            "description": "supervised learning.\nReferences\n----------\n:doi:`David Yarowsky. 1995. Unsupervised word sense disambiguation rivaling"
          },
          "supervised": {
            "type": "methods. In Proceedings of the 33rd annual meeting on",
            "description": ""
          },
          "Association": {
            "type": "for Computational Linguistics (ACL '95). Association for",
            "description": ""
          },
          "Computational": {
            "type": "Linguistics, Stroudsburg, PA, USA, 189-196.",
            "description": "<10.3115/981658.981684>`\nExamples\n--------\n>>> import numpy as np\n>>> from sklearn import datasets\n>>> from sklearn.semi_supervised import SelfTrainingClassifier\n>>> from sklearn.svm import SVC\n>>> rng = np.random.RandomState(42)\n>>> iris = datasets.load_iris()\n>>> random_unlabeled_points = rng.rand(iris.target.shape[0]) < 0.3\n>>> iris.target[random_unlabeled_points] = -1\n>>> svc = SVC(probability=True, gamma=\"auto\")\n>>> self_training_model = SelfTrainingClassifier(svc)\n>>> self_training_model.fit(iris.data, iris.target)"
          },
          "SelfTrainingClassifier": {
            "type": "...",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    LabelPropagation : Label propagation classifier.\n    LabelSpreading : Label spreading model for semi-supervised learning.\n\n    References\n    ----------\n    :doi:`David Yarowsky. 1995. Unsupervised word sense disambiguation rivaling\n    supervised methods. In Proceedings of the 33rd annual meeting on\n    Association for Computational Linguistics (ACL '95). Association for\n    Computational Linguistics, Stroudsburg, PA, USA, 189-196.\n    <10.3115/981658.981684>`\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn import datasets\n    >>> from sklearn.semi_supervised import SelfTrainingClassifier\n    >>> from sklearn.svm import SVC\n    >>> rng = np.random.RandomState(42)\n    >>> iris = datasets.load_iris()\n    >>> random_unlabeled_points = rng.rand(iris.target.shape[0]) < 0.3\n    >>> iris.target[random_unlabeled_points] = -1\n    >>> svc = SVC(probability=True, gamma=\"auto\")\n    >>> self_training_model = SelfTrainingClassifier(svc)\n    >>> self_training_model.fit(iris.data, iris.target)\n    SelfTrainingClassifier(...)",
        "notes": "",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn import datasets\n    >>> from sklearn.semi_supervised import SelfTrainingClassifier\n    >>> from sklearn.svm import SVC\n    >>> rng = np.random.RandomState(42)\n    >>> iris = datasets.load_iris()\n    >>> random_unlabeled_points = rng.rand(iris.target.shape[0]) < 0.3\n    >>> iris.target[random_unlabeled_points] = -1\n    >>> svc = SVC(probability=True, gamma=\"auto\")\n    >>> self_training_model = SelfTrainingClassifier(svc)\n    >>> self_training_model.fit(iris.data, iris.target)\n    SelfTrainingClassifier(...)"
      },
      "methods": [
        {
          "name": "decision_function",
          "signature": "decision_function(self, X, **params)",
          "documentation": {
            "description": "Call decision function of the `estimator`.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Array representing the data.\n\n        **params : dict of str -> object\n            Parameters to pass to the underlying estimator's\n            ``decision_function`` method.\n\n            .. versionadded:: 1.6\n                Only available if `enable_metadata_routing=True`,\n                which can be set by using\n                ``sklearn.set_config(enable_metadata_routing=True)``.\n                See :ref:`Metadata Routing User Guide <metadata_routing>` for\n                more details.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Array": {
                "type": "representing the data.",
                "description": "**params : dict of str -> object"
              }
            },
            "returns": "-------\n        y : ndarray of shape (n_samples, n_features)\n            Result of the decision function of the `estimator`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit",
          "signature": "fit(self, X, y, **params)",
          "documentation": {
            "description": "Fit self-training classifier using `X`, `y` as training data.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Array representing the data.\n\n        y : {array-like, sparse matrix} of shape (n_samples,)\n            Array representing the labels. Unlabeled samples should have the\n            label -1.\n\n        **params : dict\n            Parameters to pass to the underlying estimators.\n\n            .. versionadded:: 1.6\n                Only available if `enable_metadata_routing=True`,\n                which can be set by using\n                ``sklearn.set_config(enable_metadata_routing=True)``.\n                See :ref:`Metadata Routing User Guide <metadata_routing>` for\n                more details.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Array": {
                "type": "representing the labels. Unlabeled samples should have the",
                "description": ""
              },
              "y": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples,)"
              },
              "label": {
                "type": "-1.",
                "description": "**params : dict"
              }
            },
            "returns": "-------\n        self : object\n            Fitted estimator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        .. versionadded:: 1.6",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRouter\n            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict",
          "signature": "predict(self, X, **params)",
          "documentation": {
            "description": "Predict the classes of `X`.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Array representing the data.\n\n        **params : dict of str -> object\n            Parameters to pass to the underlying estimator's ``predict`` method.\n\n            .. versionadded:: 1.6\n                Only available if `enable_metadata_routing=True`,\n                which can be set by using\n                ``sklearn.set_config(enable_metadata_routing=True)``.\n                See :ref:`Metadata Routing User Guide <metadata_routing>` for\n                more details.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Array": {
                "type": "representing the data.",
                "description": "**params : dict of str -> object"
              }
            },
            "returns": "-------\n        y : ndarray of shape (n_samples,)\n            Array with predicted labels.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_log_proba",
          "signature": "predict_log_proba(self, X, **params)",
          "documentation": {
            "description": "Predict log probability for each possible outcome.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Array representing the data.\n\n        **params : dict of str -> object\n            Parameters to pass to the underlying estimator's\n            ``predict_log_proba`` method.\n\n            .. versionadded:: 1.6\n                Only available if `enable_metadata_routing=True`,\n                which can be set by using\n                ``sklearn.set_config(enable_metadata_routing=True)``.\n                See :ref:`Metadata Routing User Guide <metadata_routing>` for\n                more details.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Array": {
                "type": "representing the data.",
                "description": "**params : dict of str -> object"
              }
            },
            "returns": "-------\n        y : ndarray of shape (n_samples, n_features)\n            Array with log prediction probabilities.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_proba",
          "signature": "predict_proba(self, X, **params)",
          "documentation": {
            "description": "Predict probability for each possible outcome.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Array representing the data.\n\n        **params : dict of str -> object\n            Parameters to pass to the underlying estimator's\n            ``predict_proba`` method.\n\n            .. versionadded:: 1.6\n                Only available if `enable_metadata_routing=True`,\n                which can be set by using\n                ``sklearn.set_config(enable_metadata_routing=True)``.\n                See :ref:`Metadata Routing User Guide <metadata_routing>` for\n                more details.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Array": {
                "type": "representing the data.",
                "description": "**params : dict of str -> object"
              }
            },
            "returns": "-------\n        y : ndarray of shape (n_samples, n_features)\n            Array with prediction probabilities.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score",
          "signature": "score(self, X, y, **params)",
          "documentation": {
            "description": "Call score on the `estimator`.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Array representing the data.\n\n        y : array-like of shape (n_samples,)\n            Array representing the labels.\n\n        **params : dict of str -> object\n            Parameters to pass to the underlying estimator's ``score`` method.\n\n            .. versionadded:: 1.6\n                Only available if `enable_metadata_routing=True`,\n                which can be set by using\n                ``sklearn.set_config(enable_metadata_routing=True)``.\n                See :ref:`Metadata Routing User Guide <metadata_routing>` for\n                more details.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Array": {
                "type": "representing the labels.",
                "description": "**params : dict of str -> object"
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              }
            },
            "returns": "-------\n        score : float\n            Result of calling score on the `estimator`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    }
  ]
}