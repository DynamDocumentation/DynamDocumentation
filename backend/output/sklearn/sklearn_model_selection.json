{
  "description": "Tools for model selection, such as cross validation and hyper-parameter tuning.",
  "functions": [
    {
      "name": "BaseCrossValidator",
      "signature": "BaseCrossValidator()",
      "docstring": {
        "description": "Base class for all cross-validators.\n\nImplementations must define `_iter_test_masks` or `_iter_test_indices`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "BaseShuffleSplit",
      "signature": "BaseShuffleSplit(n_splits=10, *, test_size=None, train_size=None, random_state=None)",
      "docstring": {
        "description": "Base class for *ShuffleSplit.",
        "parameters": {
          "n_splits": {
            "type": "int, default=10",
            "description": "Number of re-shuffling & splitting iterations."
          },
          "test_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the proportion\n    of the dataset to include in the test split. If int, represents the\n    absolute number of test samples. If None, the value is set to the\n    complement of the train size. If ``train_size`` is also None, it will\n    be set to 0.1."
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the\n    proportion of the dataset to include in the train split. If\n    int, represents the absolute number of train samples. If None,\n    the value is automatically set to the complement of the test size."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the randomness of the training and testing indices produced.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "FixedThresholdClassifier",
      "signature": "FixedThresholdClassifier(estimator, *, threshold='auto', pos_label=None, response_method='auto')",
      "docstring": {
        "description": "Binary classifier that manually sets the decision threshold.\n\nThis classifier allows to change the default decision threshold used for\nconverting posterior probability estimates (i.e. output of `predict_proba`) or\ndecision scores (i.e. output of `decision_function`) into a class label.\n\nHere, the threshold is not optimized and is set to a constant value.\n\nRead more in the :ref:`User Guide <FixedThresholdClassifier>`.\n\n.. versionadded:: 1.5",
        "parameters": {
          "estimator": {
            "type": "estimator instance",
            "description": "The binary classifier, fitted or not, for which we want to optimize\n    the decision threshold used during `predict`."
          },
          "threshold": {
            "type": "{\"auto\"} or float, default=\"auto\"",
            "description": "The decision threshold to use when converting posterior probability estimates\n    (i.e. output of `predict_proba`) or decision scores (i.e. output of\n    `decision_function`) into a class label. When `\"auto\"`, the threshold is set\n    to 0.5 if `predict_proba` is used as `response_method`, otherwise it is set to\n    0 (i.e. the default threshold for `decision_function`)."
          },
          "pos_label": {
            "type": "int, float, bool or str, default=None",
            "description": "The label of the positive class. Used to process the output of the\n    `response_method` method. When `pos_label=None`, if `y_true` is in `{-1, 1}` or\n    `{0, 1}`, `pos_label` is set to 1, otherwise an error will be raised."
          },
          "response_method": {
            "type": "{\"auto\", \"decision_function\", \"predict_proba\"}, default=\"auto\"",
            "description": "Methods by the classifier `estimator` corresponding to the\n    decision function for which we want to find a threshold. It can be:\n\n    * if `\"auto\"`, it will try to invoke `\"predict_proba\"` or `\"decision_function\"`\n      in that order.\n    * otherwise, one of `\"predict_proba\"` or `\"decision_function\"`.\n      If the method is not implemented by the classifier, it will raise an\n      error.\n\nAttributes\n----------"
          },
          "estimator_": {
            "type": "estimator instance",
            "description": "The fitted classifier used when predicting."
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": "The class labels."
          },
          "n_features_in_": {
            "type": "int",
            "description": "Number of features seen during :term:`fit`. Only defined if the\n    underlying estimator exposes such an attribute when fit."
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": "Names of features seen during :term:`fit`. Only defined if the\n    underlying estimator exposes such an attribute when fit."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "sklearn.model_selection.TunedThresholdClassifierCV : Classifier that post-tunes\n    the decision threshold based on some metrics and using cross-validation.\nsklearn.calibration.CalibratedClassifierCV : Estimator that calibrates\n    probabilities.",
        "notes": "",
        "examples": ">>> from sklearn.datasets import make_classification\n>>> from sklearn.linear_model import LogisticRegression\n>>> from sklearn.metrics import confusion_matrix\n>>> from sklearn.model_selection import FixedThresholdClassifier, train_test_split\n>>> X, y = make_classification(\n...     n_samples=1_000, weights=[0.9, 0.1], class_sep=0.8, random_state=42\n... )\n>>> X_train, X_test, y_train, y_test = train_test_split(\n...     X, y, stratify=y, random_state=42\n... )\n>>> classifier = LogisticRegression(random_state=0).fit(X_train, y_train)\n>>> print(confusion_matrix(y_test, classifier.predict(X_test)))\n[[217   7]\n [ 19   7]]\n>>> classifier_other_threshold = FixedThresholdClassifier(\n...     classifier, threshold=0.1, response_method=\"predict_proba\"\n... ).fit(X_train, y_train)\n>>> print(confusion_matrix(y_test, classifier_other_threshold.predict(X_test)))\n[[184  40]\n [  6  20]]"
      }
    },
    {
      "name": "GridSearchCV",
      "signature": "GridSearchCV(estimator, param_grid, *, scoring=None, n_jobs=None, refit=True, cv=None, verbose=0, pre_dispatch='2*n_jobs', error_score=nan, return_train_score=False)",
      "docstring": {
        "description": "Exhaustive search over specified parameter values for an estimator.\n\nImportant members are fit, predict.\n\nGridSearchCV implements a \"fit\" and a \"score\" method.\nIt also implements \"score_samples\", \"predict\", \"predict_proba\",\n\"decision_function\", \"transform\" and \"inverse_transform\" if they are\nimplemented in the estimator used.\n\nThe parameters of the estimator used to apply these methods are optimized\nby cross-validated grid-search over a parameter grid.\n\nRead more in the :ref:`User Guide <grid_search>`.",
        "parameters": {
          "estimator": {
            "type": "estimator object",
            "description": "This is assumed to implement the scikit-learn estimator interface.\n    Either estimator needs to provide a ``score`` function,\n    or ``scoring`` must be passed."
          },
          "param_grid": {
            "type": "dict or list of dictionaries",
            "description": "Dictionary with parameters names (`str`) as keys and lists of\n    parameter settings to try as values, or a list of such\n    dictionaries, in which case the grids spanned by each dictionary\n    in the list are explored. This enables searching over any sequence\n    of parameter settings."
          },
          "scoring": {
            "type": "str, callable, list, tuple or dict, default=None",
            "description": "Strategy to evaluate the performance of the cross-validated model on\n    the test set.\n\n    If `scoring` represents a single score, one can use:\n\n    - a single string (see :ref:`scoring_parameter`);\n    - a callable (see :ref:`scoring_callable`) that returns a single value.\n\n    If `scoring` represents multiple scores, one can use:\n\n    - a list or tuple of unique strings;\n    - a callable returning a dictionary where the keys are the metric\n      names and the values are the metric scores;\n    - a dictionary with metric names as keys and callables as values.\n\n    See :ref:`multimetric_grid_search` for an example."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": "Number of jobs to run in parallel.\n    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n    for more details.\n\n    .. versionchanged:: v0.20\n       `n_jobs` default changed from 1 to None"
          },
          "refit": {
            "type": "bool, str, or callable, default=True",
            "description": "Refit an estimator using the best found parameters on the whole\n    dataset.\n\n    For multiple metric evaluation, this needs to be a `str` denoting the\n    scorer that would be used to find the best parameters for refitting\n    the estimator at the end.\n\n    Where there are considerations other than maximum score in\n    choosing a best estimator, ``refit`` can be set to a function which\n    returns the selected ``best_index_`` given ``cv_results_``. In that\n    case, the ``best_estimator_`` and ``best_params_`` will be set\n    according to the returned ``best_index_`` while the ``best_score_``\n    attribute will not be available.\n\n    The refitted estimator is made available at the ``best_estimator_``\n    attribute and permits using ``predict`` directly on this\n    ``GridSearchCV`` instance.\n\n    Also for multiple metric evaluation, the attributes ``best_index_``,\n    ``best_score_`` and ``best_params_`` will only be available if\n    ``refit`` is set and all of them will be determined w.r.t this specific\n    scorer.\n\n    See ``scoring`` parameter to know more about multiple metric\n    evaluation.\n\n    See :ref:`sphx_glr_auto_examples_model_selection_plot_grid_search_digits.py`\n    to see how to design a custom selection strategy using a callable\n    via `refit`.\n\n    .. versionchanged:: 0.20\n        Support for callable added."
          },
          "cv": {
            "type": "int, cross-validation generator or an iterable, default=None",
            "description": "Determines the cross-validation splitting strategy.\n    Possible inputs for cv are:\n\n    - None, to use the default 5-fold cross validation,\n    - integer, to specify the number of folds in a `(Stratified)KFold`,\n    - :term:`CV splitter`,\n    - An iterable yielding (train, test) splits as arrays of indices.\n\n    For integer/None inputs, if the estimator is a classifier and ``y`` is\n    either binary or multiclass, :class:`StratifiedKFold` is used. In all\n    other cases, :class:`KFold` is used. These splitters are instantiated\n    with `shuffle=False` so the splits will be the same across calls.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here.\n\n    .. versionchanged:: 0.22\n        ``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "verbose": {
            "type": "int",
            "description": "Controls the verbosity: the higher, the more messages.\n\n    - >1 : the computation time for each fold and parameter candidate is\n      displayed;\n    - >2 : the score is also displayed;\n    - >3 : the fold and candidate parameter indexes are also displayed\n      together with the starting time of the computation."
          },
          "pre_dispatch": {
            "type": "int, or str, default='2*n_jobs'",
            "description": "Controls the number of jobs that get dispatched during parallel\n    execution. Reducing this number can be useful to avoid an\n    explosion of memory consumption when more jobs get dispatched\n    than CPUs can process. This parameter can be:\n\n    - None, in which case all the jobs are immediately created and spawned. Use\n      this for lightweight and fast-running jobs, to avoid delays due to on-demand\n      spawning of the jobs\n    - An int, giving the exact number of total jobs that are spawned\n    - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'"
          },
          "error_score": {
            "type": "'raise' or numeric, default=np.nan",
            "description": "Value to assign to the score if an error occurs in estimator fitting.\n    If set to 'raise', the error is raised. If a numeric value is given,\n    FitFailedWarning is raised. This parameter does not affect the refit\n    step, which will always raise the error."
          },
          "return_train_score": {
            "type": "bool, default=False",
            "description": "If ``False``, the ``cv_results_`` attribute will not include training\n    scores.\n    Computing training scores is used to get insights on how different\n    parameter settings impact the overfitting/underfitting trade-off.\n    However computing the scores on the training set can be computationally\n    expensive and is not strictly required to select the parameters that\n    yield the best generalization performance.\n\n    .. versionadded:: 0.19\n\n    .. versionchanged:: 0.21\n        Default value was changed from ``True`` to ``False``\n\nAttributes\n----------"
          },
          "cv_results_": {
            "type": "dict of numpy (masked) ndarrays",
            "description": "A dict with keys as column headers and values as columns, that can be\n    imported into a pandas ``DataFrame``.\n\n    For instance the below given table\n\n    +------------+-----------+------------+-----------------+---+---------+\n    |param_kernel|param_gamma|param_degree|split0_test_score|...|rank_t...|\n    +============+===========+============+=================+===+=========+\n    |  'poly'    |     --    |      2     |       0.80      |...|    2    |\n    +------------+-----------+------------+-----------------+---+---------+\n    |  'poly'    |     --    |      3     |       0.70      |...|    4    |\n    +------------+-----------+------------+-----------------+---+---------+\n    |  'rbf'     |     0.1   |     --     |       0.80      |...|    3    |\n    +------------+-----------+------------+-----------------+---+---------+\n    |  'rbf'     |     0.2   |     --     |       0.93      |...|    1    |\n    +------------+-----------+------------+-----------------+---+---------+\n\n    will be represented by a ``cv_results_`` dict of::\n\n        {\n        'param_kernel': masked_array(data = ['poly', 'poly', 'rbf', 'rbf'],\n                                     mask = [False False False False]...)\n        'param_gamma': masked_array(data = [-- -- 0.1 0.2],\n                                    mask = [ True  True False False]...),\n        'param_degree': masked_array(data = [2.0 3.0 -- --],\n                                     mask = [False False  True  True]...),\n        'split0_test_score'  : [0.80, 0.70, 0.80, 0.93],\n        'split1_test_score'  : [0.82, 0.50, 0.70, 0.78],\n        'mean_test_score'    : [0.81, 0.60, 0.75, 0.85],\n        'std_test_score'     : [0.01, 0.10, 0.05, 0.08],\n        'rank_test_score'    : [2, 4, 3, 1],\n        'split0_train_score' : [0.80, 0.92, 0.70, 0.93],\n        'split1_train_score' : [0.82, 0.55, 0.70, 0.87],\n        'mean_train_score'   : [0.81, 0.74, 0.70, 0.90],\n        'std_train_score'    : [0.01, 0.19, 0.00, 0.03],\n        'mean_fit_time'      : [0.73, 0.63, 0.43, 0.49],\n        'std_fit_time'       : [0.01, 0.02, 0.01, 0.01],\n        'mean_score_time'    : [0.01, 0.06, 0.04, 0.04],\n        'std_score_time'     : [0.00, 0.00, 0.00, 0.01],\n        'params'             : [{'kernel': 'poly', 'degree': 2}, ...],\n        }\n\n    NOTE\n\n    The key ``'params'`` is used to store a list of parameter\n    settings dicts for all the parameter candidates.\n\n    The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and\n    ``std_score_time`` are all in seconds.\n\n    For multi-metric evaluation, the scores for all the scorers are\n    available in the ``cv_results_`` dict at the keys ending with that\n    scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\n    above. ('split0_test_precision', 'mean_train_precision' etc.)"
          },
          "best_estimator_": {
            "type": "estimator",
            "description": "Estimator that was chosen by the search, i.e. estimator\n    which gave highest score (or smallest loss if specified)\n    on the left out data. Not available if ``refit=False``.\n\n    See ``refit`` parameter for more information on allowed values."
          },
          "best_score_": {
            "type": "float",
            "description": "Mean cross-validated score of the best_estimator\n\n    For multi-metric evaluation, this is present only if ``refit`` is\n    specified.\n\n    This attribute is not available if ``refit`` is a function."
          },
          "best_params_": {
            "type": "dict",
            "description": "Parameter setting that gave the best results on the hold out data.\n\n    For multi-metric evaluation, this is present only if ``refit`` is\n    specified."
          },
          "best_index_": {
            "type": "int",
            "description": "The index (of the ``cv_results_`` arrays) which corresponds to the best\n    candidate parameter setting.\n\n    The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n    the parameter setting for the best model, that gives the highest\n    mean score (``search.best_score_``).\n\n    For multi-metric evaluation, this is present only if ``refit`` is\n    specified."
          },
          "scorer_": {
            "type": "function or a dict",
            "description": "Scorer function used on the held out data to choose the best\n    parameters for the model.\n\n    For multi-metric evaluation, this attribute holds the validated\n    ``scoring`` dict which maps the scorer key to the scorer callable."
          },
          "n_splits_": {
            "type": "int",
            "description": "The number of cross-validation splits (folds/iterations)."
          },
          "refit_time_": {
            "type": "float",
            "description": "Seconds used for refitting the best model on the whole dataset.\n\n    This is present only if ``refit`` is not False.\n\n    .. versionadded:: 0.20"
          },
          "multimetric_": {
            "type": "bool",
            "description": "Whether or not the scorers compute several metrics."
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": "The classes labels. This is present only if ``refit`` is specified and\n    the underlying estimator is a classifier."
          },
          "n_features_in_": {
            "type": "int",
            "description": "Number of features seen during :term:`fit`. Only defined if\n    `best_estimator_` is defined (see the documentation for the `refit`\n    parameter for more details) and that `best_estimator_` exposes\n    `n_features_in_` when fit.\n\n    .. versionadded:: 0.24"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": "Names of features seen during :term:`fit`. Only defined if\n    `best_estimator_` is defined (see the documentation for the `refit`\n    parameter for more details) and that `best_estimator_` exposes\n    `feature_names_in_` when fit.\n\n    .. versionadded:: 1.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "ParameterGrid : Generates all the combinations of a hyperparameter grid.\ntrain_test_split : Utility function to split the data into a development\n    set usable for fitting a GridSearchCV instance and an evaluation set\n    for its final evaluation.\nsklearn.metrics.make_scorer : Make a scorer from a performance metric or\n    loss function.",
        "notes": "The parameters selected are those that maximize the score of the left out\ndata, unless an explicit score is passed in which case it is used instead.\n\nIf `n_jobs` was set to a value higher than one, the data is copied for each\npoint in the grid (and not `n_jobs` times). This is done for efficiency\nreasons if individual jobs take very little time, but may raise errors if\nthe dataset is large and not enough memory is available.  A workaround in\nthis case is to set `pre_dispatch`. Then, the memory is copied only\n`pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\nn_jobs`.",
        "examples": ">>> from sklearn import svm, datasets\n>>> from sklearn.model_selection import GridSearchCV\n>>> iris = datasets.load_iris()\n>>> parameters = {'kernel':('linear', 'rbf'), 'C':[1, 10]}\n>>> svc = svm.SVC()\n>>> clf = GridSearchCV(svc, parameters)\n>>> clf.fit(iris.data, iris.target)\nGridSearchCV(estimator=SVC(),\n             param_grid={'C': [1, 10], 'kernel': ('linear', 'rbf')})\n>>> sorted(clf.cv_results_.keys())\n['mean_fit_time', 'mean_score_time', 'mean_test_score',...\n 'param_C', 'param_kernel', 'params',...\n 'rank_test_score', 'split0_test_score',...\n 'split2_test_score', ...\n 'std_fit_time', 'std_score_time', 'std_test_score']"
      }
    },
    {
      "name": "GroupKFold",
      "signature": "GroupKFold(n_splits=5, *, shuffle=False, random_state=None)",
      "docstring": {
        "description": "K-fold iterator variant with non-overlapping groups.\n\nEach group will appear exactly once in the test set across all folds (the\nnumber of distinct groups has to be at least equal to the number of folds).\n\nThe folds are approximately balanced in the sense that the number of\nsamples is approximately the same in each test fold when `shuffle` is True.\n\nRead more in the :ref:`User Guide <group_k_fold>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of folds. Must be at least 2.\n\n    .. versionchanged:: 0.22\n        ``n_splits`` default value changed from 3 to 5."
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": "Whether to shuffle the groups before splitting into batches.\n    Note that the samples within each split will not be shuffled.\n\n    .. versionadded:: 1.6"
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "When `shuffle` is True, `random_state` affects the ordering of the\n    indices, which controls the randomness of each fold. Otherwise, this\n    parameter has no effect.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`.\n\n    .. versionadded:: 1.6"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "LeaveOneGroupOut : For splitting the data according to explicit\n    domain-specific stratification of the dataset.\n\nStratifiedKFold : Takes class information into account to avoid building\n    folds with imbalanced class proportions (for binary or multiclass\n    classification tasks).",
        "notes": "Groups appear in an arbitrary order throughout the folds.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import GroupKFold\n>>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])\n>>> y = np.array([1, 2, 3, 4, 5, 6])\n>>> groups = np.array([0, 0, 2, 2, 3, 3])\n>>> group_kfold = GroupKFold(n_splits=2)\n>>> group_kfold.get_n_splits(X, y, groups)\n2\n>>> print(group_kfold)\nGroupKFold(n_splits=2, random_state=None, shuffle=False)\n>>> for i, (train_index, test_index) in enumerate(group_kfold.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\nFold 0:\n  Train: index=[2 3], group=[2 2]\n  Test:  index=[0 1 4 5], group=[0 0 3 3]\nFold 1:\n  Train: index=[0 1 4 5], group=[0 0 3 3]\n  Test:  index=[2 3], group=[2 2]"
      }
    },
    {
      "name": "GroupShuffleSplit",
      "signature": "GroupShuffleSplit(n_splits=5, *, test_size=None, train_size=None, random_state=None)",
      "docstring": {
        "description": "Shuffle-Group(s)-Out cross-validation iterator.\n\nProvides randomized train/test indices to split data according to a\nthird-party provided group. This group information can be used to encode\narbitrary domain specific stratifications of the samples as integers.\n\nFor instance the groups could be the year of collection of the samples\nand thus allow for cross-validation against time-based splits.\n\nThe difference between :class:`LeavePGroupsOut` and ``GroupShuffleSplit`` is that\nthe former generates splits using all subsets of size ``p`` unique groups,\nwhereas ``GroupShuffleSplit`` generates a user-determined number of random\ntest splits, each with a user-determined fraction of unique groups.\n\nFor example, a less computationally intensive alternative to\n``LeavePGroupsOut(p=10)`` would be\n``GroupShuffleSplit(test_size=10, n_splits=100)``.\n\nContrary to other cross-validation strategies, the random splits\ndo not guarantee that test sets across all folds will be mutually exclusive,\nand might include overlapping samples. However, this is still very likely for\nsizeable datasets.\n\nNote: The parameters ``test_size`` and ``train_size`` refer to groups, and\nnot to samples as in :class:`ShuffleSplit`.\n\nRead more in the :ref:`User Guide <group_shuffle_split>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of re-shuffling & splitting iterations."
          },
          "test_size": {
            "type": "float, int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the proportion\n    of groups to include in the test split (rounded up). If int,\n    represents the absolute number of test groups. If None, the value is\n    set to the complement of the train size. If ``train_size`` is also None,\n    it will be set to 0.2."
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the\n    proportion of the groups to include in the train split. If\n    int, represents the absolute number of train groups. If None,\n    the value is automatically set to the complement of the test size."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the randomness of the training and testing indices produced.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "ShuffleSplit : Shuffles samples to create independent test/train sets.\n\nLeavePGroupsOut : Train set leaves out all possible subsets of `p` groups.",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import GroupShuffleSplit\n>>> X = np.ones(shape=(8, 2))\n>>> y = np.ones(shape=(8, 1))\n>>> groups = np.array([1, 1, 2, 2, 2, 3, 3, 3])\n>>> print(groups.shape)\n(8,)\n>>> gss = GroupShuffleSplit(n_splits=2, train_size=.7, random_state=42)\n>>> gss.get_n_splits()\n2\n>>> print(gss)\nGroupShuffleSplit(n_splits=2, random_state=42, test_size=None, train_size=0.7)\n>>> for i, (train_index, test_index) in enumerate(gss.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\nFold 0:\n  Train: index=[2 3 4 5 6 7], group=[2 2 2 3 3 3]\n  Test:  index=[0 1], group=[1 1]\nFold 1:\n  Train: index=[0 1 5 6 7], group=[1 1 3 3 3]\n  Test:  index=[2 3 4], group=[2 2 2]"
      }
    },
    {
      "name": "KFold",
      "signature": "KFold(n_splits=5, *, shuffle=False, random_state=None)",
      "docstring": {
        "description": "K-Fold cross-validator.\n\nProvides train/test indices to split data in train/test sets. Split\ndataset into k consecutive folds (without shuffling by default).\n\nEach fold is then used once as a validation while the k - 1 remaining\nfolds form the training set.\n\nRead more in the :ref:`User Guide <k_fold>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of folds. Must be at least 2.\n\n    .. versionchanged:: 0.22\n        ``n_splits`` default value changed from 3 to 5."
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": "Whether to shuffle the data before splitting into batches.\n    Note that the samples within each split will not be shuffled."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "When `shuffle` is True, `random_state` affects the ordering of the\n    indices, which controls the randomness of each fold. Otherwise, this\n    parameter has no effect.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "StratifiedKFold : Takes class information into account to avoid building\n    folds with imbalanced class distributions (for binary or multiclass\n    classification tasks).\n\nGroupKFold : K-fold iterator variant with non-overlapping groups.\n\nRepeatedKFold : Repeats K-Fold n times.",
        "notes": "The first ``n_samples % n_splits`` folds have size\n``n_samples // n_splits + 1``, other folds have size\n``n_samples // n_splits``, where ``n_samples`` is the number of samples.\n\nRandomized CV splitters may return different results for each call of\nsplit. You can make the results identical by setting `random_state`\nto an integer.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import KFold\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([1, 2, 3, 4])\n>>> kf = KFold(n_splits=2)\n>>> kf.get_n_splits(X)\n2\n>>> print(kf)\nKFold(n_splits=2, random_state=None, shuffle=False)\n>>> for i, (train_index, test_index) in enumerate(kf.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[2 3]\n  Test:  index=[0 1]\nFold 1:\n  Train: index=[0 1]\n  Test:  index=[2 3]"
      }
    },
    {
      "name": "LearningCurveDisplay",
      "signature": "LearningCurveDisplay(*, train_sizes, train_scores, test_scores, score_name=None)",
      "docstring": {
        "description": "Learning Curve visualization.\n\nIt is recommended to use\n:meth:`~sklearn.model_selection.LearningCurveDisplay.from_estimator` to\ncreate a :class:`~sklearn.model_selection.LearningCurveDisplay` instance.\nAll parameters are stored as attributes.\n\nRead more in the :ref:`User Guide <visualizations>` for general information\nabout the visualization API and\n:ref:`detailed documentation <learning_curve>` regarding the learning\ncurve visualization.\n\n.. versionadded:: 1.2",
        "parameters": {
          "train_sizes": {
            "type": "ndarray of shape (n_unique_ticks,)",
            "description": "Numbers of training examples that has been used to generate the\n    learning curve."
          },
          "train_scores": {
            "type": "ndarray of shape (n_ticks, n_cv_folds)",
            "description": "Scores on training sets."
          },
          "test_scores": {
            "type": "ndarray of shape (n_ticks, n_cv_folds)",
            "description": "Scores on test set."
          },
          "score_name": {
            "type": "str, default=None",
            "description": "The name of the score used in `learning_curve`. It will override the name\n    inferred from the `scoring` parameter. If `score` is `None`, we use `\"Score\"` if\n    `negate_score` is `False` and `\"Negative score\"` otherwise. If `scoring` is a\n    string or a callable, we infer the name. We replace `_` by spaces and capitalize\n    the first letter. We remove `neg_` and replace it by `\"Negative\"` if\n    `negate_score` is `False` or just remove it otherwise.\n\nAttributes\n----------"
          },
          "ax_": {
            "type": "matplotlib Axes",
            "description": "Axes with the learning curve."
          },
          "figure_": {
            "type": "matplotlib Figure",
            "description": "Figure containing the learning curve."
          },
          "errorbar_": {
            "type": "list of matplotlib Artist or None",
            "description": "When the `std_display_style` is `\"errorbar\"`, this is a list of\n    `matplotlib.container.ErrorbarContainer` objects. If another style is\n    used, `errorbar_` is `None`."
          },
          "lines_": {
            "type": "list of matplotlib Artist or None",
            "description": "When the `std_display_style` is `\"fill_between\"`, this is a list of\n    `matplotlib.lines.Line2D` objects corresponding to the mean train and\n    test scores. If another style is used, `line_` is `None`."
          },
          "fill_between_": {
            "type": "list of matplotlib Artist or None",
            "description": "When the `std_display_style` is `\"fill_between\"`, this is a list of\n    `matplotlib.collections.PolyCollection` objects. If another style is\n    used, `fill_between_` is `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "sklearn.model_selection.learning_curve : Compute the learning curve.",
        "notes": "",
        "examples": ">>> import matplotlib.pyplot as plt\n>>> from sklearn.datasets import load_iris\n>>> from sklearn.model_selection import LearningCurveDisplay, learning_curve\n>>> from sklearn.tree import DecisionTreeClassifier\n>>> X, y = load_iris(return_X_y=True)\n>>> tree = DecisionTreeClassifier(random_state=0)\n>>> train_sizes, train_scores, test_scores = learning_curve(\n...     tree, X, y)\n>>> display = LearningCurveDisplay(train_sizes=train_sizes,\n...     train_scores=train_scores, test_scores=test_scores, score_name=\"Score\")\n>>> display.plot()\n<...>\n>>> plt.show()"
      }
    },
    {
      "name": "LeaveOneGroupOut",
      "signature": "LeaveOneGroupOut()",
      "docstring": {
        "description": "Leave One Group Out cross-validator.\n\nProvides train/test indices to split data such that each training set is\ncomprised of all samples except ones belonging to one specific group.\nArbitrary domain specific group information is provided as an array of integers\nthat encodes the group of each sample.\n\nFor instance the groups could be the year of collection of the samples\nand thus allow for cross-validation against time-based splits.\n\nRead more in the :ref:`User Guide <leave_one_group_out>`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "Splits are ordered according to the index of the group left out. The first\nsplit has testing set consisting of the group whose index in `groups` is\nlowest, and so on.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import LeaveOneGroupOut\n>>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\n>>> y = np.array([1, 2, 1, 2])\n>>> groups = np.array([1, 1, 2, 2])\n>>> logo = LeaveOneGroupOut()\n>>> logo.get_n_splits(X, y, groups)\n2\n>>> logo.get_n_splits(groups=groups)  # 'groups' is always required\n2\n>>> print(logo)\nLeaveOneGroupOut()\n>>> for i, (train_index, test_index) in enumerate(logo.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\nFold 0:\n  Train: index=[2 3], group=[2 2]\n  Test:  index=[0 1], group=[1 1]\nFold 1:\n  Train: index=[0 1], group=[1 1]\n  Test:  index=[2 3], group=[2 2]\n\nSee also\n--------\nGroupKFold: K-fold iterator variant with non-overlapping groups."
      }
    },
    {
      "name": "LeaveOneOut",
      "signature": "LeaveOneOut()",
      "docstring": {
        "description": "Leave-One-Out cross-validator.\n\nProvides train/test indices to split data in train/test sets. Each\nsample is used once as a test set (singleton) while the remaining\nsamples form the training set.\n\nNote: ``LeaveOneOut()`` is equivalent to ``KFold(n_splits=n)`` and\n``LeavePOut(p=1)`` where ``n`` is the number of samples.\n\nDue to the high number of test sets (which is the same as the\nnumber of samples) this cross-validation method can be very costly.\nFor large datasets one should favor :class:`KFold`, :class:`ShuffleSplit`\nor :class:`StratifiedKFold`.\n\nRead more in the :ref:`User Guide <leave_one_out>`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "LeaveOneGroupOut : For splitting the data according to explicit,\n    domain-specific stratification of the dataset.\nGroupKFold : K-fold iterator variant with non-overlapping groups.",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import LeaveOneOut\n>>> X = np.array([[1, 2], [3, 4]])\n>>> y = np.array([1, 2])\n>>> loo = LeaveOneOut()\n>>> loo.get_n_splits(X)\n2\n>>> print(loo)\nLeaveOneOut()\n>>> for i, (train_index, test_index) in enumerate(loo.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[1]\n  Test:  index=[0]\nFold 1:\n  Train: index=[0]\n  Test:  index=[1]"
      }
    },
    {
      "name": "LeavePGroupsOut",
      "signature": "LeavePGroupsOut(n_groups)",
      "docstring": {
        "description": "Leave P Group(s) Out cross-validator.\n\nProvides train/test indices to split data according to a third-party\nprovided group. This group information can be used to encode arbitrary\ndomain specific stratifications of the samples as integers.\n\nFor instance the groups could be the year of collection of the samples\nand thus allow for cross-validation against time-based splits.\n\nThe difference between LeavePGroupsOut and LeaveOneGroupOut is that\nthe former builds the test sets with all the samples assigned to\n``p`` different values of the groups while the latter uses samples\nall assigned the same groups.\n\nRead more in the :ref:`User Guide <leave_p_groups_out>`.",
        "parameters": {
          "n_groups": {
            "type": "int",
            "description": "Number of groups (``p``) to leave out in the test split."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "GroupKFold : K-fold iterator variant with non-overlapping groups.",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import LeavePGroupsOut\n>>> X = np.array([[1, 2], [3, 4], [5, 6]])\n>>> y = np.array([1, 2, 1])\n>>> groups = np.array([1, 2, 3])\n>>> lpgo = LeavePGroupsOut(n_groups=2)\n>>> lpgo.get_n_splits(X, y, groups)\n3\n>>> lpgo.get_n_splits(groups=groups)  # 'groups' is always required\n3\n>>> print(lpgo)\nLeavePGroupsOut(n_groups=2)\n>>> for i, (train_index, test_index) in enumerate(lpgo.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\nFold 0:\n  Train: index=[2], group=[3]\n  Test:  index=[0 1], group=[1 2]\nFold 1:\n  Train: index=[1], group=[2]\n  Test:  index=[0 2], group=[1 3]\nFold 2:\n  Train: index=[0], group=[1]\n  Test:  index=[1 2], group=[2 3]"
      }
    },
    {
      "name": "LeavePOut",
      "signature": "LeavePOut(p)",
      "docstring": {
        "description": "Leave-P-Out cross-validator.\n\nProvides train/test indices to split data in train/test sets. This results\nin testing on all distinct samples of size p, while the remaining n - p\nsamples form the training set in each iteration.\n\nNote: ``LeavePOut(p)`` is NOT equivalent to\n``KFold(n_splits=n_samples // p)`` which creates non-overlapping test sets.\n\nDue to the high number of iterations which grows combinatorically with the\nnumber of samples this cross-validation method can be very costly. For\nlarge datasets one should favor :class:`KFold`, :class:`StratifiedKFold`\nor :class:`ShuffleSplit`.\n\nRead more in the :ref:`User Guide <leave_p_out>`.",
        "parameters": {
          "p": {
            "type": "int",
            "description": "Size of the test sets. Must be strictly less than the number of\n    samples."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import LeavePOut\n>>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\n>>> y = np.array([1, 2, 3, 4])\n>>> lpo = LeavePOut(2)\n>>> lpo.get_n_splits(X)\n6\n>>> print(lpo)\nLeavePOut(p=2)\n>>> for i, (train_index, test_index) in enumerate(lpo.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[2 3]\n  Test:  index=[0 1]\nFold 1:\n  Train: index=[1 3]\n  Test:  index=[0 2]\nFold 2:\n  Train: index=[1 2]\n  Test:  index=[0 3]\nFold 3:\n  Train: index=[0 3]\n  Test:  index=[1 2]\nFold 4:\n  Train: index=[0 2]\n  Test:  index=[1 3]\nFold 5:\n  Train: index=[0 1]\n  Test:  index=[2 3]"
      }
    },
    {
      "name": "ParameterGrid",
      "signature": "ParameterGrid(param_grid)",
      "docstring": {
        "description": "Grid of parameters with a discrete number of values for each.\n\nCan be used to iterate over parameter value combinations with the\nPython built-in function iter.\nThe order of the generated parameter combinations is deterministic.\n\nRead more in the :ref:`User Guide <grid_search>`.",
        "parameters": {
          "param_grid": {
            "type": "dict of str to sequence, or sequence of such",
            "description": "The parameter grid to explore, as a dictionary mapping estimator\n    parameters to sequences of allowed values.\n\n    An empty dict signifies default parameters.\n\n    A sequence of dicts signifies a sequence of grids to search, and is\n    useful to avoid exploring parameter combinations that make no sense\n    or have no effect. See the examples below."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "GridSearchCV : Uses :class:`ParameterGrid` to perform a full parallelized\n    parameter search.",
        "notes": "",
        "examples": ">>> from sklearn.model_selection import ParameterGrid\n>>> param_grid = {'a': [1, 2], 'b': [True, False]}\n>>> list(ParameterGrid(param_grid)) == (\n...    [{'a': 1, 'b': True}, {'a': 1, 'b': False},\n...     {'a': 2, 'b': True}, {'a': 2, 'b': False}])\nTrue\n\n>>> grid = [{'kernel': ['linear']}, {'kernel': ['rbf'], 'gamma': [1, 10]}]\n>>> list(ParameterGrid(grid)) == [{'kernel': 'linear'},\n...                               {'kernel': 'rbf', 'gamma': 1},\n...                               {'kernel': 'rbf', 'gamma': 10}]\nTrue\n>>> ParameterGrid(grid)[1] == {'kernel': 'rbf', 'gamma': 1}\nTrue"
      }
    },
    {
      "name": "ParameterSampler",
      "signature": "ParameterSampler(param_distributions, n_iter, *, random_state=None)",
      "docstring": {
        "description": "Generator on parameters sampled from given distributions.\n\nNon-deterministic iterable over random candidate combinations for hyper-\nparameter search. If all parameters are presented as a list,\nsampling without replacement is performed. If at least one parameter\nis given as a distribution, sampling with replacement is used.\nIt is highly recommended to use continuous distributions for continuous\nparameters.\n\nRead more in the :ref:`User Guide <grid_search>`.",
        "parameters": {
          "param_distributions": {
            "type": "dict",
            "description": "Dictionary with parameters names (`str`) as keys and distributions\n    or lists of parameters to try. Distributions must provide a ``rvs``\n    method for sampling (such as those from scipy.stats.distributions).\n    If a list is given, it is sampled uniformly.\n    If a list of dicts is given, first a dict is sampled uniformly, and\n    then a parameter is sampled using that dict as above."
          },
          "n_iter": {
            "type": "int",
            "description": "Number of parameter settings that are produced."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Pseudo random number generator state used for random uniform sampling\n    from lists of possible values instead of scipy.stats distributions.\n    Pass an int for reproducible output across multiple\n    function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "params : dict of str to any\n    **Yields** dictionaries mapping each estimator parameter to\n    as sampled value.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> from sklearn.model_selection import ParameterSampler\n>>> from scipy.stats.distributions import expon\n>>> import numpy as np\n>>> rng = np.random.RandomState(0)\n>>> param_grid = {'a':[1, 2], 'b': expon()}\n>>> param_list = list(ParameterSampler(param_grid, n_iter=4,\n...                                    random_state=rng))\n>>> rounded_list = [dict((k, round(v, 6)) for (k, v) in d.items())\n...                 for d in param_list]\n>>> rounded_list == [{'b': 0.89856, 'a': 1},\n...                  {'b': 0.923223, 'a': 1},\n...                  {'b': 1.878964, 'a': 2},\n...                  {'b': 1.038159, 'a': 2}]\nTrue"
      }
    },
    {
      "name": "PredefinedSplit",
      "signature": "PredefinedSplit(test_fold)",
      "docstring": {
        "description": "Predefined split cross-validator.\n\nProvides train/test indices to split data into train/test sets using a\npredefined scheme specified by the user with the ``test_fold`` parameter.\n\nRead more in the :ref:`User Guide <predefined_split>`.\n\n.. versionadded:: 0.16",
        "parameters": {
          "test_fold": {
            "type": "array-like of shape (n_samples,)",
            "description": "The entry ``test_fold[i]`` represents the index of the test set that\n    sample ``i`` belongs to. It is possible to exclude sample ``i`` from\n    any test set (i.e. include sample ``i`` in every training set) by\n    setting ``test_fold[i]`` equal to -1."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import PredefinedSplit\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([0, 0, 1, 1])\n>>> test_fold = [0, 1, -1, 1]\n>>> ps = PredefinedSplit(test_fold)\n>>> ps.get_n_splits()\n2\n>>> print(ps)\nPredefinedSplit(test_fold=array([ 0,  1, -1,  1]))\n>>> for i, (train_index, test_index) in enumerate(ps.split()):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[1 2 3]\n  Test:  index=[0]\nFold 1:\n  Train: index=[0 2]\n  Test:  index=[1 3]"
      }
    },
    {
      "name": "RandomizedSearchCV",
      "signature": "RandomizedSearchCV(estimator, param_distributions, *, n_iter=10, scoring=None, n_jobs=None, refit=True, cv=None, verbose=0, pre_dispatch='2*n_jobs', random_state=None, error_score=nan, return_train_score=False)",
      "docstring": {
        "description": "Randomized search on hyper parameters.\n\nRandomizedSearchCV implements a \"fit\" and a \"score\" method.\nIt also implements \"score_samples\", \"predict\", \"predict_proba\",\n\"decision_function\", \"transform\" and \"inverse_transform\" if they are\nimplemented in the estimator used.\n\nThe parameters of the estimator used to apply these methods are optimized\nby cross-validated search over parameter settings.\n\nIn contrast to GridSearchCV, not all parameter values are tried out, but\nrather a fixed number of parameter settings is sampled from the specified\ndistributions. The number of parameter settings that are tried is\ngiven by n_iter.\n\nIf all parameters are presented as a list,\nsampling without replacement is performed. If at least one parameter\nis given as a distribution, sampling with replacement is used.\nIt is highly recommended to use continuous distributions for continuous\nparameters.\n\nRead more in the :ref:`User Guide <randomized_parameter_search>`.\n\n.. versionadded:: 0.14",
        "parameters": {
          "estimator": {
            "type": "estimator object",
            "description": "An object of that type is instantiated for each grid point.\n    This is assumed to implement the scikit-learn estimator interface.\n    Either estimator needs to provide a ``score`` function,\n    or ``scoring`` must be passed."
          },
          "param_distributions": {
            "type": "dict or list of dicts",
            "description": "Dictionary with parameters names (`str`) as keys and distributions\n    or lists of parameters to try. Distributions must provide a ``rvs``\n    method for sampling (such as those from scipy.stats.distributions).\n    If a list is given, it is sampled uniformly.\n    If a list of dicts is given, first a dict is sampled uniformly, and\n    then a parameter is sampled using that dict as above."
          },
          "n_iter": {
            "type": "int, default=10",
            "description": "Number of parameter settings that are sampled. n_iter trades\n    off runtime vs quality of the solution."
          },
          "scoring": {
            "type": "str, callable, list, tuple or dict, default=None",
            "description": "Strategy to evaluate the performance of the cross-validated model on\n    the test set.\n\n    If `scoring` represents a single score, one can use:\n\n    - a single string (see :ref:`scoring_parameter`);\n    - a callable (see :ref:`scoring_callable`) that returns a single value.\n\n    If `scoring` represents multiple scores, one can use:\n\n    - a list or tuple of unique strings;\n    - a callable returning a dictionary where the keys are the metric\n      names and the values are the metric scores;\n    - a dictionary with metric names as keys and callables as values.\n\n    See :ref:`multimetric_grid_search` for an example.\n\n    If None, the estimator's score method is used."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": "Number of jobs to run in parallel.\n    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n    for more details.\n\n    .. versionchanged:: v0.20\n       `n_jobs` default changed from 1 to None"
          },
          "refit": {
            "type": "bool, str, or callable, default=True",
            "description": "Refit an estimator using the best found parameters on the whole\n    dataset.\n\n    For multiple metric evaluation, this needs to be a `str` denoting the\n    scorer that would be used to find the best parameters for refitting\n    the estimator at the end.\n\n    Where there are considerations other than maximum score in\n    choosing a best estimator, ``refit`` can be set to a function which\n    returns the selected ``best_index_`` given the ``cv_results_``. In that\n    case, the ``best_estimator_`` and ``best_params_`` will be set\n    according to the returned ``best_index_`` while the ``best_score_``\n    attribute will not be available.\n\n    The refitted estimator is made available at the ``best_estimator_``\n    attribute and permits using ``predict`` directly on this\n    ``RandomizedSearchCV`` instance.\n\n    Also for multiple metric evaluation, the attributes ``best_index_``,\n    ``best_score_`` and ``best_params_`` will only be available if\n    ``refit`` is set and all of them will be determined w.r.t this specific\n    scorer.\n\n    See ``scoring`` parameter to know more about multiple metric\n    evaluation.\n\n    .. versionchanged:: 0.20\n        Support for callable added."
          },
          "cv": {
            "type": "int, cross-validation generator or an iterable, default=None",
            "description": "Determines the cross-validation splitting strategy.\n    Possible inputs for cv are:\n\n    - None, to use the default 5-fold cross validation,\n    - integer, to specify the number of folds in a `(Stratified)KFold`,\n    - :term:`CV splitter`,\n    - An iterable yielding (train, test) splits as arrays of indices.\n\n    For integer/None inputs, if the estimator is a classifier and ``y`` is\n    either binary or multiclass, :class:`StratifiedKFold` is used. In all\n    other cases, :class:`KFold` is used. These splitters are instantiated\n    with `shuffle=False` so the splits will be the same across calls.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here.\n\n    .. versionchanged:: 0.22\n        ``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "verbose": {
            "type": "int",
            "description": "Controls the verbosity: the higher, the more messages.\n\n    - >1 : the computation time for each fold and parameter candidate is\n      displayed;\n    - >2 : the score is also displayed;\n    - >3 : the fold and candidate parameter indexes are also displayed\n      together with the starting time of the computation."
          },
          "pre_dispatch": {
            "type": "int, or str, default='2*n_jobs'",
            "description": "Controls the number of jobs that get dispatched during parallel\n    execution. Reducing this number can be useful to avoid an\n    explosion of memory consumption when more jobs get dispatched\n    than CPUs can process. This parameter can be:\n\n    - None, in which case all the jobs are immediately created and spawned. Use\n      this for lightweight and fast-running jobs, to avoid delays due to on-demand\n      spawning of the jobs\n    - An int, giving the exact number of total jobs that are spawned\n    - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'"
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Pseudo random number generator state used for random uniform sampling\n    from lists of possible values instead of scipy.stats distributions.\n    Pass an int for reproducible output across multiple\n    function calls.\n    See :term:`Glossary <random_state>`."
          },
          "error_score": {
            "type": "'raise' or numeric, default=np.nan",
            "description": "Value to assign to the score if an error occurs in estimator fitting.\n    If set to 'raise', the error is raised. If a numeric value is given,\n    FitFailedWarning is raised. This parameter does not affect the refit\n    step, which will always raise the error."
          },
          "return_train_score": {
            "type": "bool, default=False",
            "description": "If ``False``, the ``cv_results_`` attribute will not include training\n    scores.\n    Computing training scores is used to get insights on how different\n    parameter settings impact the overfitting/underfitting trade-off.\n    However computing the scores on the training set can be computationally\n    expensive and is not strictly required to select the parameters that\n    yield the best generalization performance.\n\n    .. versionadded:: 0.19\n\n    .. versionchanged:: 0.21\n        Default value was changed from ``True`` to ``False``\n\nAttributes\n----------"
          },
          "cv_results_": {
            "type": "dict of numpy (masked) ndarrays",
            "description": "A dict with keys as column headers and values as columns, that can be\n    imported into a pandas ``DataFrame``.\n\n    For instance the below given table\n\n    +--------------+-------------+-------------------+---+---------------+\n    | param_kernel | param_gamma | split0_test_score |...|rank_test_score|\n    +==============+=============+===================+===+===============+\n    |    'rbf'     |     0.1     |       0.80        |...|       1       |\n    +--------------+-------------+-------------------+---+---------------+\n    |    'rbf'     |     0.2     |       0.84        |...|       3       |\n    +--------------+-------------+-------------------+---+---------------+\n    |    'rbf'     |     0.3     |       0.70        |...|       2       |\n    +--------------+-------------+-------------------+---+---------------+\n\n    will be represented by a ``cv_results_`` dict of::\n\n        {\n        'param_kernel' : masked_array(data = ['rbf', 'rbf', 'rbf'],\n                                      mask = False),\n        'param_gamma'  : masked_array(data = [0.1 0.2 0.3], mask = False),\n        'split0_test_score'  : [0.80, 0.84, 0.70],\n        'split1_test_score'  : [0.82, 0.50, 0.70],\n        'mean_test_score'    : [0.81, 0.67, 0.70],\n        'std_test_score'     : [0.01, 0.24, 0.00],\n        'rank_test_score'    : [1, 3, 2],\n        'split0_train_score' : [0.80, 0.92, 0.70],\n        'split1_train_score' : [0.82, 0.55, 0.70],\n        'mean_train_score'   : [0.81, 0.74, 0.70],\n        'std_train_score'    : [0.01, 0.19, 0.00],\n        'mean_fit_time'      : [0.73, 0.63, 0.43],\n        'std_fit_time'       : [0.01, 0.02, 0.01],\n        'mean_score_time'    : [0.01, 0.06, 0.04],\n        'std_score_time'     : [0.00, 0.00, 0.00],\n        'params'             : [{'kernel' : 'rbf', 'gamma' : 0.1}, ...],\n        }\n\n    NOTE\n\n    The key ``'params'`` is used to store a list of parameter\n    settings dicts for all the parameter candidates.\n\n    The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and\n    ``std_score_time`` are all in seconds.\n\n    For multi-metric evaluation, the scores for all the scorers are\n    available in the ``cv_results_`` dict at the keys ending with that\n    scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\n    above. ('split0_test_precision', 'mean_train_precision' etc.)"
          },
          "best_estimator_": {
            "type": "estimator",
            "description": "Estimator that was chosen by the search, i.e. estimator\n    which gave highest score (or smallest loss if specified)\n    on the left out data. Not available if ``refit=False``.\n\n    For multi-metric evaluation, this attribute is present only if\n    ``refit`` is specified.\n\n    See ``refit`` parameter for more information on allowed values."
          },
          "best_score_": {
            "type": "float",
            "description": "Mean cross-validated score of the best_estimator.\n\n    For multi-metric evaluation, this is not available if ``refit`` is\n    ``False``. See ``refit`` parameter for more information.\n\n    This attribute is not available if ``refit`` is a function."
          },
          "best_params_": {
            "type": "dict",
            "description": "Parameter setting that gave the best results on the hold out data.\n\n    For multi-metric evaluation, this is not available if ``refit`` is\n    ``False``. See ``refit`` parameter for more information."
          },
          "best_index_": {
            "type": "int",
            "description": "The index (of the ``cv_results_`` arrays) which corresponds to the best\n    candidate parameter setting.\n\n    The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n    the parameter setting for the best model, that gives the highest\n    mean score (``search.best_score_``).\n\n    For multi-metric evaluation, this is not available if ``refit`` is\n    ``False``. See ``refit`` parameter for more information."
          },
          "scorer_": {
            "type": "function or a dict",
            "description": "Scorer function used on the held out data to choose the best\n    parameters for the model.\n\n    For multi-metric evaluation, this attribute holds the validated\n    ``scoring`` dict which maps the scorer key to the scorer callable."
          },
          "n_splits_": {
            "type": "int",
            "description": "The number of cross-validation splits (folds/iterations)."
          },
          "refit_time_": {
            "type": "float",
            "description": "Seconds used for refitting the best model on the whole dataset.\n\n    This is present only if ``refit`` is not False.\n\n    .. versionadded:: 0.20"
          },
          "multimetric_": {
            "type": "bool",
            "description": "Whether or not the scorers compute several metrics."
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": "The classes labels. This is present only if ``refit`` is specified and\n    the underlying estimator is a classifier."
          },
          "n_features_in_": {
            "type": "int",
            "description": "Number of features seen during :term:`fit`. Only defined if\n    `best_estimator_` is defined (see the documentation for the `refit`\n    parameter for more details) and that `best_estimator_` exposes\n    `n_features_in_` when fit.\n\n    .. versionadded:: 0.24"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": "Names of features seen during :term:`fit`. Only defined if\n    `best_estimator_` is defined (see the documentation for the `refit`\n    parameter for more details) and that `best_estimator_` exposes\n    `feature_names_in_` when fit.\n\n    .. versionadded:: 1.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "GridSearchCV : Does exhaustive search over a grid of parameters.\nParameterSampler : A generator over parameter settings, constructed from\n    param_distributions.",
        "notes": "The parameters selected are those that maximize the score of the held-out\ndata, according to the scoring parameter.\n\nIf `n_jobs` was set to a value higher than one, the data is copied for each\nparameter setting(and not `n_jobs` times). This is done for efficiency\nreasons if individual jobs take very little time, but may raise errors if\nthe dataset is large and not enough memory is available.  A workaround in\nthis case is to set `pre_dispatch`. Then, the memory is copied only\n`pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\nn_jobs`.",
        "examples": ">>> from sklearn.datasets import load_iris\n>>> from sklearn.linear_model import LogisticRegression\n>>> from sklearn.model_selection import RandomizedSearchCV\n>>> from scipy.stats import uniform\n>>> iris = load_iris()\n>>> logistic = LogisticRegression(solver='saga', tol=1e-2, max_iter=200,\n...                               random_state=0)\n>>> distributions = dict(C=uniform(loc=0, scale=4),\n...                      penalty=['l2', 'l1'])\n>>> clf = RandomizedSearchCV(logistic, distributions, random_state=0)\n>>> search = clf.fit(iris.data, iris.target)\n>>> search.best_params_\n{'C': np.float64(2...), 'penalty': 'l1'}"
      }
    },
    {
      "name": "RepeatedKFold",
      "signature": "RepeatedKFold(*, n_splits=5, n_repeats=10, random_state=None)",
      "docstring": {
        "description": "Repeated K-Fold cross validator.\n\nRepeats K-Fold n times with different randomization in each repetition.\n\nRead more in the :ref:`User Guide <repeated_k_fold>`.",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of folds. Must be at least 2."
          },
          "n_repeats": {
            "type": "int, default=10",
            "description": "Number of times cross-validator needs to be repeated."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the randomness of each repeated cross-validation instance.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "RepeatedStratifiedKFold : Repeats Stratified K-Fold n times.",
        "notes": "Randomized CV splitters may return different results for each call of\nsplit. You can make the results identical by setting `random_state`\nto an integer.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import RepeatedKFold\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([0, 0, 1, 1])\n>>> rkf = RepeatedKFold(n_splits=2, n_repeats=2, random_state=2652124)\n>>> rkf.get_n_splits(X, y)\n4\n>>> print(rkf)\nRepeatedKFold(n_repeats=2, n_splits=2, random_state=2652124)\n>>> for i, (train_index, test_index) in enumerate(rkf.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\n...\nFold 0:\n  Train: index=[0 1]\n  Test:  index=[2 3]\nFold 1:\n  Train: index=[2 3]\n  Test:  index=[0 1]\nFold 2:\n  Train: index=[1 2]\n  Test:  index=[0 3]\nFold 3:\n  Train: index=[0 3]\n  Test:  index=[1 2]"
      }
    },
    {
      "name": "RepeatedStratifiedKFold",
      "signature": "RepeatedStratifiedKFold(*, n_splits=5, n_repeats=10, random_state=None)",
      "docstring": {
        "description": "Repeated Stratified K-Fold cross validator.\n\nRepeats Stratified K-Fold n times with different randomization in each\nrepetition.\n\nRead more in the :ref:`User Guide <repeated_k_fold>`.",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of folds. Must be at least 2."
          },
          "n_repeats": {
            "type": "int, default=10",
            "description": "Number of times cross-validator needs to be repeated."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the generation of the random states for each repetition.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "RepeatedKFold : Repeats K-Fold n times.",
        "notes": "Randomized CV splitters may return different results for each call of\nsplit. You can make the results identical by setting `random_state`\nto an integer.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import RepeatedStratifiedKFold\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([0, 0, 1, 1])\n>>> rskf = RepeatedStratifiedKFold(n_splits=2, n_repeats=2,\n...     random_state=36851234)\n>>> rskf.get_n_splits(X, y)\n4\n>>> print(rskf)\nRepeatedStratifiedKFold(n_repeats=2, n_splits=2, random_state=36851234)\n>>> for i, (train_index, test_index) in enumerate(rskf.split(X, y)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\n...\nFold 0:\n  Train: index=[1 2]\n  Test:  index=[0 3]\nFold 1:\n  Train: index=[0 3]\n  Test:  index=[1 2]\nFold 2:\n  Train: index=[1 3]\n  Test:  index=[0 2]\nFold 3:\n  Train: index=[0 2]\n  Test:  index=[1 3]"
      }
    },
    {
      "name": "ShuffleSplit",
      "signature": "ShuffleSplit(n_splits=10, *, test_size=None, train_size=None, random_state=None)",
      "docstring": {
        "description": "Random permutation cross-validator.\n\nYields indices to split data into training and test sets.\n\nNote: contrary to other cross-validation strategies, random splits\ndo not guarantee that test sets across all folds will be mutually exclusive,\nand might include overlapping samples. However, this is still very likely for\nsizeable datasets.\n\nRead more in the :ref:`User Guide <ShuffleSplit>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=10",
            "description": "Number of re-shuffling & splitting iterations."
          },
          "test_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the proportion\n    of the dataset to include in the test split. If int, represents the\n    absolute number of test samples. If None, the value is set to the\n    complement of the train size. If ``train_size`` is also None, it will\n    be set to 0.1."
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the\n    proportion of the dataset to include in the train split. If\n    int, represents the absolute number of train samples. If None,\n    the value is automatically set to the complement of the test size."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the randomness of the training and testing indices produced.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import ShuffleSplit\n>>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [3, 4], [5, 6]])\n>>> y = np.array([1, 2, 1, 2, 1, 2])\n>>> rs = ShuffleSplit(n_splits=5, test_size=.25, random_state=0)\n>>> rs.get_n_splits(X)\n5\n>>> print(rs)\nShuffleSplit(n_splits=5, random_state=0, test_size=0.25, train_size=None)\n>>> for i, (train_index, test_index) in enumerate(rs.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[1 3 0 4]\n  Test:  index=[5 2]\nFold 1:\n  Train: index=[4 0 2 5]\n  Test:  index=[1 3]\nFold 2:\n  Train: index=[1 2 4 0]\n  Test:  index=[3 5]\nFold 3:\n  Train: index=[3 4 1 0]\n  Test:  index=[5 2]\nFold 4:\n  Train: index=[3 5 1 0]\n  Test:  index=[2 4]\n>>> # Specify train and test size\n>>> rs = ShuffleSplit(n_splits=5, train_size=0.5, test_size=.25,\n...                   random_state=0)\n>>> for i, (train_index, test_index) in enumerate(rs.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[1 3 0]\n  Test:  index=[5 2]\nFold 1:\n  Train: index=[4 0 2]\n  Test:  index=[1 3]\nFold 2:\n  Train: index=[1 2 4]\n  Test:  index=[3 5]\nFold 3:\n  Train: index=[3 4 1]\n  Test:  index=[5 2]\nFold 4:\n  Train: index=[3 5 1]\n  Test:  index=[2 4]"
      }
    },
    {
      "name": "StratifiedGroupKFold",
      "signature": "StratifiedGroupKFold(n_splits=5, shuffle=False, random_state=None)",
      "docstring": {
        "description": "Stratified K-Fold iterator variant with non-overlapping groups.\n\nThis cross-validation object is a variation of StratifiedKFold attempts to\nreturn stratified folds with non-overlapping groups. The folds are made by\npreserving the percentage of samples for each class.\n\nEach group will appear exactly once in the test set across all folds (the\nnumber of distinct groups has to be at least equal to the number of folds).\n\nThe difference between :class:`GroupKFold`\nand `StratifiedGroupKFold` is that\nthe former attempts to create balanced folds such that the number of\ndistinct groups is approximately the same in each fold, whereas\n`StratifiedGroupKFold` attempts to create folds which preserve the\npercentage of samples for each class as much as possible given the\nconstraint of non-overlapping groups between splits.\n\nRead more in the :ref:`User Guide <stratified_group_k_fold>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of folds. Must be at least 2."
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": "Whether to shuffle each class's samples before splitting into batches.\n    Note that the samples within each split will not be shuffled.\n    This implementation can only shuffle groups that have approximately the\n    same y distribution, no global shuffle will be performed."
          },
          "random_state": {
            "type": "int or RandomState instance, default=None",
            "description": "When `shuffle` is True, `random_state` affects the ordering of the\n    indices, which controls the randomness of each fold for each class.\n    Otherwise, leave `random_state` as `None`.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "The implementation is designed to:\n\n* Mimic the behavior of StratifiedKFold as much as possible for trivial\n  groups (e.g. when each group contains only one sample).\n* Be invariant to class label: relabelling ``y = [\"Happy\", \"Sad\"]`` to\n  ``y = [1, 0]`` should not change the indices generated.\n* Stratify based on samples as much as possible while keeping\n  non-overlapping groups constraint. That means that in some cases when\n  there is a small number of groups containing a large number of samples\n  the stratification will not be possible and the behavior will be close\n  to GroupKFold.\n\nSee also\n--------\nStratifiedKFold: Takes class information into account to build folds which\n    retain class distributions (for binary or multiclass classification\n    tasks).\n\nGroupKFold: K-fold iterator variant with non-overlapping groups.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import StratifiedGroupKFold\n>>> X = np.ones((17, 2))\n>>> y = np.array([0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n>>> groups = np.array([1, 1, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5, 6, 6, 7, 8, 8])\n>>> sgkf = StratifiedGroupKFold(n_splits=3)\n>>> sgkf.get_n_splits(X, y)\n3\n>>> print(sgkf)\nStratifiedGroupKFold(n_splits=3, random_state=None, shuffle=False)\n>>> for i, (train_index, test_index) in enumerate(sgkf.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"         group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}\")\n...     print(f\"         group={groups[test_index]}\")\nFold 0:\n  Train: index=[ 0  1  2  3  7  8  9 10 11 15 16]\n         group=[1 1 2 2 4 5 5 5 5 8 8]\n  Test:  index=[ 4  5  6 12 13 14]\n         group=[3 3 3 6 6 7]\nFold 1:\n  Train: index=[ 4  5  6  7  8  9 10 11 12 13 14]\n         group=[3 3 3 4 5 5 5 5 6 6 7]\n  Test:  index=[ 0  1  2  3 15 16]\n         group=[1 1 2 2 8 8]\nFold 2:\n  Train: index=[ 0  1  2  3  4  5  6 12 13 14 15 16]\n         group=[1 1 2 2 3 3 3 6 6 7 8 8]\n  Test:  index=[ 7  8  9 10 11]\n         group=[4 5 5 5 5]"
      }
    },
    {
      "name": "StratifiedKFold",
      "signature": "StratifiedKFold(n_splits=5, *, shuffle=False, random_state=None)",
      "docstring": {
        "description": "Stratified K-Fold cross-validator.\n\nProvides train/test indices to split data in train/test sets.\n\nThis cross-validation object is a variation of KFold that returns\nstratified folds. The folds are made by preserving the percentage of\nsamples for each class.\n\nRead more in the :ref:`User Guide <stratified_k_fold>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of folds. Must be at least 2.\n\n    .. versionchanged:: 0.22\n        ``n_splits`` default value changed from 3 to 5."
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": "Whether to shuffle each class's samples before splitting into batches.\n    Note that the samples within each split will not be shuffled."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "When `shuffle` is True, `random_state` affects the ordering of the\n    indices, which controls the randomness of each fold for each class.\n    Otherwise, leave `random_state` as `None`.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "RepeatedStratifiedKFold : Repeats Stratified K-Fold n times.",
        "notes": "The implementation is designed to:\n\n* Generate test sets such that all contain the same distribution of\n  classes, or as close as possible.\n* Be invariant to class label: relabelling ``y = [\"Happy\", \"Sad\"]`` to\n  ``y = [1, 0]`` should not change the indices generated.\n* Preserve order dependencies in the dataset ordering, when\n  ``shuffle=False``: all samples from class k in some test set were\n  contiguous in y, or separated in y by samples from classes other than k.\n* Generate test sets where the smallest and largest differ by at most one\n  sample.\n\n.. versionchanged:: 0.22\n    The previous implementation did not follow the last constraint.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import StratifiedKFold\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([0, 0, 1, 1])\n>>> skf = StratifiedKFold(n_splits=2)\n>>> skf.get_n_splits(X, y)\n2\n>>> print(skf)\nStratifiedKFold(n_splits=2, random_state=None, shuffle=False)\n>>> for i, (train_index, test_index) in enumerate(skf.split(X, y)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[1 3]\n  Test:  index=[0 2]\nFold 1:\n  Train: index=[0 2]\n  Test:  index=[1 3]"
      }
    },
    {
      "name": "StratifiedShuffleSplit",
      "signature": "StratifiedShuffleSplit(n_splits=10, *, test_size=None, train_size=None, random_state=None)",
      "docstring": {
        "description": "Stratified ShuffleSplit cross-validator.\n\nProvides train/test indices to split data in train/test sets.\n\nThis cross-validation object is a merge of :class:`StratifiedKFold` and\n:class:`ShuffleSplit`, which returns stratified randomized folds. The folds\nare made by preserving the percentage of samples for each class.\n\nNote: like the :class:`ShuffleSplit` strategy, stratified random splits\ndo not guarantee that test sets across all folds will be mutually exclusive,\nand might include overlapping samples. However, this is still very likely for\nsizeable datasets.\n\nRead more in the :ref:`User Guide <stratified_shuffle_split>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=10",
            "description": "Number of re-shuffling & splitting iterations."
          },
          "test_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the proportion\n    of the dataset to include in the test split. If int, represents the\n    absolute number of test samples. If None, the value is set to the\n    complement of the train size. If ``train_size`` is also None, it will\n    be set to 0.1."
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the\n    proportion of the dataset to include in the train split. If\n    int, represents the absolute number of train samples. If None,\n    the value is automatically set to the complement of the test size."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the randomness of the training and testing indices produced.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import StratifiedShuffleSplit\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([0, 0, 0, 1, 1, 1])\n>>> sss = StratifiedShuffleSplit(n_splits=5, test_size=0.5, random_state=0)\n>>> sss.get_n_splits(X, y)\n5\n>>> print(sss)\nStratifiedShuffleSplit(n_splits=5, random_state=0, ...)\n>>> for i, (train_index, test_index) in enumerate(sss.split(X, y)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[5 2 3]\n  Test:  index=[4 1 0]\nFold 1:\n  Train: index=[5 1 4]\n  Test:  index=[0 2 3]\nFold 2:\n  Train: index=[5 0 2]\n  Test:  index=[4 3 1]\nFold 3:\n  Train: index=[4 1 0]\n  Test:  index=[2 3 5]\nFold 4:\n  Train: index=[0 5 1]\n  Test:  index=[3 4 2]"
      }
    },
    {
      "name": "TimeSeriesSplit",
      "signature": "TimeSeriesSplit(n_splits=5, *, max_train_size=None, test_size=None, gap=0)",
      "docstring": {
        "description": "Time Series cross-validator.\n\nProvides train/test indices to split time series data samples\nthat are observed at fixed time intervals, in train/test sets.\nIn each split, test indices must be higher than before, and thus shuffling\nin cross validator is inappropriate.\n\nThis cross-validation object is a variation of :class:`KFold`.\nIn the kth split, it returns first k folds as train set and the\n(k+1)th fold as test set.\n\nNote that unlike standard cross-validation methods, successive\ntraining sets are supersets of those that come before them.\n\nRead more in the :ref:`User Guide <time_series_split>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n.. versionadded:: 0.18",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of splits. Must be at least 2.\n\n    .. versionchanged:: 0.22\n        ``n_splits`` default value changed from 3 to 5."
          },
          "max_train_size": {
            "type": "int, default=None",
            "description": "Maximum size for a single training set."
          },
          "test_size": {
            "type": "int, default=None",
            "description": "Used to limit the size of the test set. Defaults to\n    ``n_samples // (n_splits + 1)``, which is the maximum allowed value\n    with ``gap=0``.\n\n    .. versionadded:: 0.24"
          },
          "gap": {
            "type": "int, default=0",
            "description": "Number of samples to exclude from the end of each train set before\n    the test set.\n\n    .. versionadded:: 0.24"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "The training set has size ``i * n_samples // (n_splits + 1)\n+ n_samples % (n_splits + 1)`` in the ``i`` th split,\nwith a test set of size ``n_samples//(n_splits + 1)`` by default,\nwhere ``n_samples`` is the number of samples. Note that this\nformula is only valid when ``test_size`` and ``max_train_size`` are\nleft to their default values.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import TimeSeriesSplit\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([1, 2, 3, 4, 5, 6])\n>>> tscv = TimeSeriesSplit()\n>>> print(tscv)\nTimeSeriesSplit(gap=0, max_train_size=None, n_splits=5, test_size=None)\n>>> for i, (train_index, test_index) in enumerate(tscv.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[0]\n  Test:  index=[1]\nFold 1:\n  Train: index=[0 1]\n  Test:  index=[2]\nFold 2:\n  Train: index=[0 1 2]\n  Test:  index=[3]\nFold 3:\n  Train: index=[0 1 2 3]\n  Test:  index=[4]\nFold 4:\n  Train: index=[0 1 2 3 4]\n  Test:  index=[5]\n>>> # Fix test_size to 2 with 12 samples\n>>> X = np.random.randn(12, 2)\n>>> y = np.random.randint(0, 2, 12)\n>>> tscv = TimeSeriesSplit(n_splits=3, test_size=2)\n>>> for i, (train_index, test_index) in enumerate(tscv.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[0 1 2 3 4 5]\n  Test:  index=[6 7]\nFold 1:\n  Train: index=[0 1 2 3 4 5 6 7]\n  Test:  index=[8 9]\nFold 2:\n  Train: index=[0 1 2 3 4 5 6 7 8 9]\n  Test:  index=[10 11]\n>>> # Add in a 2 period gap\n>>> tscv = TimeSeriesSplit(n_splits=3, test_size=2, gap=2)\n>>> for i, (train_index, test_index) in enumerate(tscv.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[0 1 2 3]\n  Test:  index=[6 7]\nFold 1:\n  Train: index=[0 1 2 3 4 5]\n  Test:  index=[8 9]\nFold 2:\n  Train: index=[0 1 2 3 4 5 6 7]\n  Test:  index=[10 11]\n\nFor a more extended example see\n:ref:`sphx_glr_auto_examples_applications_plot_cyclical_feature_engineering.py`."
      }
    },
    {
      "name": "TunedThresholdClassifierCV",
      "signature": "TunedThresholdClassifierCV(estimator, *, scoring='balanced_accuracy', response_method='auto', thresholds=100, cv=None, refit=True, n_jobs=None, random_state=None, store_cv_results=False)",
      "docstring": {
        "description": "Classifier that post-tunes the decision threshold using cross-validation.\n\nThis estimator post-tunes the decision threshold (cut-off point) that is\nused for converting posterior probability estimates (i.e. output of\n`predict_proba`) or decision scores (i.e. output of `decision_function`)\ninto a class label. The tuning is done by optimizing a binary metric,\npotentially constrained by a another metric.\n\nRead more in the :ref:`User Guide <TunedThresholdClassifierCV>`.\n\n.. versionadded:: 1.5",
        "parameters": {
          "estimator": {
            "type": "estimator instance",
            "description": "The classifier, fitted or not, for which we want to optimize\n    the decision threshold used during `predict`."
          },
          "scoring": {
            "type": "str or callable, default=\"balanced_accuracy\"",
            "description": "The objective metric to be optimized. Can be one of:\n\n    * a string associated to a scoring function for binary classification\n      (see :ref:`scoring_parameter`);\n    * a scorer callable object created with :func:`~sklearn.metrics.make_scorer`;"
          },
          "response_method": {
            "type": "{\"auto\", \"decision_function\", \"predict_proba\"}, default=\"auto\"",
            "description": "Methods by the classifier `estimator` corresponding to the\n    decision function for which we want to find a threshold. It can be:\n\n    * if `\"auto\"`, it will try to invoke, for each classifier,\n      `\"predict_proba\"` or `\"decision_function\"` in that order.\n    * otherwise, one of `\"predict_proba\"` or `\"decision_function\"`.\n      If the method is not implemented by the classifier, it will raise an\n      error."
          },
          "thresholds": {
            "type": "int or array-like, default=100",
            "description": "The number of decision threshold to use when discretizing the output of the\n    classifier `method`. Pass an array-like to manually specify the thresholds\n    to use."
          },
          "cv": {
            "type": "int, float, cross-validation generator, iterable or \"prefit\", default=None",
            "description": "Determines the cross-validation splitting strategy to train classifier.\n    Possible inputs for cv are:\n\n    * `None`, to use the default 5-fold stratified K-fold cross validation;\n    * An integer number, to specify the number of folds in a stratified k-fold;\n    * A float number, to specify a single shuffle split. The floating number should\n      be in (0, 1) and represent the size of the validation set;\n    * An object to be used as a cross-validation generator;\n    * An iterable yielding train, test splits;\n    * `\"prefit\"`, to bypass the cross-validation.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here.\n\n    .. warning::\n        Using `cv=\"prefit\"` and passing the same dataset for fitting `estimator`\n        and tuning the cut-off point is subject to undesired overfitting. You can\n        refer to :ref:`TunedThresholdClassifierCV_no_cv` for an example.\n\n        This option should only be used when the set used to fit `estimator` is\n        different from the one used to tune the cut-off point (by calling\n        :meth:`TunedThresholdClassifierCV.fit`)."
          },
          "refit": {
            "type": "bool, default=True",
            "description": "Whether or not to refit the classifier on the entire training set once\n    the decision threshold has been found.\n    Note that forcing `refit=False` on cross-validation having more\n    than a single split will raise an error. Similarly, `refit=True` in\n    conjunction with `cv=\"prefit\"` will raise an error."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": "The number of jobs to run in parallel. When `cv` represents a\n    cross-validation strategy, the fitting and scoring on each data split\n    is done in parallel. ``None`` means 1 unless in a\n    :obj:`joblib.parallel_backend` context. ``-1`` means using all\n    processors. See :term:`Glossary <n_jobs>` for more details."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the randomness of cross-validation when `cv` is a float.\n    See :term:`Glossary <random_state>`."
          },
          "store_cv_results": {
            "type": "bool, default=False",
            "description": "Whether to store all scores and thresholds computed during the cross-validation\n    process.\n\nAttributes\n----------"
          },
          "estimator_": {
            "type": "estimator instance",
            "description": "The fitted classifier used when predicting."
          },
          "best_threshold_": {
            "type": "float",
            "description": "The new decision threshold."
          },
          "best_score_": {
            "type": "float or None",
            "description": "The optimal score of the objective metric, evaluated at `best_threshold_`."
          },
          "cv_results_": {
            "type": "dict or None",
            "description": "A dictionary containing the scores and thresholds computed during the\n    cross-validation process. Only exist if `store_cv_results=True`. The\n    keys are `\"thresholds\"` and `\"scores\"`."
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": "The class labels."
          },
          "n_features_in_": {
            "type": "int",
            "description": "Number of features seen during :term:`fit`. Only defined if the\n    underlying estimator exposes such an attribute when fit."
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": "Names of features seen during :term:`fit`. Only defined if the\n    underlying estimator exposes such an attribute when fit."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "sklearn.model_selection.FixedThresholdClassifier : Classifier that uses a\n    constant threshold.\nsklearn.calibration.CalibratedClassifierCV : Estimator that calibrates\n    probabilities.",
        "notes": "",
        "examples": ">>> from sklearn.datasets import make_classification\n>>> from sklearn.ensemble import RandomForestClassifier\n>>> from sklearn.metrics import classification_report\n>>> from sklearn.model_selection import TunedThresholdClassifierCV, train_test_split\n>>> X, y = make_classification(\n...     n_samples=1_000, weights=[0.9, 0.1], class_sep=0.8, random_state=42\n... )\n>>> X_train, X_test, y_train, y_test = train_test_split(\n...     X, y, stratify=y, random_state=42\n... )\n>>> classifier = RandomForestClassifier(random_state=0).fit(X_train, y_train)\n>>> print(classification_report(y_test, classifier.predict(X_test)))\n              precision    recall  f1-score   support\n<BLANKLINE>\n           0       0.94      0.99      0.96       224\n           1       0.80      0.46      0.59        26\n<BLANKLINE>\n    accuracy                           0.93       250\n   macro avg       0.87      0.72      0.77       250\nweighted avg       0.93      0.93      0.92       250\n<BLANKLINE>\n>>> classifier_tuned = TunedThresholdClassifierCV(\n...     classifier, scoring=\"balanced_accuracy\"\n... ).fit(X_train, y_train)\n>>> print(\n...     f\"Cut-off point found at {classifier_tuned.best_threshold_:.3f}\"\n... )\nCut-off point found at 0.342\n>>> print(classification_report(y_test, classifier_tuned.predict(X_test)))\n              precision    recall  f1-score   support\n<BLANKLINE>\n           0       0.96      0.95      0.96       224\n           1       0.61      0.65      0.63        26\n<BLANKLINE>\n    accuracy                           0.92       250\n   macro avg       0.78      0.80      0.79       250\nweighted avg       0.92      0.92      0.92       250\n<BLANKLINE>"
      }
    },
    {
      "name": "ValidationCurveDisplay",
      "signature": "ValidationCurveDisplay(*, param_name, param_range, train_scores, test_scores, score_name=None)",
      "docstring": {
        "description": "Validation Curve visualization.\n\nIt is recommended to use\n:meth:`~sklearn.model_selection.ValidationCurveDisplay.from_estimator` to\ncreate a :class:`~sklearn.model_selection.ValidationCurveDisplay` instance.\nAll parameters are stored as attributes.\n\nRead more in the :ref:`User Guide <visualizations>` for general information\nabout the visualization API and :ref:`detailed documentation\n<validation_curve>` regarding the validation curve visualization.\n\n.. versionadded:: 1.3",
        "parameters": {
          "param_name": {
            "type": "str",
            "description": "Name of the parameter that has been varied."
          },
          "param_range": {
            "type": "array-like of shape (n_ticks,)",
            "description": "The values of the parameter that have been evaluated."
          },
          "train_scores": {
            "type": "ndarray of shape (n_ticks, n_cv_folds)",
            "description": "Scores on training sets."
          },
          "test_scores": {
            "type": "ndarray of shape (n_ticks, n_cv_folds)",
            "description": "Scores on test set."
          },
          "score_name": {
            "type": "str, default=None",
            "description": "The name of the score used in `validation_curve`. It will override the name\n    inferred from the `scoring` parameter. If `score` is `None`, we use `\"Score\"` if\n    `negate_score` is `False` and `\"Negative score\"` otherwise. If `scoring` is a\n    string or a callable, we infer the name. We replace `_` by spaces and capitalize\n    the first letter. We remove `neg_` and replace it by `\"Negative\"` if\n    `negate_score` is `False` or just remove it otherwise.\n\nAttributes\n----------"
          },
          "ax_": {
            "type": "matplotlib Axes",
            "description": "Axes with the validation curve."
          },
          "figure_": {
            "type": "matplotlib Figure",
            "description": "Figure containing the validation curve."
          },
          "errorbar_": {
            "type": "list of matplotlib Artist or None",
            "description": "When the `std_display_style` is `\"errorbar\"`, this is a list of\n    `matplotlib.container.ErrorbarContainer` objects. If another style is\n    used, `errorbar_` is `None`."
          },
          "lines_": {
            "type": "list of matplotlib Artist or None",
            "description": "When the `std_display_style` is `\"fill_between\"`, this is a list of\n    `matplotlib.lines.Line2D` objects corresponding to the mean train and\n    test scores. If another style is used, `line_` is `None`."
          },
          "fill_between_": {
            "type": "list of matplotlib Artist or None",
            "description": "When the `std_display_style` is `\"fill_between\"`, this is a list of\n    `matplotlib.collections.PolyCollection` objects. If another style is\n    used, `fill_between_` is `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "sklearn.model_selection.validation_curve : Compute the validation curve.",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> from sklearn.datasets import make_classification\n>>> from sklearn.model_selection import ValidationCurveDisplay, validation_curve\n>>> from sklearn.linear_model import LogisticRegression\n>>> X, y = make_classification(n_samples=1_000, random_state=0)\n>>> logistic_regression = LogisticRegression()\n>>> param_name, param_range = \"C\", np.logspace(-8, 3, 10)\n>>> train_scores, test_scores = validation_curve(\n...     logistic_regression, X, y, param_name=param_name, param_range=param_range\n... )\n>>> display = ValidationCurveDisplay(\n...     param_name=param_name, param_range=param_range,\n...     train_scores=train_scores, test_scores=test_scores, score_name=\"Score\"\n... )\n>>> display.plot()\n<...>\n>>> plt.show()"
      }
    },
    {
      "name": "check_cv",
      "signature": "check_cv(cv=5, y=None, *, classifier=False)",
      "docstring": {
        "description": "Input checker utility for building a cross-validator.",
        "parameters": {
          "cv": {
            "type": "int, cross-validation generator, iterable or None, default=5",
            "description": "Determines the cross-validation splitting strategy.\n    Possible inputs for cv are:\n    - None, to use the default 5-fold cross validation,\n    - integer, to specify the number of folds.\n    - :term:`CV splitter`,\n    - An iterable that generates (train, test) splits as arrays of indices.\n\n    For integer/None inputs, if classifier is True and ``y`` is either\n    binary or multiclass, :class:`StratifiedKFold` is used. In all other\n    cases, :class:`KFold` is used.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here.\n\n    .. versionchanged:: 0.22\n        ``cv`` default value changed from 3-fold to 5-fold."
          },
          "y": {
            "type": "array-like, default=None",
            "description": "The target variable for supervised learning problems."
          },
          "classifier": {
            "type": "bool, default=False",
            "description": "Whether the task is a classification task, in which case\n    stratified KFold will be used."
          }
        },
        "returns": "checked_cv : a cross-validator instance.\n    The return value is a cross-validator which generates the train/test\n    splits via the ``split`` method.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> from sklearn.model_selection import check_cv\n>>> check_cv(cv=5, y=None, classifier=False)\nKFold(...)\n>>> check_cv(cv=5, y=[1, 1, 0, 0, 0, 0], classifier=True)\nStratifiedKFold(...)"
      }
    },
    {
      "name": "cross_val_predict",
      "signature": "cross_val_predict(estimator, X, y=None, *, groups=None, cv=None, n_jobs=None, verbose=0, params=None, pre_dispatch='2*n_jobs', method='predict')",
      "docstring": {
        "description": "Generate cross-validated estimates for each input data point.\n\nThe data is split according to the cv parameter. Each sample belongs\nto exactly one test set, and its prediction is computed with an\nestimator fitted on the corresponding training set.\n\nPassing these predictions into an evaluation metric may not be a valid\nway to measure generalization performance. Results can differ from\n:func:`cross_validate` and :func:`cross_val_score` unless all tests sets\nhave equal size and the metric decomposes over samples.\n\nRead more in the :ref:`User Guide <cross_validation>`.",
        "parameters": {
          "estimator": {
            "type": "estimator",
            "description": "The estimator instance to use to fit the data. It must implement a `fit`\n    method and the method given by the `method` parameter."
          },
          "X": {
            "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
            "description": "The data to fit. Can be, for example a list, or an array at least 2d."
          },
          "y": {
            "type": "{array-like, sparse matrix} of shape (n_samples,) or (n_samples, n_outputs),             default=None",
            "description": "The target variable to try to predict in the case of\n    supervised learning."
          },
          "groups": {
            "type": "array-like of shape (n_samples,), default=None",
            "description": "Group labels for the samples used while splitting the dataset into\n    train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n    instance (e.g., :class:`GroupKFold`).\n\n    .. versionchanged:: 1.4\n        ``groups`` can only be passed if metadata routing is not enabled\n        via ``sklearn.set_config(enable_metadata_routing=True)``. When routing\n        is enabled, pass ``groups`` alongside other metadata via the ``params``\n        argument instead. E.g.:\n        ``cross_val_predict(..., params={'groups': groups})``."
          },
          "cv": {
            "type": "int, cross-validation generator or an iterable, default=None",
            "description": "Determines the cross-validation splitting strategy.\n    Possible inputs for cv are:\n\n    - None, to use the default 5-fold cross validation,\n    - int, to specify the number of folds in a `(Stratified)KFold`,\n    - :term:`CV splitter`,\n    - An iterable that generates (train, test) splits as arrays of indices.\n\n    For int/None inputs, if the estimator is a classifier and ``y`` is\n    either binary or multiclass, :class:`StratifiedKFold` is used. In all\n    other cases, :class:`KFold` is used. These splitters are instantiated\n    with `shuffle=False` so the splits will be the same across calls.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here.\n\n    .. versionchanged:: 0.22\n        ``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": "Number of jobs to run in parallel. Training the estimator and\n    predicting are parallelized over the cross-validation splits.\n    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n    for more details."
          },
          "verbose": {
            "type": "int, default=0",
            "description": "The verbosity level."
          },
          "params": {
            "type": "dict, default=None",
            "description": "Parameters to pass to the underlying estimator's ``fit`` and the CV\n    splitter.\n\n    .. versionadded:: 1.4"
          },
          "pre_dispatch": {
            "type": "int or str, default='2*n_jobs'",
            "description": "Controls the number of jobs that get dispatched during parallel\n    execution. Reducing this number can be useful to avoid an\n    explosion of memory consumption when more jobs get dispatched\n    than CPUs can process. This parameter can be:\n\n    - None, in which case all the jobs are immediately created and spawned. Use\n      this for lightweight and fast-running jobs, to avoid delays due to on-demand\n      spawning of the jobs\n    - An int, giving the exact number of total jobs that are spawned\n    - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'"
          },
          "method": {
            "type": "{'predict', 'predict_proba', 'predict_log_proba',               'decision_function'}, default='predict'",
            "description": "The method to be invoked by `estimator`."
          }
        },
        "returns": "predictions : ndarray\n    This is the result of calling `method`. Shape:\n\n    - When `method` is 'predict' and in special case where `method` is\n      'decision_function' and the target is binary: (n_samples,)\n    - When `method` is one of {'predict_proba', 'predict_log_proba',\n      'decision_function'} (unless special case above):\n      (n_samples, n_classes)\n    - If `estimator` is :term:`multioutput`, an extra dimension\n      'n_outputs' is added to the end of each shape above.",
        "raises": "",
        "see_also": "cross_val_score : Calculate score for each CV split.\ncross_validate : Calculate one or more scores and timings for each CV\n    split.",
        "notes": "In the case that one or more classes are absent in a training portion, a\ndefault score needs to be assigned to all instances for that class if\n``method`` produces columns per class, as in {'decision_function',\n'predict_proba', 'predict_log_proba'}.  For ``predict_proba`` this value is\n0.  In order to ensure finite output, we approximate negative infinity by\nthe minimum finite float value for the dtype in other cases.",
        "examples": ">>> from sklearn import datasets, linear_model\n>>> from sklearn.model_selection import cross_val_predict\n>>> diabetes = datasets.load_diabetes()\n>>> X = diabetes.data[:150]\n>>> y = diabetes.target[:150]\n>>> lasso = linear_model.Lasso()\n>>> y_pred = cross_val_predict(lasso, X, y, cv=3)"
      }
    },
    {
      "name": "cross_val_score",
      "signature": "cross_val_score(estimator, X, y=None, *, groups=None, scoring=None, cv=None, n_jobs=None, verbose=0, params=None, pre_dispatch='2*n_jobs', error_score=nan)",
      "docstring": {
        "description": "Evaluate a score by cross-validation.\n\nRead more in the :ref:`User Guide <cross_validation>`.",
        "parameters": {
          "estimator": {
            "type": "estimator object implementing 'fit'",
            "description": "The object to use to fit the data."
          },
          "X": {
            "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
            "description": "The data to fit. Can be for example a list, or an array."
          },
          "y": {
            "type": "array-like of shape (n_samples,) or (n_samples, n_outputs),             default=None",
            "description": "The target variable to try to predict in the case of\n    supervised learning."
          },
          "groups": {
            "type": "array-like of shape (n_samples,), default=None",
            "description": "Group labels for the samples used while splitting the dataset into\n    train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n    instance (e.g., :class:`GroupKFold`).\n\n    .. versionchanged:: 1.4\n        ``groups`` can only be passed if metadata routing is not enabled\n        via ``sklearn.set_config(enable_metadata_routing=True)``. When routing\n        is enabled, pass ``groups`` alongside other metadata via the ``params``\n        argument instead. E.g.:\n        ``cross_val_score(..., params={'groups': groups})``."
          },
          "scoring": {
            "type": "str or callable, default=None",
            "description": "A str (see :ref:`scoring_parameter`) or a scorer callable object / function with\n    signature ``scorer(estimator, X, y)`` which should return only a single value.\n\n    Similar to :func:`cross_validate`\n    but only a single metric is permitted.\n\n    If `None`, the estimator's default scorer (if available) is used."
          },
          "cv": {
            "type": "int, cross-validation generator or an iterable, default=None",
            "description": "Determines the cross-validation splitting strategy.\n    Possible inputs for cv are:\n\n    - `None`, to use the default 5-fold cross validation,\n    - int, to specify the number of folds in a `(Stratified)KFold`,\n    - :term:`CV splitter`,\n    - An iterable that generates (train, test) splits as arrays of indices.\n\n    For `int`/`None` inputs, if the estimator is a classifier and `y` is\n    either binary or multiclass, :class:`StratifiedKFold` is used. In all\n    other cases, :class:`KFold` is used. These splitters are instantiated\n    with `shuffle=False` so the splits will be the same across calls.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here.\n\n    .. versionchanged:: 0.22\n        `cv` default value if `None` changed from 3-fold to 5-fold."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": "Number of jobs to run in parallel. Training the estimator and computing\n    the score are parallelized over the cross-validation splits.\n    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n    for more details."
          },
          "verbose": {
            "type": "int, default=0",
            "description": "The verbosity level."
          },
          "params": {
            "type": "dict, default=None",
            "description": "Parameters to pass to the underlying estimator's ``fit``, the scorer,\n    and the CV splitter.\n\n    .. versionadded:: 1.4"
          },
          "pre_dispatch": {
            "type": "int or str, default='2*n_jobs'",
            "description": "Controls the number of jobs that get dispatched during parallel\n    execution. Reducing this number can be useful to avoid an\n    explosion of memory consumption when more jobs get dispatched\n    than CPUs can process. This parameter can be:\n\n    - ``None``, in which case all the jobs are immediately created and spawned. Use\n      this for lightweight and fast-running jobs, to avoid delays due to on-demand\n      spawning of the jobs\n    - An int, giving the exact number of total jobs that are spawned\n    - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'"
          },
          "error_score": {
            "type": "'raise' or numeric, default=np.nan",
            "description": "Value to assign to the score if an error occurs in estimator fitting.\n    If set to 'raise', the error is raised.\n    If a numeric value is given, FitFailedWarning is raised.\n\n    .. versionadded:: 0.20"
          }
        },
        "returns": "scores : ndarray of float of shape=(len(list(cv)),)\n    Array of scores of the estimator for each run of the cross validation.",
        "raises": "",
        "see_also": "cross_validate : To run cross-validation on multiple metrics and also to\n    return train scores, fit times and score times.\n\ncross_val_predict : Get predictions from each split of cross-validation for\n    diagnostic purposes.\n\nsklearn.metrics.make_scorer : Make a scorer from a performance metric or\n    loss function.",
        "notes": "",
        "examples": ">>> from sklearn import datasets, linear_model\n>>> from sklearn.model_selection import cross_val_score\n>>> diabetes = datasets.load_diabetes()\n>>> X = diabetes.data[:150]\n>>> y = diabetes.target[:150]\n>>> lasso = linear_model.Lasso()\n>>> print(cross_val_score(lasso, X, y, cv=3))\n[0.3315057  0.08022103 0.03531816]"
      }
    },
    {
      "name": "cross_validate",
      "signature": "cross_validate(estimator, X, y=None, *, groups=None, scoring=None, cv=None, n_jobs=None, verbose=0, params=None, pre_dispatch='2*n_jobs', return_train_score=False, return_estimator=False, return_indices=False, error_score=nan)",
      "docstring": {
        "description": "Evaluate metric(s) by cross-validation and also record fit/score times.\n\nRead more in the :ref:`User Guide <multimetric_cross_validation>`.",
        "parameters": {
          "estimator": {
            "type": "estimator object implementing 'fit'",
            "description": "The object to use to fit the data."
          },
          "X": {
            "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
            "description": "The data to fit. Can be for example a list, or an array."
          },
          "y": {
            "type": "array-like of shape (n_samples,) or (n_samples, n_outputs), default=None",
            "description": "The target variable to try to predict in the case of\n    supervised learning."
          },
          "groups": {
            "type": "array-like of shape (n_samples,), default=None",
            "description": "Group labels for the samples used while splitting the dataset into\n    train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n    instance (e.g., :class:`GroupKFold`).\n\n    .. versionchanged:: 1.4\n        ``groups`` can only be passed if metadata routing is not enabled\n        via ``sklearn.set_config(enable_metadata_routing=True)``. When routing\n        is enabled, pass ``groups`` alongside other metadata via the ``params``\n        argument instead. E.g.:\n        ``cross_validate(..., params={'groups': groups})``."
          },
          "scoring": {
            "type": "str, callable, list, tuple, or dict, default=None",
            "description": "Strategy to evaluate the performance of the cross-validated model on\n    the test set. If `None`, the\n    :ref:`default evaluation criterion <scoring_api_overview>` of the estimator\n    is used.\n\n    If `scoring` represents a single score, one can use:\n\n    - a single string (see :ref:`scoring_parameter`);\n    - a callable (see :ref:`scoring_callable`) that returns a single value.\n\n    If `scoring` represents multiple scores, one can use:\n\n    - a list or tuple of unique strings;\n    - a callable returning a dictionary where the keys are the metric\n      names and the values are the metric scores;\n    - a dictionary with metric names as keys and callables a values.\n\n    See :ref:`multimetric_grid_search` for an example."
          },
          "cv": {
            "type": "int, cross-validation generator or an iterable, default=None",
            "description": "Determines the cross-validation splitting strategy.\n    Possible inputs for cv are:\n\n    - None, to use the default 5-fold cross validation,\n    - int, to specify the number of folds in a `(Stratified)KFold`,\n    - :term:`CV splitter`,\n    - An iterable yielding (train, test) splits as arrays of indices.\n\n    For int/None inputs, if the estimator is a classifier and ``y`` is\n    either binary or multiclass, :class:`StratifiedKFold` is used. In all\n    other cases, :class:`KFold` is used. These splitters are instantiated\n    with `shuffle=False` so the splits will be the same across calls.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here.\n\n    .. versionchanged:: 0.22\n        ``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": "Number of jobs to run in parallel. Training the estimator and computing\n    the score are parallelized over the cross-validation splits.\n    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n    for more details."
          },
          "verbose": {
            "type": "int, default=0",
            "description": "The verbosity level."
          },
          "params": {
            "type": "dict, default=None",
            "description": "Parameters to pass to the underlying estimator's ``fit``, the scorer,\n    and the CV splitter.\n\n    .. versionadded:: 1.4"
          },
          "pre_dispatch": {
            "type": "int or str, default='2*n_jobs'",
            "description": "Controls the number of jobs that get dispatched during parallel\n    execution. Reducing this number can be useful to avoid an\n    explosion of memory consumption when more jobs get dispatched\n    than CPUs can process. This parameter can be:\n\n    - An int, giving the exact number of total jobs that are spawned\n    - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'"
          },
          "return_train_score": {
            "type": "bool, default=False",
            "description": "Whether to include train scores.\n    Computing training scores is used to get insights on how different\n    parameter settings impact the overfitting/underfitting trade-off.\n    However computing the scores on the training set can be computationally\n    expensive and is not strictly required to select the parameters that\n    yield the best generalization performance.\n\n    .. versionadded:: 0.19\n\n    .. versionchanged:: 0.21\n        Default value was changed from ``True`` to ``False``"
          },
          "return_estimator": {
            "type": "bool, default=False",
            "description": "Whether to return the estimators fitted on each split.\n\n    .. versionadded:: 0.20"
          },
          "return_indices": {
            "type": "bool, default=False",
            "description": "Whether to return the train-test indices selected for each split.\n\n    .. versionadded:: 1.3"
          },
          "error_score": {
            "type": "'raise' or numeric, default=np.nan",
            "description": "Value to assign to the score if an error occurs in estimator fitting.\n    If set to 'raise', the error is raised.\n    If a numeric value is given, FitFailedWarning is raised.\n\n    .. versionadded:: 0.20"
          }
        },
        "returns": "scores : dict of float arrays of shape (n_splits,)\n    Array of scores of the estimator for each run of the cross validation.\n\n    A dict of arrays containing the score/time arrays for each scorer is\n    returned. The possible keys for this ``dict`` are:\n\n    ``test_score``\n        The score array for test scores on each cv split.\n        Suffix ``_score`` in ``test_score`` changes to a specific\n        metric like ``test_r2`` or ``test_auc`` if there are\n        multiple scoring metrics in the scoring parameter.\n    ``train_score``\n        The score array for train scores on each cv split.\n        Suffix ``_score`` in ``train_score`` changes to a specific\n        metric like ``train_r2`` or ``train_auc`` if there are\n        multiple scoring metrics in the scoring parameter.\n        This is available only if ``return_train_score`` parameter\n        is ``True``.\n    ``fit_time``\n        The time for fitting the estimator on the train\n        set for each cv split.\n    ``score_time``\n        The time for scoring the estimator on the test set for each\n        cv split. (Note time for scoring on the train set is not\n        included even if ``return_train_score`` is set to ``True``\n    ``estimator``\n        The estimator objects for each cv split.\n        This is available only if ``return_estimator`` parameter\n        is set to ``True``.\n    ``indices``\n        The train/test positional indices for each cv split. A dictionary\n        is returned where the keys are either `\"train\"` or `\"test\"`\n        and the associated values are a list of integer-dtyped NumPy\n        arrays with the indices. Available only if `return_indices=True`.",
        "raises": "",
        "see_also": "cross_val_score : Run cross-validation for single metric evaluation.\n\ncross_val_predict : Get predictions from each split of cross-validation for\n    diagnostic purposes.\n\nsklearn.metrics.make_scorer : Make a scorer from a performance metric or\n    loss function.",
        "notes": "",
        "examples": ">>> from sklearn import datasets, linear_model\n>>> from sklearn.model_selection import cross_validate\n>>> from sklearn.metrics import make_scorer\n>>> from sklearn.metrics import confusion_matrix\n>>> from sklearn.svm import LinearSVC\n>>> diabetes = datasets.load_diabetes()\n>>> X = diabetes.data[:150]\n>>> y = diabetes.target[:150]\n>>> lasso = linear_model.Lasso()\n\nSingle metric evaluation using ``cross_validate``\n\n>>> cv_results = cross_validate(lasso, X, y, cv=3)\n>>> sorted(cv_results.keys())\n['fit_time', 'score_time', 'test_score']\n>>> cv_results['test_score']\narray([0.3315057 , 0.08022103, 0.03531816])\n\nMultiple metric evaluation using ``cross_validate``\n(please refer the ``scoring`` parameter doc for more information)\n\n>>> scores = cross_validate(lasso, X, y, cv=3,\n...                         scoring=('r2', 'neg_mean_squared_error'),\n...                         return_train_score=True)\n>>> print(scores['test_neg_mean_squared_error'])\n[-3635.5... -3573.3... -6114.7...]\n>>> print(scores['train_r2'])\n[0.28009951 0.3908844  0.22784907]"
      }
    },
    {
      "name": "learning_curve",
      "signature": "learning_curve(estimator, X, y, *, groups=None, train_sizes=array([0.1  , 0.325, 0.55 , 0.775, 1.   ]), cv=None, scoring=None, exploit_incremental_learning=False, n_jobs=None, pre_dispatch='all', verbose=0, shuffle=False, random_state=None, error_score=nan, return_times=False, fit_params=None, params=None)",
      "docstring": {
        "description": "Learning curve.\n\nDetermines cross-validated training and test scores for different training\nset sizes.\n\nA cross-validation generator splits the whole dataset k times in training\nand test data. Subsets of the training set with varying sizes will be used\nto train the estimator and a score for each training subset size and the\ntest set will be computed. Afterwards, the scores will be averaged over\nall k runs for each training subset size.\n\nRead more in the :ref:`User Guide <learning_curve>`.",
        "parameters": {
          "estimator": {
            "type": "object type that implements the \"fit\" method",
            "description": "An object of that type which is cloned for each validation. It must\n    also implement \"predict\" unless `scoring` is a callable that doesn't\n    rely on \"predict\" to compute a score."
          },
          "X": {
            "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
            "description": "Training vector, where `n_samples` is the number of samples and\n    `n_features` is the number of features."
          },
          "y": {
            "type": "array-like of shape (n_samples,) or (n_samples, n_outputs) or None",
            "description": "Target relative to X for classification or regression;\n    None for unsupervised learning."
          },
          "groups": {
            "type": "array-like of shape (n_samples,), default=None",
            "description": "Group labels for the samples used while splitting the dataset into\n    train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n    instance (e.g., :class:`GroupKFold`).\n\n    .. versionchanged:: 1.6\n        ``groups`` can only be passed if metadata routing is not enabled\n        via ``sklearn.set_config(enable_metadata_routing=True)``. When routing\n        is enabled, pass ``groups`` alongside other metadata via the ``params``\n        argument instead. E.g.:\n        ``learning_curve(..., params={'groups': groups})``."
          },
          "train_sizes": {
            "type": "array-like of shape (n_ticks,),             default=np.linspace(0.1, 1.0, 5)",
            "description": "Relative or absolute numbers of training examples that will be used to\n    generate the learning curve. If the dtype is float, it is regarded as a\n    fraction of the maximum size of the training set (that is determined\n    by the selected validation method), i.e. it has to be within (0, 1].\n    Otherwise it is interpreted as absolute sizes of the training sets.\n    Note that for classification the number of samples usually has to\n    be big enough to contain at least one sample from each class."
          },
          "cv": {
            "type": "int, cross-validation generator or an iterable, default=None",
            "description": "Determines the cross-validation splitting strategy.\n    Possible inputs for cv are:\n\n    - None, to use the default 5-fold cross validation,\n    - int, to specify the number of folds in a `(Stratified)KFold`,\n    - :term:`CV splitter`,\n    - An iterable yielding (train, test) splits as arrays of indices.\n\n    For int/None inputs, if the estimator is a classifier and ``y`` is\n    either binary or multiclass, :class:`StratifiedKFold` is used. In all\n    other cases, :class:`KFold` is used. These splitters are instantiated\n    with `shuffle=False` so the splits will be the same across calls.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here.\n\n    .. versionchanged:: 0.22\n        ``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "scoring": {
            "type": "str or callable, default=None",
            "description": "A str (see :ref:`scoring_parameter`) or a scorer callable object / function with\n    signature ``scorer(estimator, X, y)``."
          },
          "exploit_incremental_learning": {
            "type": "bool, default=False",
            "description": "If the estimator supports incremental learning, this will be\n    used to speed up fitting for different training set sizes."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": "Number of jobs to run in parallel. Training the estimator and computing\n    the score are parallelized over the different training and test sets.\n    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n    for more details."
          },
          "pre_dispatch": {
            "type": "int or str, default='all'",
            "description": "Number of predispatched jobs for parallel execution (default is\n    all). The option can reduce the allocated memory. The str can\n    be an expression like '2*n_jobs'."
          },
          "verbose": {
            "type": "int, default=0",
            "description": "Controls the verbosity: the higher, the more messages."
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": "Whether to shuffle training data before taking prefixes of it\n    based on``train_sizes``."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Used when ``shuffle`` is True. Pass an int for reproducible\n    output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          },
          "error_score": {
            "type": "'raise' or numeric, default=np.nan",
            "description": "Value to assign to the score if an error occurs in estimator fitting.\n    If set to 'raise', the error is raised.\n    If a numeric value is given, FitFailedWarning is raised.\n\n    .. versionadded:: 0.20"
          },
          "return_times": {
            "type": "bool, default=False",
            "description": "Whether to return the fit and score times."
          },
          "fit_params": {
            "type": "dict, default=None",
            "description": "Parameters to pass to the fit method of the estimator.\n\n    .. deprecated:: 1.6\n        This parameter is deprecated and will be removed in version 1.8. Use\n        ``params`` instead."
          },
          "params": {
            "type": "dict, default=None",
            "description": "Parameters to pass to the `fit` method of the estimator and to the scorer.\n\n    - If `enable_metadata_routing=False` (default): Parameters directly passed to\n      the `fit` method of the estimator.\n\n    - If `enable_metadata_routing=True`: Parameters safely routed to the `fit`\n      method of the estimator. See :ref:`Metadata Routing User Guide\n      <metadata_routing>` for more details.\n\n    .. versionadded:: 1.6"
          }
        },
        "returns": "train_sizes_abs : array of shape (n_unique_ticks,)\n    Numbers of training examples that has been used to generate the\n    learning curve. Note that the number of ticks might be less\n    than n_ticks because duplicate entries will be removed.\n\ntrain_scores : array of shape (n_ticks, n_cv_folds)\n    Scores on training sets.\n\ntest_scores : array of shape (n_ticks, n_cv_folds)\n    Scores on test set.\n\nfit_times : array of shape (n_ticks, n_cv_folds)\n    Times spent for fitting in seconds. Only present if ``return_times``\n    is True.\n\nscore_times : array of shape (n_ticks, n_cv_folds)\n    Times spent for scoring in seconds. Only present if ``return_times``\n    is True.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> from sklearn.datasets import make_classification\n>>> from sklearn.tree import DecisionTreeClassifier\n>>> from sklearn.model_selection import learning_curve\n>>> X, y = make_classification(n_samples=100, n_features=10, random_state=42)\n>>> tree = DecisionTreeClassifier(max_depth=4, random_state=42)\n>>> train_size_abs, train_scores, test_scores = learning_curve(\n...     tree, X, y, train_sizes=[0.3, 0.6, 0.9]\n... )\n>>> for train_size, cv_train_scores, cv_test_scores in zip(\n...     train_size_abs, train_scores, test_scores\n... ):\n...     print(f\"{train_size} samples were used to train the model\")\n...     print(f\"The average train accuracy is {cv_train_scores.mean():.2f}\")\n...     print(f\"The average test accuracy is {cv_test_scores.mean():.2f}\")\n24 samples were used to train the model\nThe average train accuracy is 1.00\nThe average test accuracy is 0.85\n48 samples were used to train the model\nThe average train accuracy is 1.00\nThe average test accuracy is 0.90\n72 samples were used to train the model\nThe average train accuracy is 1.00\nThe average test accuracy is 0.93"
      }
    },
    {
      "name": "permutation_test_score",
      "signature": "permutation_test_score(estimator, X, y, *, groups=None, cv=None, n_permutations=100, n_jobs=None, random_state=0, verbose=0, scoring=None, fit_params=None, params=None)",
      "docstring": {
        "description": "Evaluate the significance of a cross-validated score with permutations.\n\nPermutes targets to generate 'randomized data' and compute the empirical\np-value against the null hypothesis that features and targets are\nindependent.\n\nThe p-value represents the fraction of randomized data sets where the\nestimator performed as well or better than in the original data. A small\np-value suggests that there is a real dependency between features and\ntargets which has been used by the estimator to give good predictions.\nA large p-value may be due to lack of real dependency between features\nand targets or the estimator was not able to use the dependency to\ngive good predictions.\n\nRead more in the :ref:`User Guide <permutation_test_score>`.",
        "parameters": {
          "estimator": {
            "type": "estimator object implementing 'fit'",
            "description": "The object to use to fit the data."
          },
          "X": {
            "type": "array-like of shape at least 2D",
            "description": "The data to fit."
          },
          "y": {
            "type": "array-like of shape (n_samples,) or (n_samples, n_outputs) or None",
            "description": "The target variable to try to predict in the case of\n    supervised learning."
          },
          "groups": {
            "type": "array-like of shape (n_samples,), default=None",
            "description": "Labels to constrain permutation within groups, i.e. ``y`` values\n    are permuted among samples with the same group identifier.\n    When not specified, ``y`` values are permuted among all samples.\n\n    When a grouped cross-validator is used, the group labels are\n    also passed on to the ``split`` method of the cross-validator. The\n    cross-validator uses them for grouping the samples  while splitting\n    the dataset into train/test set.\n\n    .. versionchanged:: 1.6\n        ``groups`` can only be passed if metadata routing is not enabled\n        via ``sklearn.set_config(enable_metadata_routing=True)``. When routing\n        is enabled, pass ``groups`` alongside other metadata via the ``params``\n        argument instead. E.g.:\n        ``permutation_test_score(..., params={'groups': groups})``."
          },
          "cv": {
            "type": "int, cross-validation generator or an iterable, default=None",
            "description": "Determines the cross-validation splitting strategy.\n    Possible inputs for cv are:\n\n    - `None`, to use the default 5-fold cross validation,\n    - int, to specify the number of folds in a `(Stratified)KFold`,\n    - :term:`CV splitter`,\n    - An iterable yielding (train, test) splits as arrays of indices.\n\n    For `int`/`None` inputs, if the estimator is a classifier and `y` is\n    either binary or multiclass, :class:`StratifiedKFold` is used. In all\n    other cases, :class:`KFold` is used. These splitters are instantiated\n    with `shuffle=False` so the splits will be the same across calls.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here.\n\n    .. versionchanged:: 0.22\n        `cv` default value if `None` changed from 3-fold to 5-fold."
          },
          "n_permutations": {
            "type": "int, default=100",
            "description": "Number of times to permute ``y``."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": "Number of jobs to run in parallel. Training the estimator and computing\n    the cross-validated score are parallelized over the permutations.\n    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n    for more details."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=0",
            "description": "Pass an int for reproducible output for permutation of\n    ``y`` values among samples. See :term:`Glossary <random_state>`."
          },
          "verbose": {
            "type": "int, default=0",
            "description": "The verbosity level."
          },
          "scoring": {
            "type": "str or callable, default=None",
            "description": "A single str (see :ref:`scoring_parameter`) or a callable\n    (see :ref:`scoring_callable`) to evaluate the predictions on the test set.\n\n    If `None` the estimator's score method is used."
          },
          "fit_params": {
            "type": "dict, default=None",
            "description": "Parameters to pass to the fit method of the estimator.\n\n    .. deprecated:: 1.6\n        This parameter is deprecated and will be removed in version 1.6. Use\n        ``params`` instead."
          },
          "params": {
            "type": "dict, default=None",
            "description": "Parameters to pass to the `fit` method of the estimator, the scorer\n    and the cv splitter.\n\n    - If `enable_metadata_routing=False` (default): Parameters directly passed to\n      the `fit` method of the estimator.\n\n    - If `enable_metadata_routing=True`: Parameters safely routed to the `fit`\n      method of the estimator, `cv` object and `scorer`. See :ref:`Metadata Routing\n      User Guide <metadata_routing>` for more details.\n\n    .. versionadded:: 1.6"
          }
        },
        "returns": "score : float\n    The true score without permuting targets.\n\npermutation_scores : array of shape (n_permutations,)\n    The scores obtained for each permutations.\n\npvalue : float\n    The p-value, which approximates the probability that the score would\n    be obtained by chance. This is calculated as:\n\n    `(C + 1) / (n_permutations + 1)`\n\n    Where C is the number of permutations whose score >= the true score.\n\n    The best possible p-value is 1/(n_permutations + 1), the worst is 1.0.",
        "raises": "",
        "see_also": "",
        "notes": "This function implements Test 1 in:\n\nOjala and Garriga. `Permutation Tests for Studying Classifier Performance\n<http://www.jmlr.org/papers/volume11/ojala10a/ojala10a.pdf>`_. The\nJournal of Machine Learning Research (2010) vol. 11",
        "examples": ">>> from sklearn.datasets import make_classification\n>>> from sklearn.linear_model import LogisticRegression\n>>> from sklearn.model_selection import permutation_test_score\n>>> X, y = make_classification(random_state=0)\n>>> estimator = LogisticRegression()\n>>> score, permutation_scores, pvalue = permutation_test_score(\n...     estimator, X, y, random_state=0\n... )\n>>> print(f\"Original Score: {score:.3f}\")\nOriginal Score: 0.810\n>>> print(\n...     f\"Permutation Scores: {permutation_scores.mean():.3f} +/- \"\n...     f\"{permutation_scores.std():.3f}\"\n... )\nPermutation Scores: 0.505 +/- 0.057\n>>> print(f\"P-value: {pvalue:.3f}\")\nP-value: 0.010"
      }
    },
    {
      "name": "train_test_split",
      "signature": "train_test_split(*arrays, test_size=None, train_size=None, random_state=None, shuffle=True, stratify=None)",
      "docstring": {
        "description": "Split arrays or matrices into random train and test subsets.\n\nQuick utility that wraps input validation,\n``next(ShuffleSplit().split(X, y))``, and application to input data\ninto a single call for splitting (and optionally subsampling) data into a\none-liner.\n\nRead more in the :ref:`User Guide <cross_validation>`.",
        "parameters": {
          "*arrays": {
            "type": "sequence of indexables with same length / shape[0]",
            "description": "Allowed inputs are lists, numpy arrays, scipy-sparse\n    matrices or pandas dataframes."
          },
          "test_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the proportion\n    of the dataset to include in the test split. If int, represents the\n    absolute number of test samples. If None, the value is set to the\n    complement of the train size. If ``train_size`` is also None, it will\n    be set to 0.25."
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the\n    proportion of the dataset to include in the train split. If\n    int, represents the absolute number of train samples. If None,\n    the value is automatically set to the complement of the test size."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the shuffling applied to the data before applying the split.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          },
          "shuffle": {
            "type": "bool, default=True",
            "description": "Whether or not to shuffle the data before splitting. If shuffle=False\n    then stratify must be None."
          },
          "stratify": {
            "type": "array-like, default=None",
            "description": "If not None, data is split in a stratified fashion, using this as\n    the class labels.\n    Read more in the :ref:`User Guide <stratification>`."
          }
        },
        "returns": "splitting : list, length=2 * len(arrays)\n    List containing train-test split of inputs.\n\n    .. versionadded:: 0.16\n        If the input is sparse, the output will be a\n        ``scipy.sparse.csr_matrix``. Else, output type is the same as the\n        input type.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import train_test_split\n>>> X, y = np.arange(10).reshape((5, 2)), range(5)\n>>> X\narray([[0, 1],\n       [2, 3],\n       [4, 5],\n       [6, 7],\n       [8, 9]])\n>>> list(y)\n[0, 1, 2, 3, 4]\n\n>>> X_train, X_test, y_train, y_test = train_test_split(\n...     X, y, test_size=0.33, random_state=42)\n...\n>>> X_train\narray([[4, 5],\n       [0, 1],\n       [6, 7]])\n>>> y_train\n[2, 0, 3]\n>>> X_test\narray([[2, 3],\n       [8, 9]])\n>>> y_test\n[1, 4]\n\n>>> train_test_split(y, shuffle=False)\n[[0, 1, 2], [3, 4]]"
      }
    },
    {
      "name": "validation_curve",
      "signature": "validation_curve(estimator, X, y, *, param_name, param_range, groups=None, cv=None, scoring=None, n_jobs=None, pre_dispatch='all', verbose=0, error_score=nan, fit_params=None, params=None)",
      "docstring": {
        "description": "Validation curve.\n\nDetermine training and test scores for varying parameter values.\n\nCompute scores for an estimator with different values of a specified\nparameter. This is similar to grid search with one parameter. However, this\nwill also compute training scores and is merely a utility for plotting the\nresults.\n\nRead more in the :ref:`User Guide <validation_curve>`.",
        "parameters": {
          "estimator": {
            "type": "object type that implements the \"fit\" method",
            "description": "An object of that type which is cloned for each validation. It must\n    also implement \"predict\" unless `scoring` is a callable that doesn't\n    rely on \"predict\" to compute a score."
          },
          "X": {
            "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
            "description": "Training vector, where `n_samples` is the number of samples and\n    `n_features` is the number of features."
          },
          "y": {
            "type": "array-like of shape (n_samples,) or (n_samples, n_outputs) or None",
            "description": "Target relative to X for classification or regression;\n    None for unsupervised learning."
          },
          "param_name": {
            "type": "str",
            "description": "Name of the parameter that will be varied."
          },
          "param_range": {
            "type": "array-like of shape (n_values,)",
            "description": "The values of the parameter that will be evaluated."
          },
          "groups": {
            "type": "array-like of shape (n_samples,), default=None",
            "description": "Group labels for the samples used while splitting the dataset into\n    train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n    instance (e.g., :class:`GroupKFold`).\n\n    .. versionchanged:: 1.6\n        ``groups`` can only be passed if metadata routing is not enabled\n        via ``sklearn.set_config(enable_metadata_routing=True)``. When routing\n        is enabled, pass ``groups`` alongside other metadata via the ``params``\n        argument instead. E.g.:\n        ``validation_curve(..., params={'groups': groups})``."
          },
          "cv": {
            "type": "int, cross-validation generator or an iterable, default=None",
            "description": "Determines the cross-validation splitting strategy.\n    Possible inputs for cv are:\n\n    - None, to use the default 5-fold cross validation,\n    - int, to specify the number of folds in a `(Stratified)KFold`,\n    - :term:`CV splitter`,\n    - An iterable yielding (train, test) splits as arrays of indices.\n\n    For int/None inputs, if the estimator is a classifier and ``y`` is\n    either binary or multiclass, :class:`StratifiedKFold` is used. In all\n    other cases, :class:`KFold` is used. These splitters are instantiated\n    with `shuffle=False` so the splits will be the same across calls.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here.\n\n    .. versionchanged:: 0.22\n        ``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "scoring": {
            "type": "str or callable, default=None",
            "description": "A str (see :ref:`scoring_parameter`) or a scorer callable object / function with\n    signature ``scorer(estimator, X, y)``."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": "Number of jobs to run in parallel. Training the estimator and computing\n    the score are parallelized over the combinations of each parameter\n    value and each cross-validation split.\n    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n    for more details."
          },
          "pre_dispatch": {
            "type": "int or str, default='all'",
            "description": "Number of predispatched jobs for parallel execution (default is\n    all). The option can reduce the allocated memory. The str can\n    be an expression like '2*n_jobs'."
          },
          "verbose": {
            "type": "int, default=0",
            "description": "Controls the verbosity: the higher, the more messages."
          },
          "error_score": {
            "type": "'raise' or numeric, default=np.nan",
            "description": "Value to assign to the score if an error occurs in estimator fitting.\n    If set to 'raise', the error is raised.\n    If a numeric value is given, FitFailedWarning is raised.\n\n    .. versionadded:: 0.20"
          },
          "fit_params": {
            "type": "dict, default=None",
            "description": "Parameters to pass to the fit method of the estimator.\n\n    .. deprecated:: 1.6\n        This parameter is deprecated and will be removed in version 1.8. Use\n        ``params`` instead."
          },
          "params": {
            "type": "dict, default=None",
            "description": "Parameters to pass to the estimator, scorer and cross-validation object.\n\n    - If `enable_metadata_routing=False` (default): Parameters directly passed to\n      the `fit` method of the estimator.\n\n    - If `enable_metadata_routing=True`: Parameters safely routed to the `fit`\n      method of the estimator, to the scorer and to the cross-validation object.\n      See :ref:`Metadata Routing User Guide <metadata_routing>` for more details.\n\n    .. versionadded:: 1.6"
          }
        },
        "returns": "train_scores : array of shape (n_ticks, n_cv_folds)\n    Scores on training sets.\n\ntest_scores : array of shape (n_ticks, n_cv_folds)\n    Scores on test set.",
        "raises": "",
        "see_also": "",
        "notes": "See :ref:`sphx_glr_auto_examples_model_selection_plot_train_error_vs_test_error.py`",
        "examples": ">>> import numpy as np\n>>> from sklearn.datasets import make_classification\n>>> from sklearn.model_selection import validation_curve\n>>> from sklearn.linear_model import LogisticRegression\n>>> X, y = make_classification(n_samples=1_000, random_state=0)\n>>> logistic_regression = LogisticRegression()\n>>> param_name, param_range = \"C\", np.logspace(-8, 3, 10)\n>>> train_scores, test_scores = validation_curve(\n...     logistic_regression, X, y, param_name=param_name, param_range=param_range\n... )\n>>> print(f\"The average train accuracy is {train_scores.mean():.2f}\")\nThe average train accuracy is 0.81\n>>> print(f\"The average test accuracy is {test_scores.mean():.2f}\")\nThe average test accuracy is 0.81"
      }
    }
  ],
  "classes": [
    {
      "name": "BaseCrossValidator",
      "docstring": {
        "description": "Base class for all cross-validators.\n\nImplementations must define `_iter_test_masks` or `_iter_test_indices`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,)",
                "description": "The target variable for supervised learning problems."
              },
              "groups": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "Group labels for the samples used while splitting the dataset into\n    train/test set.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "BaseShuffleSplit",
      "docstring": {
        "description": "Base class for *ShuffleSplit.",
        "parameters": {
          "n_splits": {
            "type": "int, default=10",
            "description": "Number of re-shuffling & splitting iterations."
          },
          "test_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the proportion\n    of the dataset to include in the test split. If int, represents the\n    absolute number of test samples. If None, the value is set to the\n    complement of the train size. If ``train_size`` is also None, it will\n    be set to 0.1."
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the\n    proportion of the dataset to include in the train split. If\n    int, represents the absolute number of train samples. If None,\n    the value is automatically set to the complement of the test size."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the randomness of the training and testing indices produced.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,)",
                "description": "The target variable for supervised learning problems."
              },
              "groups": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "Group labels for the samples used while splitting the dataset into\n    train/test set.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "Randomized CV splitters may return different results for each call of\nsplit. You can make the results identical by setting `random_state`\nto an integer.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "FixedThresholdClassifier",
      "docstring": {
        "description": "Binary classifier that manually sets the decision threshold.\n\nThis classifier allows to change the default decision threshold used for\nconverting posterior probability estimates (i.e. output of `predict_proba`) or\ndecision scores (i.e. output of `decision_function`) into a class label.\n\nHere, the threshold is not optimized and is set to a constant value.\n\nRead more in the :ref:`User Guide <FixedThresholdClassifier>`.\n\n.. versionadded:: 1.5",
        "parameters": {
          "estimator": {
            "type": "estimator instance",
            "description": "The binary classifier, fitted or not, for which we want to optimize\n    the decision threshold used during `predict`."
          },
          "threshold": {
            "type": "{\"auto\"} or float, default=\"auto\"",
            "description": "The decision threshold to use when converting posterior probability estimates\n    (i.e. output of `predict_proba`) or decision scores (i.e. output of\n    `decision_function`) into a class label. When `\"auto\"`, the threshold is set\n    to 0.5 if `predict_proba` is used as `response_method`, otherwise it is set to\n    0 (i.e. the default threshold for `decision_function`)."
          },
          "pos_label": {
            "type": "int, float, bool or str, default=None",
            "description": "The label of the positive class. Used to process the output of the\n    `response_method` method. When `pos_label=None`, if `y_true` is in `{-1, 1}` or\n    `{0, 1}`, `pos_label` is set to 1, otherwise an error will be raised."
          },
          "response_method": {
            "type": "{\"auto\", \"decision_function\", \"predict_proba\"}, default=\"auto\"",
            "description": "Methods by the classifier `estimator` corresponding to the\n    decision function for which we want to find a threshold. It can be:\n\n    * if `\"auto\"`, it will try to invoke `\"predict_proba\"` or `\"decision_function\"`\n      in that order.\n    * otherwise, one of `\"predict_proba\"` or `\"decision_function\"`.\n      If the method is not implemented by the classifier, it will raise an\n      error.\n\nAttributes\n----------"
          },
          "estimator_": {
            "type": "estimator instance",
            "description": "The fitted classifier used when predicting."
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": "The class labels."
          },
          "n_features_in_": {
            "type": "int",
            "description": "Number of features seen during :term:`fit`. Only defined if the\n    underlying estimator exposes such an attribute when fit."
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": "Names of features seen during :term:`fit`. Only defined if the\n    underlying estimator exposes such an attribute when fit."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "sklearn.model_selection.TunedThresholdClassifierCV : Classifier that post-tunes\n    the decision threshold based on some metrics and using cross-validation.\nsklearn.calibration.CalibratedClassifierCV : Estimator that calibrates\n    probabilities.",
        "notes": "",
        "examples": ">>> from sklearn.datasets import make_classification\n>>> from sklearn.linear_model import LogisticRegression\n>>> from sklearn.metrics import confusion_matrix\n>>> from sklearn.model_selection import FixedThresholdClassifier, train_test_split\n>>> X, y = make_classification(\n...     n_samples=1_000, weights=[0.9, 0.1], class_sep=0.8, random_state=42\n... )\n>>> X_train, X_test, y_train, y_test = train_test_split(\n...     X, y, stratify=y, random_state=42\n... )\n>>> classifier = LogisticRegression(random_state=0).fit(X_train, y_train)\n>>> print(confusion_matrix(y_test, classifier.predict(X_test)))\n[[217   7]\n [ 19   7]]\n>>> classifier_other_threshold = FixedThresholdClassifier(\n...     classifier, threshold=0.1, response_method=\"predict_proba\"\n... ).fit(X_train, y_train)\n>>> print(confusion_matrix(y_test, classifier_other_threshold.predict(X_test)))\n[[184  40]\n [  6  20]]"
      },
      "methods": [
        {
          "name": "decision_function",
          "signature": "decision_function(self, X)",
          "docstring": {
            "description": "Decision function for samples in `X` using the fitted estimator.",
            "parameters": {
              "X": {
                "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
                "description": "Training vectors, where `n_samples` is the number of samples and\n    `n_features` is the number of features."
              }
            },
            "returns": "decisions : ndarray of shape (n_samples,)\n    The decision function computed the fitted estimator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit",
          "signature": "fit(self, X, y, **params)",
          "docstring": {
            "description": "Fit the classifier.",
            "parameters": {
              "X": {
                "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
                "description": "Training data."
              },
              "y": {
                "type": "array-like of shape (n_samples,)",
                "description": "Target values."
              },
              "**params": {
                "type": "dict",
                "description": "Parameters to pass to the `fit` method of the underlying\n    classifier."
              }
            },
            "returns": "self : object\n    Returns an instance of self.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRouter\n    A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "docstring": {
            "description": "Get parameters for this estimator.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": "If True, will return the parameters for this estimator and\n    contained subobjects that are estimators."
              }
            },
            "returns": "params : dict\n    Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict",
          "signature": "predict(self, X)",
          "docstring": {
            "description": "Predict the target of new samples.",
            "parameters": {
              "X": {
                "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
                "description": "The samples, as accepted by `estimator.predict`."
              }
            },
            "returns": "class_labels : ndarray of shape (n_samples,)\n    The predicted class.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_log_proba",
          "signature": "predict_log_proba(self, X)",
          "docstring": {
            "description": "Predict logarithm class probabilities for `X` using the fitted estimator.",
            "parameters": {
              "X": {
                "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
                "description": "Training vectors, where `n_samples` is the number of samples and\n    `n_features` is the number of features."
              }
            },
            "returns": "log_probabilities : ndarray of shape (n_samples, n_classes)\n    The logarithm class probabilities of the input samples.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_proba",
          "signature": "predict_proba(self, X)",
          "docstring": {
            "description": "Predict class probabilities for `X` using the fitted estimator.",
            "parameters": {
              "X": {
                "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
                "description": "Training vectors, where `n_samples` is the number of samples and\n    `n_features` is the number of features."
              }
            },
            "returns": "probabilities : ndarray of shape (n_samples, n_classes)\n    The class probabilities of the input samples.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score",
          "signature": "score(self, X, y, sample_weight=None)",
          "docstring": {
            "description": "Return the mean accuracy on the given test data and labels.\n\nIn multi-label classification, this is the subset accuracy\nwhich is a harsh metric since you require for each sample that\neach label set be correctly predicted.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Test samples."
              },
              "y": {
                "type": "array-like of shape (n_samples,) or (n_samples, n_outputs)",
                "description": "True labels for `X`."
              },
              "sample_weight": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "Sample weights."
              }
            },
            "returns": "score : float\n    Mean accuracy of ``self.predict(X)`` w.r.t. `y`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "docstring": {
            "description": "Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects\n(such as :class:`~sklearn.pipeline.Pipeline`). The latter have\nparameters of the form ``<component>__<parameter>`` so that it's\npossible to update each component of a nested object.",
            "parameters": {
              "**params": {
                "type": "dict",
                "description": "Estimator parameters."
              }
            },
            "returns": "self : estimator instance\n    Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_score_request",
          "signature": "set_score_request(self: sklearn.model_selection._classification_threshold.FixedThresholdClassifier, *, sample_weight: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._classification_threshold.FixedThresholdClassifier",
          "docstring": {
            "description": "Request metadata passed to the ``score`` method.\n\nNote that this method is only relevant if\n``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\nPlease see :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.\n\nThe options for each parameter are:\n\n- ``True``: metadata is requested, and passed to ``score`` if provided. The request is ignored if metadata is not provided.\n\n- ``False``: metadata is not requested and the meta-estimator will not pass it to ``score``.\n\n- ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n- ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\nexisting request. This allows you to change the request for some\nparameters and not others.\n\n.. versionadded:: 1.3\n\n.. note::\n    This method is only relevant if this estimator is used as a\n    sub-estimator of a meta-estimator, e.g. used inside a\n    :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.",
            "parameters": {
              "sample_weight": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": "Metadata routing for ``sample_weight`` parameter in ``score``."
              }
            },
            "returns": "self : object\n    The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "GridSearchCV",
      "docstring": {
        "description": "Exhaustive search over specified parameter values for an estimator.\n\nImportant members are fit, predict.\n\nGridSearchCV implements a \"fit\" and a \"score\" method.\nIt also implements \"score_samples\", \"predict\", \"predict_proba\",\n\"decision_function\", \"transform\" and \"inverse_transform\" if they are\nimplemented in the estimator used.\n\nThe parameters of the estimator used to apply these methods are optimized\nby cross-validated grid-search over a parameter grid.\n\nRead more in the :ref:`User Guide <grid_search>`.",
        "parameters": {
          "estimator": {
            "type": "estimator object",
            "description": "This is assumed to implement the scikit-learn estimator interface.\n    Either estimator needs to provide a ``score`` function,\n    or ``scoring`` must be passed."
          },
          "param_grid": {
            "type": "dict or list of dictionaries",
            "description": "Dictionary with parameters names (`str`) as keys and lists of\n    parameter settings to try as values, or a list of such\n    dictionaries, in which case the grids spanned by each dictionary\n    in the list are explored. This enables searching over any sequence\n    of parameter settings."
          },
          "scoring": {
            "type": "str, callable, list, tuple or dict, default=None",
            "description": "Strategy to evaluate the performance of the cross-validated model on\n    the test set.\n\n    If `scoring` represents a single score, one can use:\n\n    - a single string (see :ref:`scoring_parameter`);\n    - a callable (see :ref:`scoring_callable`) that returns a single value.\n\n    If `scoring` represents multiple scores, one can use:\n\n    - a list or tuple of unique strings;\n    - a callable returning a dictionary where the keys are the metric\n      names and the values are the metric scores;\n    - a dictionary with metric names as keys and callables as values.\n\n    See :ref:`multimetric_grid_search` for an example."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": "Number of jobs to run in parallel.\n    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n    for more details.\n\n    .. versionchanged:: v0.20\n       `n_jobs` default changed from 1 to None"
          },
          "refit": {
            "type": "bool, str, or callable, default=True",
            "description": "Refit an estimator using the best found parameters on the whole\n    dataset.\n\n    For multiple metric evaluation, this needs to be a `str` denoting the\n    scorer that would be used to find the best parameters for refitting\n    the estimator at the end.\n\n    Where there are considerations other than maximum score in\n    choosing a best estimator, ``refit`` can be set to a function which\n    returns the selected ``best_index_`` given ``cv_results_``. In that\n    case, the ``best_estimator_`` and ``best_params_`` will be set\n    according to the returned ``best_index_`` while the ``best_score_``\n    attribute will not be available.\n\n    The refitted estimator is made available at the ``best_estimator_``\n    attribute and permits using ``predict`` directly on this\n    ``GridSearchCV`` instance.\n\n    Also for multiple metric evaluation, the attributes ``best_index_``,\n    ``best_score_`` and ``best_params_`` will only be available if\n    ``refit`` is set and all of them will be determined w.r.t this specific\n    scorer.\n\n    See ``scoring`` parameter to know more about multiple metric\n    evaluation.\n\n    See :ref:`sphx_glr_auto_examples_model_selection_plot_grid_search_digits.py`\n    to see how to design a custom selection strategy using a callable\n    via `refit`.\n\n    .. versionchanged:: 0.20\n        Support for callable added."
          },
          "cv": {
            "type": "int, cross-validation generator or an iterable, default=None",
            "description": "Determines the cross-validation splitting strategy.\n    Possible inputs for cv are:\n\n    - None, to use the default 5-fold cross validation,\n    - integer, to specify the number of folds in a `(Stratified)KFold`,\n    - :term:`CV splitter`,\n    - An iterable yielding (train, test) splits as arrays of indices.\n\n    For integer/None inputs, if the estimator is a classifier and ``y`` is\n    either binary or multiclass, :class:`StratifiedKFold` is used. In all\n    other cases, :class:`KFold` is used. These splitters are instantiated\n    with `shuffle=False` so the splits will be the same across calls.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here.\n\n    .. versionchanged:: 0.22\n        ``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "verbose": {
            "type": "int",
            "description": "Controls the verbosity: the higher, the more messages.\n\n    - >1 : the computation time for each fold and parameter candidate is\n      displayed;\n    - >2 : the score is also displayed;\n    - >3 : the fold and candidate parameter indexes are also displayed\n      together with the starting time of the computation."
          },
          "pre_dispatch": {
            "type": "int, or str, default='2*n_jobs'",
            "description": "Controls the number of jobs that get dispatched during parallel\n    execution. Reducing this number can be useful to avoid an\n    explosion of memory consumption when more jobs get dispatched\n    than CPUs can process. This parameter can be:\n\n    - None, in which case all the jobs are immediately created and spawned. Use\n      this for lightweight and fast-running jobs, to avoid delays due to on-demand\n      spawning of the jobs\n    - An int, giving the exact number of total jobs that are spawned\n    - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'"
          },
          "error_score": {
            "type": "'raise' or numeric, default=np.nan",
            "description": "Value to assign to the score if an error occurs in estimator fitting.\n    If set to 'raise', the error is raised. If a numeric value is given,\n    FitFailedWarning is raised. This parameter does not affect the refit\n    step, which will always raise the error."
          },
          "return_train_score": {
            "type": "bool, default=False",
            "description": "If ``False``, the ``cv_results_`` attribute will not include training\n    scores.\n    Computing training scores is used to get insights on how different\n    parameter settings impact the overfitting/underfitting trade-off.\n    However computing the scores on the training set can be computationally\n    expensive and is not strictly required to select the parameters that\n    yield the best generalization performance.\n\n    .. versionadded:: 0.19\n\n    .. versionchanged:: 0.21\n        Default value was changed from ``True`` to ``False``\n\nAttributes\n----------"
          },
          "cv_results_": {
            "type": "dict of numpy (masked) ndarrays",
            "description": "A dict with keys as column headers and values as columns, that can be\n    imported into a pandas ``DataFrame``.\n\n    For instance the below given table\n\n    +------------+-----------+------------+-----------------+---+---------+\n    |param_kernel|param_gamma|param_degree|split0_test_score|...|rank_t...|\n    +============+===========+============+=================+===+=========+\n    |  'poly'    |     --    |      2     |       0.80      |...|    2    |\n    +------------+-----------+------------+-----------------+---+---------+\n    |  'poly'    |     --    |      3     |       0.70      |...|    4    |\n    +------------+-----------+------------+-----------------+---+---------+\n    |  'rbf'     |     0.1   |     --     |       0.80      |...|    3    |\n    +------------+-----------+------------+-----------------+---+---------+\n    |  'rbf'     |     0.2   |     --     |       0.93      |...|    1    |\n    +------------+-----------+------------+-----------------+---+---------+\n\n    will be represented by a ``cv_results_`` dict of::\n\n        {\n        'param_kernel': masked_array(data = ['poly', 'poly', 'rbf', 'rbf'],\n                                     mask = [False False False False]...)\n        'param_gamma': masked_array(data = [-- -- 0.1 0.2],\n                                    mask = [ True  True False False]...),\n        'param_degree': masked_array(data = [2.0 3.0 -- --],\n                                     mask = [False False  True  True]...),\n        'split0_test_score'  : [0.80, 0.70, 0.80, 0.93],\n        'split1_test_score'  : [0.82, 0.50, 0.70, 0.78],\n        'mean_test_score'    : [0.81, 0.60, 0.75, 0.85],\n        'std_test_score'     : [0.01, 0.10, 0.05, 0.08],\n        'rank_test_score'    : [2, 4, 3, 1],\n        'split0_train_score' : [0.80, 0.92, 0.70, 0.93],\n        'split1_train_score' : [0.82, 0.55, 0.70, 0.87],\n        'mean_train_score'   : [0.81, 0.74, 0.70, 0.90],\n        'std_train_score'    : [0.01, 0.19, 0.00, 0.03],\n        'mean_fit_time'      : [0.73, 0.63, 0.43, 0.49],\n        'std_fit_time'       : [0.01, 0.02, 0.01, 0.01],\n        'mean_score_time'    : [0.01, 0.06, 0.04, 0.04],\n        'std_score_time'     : [0.00, 0.00, 0.00, 0.01],\n        'params'             : [{'kernel': 'poly', 'degree': 2}, ...],\n        }\n\n    NOTE\n\n    The key ``'params'`` is used to store a list of parameter\n    settings dicts for all the parameter candidates.\n\n    The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and\n    ``std_score_time`` are all in seconds.\n\n    For multi-metric evaluation, the scores for all the scorers are\n    available in the ``cv_results_`` dict at the keys ending with that\n    scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\n    above. ('split0_test_precision', 'mean_train_precision' etc.)"
          },
          "best_estimator_": {
            "type": "estimator",
            "description": "Estimator that was chosen by the search, i.e. estimator\n    which gave highest score (or smallest loss if specified)\n    on the left out data. Not available if ``refit=False``.\n\n    See ``refit`` parameter for more information on allowed values."
          },
          "best_score_": {
            "type": "float",
            "description": "Mean cross-validated score of the best_estimator\n\n    For multi-metric evaluation, this is present only if ``refit`` is\n    specified.\n\n    This attribute is not available if ``refit`` is a function."
          },
          "best_params_": {
            "type": "dict",
            "description": "Parameter setting that gave the best results on the hold out data.\n\n    For multi-metric evaluation, this is present only if ``refit`` is\n    specified."
          },
          "best_index_": {
            "type": "int",
            "description": "The index (of the ``cv_results_`` arrays) which corresponds to the best\n    candidate parameter setting.\n\n    The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n    the parameter setting for the best model, that gives the highest\n    mean score (``search.best_score_``).\n\n    For multi-metric evaluation, this is present only if ``refit`` is\n    specified."
          },
          "scorer_": {
            "type": "function or a dict",
            "description": "Scorer function used on the held out data to choose the best\n    parameters for the model.\n\n    For multi-metric evaluation, this attribute holds the validated\n    ``scoring`` dict which maps the scorer key to the scorer callable."
          },
          "n_splits_": {
            "type": "int",
            "description": "The number of cross-validation splits (folds/iterations)."
          },
          "refit_time_": {
            "type": "float",
            "description": "Seconds used for refitting the best model on the whole dataset.\n\n    This is present only if ``refit`` is not False.\n\n    .. versionadded:: 0.20"
          },
          "multimetric_": {
            "type": "bool",
            "description": "Whether or not the scorers compute several metrics."
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": "The classes labels. This is present only if ``refit`` is specified and\n    the underlying estimator is a classifier."
          },
          "n_features_in_": {
            "type": "int",
            "description": "Number of features seen during :term:`fit`. Only defined if\n    `best_estimator_` is defined (see the documentation for the `refit`\n    parameter for more details) and that `best_estimator_` exposes\n    `n_features_in_` when fit.\n\n    .. versionadded:: 0.24"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": "Names of features seen during :term:`fit`. Only defined if\n    `best_estimator_` is defined (see the documentation for the `refit`\n    parameter for more details) and that `best_estimator_` exposes\n    `feature_names_in_` when fit.\n\n    .. versionadded:: 1.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "ParameterGrid : Generates all the combinations of a hyperparameter grid.\ntrain_test_split : Utility function to split the data into a development\n    set usable for fitting a GridSearchCV instance and an evaluation set\n    for its final evaluation.\nsklearn.metrics.make_scorer : Make a scorer from a performance metric or\n    loss function.",
        "notes": "The parameters selected are those that maximize the score of the left out\ndata, unless an explicit score is passed in which case it is used instead.\n\nIf `n_jobs` was set to a value higher than one, the data is copied for each\npoint in the grid (and not `n_jobs` times). This is done for efficiency\nreasons if individual jobs take very little time, but may raise errors if\nthe dataset is large and not enough memory is available.  A workaround in\nthis case is to set `pre_dispatch`. Then, the memory is copied only\n`pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\nn_jobs`.",
        "examples": ">>> from sklearn import svm, datasets\n>>> from sklearn.model_selection import GridSearchCV\n>>> iris = datasets.load_iris()\n>>> parameters = {'kernel':('linear', 'rbf'), 'C':[1, 10]}\n>>> svc = svm.SVC()\n>>> clf = GridSearchCV(svc, parameters)\n>>> clf.fit(iris.data, iris.target)\nGridSearchCV(estimator=SVC(),\n             param_grid={'C': [1, 10], 'kernel': ('linear', 'rbf')})\n>>> sorted(clf.cv_results_.keys())\n['mean_fit_time', 'mean_score_time', 'mean_test_score',...\n 'param_C', 'param_kernel', 'params',...\n 'rank_test_score', 'split0_test_score',...\n 'split2_test_score', ...\n 'std_fit_time', 'std_score_time', 'std_test_score']"
      },
      "methods": [
        {
          "name": "decision_function",
          "signature": "decision_function(self, X)",
          "docstring": {
            "description": "Call decision_function on the estimator with the best found parameters.\n\nOnly available if ``refit=True`` and the underlying estimator supports\n``decision_function``.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator."
              }
            },
            "returns": "y_score : ndarray of shape (n_samples,) or (n_samples, n_classes)                 or (n_samples, n_classes * (n_classes-1) / 2)\n    Result of the decision function for `X` based on the estimator with\n    the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit",
          "signature": "fit(self, X, y=None, **params)",
          "docstring": {
            "description": "Run fit with all sets of parameters.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features) or (n_samples, n_samples)",
                "description": "Training vectors, where `n_samples` is the number of samples and\n    `n_features` is the number of features. For precomputed kernel or\n    distance matrix, the expected shape of X is (n_samples, n_samples)."
              },
              "y": {
                "type": "array-like of shape (n_samples, n_output)             or (n_samples,), default=None",
                "description": "Target relative to X for classification or regression;\n    None for unsupervised learning."
              },
              "**params": {
                "type": "dict of str -> object",
                "description": "Parameters passed to the ``fit`` method of the estimator, the scorer,\n    and the CV splitter.\n\n    If a fit parameter is an array-like whose length is equal to\n    `num_samples` then it will be split by cross-validation along with\n    `X` and `y`. For example, the :term:`sample_weight` parameter is\n    split because `len(sample_weights) = len(X)`. However, this behavior\n    does not apply to `groups` which is passed to the splitter configured\n    via the `cv` parameter of the constructor. Thus, `groups` is used\n    *to perform the split* and determines which samples are\n    assigned to the each side of the a split."
              }
            },
            "returns": "self : object\n    Instance of fitted estimator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.\n\n.. versionadded:: 1.4",
            "parameters": {},
            "returns": "routing : MetadataRouter\n    A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "docstring": {
            "description": "Get parameters for this estimator.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": "If True, will return the parameters for this estimator and\n    contained subobjects that are estimators."
              }
            },
            "returns": "params : dict\n    Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X=None, Xt=None)",
          "docstring": {
            "description": "Call inverse_transform on the estimator with the best found params.\n\nOnly available if the underlying estimator implements\n``inverse_transform`` and ``refit=True``.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator."
              },
              "Xt": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator.\n\n    .. deprecated:: 1.5\n        `Xt` was deprecated in 1.5 and will be removed in 1.7. Use `X` instead."
              }
            },
            "returns": "X : {ndarray, sparse matrix} of shape (n_samples, n_features)\n    Result of the `inverse_transform` function for `Xt` based on the\n    estimator with the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict",
          "signature": "predict(self, X)",
          "docstring": {
            "description": "Call predict on the estimator with the best found parameters.\n\nOnly available if ``refit=True`` and the underlying estimator supports\n``predict``.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator."
              }
            },
            "returns": "y_pred : ndarray of shape (n_samples,)\n    The predicted labels or values for `X` based on the estimator with\n    the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_log_proba",
          "signature": "predict_log_proba(self, X)",
          "docstring": {
            "description": "Call predict_log_proba on the estimator with the best found parameters.\n\nOnly available if ``refit=True`` and the underlying estimator supports\n``predict_log_proba``.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator."
              }
            },
            "returns": "y_pred : ndarray of shape (n_samples,) or (n_samples, n_classes)\n    Predicted class log-probabilities for `X` based on the estimator\n    with the best found parameters. The order of the classes\n    corresponds to that in the fitted attribute :term:`classes_`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_proba",
          "signature": "predict_proba(self, X)",
          "docstring": {
            "description": "Call predict_proba on the estimator with the best found parameters.\n\nOnly available if ``refit=True`` and the underlying estimator supports\n``predict_proba``.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator."
              }
            },
            "returns": "y_pred : ndarray of shape (n_samples,) or (n_samples, n_classes)\n    Predicted class probabilities for `X` based on the estimator with\n    the best found parameters. The order of the classes corresponds\n    to that in the fitted attribute :term:`classes_`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score",
          "signature": "score(self, X, y=None, **params)",
          "docstring": {
            "description": "Return the score on the given data, if the estimator has been refit.\n\nThis uses the score defined by ``scoring`` where provided, and the\n``best_estimator_.score`` method otherwise.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Input data, where `n_samples` is the number of samples and\n    `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples, n_output)             or (n_samples,), default=None",
                "description": "Target relative to X for classification or regression;\n    None for unsupervised learning."
              },
              "**params": {
                "type": "dict",
                "description": "Parameters to be passed to the underlying scorer(s).\n\n    .. versionadded:: 1.4\n        Only available if `enable_metadata_routing=True`. See\n        :ref:`Metadata Routing User Guide <metadata_routing>` for more\n        details."
              }
            },
            "returns": "score : float\n    The score defined by ``scoring`` if provided, and the\n    ``best_estimator_.score`` method otherwise.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score_samples",
          "signature": "score_samples(self, X)",
          "docstring": {
            "description": "Call score_samples on the estimator with the best found parameters.\n\nOnly available if ``refit=True`` and the underlying estimator supports\n``score_samples``.\n\n.. versionadded:: 0.24",
            "parameters": {
              "X": {
                "type": "iterable",
                "description": "Data to predict on. Must fulfill input requirements\n    of the underlying estimator."
              }
            },
            "returns": "y_score : ndarray of shape (n_samples,)\n    The ``best_estimator_.score_samples`` method.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "docstring": {
            "description": "Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects\n(such as :class:`~sklearn.pipeline.Pipeline`). The latter have\nparameters of the form ``<component>__<parameter>`` so that it's\npossible to update each component of a nested object.",
            "parameters": {
              "**params": {
                "type": "dict",
                "description": "Estimator parameters."
              }
            },
            "returns": "self : estimator instance\n    Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "docstring": {
            "description": "Call transform on the estimator with the best found parameters.\n\nOnly available if the underlying estimator supports ``transform`` and\n``refit=True``.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator."
              }
            },
            "returns": "Xt : {ndarray, sparse matrix} of shape (n_samples, n_features)\n    `X` transformed in the new space based on the estimator with\n    the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "GroupKFold",
      "docstring": {
        "description": "K-fold iterator variant with non-overlapping groups.\n\nEach group will appear exactly once in the test set across all folds (the\nnumber of distinct groups has to be at least equal to the number of folds).\n\nThe folds are approximately balanced in the sense that the number of\nsamples is approximately the same in each test fold when `shuffle` is True.\n\nRead more in the :ref:`User Guide <group_k_fold>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of folds. Must be at least 2.\n\n    .. versionchanged:: 0.22\n        ``n_splits`` default value changed from 3 to 5."
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": "Whether to shuffle the groups before splitting into batches.\n    Note that the samples within each split will not be shuffled.\n\n    .. versionadded:: 1.6"
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "When `shuffle` is True, `random_state` affects the ordering of the\n    indices, which controls the randomness of each fold. Otherwise, this\n    parameter has no effect.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`.\n\n    .. versionadded:: 1.6"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "LeaveOneGroupOut : For splitting the data according to explicit\n    domain-specific stratification of the dataset.\n\nStratifiedKFold : Takes class information into account to avoid building\n    folds with imbalanced class proportions (for binary or multiclass\n    classification tasks).",
        "notes": "Groups appear in an arbitrary order throughout the folds.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import GroupKFold\n>>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])\n>>> y = np.array([1, 2, 3, 4, 5, 6])\n>>> groups = np.array([0, 0, 2, 2, 3, 3])\n>>> group_kfold = GroupKFold(n_splits=2)\n>>> group_kfold.get_n_splits(X, y, groups)\n2\n>>> print(group_kfold)\nGroupKFold(n_splits=2, random_state=None, shuffle=False)\n>>> for i, (train_index, test_index) in enumerate(group_kfold.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\nFold 0:\n  Train: index=[2 3], group=[2 2]\n  Test:  index=[0 1 4 5], group=[0 0 3 3]\nFold 1:\n  Train: index=[0 1 4 5], group=[0 0 3 3]\n  Test:  index=[2 3], group=[2 2]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_split_request",
          "signature": "set_split_request(self: sklearn.model_selection._split.GroupKFold, *, groups: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._split.GroupKFold",
          "docstring": {
            "description": "Request metadata passed to the ``split`` method.\n\nNote that this method is only relevant if\n``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\nPlease see :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.\n\nThe options for each parameter are:\n\n- ``True``: metadata is requested, and passed to ``split`` if provided. The request is ignored if metadata is not provided.\n\n- ``False``: metadata is not requested and the meta-estimator will not pass it to ``split``.\n\n- ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n- ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\nexisting request. This allows you to change the request for some\nparameters and not others.\n\n.. versionadded:: 1.3\n\n.. note::\n    This method is only relevant if this estimator is used as a\n    sub-estimator of a meta-estimator, e.g. used inside a\n    :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.",
            "parameters": {
              "groups": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": "Metadata routing for ``groups`` parameter in ``split``."
              }
            },
            "returns": "self : object\n    The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "The target variable for supervised learning problems."
              },
              "groups": {
                "type": "array-like of shape (n_samples,)",
                "description": "Group labels for the samples used while splitting the dataset into\n    train/test set.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "GroupShuffleSplit",
      "docstring": {
        "description": "Shuffle-Group(s)-Out cross-validation iterator.\n\nProvides randomized train/test indices to split data according to a\nthird-party provided group. This group information can be used to encode\narbitrary domain specific stratifications of the samples as integers.\n\nFor instance the groups could be the year of collection of the samples\nand thus allow for cross-validation against time-based splits.\n\nThe difference between :class:`LeavePGroupsOut` and ``GroupShuffleSplit`` is that\nthe former generates splits using all subsets of size ``p`` unique groups,\nwhereas ``GroupShuffleSplit`` generates a user-determined number of random\ntest splits, each with a user-determined fraction of unique groups.\n\nFor example, a less computationally intensive alternative to\n``LeavePGroupsOut(p=10)`` would be\n``GroupShuffleSplit(test_size=10, n_splits=100)``.\n\nContrary to other cross-validation strategies, the random splits\ndo not guarantee that test sets across all folds will be mutually exclusive,\nand might include overlapping samples. However, this is still very likely for\nsizeable datasets.\n\nNote: The parameters ``test_size`` and ``train_size`` refer to groups, and\nnot to samples as in :class:`ShuffleSplit`.\n\nRead more in the :ref:`User Guide <group_shuffle_split>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of re-shuffling & splitting iterations."
          },
          "test_size": {
            "type": "float, int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the proportion\n    of groups to include in the test split (rounded up). If int,\n    represents the absolute number of test groups. If None, the value is\n    set to the complement of the train size. If ``train_size`` is also None,\n    it will be set to 0.2."
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the\n    proportion of the groups to include in the train split. If\n    int, represents the absolute number of train groups. If None,\n    the value is automatically set to the complement of the test size."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the randomness of the training and testing indices produced.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "ShuffleSplit : Shuffles samples to create independent test/train sets.\n\nLeavePGroupsOut : Train set leaves out all possible subsets of `p` groups.",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import GroupShuffleSplit\n>>> X = np.ones(shape=(8, 2))\n>>> y = np.ones(shape=(8, 1))\n>>> groups = np.array([1, 1, 2, 2, 2, 3, 3, 3])\n>>> print(groups.shape)\n(8,)\n>>> gss = GroupShuffleSplit(n_splits=2, train_size=.7, random_state=42)\n>>> gss.get_n_splits()\n2\n>>> print(gss)\nGroupShuffleSplit(n_splits=2, random_state=42, test_size=None, train_size=0.7)\n>>> for i, (train_index, test_index) in enumerate(gss.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\nFold 0:\n  Train: index=[2 3 4 5 6 7], group=[2 2 2 3 3 3]\n  Test:  index=[0 1], group=[1 1]\nFold 1:\n  Train: index=[0 1 5 6 7], group=[1 1 3 3 3]\n  Test:  index=[2 3 4], group=[2 2 2]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_split_request",
          "signature": "set_split_request(self: sklearn.model_selection._split.GroupShuffleSplit, *, groups: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._split.GroupShuffleSplit",
          "docstring": {
            "description": "Request metadata passed to the ``split`` method.\n\nNote that this method is only relevant if\n``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\nPlease see :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.\n\nThe options for each parameter are:\n\n- ``True``: metadata is requested, and passed to ``split`` if provided. The request is ignored if metadata is not provided.\n\n- ``False``: metadata is not requested and the meta-estimator will not pass it to ``split``.\n\n- ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n- ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\nexisting request. This allows you to change the request for some\nparameters and not others.\n\n.. versionadded:: 1.3\n\n.. note::\n    This method is only relevant if this estimator is used as a\n    sub-estimator of a meta-estimator, e.g. used inside a\n    :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.",
            "parameters": {
              "groups": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": "Metadata routing for ``groups`` parameter in ``split``."
              }
            },
            "returns": "self : object\n    The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "The target variable for supervised learning problems."
              },
              "groups": {
                "type": "array-like of shape (n_samples,)",
                "description": "Group labels for the samples used while splitting the dataset into\n    train/test set.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "Randomized CV splitters may return different results for each call of\nsplit. You can make the results identical by setting `random_state`\nto an integer.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "KFold",
      "docstring": {
        "description": "K-Fold cross-validator.\n\nProvides train/test indices to split data in train/test sets. Split\ndataset into k consecutive folds (without shuffling by default).\n\nEach fold is then used once as a validation while the k - 1 remaining\nfolds form the training set.\n\nRead more in the :ref:`User Guide <k_fold>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of folds. Must be at least 2.\n\n    .. versionchanged:: 0.22\n        ``n_splits`` default value changed from 3 to 5."
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": "Whether to shuffle the data before splitting into batches.\n    Note that the samples within each split will not be shuffled."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "When `shuffle` is True, `random_state` affects the ordering of the\n    indices, which controls the randomness of each fold. Otherwise, this\n    parameter has no effect.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "StratifiedKFold : Takes class information into account to avoid building\n    folds with imbalanced class distributions (for binary or multiclass\n    classification tasks).\n\nGroupKFold : K-fold iterator variant with non-overlapping groups.\n\nRepeatedKFold : Repeats K-Fold n times.",
        "notes": "The first ``n_samples % n_splits`` folds have size\n``n_samples // n_splits + 1``, other folds have size\n``n_samples // n_splits``, where ``n_samples`` is the number of samples.\n\nRandomized CV splitters may return different results for each call of\nsplit. You can make the results identical by setting `random_state`\nto an integer.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import KFold\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([1, 2, 3, 4])\n>>> kf = KFold(n_splits=2)\n>>> kf.get_n_splits(X)\n2\n>>> print(kf)\nKFold(n_splits=2, random_state=None, shuffle=False)\n>>> for i, (train_index, test_index) in enumerate(kf.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[2 3]\n  Test:  index=[0 1]\nFold 1:\n  Train: index=[0 1]\n  Test:  index=[2 3]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,)",
                "description": "The target variable for supervised learning problems."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "LearningCurveDisplay",
      "docstring": {
        "description": "Learning Curve visualization.\n\nIt is recommended to use\n:meth:`~sklearn.model_selection.LearningCurveDisplay.from_estimator` to\ncreate a :class:`~sklearn.model_selection.LearningCurveDisplay` instance.\nAll parameters are stored as attributes.\n\nRead more in the :ref:`User Guide <visualizations>` for general information\nabout the visualization API and\n:ref:`detailed documentation <learning_curve>` regarding the learning\ncurve visualization.\n\n.. versionadded:: 1.2",
        "parameters": {
          "train_sizes": {
            "type": "ndarray of shape (n_unique_ticks,)",
            "description": "Numbers of training examples that has been used to generate the\n    learning curve."
          },
          "train_scores": {
            "type": "ndarray of shape (n_ticks, n_cv_folds)",
            "description": "Scores on training sets."
          },
          "test_scores": {
            "type": "ndarray of shape (n_ticks, n_cv_folds)",
            "description": "Scores on test set."
          },
          "score_name": {
            "type": "str, default=None",
            "description": "The name of the score used in `learning_curve`. It will override the name\n    inferred from the `scoring` parameter. If `score` is `None`, we use `\"Score\"` if\n    `negate_score` is `False` and `\"Negative score\"` otherwise. If `scoring` is a\n    string or a callable, we infer the name. We replace `_` by spaces and capitalize\n    the first letter. We remove `neg_` and replace it by `\"Negative\"` if\n    `negate_score` is `False` or just remove it otherwise.\n\nAttributes\n----------"
          },
          "ax_": {
            "type": "matplotlib Axes",
            "description": "Axes with the learning curve."
          },
          "figure_": {
            "type": "matplotlib Figure",
            "description": "Figure containing the learning curve."
          },
          "errorbar_": {
            "type": "list of matplotlib Artist or None",
            "description": "When the `std_display_style` is `\"errorbar\"`, this is a list of\n    `matplotlib.container.ErrorbarContainer` objects. If another style is\n    used, `errorbar_` is `None`."
          },
          "lines_": {
            "type": "list of matplotlib Artist or None",
            "description": "When the `std_display_style` is `\"fill_between\"`, this is a list of\n    `matplotlib.lines.Line2D` objects corresponding to the mean train and\n    test scores. If another style is used, `line_` is `None`."
          },
          "fill_between_": {
            "type": "list of matplotlib Artist or None",
            "description": "When the `std_display_style` is `\"fill_between\"`, this is a list of\n    `matplotlib.collections.PolyCollection` objects. If another style is\n    used, `fill_between_` is `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "sklearn.model_selection.learning_curve : Compute the learning curve.",
        "notes": "",
        "examples": ">>> import matplotlib.pyplot as plt\n>>> from sklearn.datasets import load_iris\n>>> from sklearn.model_selection import LearningCurveDisplay, learning_curve\n>>> from sklearn.tree import DecisionTreeClassifier\n>>> X, y = load_iris(return_X_y=True)\n>>> tree = DecisionTreeClassifier(random_state=0)\n>>> train_sizes, train_scores, test_scores = learning_curve(\n...     tree, X, y)\n>>> display = LearningCurveDisplay(train_sizes=train_sizes,\n...     train_scores=train_scores, test_scores=test_scores, score_name=\"Score\")\n>>> display.plot()\n<...>\n>>> plt.show()"
      },
      "methods": [
        {
          "name": "from_estimator",
          "signature": "from_estimator(estimator, X, y, *, groups=None, train_sizes=array([0.1  , 0.325, 0.55 , 0.775, 1.   ]), cv=None, scoring=None, exploit_incremental_learning=False, n_jobs=None, pre_dispatch='all', verbose=0, shuffle=False, random_state=None, error_score=nan, fit_params=None, ax=None, negate_score=False, score_name=None, score_type='both', std_display_style='fill_between', line_kw=None, fill_between_kw=None, errorbar_kw=None)",
          "docstring": {
            "description": "Create a learning curve display from an estimator.\n\nRead more in the :ref:`User Guide <visualizations>` for general\ninformation about the visualization API and :ref:`detailed\ndocumentation <learning_curve>` regarding the learning curve\nvisualization.",
            "parameters": {
              "estimator": {
                "type": "object type that implements the \"fit\" and \"predict\" methods",
                "description": "An object of that type which is cloned for each validation."
              },
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples and\n    `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,) or (n_samples, n_outputs) or None",
                "description": "Target relative to X for classification or regression;\n    None for unsupervised learning."
              },
              "groups": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "Group labels for the samples used while splitting the dataset into\n    train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n    instance (e.g., :class:`GroupKFold`)."
              },
              "train_sizes": {
                "type": "array-like of shape (n_ticks,),                 default=np.linspace(0.1, 1.0, 5)",
                "description": "Relative or absolute numbers of training examples that will be used\n    to generate the learning curve. If the dtype is float, it is\n    regarded as a fraction of the maximum size of the training set\n    (that is determined by the selected validation method), i.e. it has\n    to be within (0, 1]. Otherwise it is interpreted as absolute sizes\n    of the training sets. Note that for classification the number of\n    samples usually have to be big enough to contain at least one\n    sample from each class."
              },
              "cv": {
                "type": "int, cross-validation generator or an iterable, default=None",
                "description": "Determines the cross-validation splitting strategy.\n    Possible inputs for cv are:\n\n    - None, to use the default 5-fold cross validation,\n    - int, to specify the number of folds in a `(Stratified)KFold`,\n    - :term:`CV splitter`,\n    - An iterable yielding (train, test) splits as arrays of indices.\n\n    For int/None inputs, if the estimator is a classifier and `y` is\n    either binary or multiclass,\n    :class:`~sklearn.model_selection.StratifiedKFold` is used. In all\n    other cases, :class:`~sklearn.model_selection.KFold` is used. These\n    splitters are instantiated with `shuffle=False` so the splits will\n    be the same across calls.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here."
              },
              "scoring": {
                "type": "str or callable, default=None",
                "description": "A string (see :ref:`scoring_parameter`) or\n    a scorer callable object / function with signature\n    `scorer(estimator, X, y)` (see :ref:`scoring_callable`)."
              },
              "exploit_incremental_learning": {
                "type": "bool, default=False",
                "description": "If the estimator supports incremental learning, this will be\n    used to speed up fitting for different training set sizes."
              },
              "n_jobs": {
                "type": "int, default=None",
                "description": "Number of jobs to run in parallel. Training the estimator and\n    computing the score are parallelized over the different training\n    and test sets. `None` means 1 unless in a\n    :obj:`joblib.parallel_backend` context. `-1` means using all\n    processors. See :term:`Glossary <n_jobs>` for more details."
              },
              "pre_dispatch": {
                "type": "int or str, default='all'",
                "description": "Number of predispatched jobs for parallel execution (default is\n    all). The option can reduce the allocated memory. The str can\n    be an expression like '2*n_jobs'."
              },
              "verbose": {
                "type": "int, default=0",
                "description": "Controls the verbosity: the higher, the more messages."
              },
              "shuffle": {
                "type": "bool, default=False",
                "description": "Whether to shuffle training data before taking prefixes of it\n    based on`train_sizes`."
              },
              "random_state": {
                "type": "int, RandomState instance or None, default=None",
                "description": "Used when `shuffle` is True. Pass an int for reproducible\n    output across multiple function calls.\n    See :term:`Glossary <random_state>`."
              },
              "error_score": {
                "type": "'raise' or numeric, default=np.nan",
                "description": "Value to assign to the score if an error occurs in estimator\n    fitting. If set to 'raise', the error is raised. If a numeric value\n    is given, FitFailedWarning is raised."
              },
              "fit_params": {
                "type": "dict, default=None",
                "description": "Parameters to pass to the fit method of the estimator."
              },
              "ax": {
                "type": "matplotlib Axes, default=None",
                "description": "Axes object to plot on. If `None`, a new figure and axes is\n    created."
              },
              "negate_score": {
                "type": "bool, default=False",
                "description": "Whether or not to negate the scores obtained through\n    :func:`~sklearn.model_selection.learning_curve`. This is\n    particularly useful when using the error denoted by `neg_*` in\n    `scikit-learn`."
              },
              "score_name": {
                "type": "str, default=None",
                "description": "The name of the score used to decorate the y-axis of the plot. It will\n    override the name inferred from the `scoring` parameter. If `score` is\n    `None`, we use `\"Score\"` if `negate_score` is `False` and `\"Negative score\"`\n    otherwise. If `scoring` is a string or a callable, we infer the name. We\n    replace `_` by spaces and capitalize the first letter. We remove `neg_` and\n    replace it by `\"Negative\"` if `negate_score` is\n    `False` or just remove it otherwise."
              },
              "score_type": {
                "type": "{\"test\", \"train\", \"both\"}, default=\"both\"",
                "description": "The type of score to plot. Can be one of `\"test\"`, `\"train\"`, or\n    `\"both\"`."
              },
              "std_display_style": {
                "type": "{\"errorbar\", \"fill_between\"} or None, default=\"fill_between\"",
                "description": "The style used to display the score standard deviation around the\n    mean score. If `None`, no representation of the standard deviation\n    is displayed."
              },
              "line_kw": {
                "type": "dict, default=None",
                "description": "Additional keyword arguments passed to the `plt.plot` used to draw\n    the mean score."
              },
              "fill_between_kw": {
                "type": "dict, default=None",
                "description": "Additional keyword arguments passed to the `plt.fill_between` used\n    to draw the score standard deviation."
              },
              "errorbar_kw": {
                "type": "dict, default=None",
                "description": "Additional keyword arguments passed to the `plt.errorbar` used to\n    draw mean score and standard deviation score."
              }
            },
            "returns": "display : :class:`~sklearn.model_selection.LearningCurveDisplay`\n    Object that stores computed values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> import matplotlib.pyplot as plt\n>>> from sklearn.datasets import load_iris\n>>> from sklearn.model_selection import LearningCurveDisplay\n>>> from sklearn.tree import DecisionTreeClassifier\n>>> X, y = load_iris(return_X_y=True)\n>>> tree = DecisionTreeClassifier(random_state=0)\n>>> LearningCurveDisplay.from_estimator(tree, X, y)\n<...>\n>>> plt.show()"
          }
        },
        {
          "name": "plot",
          "signature": "plot(self, ax=None, *, negate_score=False, score_name=None, score_type='both', std_display_style='fill_between', line_kw=None, fill_between_kw=None, errorbar_kw=None)",
          "docstring": {
            "description": "Plot visualization.",
            "parameters": {
              "ax": {
                "type": "matplotlib Axes, default=None",
                "description": "Axes object to plot on. If `None`, a new figure and axes is\n    created."
              },
              "negate_score": {
                "type": "bool, default=False",
                "description": "Whether or not to negate the scores obtained through\n    :func:`~sklearn.model_selection.learning_curve`. This is\n    particularly useful when using the error denoted by `neg_*` in\n    `scikit-learn`."
              },
              "score_name": {
                "type": "str, default=None",
                "description": "The name of the score used to decorate the y-axis of the plot. It will\n    override the name inferred from the `scoring` parameter. If `score` is\n    `None`, we use `\"Score\"` if `negate_score` is `False` and `\"Negative score\"`\n    otherwise. If `scoring` is a string or a callable, we infer the name. We\n    replace `_` by spaces and capitalize the first letter. We remove `neg_` and\n    replace it by `\"Negative\"` if `negate_score` is\n    `False` or just remove it otherwise."
              },
              "score_type": {
                "type": "{\"test\", \"train\", \"both\"}, default=\"both\"",
                "description": "The type of score to plot. Can be one of `\"test\"`, `\"train\"`, or\n    `\"both\"`."
              },
              "std_display_style": {
                "type": "{\"errorbar\", \"fill_between\"} or None, default=\"fill_between\"",
                "description": "The style used to display the score standard deviation around the\n    mean score. If None, no standard deviation representation is\n    displayed."
              },
              "line_kw": {
                "type": "dict, default=None",
                "description": "Additional keyword arguments passed to the `plt.plot` used to draw\n    the mean score."
              },
              "fill_between_kw": {
                "type": "dict, default=None",
                "description": "Additional keyword arguments passed to the `plt.fill_between` used\n    to draw the score standard deviation."
              },
              "errorbar_kw": {
                "type": "dict, default=None",
                "description": "Additional keyword arguments passed to the `plt.errorbar` used to\n    draw mean score and standard deviation score."
              }
            },
            "returns": "display : :class:`~sklearn.model_selection.LearningCurveDisplay`\n    Object that stores computed values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "LeaveOneGroupOut",
      "docstring": {
        "description": "Leave One Group Out cross-validator.\n\nProvides train/test indices to split data such that each training set is\ncomprised of all samples except ones belonging to one specific group.\nArbitrary domain specific group information is provided as an array of integers\nthat encodes the group of each sample.\n\nFor instance the groups could be the year of collection of the samples\nand thus allow for cross-validation against time-based splits.\n\nRead more in the :ref:`User Guide <leave_one_group_out>`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "Splits are ordered according to the index of the group left out. The first\nsplit has testing set consisting of the group whose index in `groups` is\nlowest, and so on.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import LeaveOneGroupOut\n>>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\n>>> y = np.array([1, 2, 1, 2])\n>>> groups = np.array([1, 1, 2, 2])\n>>> logo = LeaveOneGroupOut()\n>>> logo.get_n_splits(X, y, groups)\n2\n>>> logo.get_n_splits(groups=groups)  # 'groups' is always required\n2\n>>> print(logo)\nLeaveOneGroupOut()\n>>> for i, (train_index, test_index) in enumerate(logo.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\nFold 0:\n  Train: index=[2 3], group=[2 2]\n  Test:  index=[0 1], group=[1 1]\nFold 1:\n  Train: index=[0 1], group=[1 1]\n  Test:  index=[2 3], group=[2 2]\n\nSee also\n--------\nGroupKFold: K-fold iterator variant with non-overlapping groups."
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "array-like of shape (n_samples,)",
                "description": "Group labels for the samples used while splitting the dataset into\n    train/test set. This 'groups' parameter must always be specified to\n    calculate the number of splits, though the other parameters can be\n    omitted."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_split_request",
          "signature": "set_split_request(self: sklearn.model_selection._split.LeaveOneGroupOut, *, groups: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._split.LeaveOneGroupOut",
          "docstring": {
            "description": "Request metadata passed to the ``split`` method.\n\nNote that this method is only relevant if\n``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\nPlease see :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.\n\nThe options for each parameter are:\n\n- ``True``: metadata is requested, and passed to ``split`` if provided. The request is ignored if metadata is not provided.\n\n- ``False``: metadata is not requested and the meta-estimator will not pass it to ``split``.\n\n- ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n- ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\nexisting request. This allows you to change the request for some\nparameters and not others.\n\n.. versionadded:: 1.3\n\n.. note::\n    This method is only relevant if this estimator is used as a\n    sub-estimator of a meta-estimator, e.g. used inside a\n    :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.",
            "parameters": {
              "groups": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": "Metadata routing for ``groups`` parameter in ``split``."
              }
            },
            "returns": "self : object\n    The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "The target variable for supervised learning problems."
              },
              "groups": {
                "type": "array-like of shape (n_samples,)",
                "description": "Group labels for the samples used while splitting the dataset into\n    train/test set.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "LeaveOneOut",
      "docstring": {
        "description": "Leave-One-Out cross-validator.\n\nProvides train/test indices to split data in train/test sets. Each\nsample is used once as a test set (singleton) while the remaining\nsamples form the training set.\n\nNote: ``LeaveOneOut()`` is equivalent to ``KFold(n_splits=n)`` and\n``LeavePOut(p=1)`` where ``n`` is the number of samples.\n\nDue to the high number of test sets (which is the same as the\nnumber of samples) this cross-validation method can be very costly.\nFor large datasets one should favor :class:`KFold`, :class:`ShuffleSplit`\nor :class:`StratifiedKFold`.\n\nRead more in the :ref:`User Guide <leave_one_out>`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "LeaveOneGroupOut : For splitting the data according to explicit,\n    domain-specific stratification of the dataset.\nGroupKFold : K-fold iterator variant with non-overlapping groups.",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import LeaveOneOut\n>>> X = np.array([[1, 2], [3, 4]])\n>>> y = np.array([1, 2])\n>>> loo = LeaveOneOut()\n>>> loo.get_n_splits(X)\n2\n>>> print(loo)\nLeaveOneOut()\n>>> for i, (train_index, test_index) in enumerate(loo.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[1]\n  Test:  index=[0]\nFold 1:\n  Train: index=[0]\n  Test:  index=[1]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,)",
                "description": "The target variable for supervised learning problems."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "LeavePGroupsOut",
      "docstring": {
        "description": "Leave P Group(s) Out cross-validator.\n\nProvides train/test indices to split data according to a third-party\nprovided group. This group information can be used to encode arbitrary\ndomain specific stratifications of the samples as integers.\n\nFor instance the groups could be the year of collection of the samples\nand thus allow for cross-validation against time-based splits.\n\nThe difference between LeavePGroupsOut and LeaveOneGroupOut is that\nthe former builds the test sets with all the samples assigned to\n``p`` different values of the groups while the latter uses samples\nall assigned the same groups.\n\nRead more in the :ref:`User Guide <leave_p_groups_out>`.",
        "parameters": {
          "n_groups": {
            "type": "int",
            "description": "Number of groups (``p``) to leave out in the test split."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "GroupKFold : K-fold iterator variant with non-overlapping groups.",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import LeavePGroupsOut\n>>> X = np.array([[1, 2], [3, 4], [5, 6]])\n>>> y = np.array([1, 2, 1])\n>>> groups = np.array([1, 2, 3])\n>>> lpgo = LeavePGroupsOut(n_groups=2)\n>>> lpgo.get_n_splits(X, y, groups)\n3\n>>> lpgo.get_n_splits(groups=groups)  # 'groups' is always required\n3\n>>> print(lpgo)\nLeavePGroupsOut(n_groups=2)\n>>> for i, (train_index, test_index) in enumerate(lpgo.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\nFold 0:\n  Train: index=[2], group=[3]\n  Test:  index=[0 1], group=[1 2]\nFold 1:\n  Train: index=[1], group=[2]\n  Test:  index=[0 2], group=[1 3]\nFold 2:\n  Train: index=[0], group=[1]\n  Test:  index=[1 2], group=[2 3]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "array-like of shape (n_samples,)",
                "description": "Group labels for the samples used while splitting the dataset into\n    train/test set. This 'groups' parameter must always be specified to\n    calculate the number of splits, though the other parameters can be\n    omitted."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_split_request",
          "signature": "set_split_request(self: sklearn.model_selection._split.LeavePGroupsOut, *, groups: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._split.LeavePGroupsOut",
          "docstring": {
            "description": "Request metadata passed to the ``split`` method.\n\nNote that this method is only relevant if\n``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\nPlease see :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.\n\nThe options for each parameter are:\n\n- ``True``: metadata is requested, and passed to ``split`` if provided. The request is ignored if metadata is not provided.\n\n- ``False``: metadata is not requested and the meta-estimator will not pass it to ``split``.\n\n- ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n- ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\nexisting request. This allows you to change the request for some\nparameters and not others.\n\n.. versionadded:: 1.3\n\n.. note::\n    This method is only relevant if this estimator is used as a\n    sub-estimator of a meta-estimator, e.g. used inside a\n    :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.",
            "parameters": {
              "groups": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": "Metadata routing for ``groups`` parameter in ``split``."
              }
            },
            "returns": "self : object\n    The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "The target variable for supervised learning problems."
              },
              "groups": {
                "type": "array-like of shape (n_samples,)",
                "description": "Group labels for the samples used while splitting the dataset into\n    train/test set.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "LeavePOut",
      "docstring": {
        "description": "Leave-P-Out cross-validator.\n\nProvides train/test indices to split data in train/test sets. This results\nin testing on all distinct samples of size p, while the remaining n - p\nsamples form the training set in each iteration.\n\nNote: ``LeavePOut(p)`` is NOT equivalent to\n``KFold(n_splits=n_samples // p)`` which creates non-overlapping test sets.\n\nDue to the high number of iterations which grows combinatorically with the\nnumber of samples this cross-validation method can be very costly. For\nlarge datasets one should favor :class:`KFold`, :class:`StratifiedKFold`\nor :class:`ShuffleSplit`.\n\nRead more in the :ref:`User Guide <leave_p_out>`.",
        "parameters": {
          "p": {
            "type": "int",
            "description": "Size of the test sets. Must be strictly less than the number of\n    samples."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import LeavePOut\n>>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\n>>> y = np.array([1, 2, 3, 4])\n>>> lpo = LeavePOut(2)\n>>> lpo.get_n_splits(X)\n6\n>>> print(lpo)\nLeavePOut(p=2)\n>>> for i, (train_index, test_index) in enumerate(lpo.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[2 3]\n  Test:  index=[0 1]\nFold 1:\n  Train: index=[1 3]\n  Test:  index=[0 2]\nFold 2:\n  Train: index=[1 2]\n  Test:  index=[0 3]\nFold 3:\n  Train: index=[0 3]\n  Test:  index=[1 2]\nFold 4:\n  Train: index=[0 2]\n  Test:  index=[1 3]\nFold 5:\n  Train: index=[0 1]\n  Test:  index=[2 3]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,)",
                "description": "The target variable for supervised learning problems."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ParameterGrid",
      "docstring": {
        "description": "Grid of parameters with a discrete number of values for each.\n\nCan be used to iterate over parameter value combinations with the\nPython built-in function iter.\nThe order of the generated parameter combinations is deterministic.\n\nRead more in the :ref:`User Guide <grid_search>`.",
        "parameters": {
          "param_grid": {
            "type": "dict of str to sequence, or sequence of such",
            "description": "The parameter grid to explore, as a dictionary mapping estimator\n    parameters to sequences of allowed values.\n\n    An empty dict signifies default parameters.\n\n    A sequence of dicts signifies a sequence of grids to search, and is\n    useful to avoid exploring parameter combinations that make no sense\n    or have no effect. See the examples below."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "GridSearchCV : Uses :class:`ParameterGrid` to perform a full parallelized\n    parameter search.",
        "notes": "",
        "examples": ">>> from sklearn.model_selection import ParameterGrid\n>>> param_grid = {'a': [1, 2], 'b': [True, False]}\n>>> list(ParameterGrid(param_grid)) == (\n...    [{'a': 1, 'b': True}, {'a': 1, 'b': False},\n...     {'a': 2, 'b': True}, {'a': 2, 'b': False}])\nTrue\n\n>>> grid = [{'kernel': ['linear']}, {'kernel': ['rbf'], 'gamma': [1, 10]}]\n>>> list(ParameterGrid(grid)) == [{'kernel': 'linear'},\n...                               {'kernel': 'rbf', 'gamma': 1},\n...                               {'kernel': 'rbf', 'gamma': 10}]\nTrue\n>>> ParameterGrid(grid)[1] == {'kernel': 'rbf', 'gamma': 1}\nTrue"
      },
      "methods": []
    },
    {
      "name": "ParameterSampler",
      "docstring": {
        "description": "Generator on parameters sampled from given distributions.\n\nNon-deterministic iterable over random candidate combinations for hyper-\nparameter search. If all parameters are presented as a list,\nsampling without replacement is performed. If at least one parameter\nis given as a distribution, sampling with replacement is used.\nIt is highly recommended to use continuous distributions for continuous\nparameters.\n\nRead more in the :ref:`User Guide <grid_search>`.",
        "parameters": {
          "param_distributions": {
            "type": "dict",
            "description": "Dictionary with parameters names (`str`) as keys and distributions\n    or lists of parameters to try. Distributions must provide a ``rvs``\n    method for sampling (such as those from scipy.stats.distributions).\n    If a list is given, it is sampled uniformly.\n    If a list of dicts is given, first a dict is sampled uniformly, and\n    then a parameter is sampled using that dict as above."
          },
          "n_iter": {
            "type": "int",
            "description": "Number of parameter settings that are produced."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Pseudo random number generator state used for random uniform sampling\n    from lists of possible values instead of scipy.stats distributions.\n    Pass an int for reproducible output across multiple\n    function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "params : dict of str to any\n    **Yields** dictionaries mapping each estimator parameter to\n    as sampled value.",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> from sklearn.model_selection import ParameterSampler\n>>> from scipy.stats.distributions import expon\n>>> import numpy as np\n>>> rng = np.random.RandomState(0)\n>>> param_grid = {'a':[1, 2], 'b': expon()}\n>>> param_list = list(ParameterSampler(param_grid, n_iter=4,\n...                                    random_state=rng))\n>>> rounded_list = [dict((k, round(v, 6)) for (k, v) in d.items())\n...                 for d in param_list]\n>>> rounded_list == [{'b': 0.89856, 'a': 1},\n...                  {'b': 0.923223, 'a': 1},\n...                  {'b': 1.878964, 'a': 2},\n...                  {'b': 1.038159, 'a': 2}]\nTrue"
      },
      "methods": []
    },
    {
      "name": "PredefinedSplit",
      "docstring": {
        "description": "Predefined split cross-validator.\n\nProvides train/test indices to split data into train/test sets using a\npredefined scheme specified by the user with the ``test_fold`` parameter.\n\nRead more in the :ref:`User Guide <predefined_split>`.\n\n.. versionadded:: 0.16",
        "parameters": {
          "test_fold": {
            "type": "array-like of shape (n_samples,)",
            "description": "The entry ``test_fold[i]`` represents the index of the test set that\n    sample ``i`` belongs to. It is possible to exclude sample ``i`` from\n    any test set (i.e. include sample ``i`` in every training set) by\n    setting ``test_fold[i]`` equal to -1."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import PredefinedSplit\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([0, 0, 1, 1])\n>>> test_fold = [0, 1, -1, 1]\n>>> ps = PredefinedSplit(test_fold)\n>>> ps.get_n_splits()\n2\n>>> print(ps)\nPredefinedSplit(test_fold=array([ 0,  1, -1,  1]))\n>>> for i, (train_index, test_index) in enumerate(ps.split()):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[1 2 3]\n  Test:  index=[0]\nFold 1:\n  Train: index=[0 2]\n  Test:  index=[1 3]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "RandomizedSearchCV",
      "docstring": {
        "description": "Randomized search on hyper parameters.\n\nRandomizedSearchCV implements a \"fit\" and a \"score\" method.\nIt also implements \"score_samples\", \"predict\", \"predict_proba\",\n\"decision_function\", \"transform\" and \"inverse_transform\" if they are\nimplemented in the estimator used.\n\nThe parameters of the estimator used to apply these methods are optimized\nby cross-validated search over parameter settings.\n\nIn contrast to GridSearchCV, not all parameter values are tried out, but\nrather a fixed number of parameter settings is sampled from the specified\ndistributions. The number of parameter settings that are tried is\ngiven by n_iter.\n\nIf all parameters are presented as a list,\nsampling without replacement is performed. If at least one parameter\nis given as a distribution, sampling with replacement is used.\nIt is highly recommended to use continuous distributions for continuous\nparameters.\n\nRead more in the :ref:`User Guide <randomized_parameter_search>`.\n\n.. versionadded:: 0.14",
        "parameters": {
          "estimator": {
            "type": "estimator object",
            "description": "An object of that type is instantiated for each grid point.\n    This is assumed to implement the scikit-learn estimator interface.\n    Either estimator needs to provide a ``score`` function,\n    or ``scoring`` must be passed."
          },
          "param_distributions": {
            "type": "dict or list of dicts",
            "description": "Dictionary with parameters names (`str`) as keys and distributions\n    or lists of parameters to try. Distributions must provide a ``rvs``\n    method for sampling (such as those from scipy.stats.distributions).\n    If a list is given, it is sampled uniformly.\n    If a list of dicts is given, first a dict is sampled uniformly, and\n    then a parameter is sampled using that dict as above."
          },
          "n_iter": {
            "type": "int, default=10",
            "description": "Number of parameter settings that are sampled. n_iter trades\n    off runtime vs quality of the solution."
          },
          "scoring": {
            "type": "str, callable, list, tuple or dict, default=None",
            "description": "Strategy to evaluate the performance of the cross-validated model on\n    the test set.\n\n    If `scoring` represents a single score, one can use:\n\n    - a single string (see :ref:`scoring_parameter`);\n    - a callable (see :ref:`scoring_callable`) that returns a single value.\n\n    If `scoring` represents multiple scores, one can use:\n\n    - a list or tuple of unique strings;\n    - a callable returning a dictionary where the keys are the metric\n      names and the values are the metric scores;\n    - a dictionary with metric names as keys and callables as values.\n\n    See :ref:`multimetric_grid_search` for an example.\n\n    If None, the estimator's score method is used."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": "Number of jobs to run in parallel.\n    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n    for more details.\n\n    .. versionchanged:: v0.20\n       `n_jobs` default changed from 1 to None"
          },
          "refit": {
            "type": "bool, str, or callable, default=True",
            "description": "Refit an estimator using the best found parameters on the whole\n    dataset.\n\n    For multiple metric evaluation, this needs to be a `str` denoting the\n    scorer that would be used to find the best parameters for refitting\n    the estimator at the end.\n\n    Where there are considerations other than maximum score in\n    choosing a best estimator, ``refit`` can be set to a function which\n    returns the selected ``best_index_`` given the ``cv_results_``. In that\n    case, the ``best_estimator_`` and ``best_params_`` will be set\n    according to the returned ``best_index_`` while the ``best_score_``\n    attribute will not be available.\n\n    The refitted estimator is made available at the ``best_estimator_``\n    attribute and permits using ``predict`` directly on this\n    ``RandomizedSearchCV`` instance.\n\n    Also for multiple metric evaluation, the attributes ``best_index_``,\n    ``best_score_`` and ``best_params_`` will only be available if\n    ``refit`` is set and all of them will be determined w.r.t this specific\n    scorer.\n\n    See ``scoring`` parameter to know more about multiple metric\n    evaluation.\n\n    .. versionchanged:: 0.20\n        Support for callable added."
          },
          "cv": {
            "type": "int, cross-validation generator or an iterable, default=None",
            "description": "Determines the cross-validation splitting strategy.\n    Possible inputs for cv are:\n\n    - None, to use the default 5-fold cross validation,\n    - integer, to specify the number of folds in a `(Stratified)KFold`,\n    - :term:`CV splitter`,\n    - An iterable yielding (train, test) splits as arrays of indices.\n\n    For integer/None inputs, if the estimator is a classifier and ``y`` is\n    either binary or multiclass, :class:`StratifiedKFold` is used. In all\n    other cases, :class:`KFold` is used. These splitters are instantiated\n    with `shuffle=False` so the splits will be the same across calls.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here.\n\n    .. versionchanged:: 0.22\n        ``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "verbose": {
            "type": "int",
            "description": "Controls the verbosity: the higher, the more messages.\n\n    - >1 : the computation time for each fold and parameter candidate is\n      displayed;\n    - >2 : the score is also displayed;\n    - >3 : the fold and candidate parameter indexes are also displayed\n      together with the starting time of the computation."
          },
          "pre_dispatch": {
            "type": "int, or str, default='2*n_jobs'",
            "description": "Controls the number of jobs that get dispatched during parallel\n    execution. Reducing this number can be useful to avoid an\n    explosion of memory consumption when more jobs get dispatched\n    than CPUs can process. This parameter can be:\n\n    - None, in which case all the jobs are immediately created and spawned. Use\n      this for lightweight and fast-running jobs, to avoid delays due to on-demand\n      spawning of the jobs\n    - An int, giving the exact number of total jobs that are spawned\n    - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'"
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Pseudo random number generator state used for random uniform sampling\n    from lists of possible values instead of scipy.stats distributions.\n    Pass an int for reproducible output across multiple\n    function calls.\n    See :term:`Glossary <random_state>`."
          },
          "error_score": {
            "type": "'raise' or numeric, default=np.nan",
            "description": "Value to assign to the score if an error occurs in estimator fitting.\n    If set to 'raise', the error is raised. If a numeric value is given,\n    FitFailedWarning is raised. This parameter does not affect the refit\n    step, which will always raise the error."
          },
          "return_train_score": {
            "type": "bool, default=False",
            "description": "If ``False``, the ``cv_results_`` attribute will not include training\n    scores.\n    Computing training scores is used to get insights on how different\n    parameter settings impact the overfitting/underfitting trade-off.\n    However computing the scores on the training set can be computationally\n    expensive and is not strictly required to select the parameters that\n    yield the best generalization performance.\n\n    .. versionadded:: 0.19\n\n    .. versionchanged:: 0.21\n        Default value was changed from ``True`` to ``False``\n\nAttributes\n----------"
          },
          "cv_results_": {
            "type": "dict of numpy (masked) ndarrays",
            "description": "A dict with keys as column headers and values as columns, that can be\n    imported into a pandas ``DataFrame``.\n\n    For instance the below given table\n\n    +--------------+-------------+-------------------+---+---------------+\n    | param_kernel | param_gamma | split0_test_score |...|rank_test_score|\n    +==============+=============+===================+===+===============+\n    |    'rbf'     |     0.1     |       0.80        |...|       1       |\n    +--------------+-------------+-------------------+---+---------------+\n    |    'rbf'     |     0.2     |       0.84        |...|       3       |\n    +--------------+-------------+-------------------+---+---------------+\n    |    'rbf'     |     0.3     |       0.70        |...|       2       |\n    +--------------+-------------+-------------------+---+---------------+\n\n    will be represented by a ``cv_results_`` dict of::\n\n        {\n        'param_kernel' : masked_array(data = ['rbf', 'rbf', 'rbf'],\n                                      mask = False),\n        'param_gamma'  : masked_array(data = [0.1 0.2 0.3], mask = False),\n        'split0_test_score'  : [0.80, 0.84, 0.70],\n        'split1_test_score'  : [0.82, 0.50, 0.70],\n        'mean_test_score'    : [0.81, 0.67, 0.70],\n        'std_test_score'     : [0.01, 0.24, 0.00],\n        'rank_test_score'    : [1, 3, 2],\n        'split0_train_score' : [0.80, 0.92, 0.70],\n        'split1_train_score' : [0.82, 0.55, 0.70],\n        'mean_train_score'   : [0.81, 0.74, 0.70],\n        'std_train_score'    : [0.01, 0.19, 0.00],\n        'mean_fit_time'      : [0.73, 0.63, 0.43],\n        'std_fit_time'       : [0.01, 0.02, 0.01],\n        'mean_score_time'    : [0.01, 0.06, 0.04],\n        'std_score_time'     : [0.00, 0.00, 0.00],\n        'params'             : [{'kernel' : 'rbf', 'gamma' : 0.1}, ...],\n        }\n\n    NOTE\n\n    The key ``'params'`` is used to store a list of parameter\n    settings dicts for all the parameter candidates.\n\n    The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and\n    ``std_score_time`` are all in seconds.\n\n    For multi-metric evaluation, the scores for all the scorers are\n    available in the ``cv_results_`` dict at the keys ending with that\n    scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\n    above. ('split0_test_precision', 'mean_train_precision' etc.)"
          },
          "best_estimator_": {
            "type": "estimator",
            "description": "Estimator that was chosen by the search, i.e. estimator\n    which gave highest score (or smallest loss if specified)\n    on the left out data. Not available if ``refit=False``.\n\n    For multi-metric evaluation, this attribute is present only if\n    ``refit`` is specified.\n\n    See ``refit`` parameter for more information on allowed values."
          },
          "best_score_": {
            "type": "float",
            "description": "Mean cross-validated score of the best_estimator.\n\n    For multi-metric evaluation, this is not available if ``refit`` is\n    ``False``. See ``refit`` parameter for more information.\n\n    This attribute is not available if ``refit`` is a function."
          },
          "best_params_": {
            "type": "dict",
            "description": "Parameter setting that gave the best results on the hold out data.\n\n    For multi-metric evaluation, this is not available if ``refit`` is\n    ``False``. See ``refit`` parameter for more information."
          },
          "best_index_": {
            "type": "int",
            "description": "The index (of the ``cv_results_`` arrays) which corresponds to the best\n    candidate parameter setting.\n\n    The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n    the parameter setting for the best model, that gives the highest\n    mean score (``search.best_score_``).\n\n    For multi-metric evaluation, this is not available if ``refit`` is\n    ``False``. See ``refit`` parameter for more information."
          },
          "scorer_": {
            "type": "function or a dict",
            "description": "Scorer function used on the held out data to choose the best\n    parameters for the model.\n\n    For multi-metric evaluation, this attribute holds the validated\n    ``scoring`` dict which maps the scorer key to the scorer callable."
          },
          "n_splits_": {
            "type": "int",
            "description": "The number of cross-validation splits (folds/iterations)."
          },
          "refit_time_": {
            "type": "float",
            "description": "Seconds used for refitting the best model on the whole dataset.\n\n    This is present only if ``refit`` is not False.\n\n    .. versionadded:: 0.20"
          },
          "multimetric_": {
            "type": "bool",
            "description": "Whether or not the scorers compute several metrics."
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": "The classes labels. This is present only if ``refit`` is specified and\n    the underlying estimator is a classifier."
          },
          "n_features_in_": {
            "type": "int",
            "description": "Number of features seen during :term:`fit`. Only defined if\n    `best_estimator_` is defined (see the documentation for the `refit`\n    parameter for more details) and that `best_estimator_` exposes\n    `n_features_in_` when fit.\n\n    .. versionadded:: 0.24"
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": "Names of features seen during :term:`fit`. Only defined if\n    `best_estimator_` is defined (see the documentation for the `refit`\n    parameter for more details) and that `best_estimator_` exposes\n    `feature_names_in_` when fit.\n\n    .. versionadded:: 1.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "GridSearchCV : Does exhaustive search over a grid of parameters.\nParameterSampler : A generator over parameter settings, constructed from\n    param_distributions.",
        "notes": "The parameters selected are those that maximize the score of the held-out\ndata, according to the scoring parameter.\n\nIf `n_jobs` was set to a value higher than one, the data is copied for each\nparameter setting(and not `n_jobs` times). This is done for efficiency\nreasons if individual jobs take very little time, but may raise errors if\nthe dataset is large and not enough memory is available.  A workaround in\nthis case is to set `pre_dispatch`. Then, the memory is copied only\n`pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\nn_jobs`.",
        "examples": ">>> from sklearn.datasets import load_iris\n>>> from sklearn.linear_model import LogisticRegression\n>>> from sklearn.model_selection import RandomizedSearchCV\n>>> from scipy.stats import uniform\n>>> iris = load_iris()\n>>> logistic = LogisticRegression(solver='saga', tol=1e-2, max_iter=200,\n...                               random_state=0)\n>>> distributions = dict(C=uniform(loc=0, scale=4),\n...                      penalty=['l2', 'l1'])\n>>> clf = RandomizedSearchCV(logistic, distributions, random_state=0)\n>>> search = clf.fit(iris.data, iris.target)\n>>> search.best_params_\n{'C': np.float64(2...), 'penalty': 'l1'}"
      },
      "methods": [
        {
          "name": "decision_function",
          "signature": "decision_function(self, X)",
          "docstring": {
            "description": "Call decision_function on the estimator with the best found parameters.\n\nOnly available if ``refit=True`` and the underlying estimator supports\n``decision_function``.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator."
              }
            },
            "returns": "y_score : ndarray of shape (n_samples,) or (n_samples, n_classes)                 or (n_samples, n_classes * (n_classes-1) / 2)\n    Result of the decision function for `X` based on the estimator with\n    the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit",
          "signature": "fit(self, X, y=None, **params)",
          "docstring": {
            "description": "Run fit with all sets of parameters.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features) or (n_samples, n_samples)",
                "description": "Training vectors, where `n_samples` is the number of samples and\n    `n_features` is the number of features. For precomputed kernel or\n    distance matrix, the expected shape of X is (n_samples, n_samples)."
              },
              "y": {
                "type": "array-like of shape (n_samples, n_output)             or (n_samples,), default=None",
                "description": "Target relative to X for classification or regression;\n    None for unsupervised learning."
              },
              "**params": {
                "type": "dict of str -> object",
                "description": "Parameters passed to the ``fit`` method of the estimator, the scorer,\n    and the CV splitter.\n\n    If a fit parameter is an array-like whose length is equal to\n    `num_samples` then it will be split by cross-validation along with\n    `X` and `y`. For example, the :term:`sample_weight` parameter is\n    split because `len(sample_weights) = len(X)`. However, this behavior\n    does not apply to `groups` which is passed to the splitter configured\n    via the `cv` parameter of the constructor. Thus, `groups` is used\n    *to perform the split* and determines which samples are\n    assigned to the each side of the a split."
              }
            },
            "returns": "self : object\n    Instance of fitted estimator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.\n\n.. versionadded:: 1.4",
            "parameters": {},
            "returns": "routing : MetadataRouter\n    A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "docstring": {
            "description": "Get parameters for this estimator.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": "If True, will return the parameters for this estimator and\n    contained subobjects that are estimators."
              }
            },
            "returns": "params : dict\n    Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X=None, Xt=None)",
          "docstring": {
            "description": "Call inverse_transform on the estimator with the best found params.\n\nOnly available if the underlying estimator implements\n``inverse_transform`` and ``refit=True``.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator."
              },
              "Xt": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator.\n\n    .. deprecated:: 1.5\n        `Xt` was deprecated in 1.5 and will be removed in 1.7. Use `X` instead."
              }
            },
            "returns": "X : {ndarray, sparse matrix} of shape (n_samples, n_features)\n    Result of the `inverse_transform` function for `Xt` based on the\n    estimator with the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict",
          "signature": "predict(self, X)",
          "docstring": {
            "description": "Call predict on the estimator with the best found parameters.\n\nOnly available if ``refit=True`` and the underlying estimator supports\n``predict``.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator."
              }
            },
            "returns": "y_pred : ndarray of shape (n_samples,)\n    The predicted labels or values for `X` based on the estimator with\n    the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_log_proba",
          "signature": "predict_log_proba(self, X)",
          "docstring": {
            "description": "Call predict_log_proba on the estimator with the best found parameters.\n\nOnly available if ``refit=True`` and the underlying estimator supports\n``predict_log_proba``.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator."
              }
            },
            "returns": "y_pred : ndarray of shape (n_samples,) or (n_samples, n_classes)\n    Predicted class log-probabilities for `X` based on the estimator\n    with the best found parameters. The order of the classes\n    corresponds to that in the fitted attribute :term:`classes_`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_proba",
          "signature": "predict_proba(self, X)",
          "docstring": {
            "description": "Call predict_proba on the estimator with the best found parameters.\n\nOnly available if ``refit=True`` and the underlying estimator supports\n``predict_proba``.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator."
              }
            },
            "returns": "y_pred : ndarray of shape (n_samples,) or (n_samples, n_classes)\n    Predicted class probabilities for `X` based on the estimator with\n    the best found parameters. The order of the classes corresponds\n    to that in the fitted attribute :term:`classes_`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score",
          "signature": "score(self, X, y=None, **params)",
          "docstring": {
            "description": "Return the score on the given data, if the estimator has been refit.\n\nThis uses the score defined by ``scoring`` where provided, and the\n``best_estimator_.score`` method otherwise.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Input data, where `n_samples` is the number of samples and\n    `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples, n_output)             or (n_samples,), default=None",
                "description": "Target relative to X for classification or regression;\n    None for unsupervised learning."
              },
              "**params": {
                "type": "dict",
                "description": "Parameters to be passed to the underlying scorer(s).\n\n    .. versionadded:: 1.4\n        Only available if `enable_metadata_routing=True`. See\n        :ref:`Metadata Routing User Guide <metadata_routing>` for more\n        details."
              }
            },
            "returns": "score : float\n    The score defined by ``scoring`` if provided, and the\n    ``best_estimator_.score`` method otherwise.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score_samples",
          "signature": "score_samples(self, X)",
          "docstring": {
            "description": "Call score_samples on the estimator with the best found parameters.\n\nOnly available if ``refit=True`` and the underlying estimator supports\n``score_samples``.\n\n.. versionadded:: 0.24",
            "parameters": {
              "X": {
                "type": "iterable",
                "description": "Data to predict on. Must fulfill input requirements\n    of the underlying estimator."
              }
            },
            "returns": "y_score : ndarray of shape (n_samples,)\n    The ``best_estimator_.score_samples`` method.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "docstring": {
            "description": "Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects\n(such as :class:`~sklearn.pipeline.Pipeline`). The latter have\nparameters of the form ``<component>__<parameter>`` so that it's\npossible to update each component of a nested object.",
            "parameters": {
              "**params": {
                "type": "dict",
                "description": "Estimator parameters."
              }
            },
            "returns": "self : estimator instance\n    Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "docstring": {
            "description": "Call transform on the estimator with the best found parameters.\n\nOnly available if the underlying estimator supports ``transform`` and\n``refit=True``.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": "Must fulfill the input assumptions of the\n    underlying estimator."
              }
            },
            "returns": "Xt : {ndarray, sparse matrix} of shape (n_samples, n_features)\n    `X` transformed in the new space based on the estimator with\n    the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "RepeatedKFold",
      "docstring": {
        "description": "Repeated K-Fold cross validator.\n\nRepeats K-Fold n times with different randomization in each repetition.\n\nRead more in the :ref:`User Guide <repeated_k_fold>`.",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of folds. Must be at least 2."
          },
          "n_repeats": {
            "type": "int, default=10",
            "description": "Number of times cross-validator needs to be repeated."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the randomness of each repeated cross-validation instance.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "RepeatedStratifiedKFold : Repeats Stratified K-Fold n times.",
        "notes": "Randomized CV splitters may return different results for each call of\nsplit. You can make the results identical by setting `random_state`\nto an integer.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import RepeatedKFold\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([0, 0, 1, 1])\n>>> rkf = RepeatedKFold(n_splits=2, n_repeats=2, random_state=2652124)\n>>> rkf.get_n_splits(X, y)\n4\n>>> print(rkf)\nRepeatedKFold(n_repeats=2, n_splits=2, random_state=2652124)\n>>> for i, (train_index, test_index) in enumerate(rkf.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\n...\nFold 0:\n  Train: index=[0 1]\n  Test:  index=[2 3]\nFold 1:\n  Train: index=[2 3]\n  Test:  index=[0 1]\nFold 2:\n  Train: index=[1 2]\n  Test:  index=[0 3]\nFold 3:\n  Train: index=[0 3]\n  Test:  index=[1 2]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility.\n    ``np.zeros(n_samples)`` may be used as a placeholder."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility.\n    ``np.zeros(n_samples)`` may be used as a placeholder."
              },
              "groups": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "Group labels for the samples used while splitting the dataset into\n    train/test set."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,)",
                "description": "The target variable for supervised learning problems."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "RepeatedStratifiedKFold",
      "docstring": {
        "description": "Repeated Stratified K-Fold cross validator.\n\nRepeats Stratified K-Fold n times with different randomization in each\nrepetition.\n\nRead more in the :ref:`User Guide <repeated_k_fold>`.",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of folds. Must be at least 2."
          },
          "n_repeats": {
            "type": "int, default=10",
            "description": "Number of times cross-validator needs to be repeated."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the generation of the random states for each repetition.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "RepeatedKFold : Repeats K-Fold n times.",
        "notes": "Randomized CV splitters may return different results for each call of\nsplit. You can make the results identical by setting `random_state`\nto an integer.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import RepeatedStratifiedKFold\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([0, 0, 1, 1])\n>>> rskf = RepeatedStratifiedKFold(n_splits=2, n_repeats=2,\n...     random_state=36851234)\n>>> rskf.get_n_splits(X, y)\n4\n>>> print(rskf)\nRepeatedStratifiedKFold(n_repeats=2, n_splits=2, random_state=36851234)\n>>> for i, (train_index, test_index) in enumerate(rskf.split(X, y)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\n...\nFold 0:\n  Train: index=[1 2]\n  Test:  index=[0 3]\nFold 1:\n  Train: index=[0 3]\n  Test:  index=[1 2]\nFold 2:\n  Train: index=[1 3]\n  Test:  index=[0 2]\nFold 3:\n  Train: index=[0 2]\n  Test:  index=[1 3]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility.\n    ``np.zeros(n_samples)`` may be used as a placeholder."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility.\n    ``np.zeros(n_samples)`` may be used as a placeholder."
              },
              "groups": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "Group labels for the samples used while splitting the dataset into\n    train/test set."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features.\n\n    Note that providing ``y`` is sufficient to generate the splits and\n    hence ``np.zeros(n_samples)`` may be used as a placeholder for\n    ``X`` instead of actual training data."
              },
              "y": {
                "type": "array-like of shape (n_samples,)",
                "description": "The target variable for supervised learning problems.\n    Stratification is done based on the y labels."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "Randomized CV splitters may return different results for each call of\nsplit. You can make the results identical by setting `random_state`\nto an integer.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ShuffleSplit",
      "docstring": {
        "description": "Random permutation cross-validator.\n\nYields indices to split data into training and test sets.\n\nNote: contrary to other cross-validation strategies, random splits\ndo not guarantee that test sets across all folds will be mutually exclusive,\nand might include overlapping samples. However, this is still very likely for\nsizeable datasets.\n\nRead more in the :ref:`User Guide <ShuffleSplit>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=10",
            "description": "Number of re-shuffling & splitting iterations."
          },
          "test_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the proportion\n    of the dataset to include in the test split. If int, represents the\n    absolute number of test samples. If None, the value is set to the\n    complement of the train size. If ``train_size`` is also None, it will\n    be set to 0.1."
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the\n    proportion of the dataset to include in the train split. If\n    int, represents the absolute number of train samples. If None,\n    the value is automatically set to the complement of the test size."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the randomness of the training and testing indices produced.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import ShuffleSplit\n>>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [3, 4], [5, 6]])\n>>> y = np.array([1, 2, 1, 2, 1, 2])\n>>> rs = ShuffleSplit(n_splits=5, test_size=.25, random_state=0)\n>>> rs.get_n_splits(X)\n5\n>>> print(rs)\nShuffleSplit(n_splits=5, random_state=0, test_size=0.25, train_size=None)\n>>> for i, (train_index, test_index) in enumerate(rs.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[1 3 0 4]\n  Test:  index=[5 2]\nFold 1:\n  Train: index=[4 0 2 5]\n  Test:  index=[1 3]\nFold 2:\n  Train: index=[1 2 4 0]\n  Test:  index=[3 5]\nFold 3:\n  Train: index=[3 4 1 0]\n  Test:  index=[5 2]\nFold 4:\n  Train: index=[3 5 1 0]\n  Test:  index=[2 4]\n>>> # Specify train and test size\n>>> rs = ShuffleSplit(n_splits=5, train_size=0.5, test_size=.25,\n...                   random_state=0)\n>>> for i, (train_index, test_index) in enumerate(rs.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[1 3 0]\n  Test:  index=[5 2]\nFold 1:\n  Train: index=[4 0 2]\n  Test:  index=[1 3]\nFold 2:\n  Train: index=[1 2 4]\n  Test:  index=[3 5]\nFold 3:\n  Train: index=[3 4 1]\n  Test:  index=[5 2]\nFold 4:\n  Train: index=[3 5 1]\n  Test:  index=[2 4]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,)",
                "description": "The target variable for supervised learning problems."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "StratifiedGroupKFold",
      "docstring": {
        "description": "Stratified K-Fold iterator variant with non-overlapping groups.\n\nThis cross-validation object is a variation of StratifiedKFold attempts to\nreturn stratified folds with non-overlapping groups. The folds are made by\npreserving the percentage of samples for each class.\n\nEach group will appear exactly once in the test set across all folds (the\nnumber of distinct groups has to be at least equal to the number of folds).\n\nThe difference between :class:`GroupKFold`\nand `StratifiedGroupKFold` is that\nthe former attempts to create balanced folds such that the number of\ndistinct groups is approximately the same in each fold, whereas\n`StratifiedGroupKFold` attempts to create folds which preserve the\npercentage of samples for each class as much as possible given the\nconstraint of non-overlapping groups between splits.\n\nRead more in the :ref:`User Guide <stratified_group_k_fold>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of folds. Must be at least 2."
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": "Whether to shuffle each class's samples before splitting into batches.\n    Note that the samples within each split will not be shuffled.\n    This implementation can only shuffle groups that have approximately the\n    same y distribution, no global shuffle will be performed."
          },
          "random_state": {
            "type": "int or RandomState instance, default=None",
            "description": "When `shuffle` is True, `random_state` affects the ordering of the\n    indices, which controls the randomness of each fold for each class.\n    Otherwise, leave `random_state` as `None`.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "The implementation is designed to:\n\n* Mimic the behavior of StratifiedKFold as much as possible for trivial\n  groups (e.g. when each group contains only one sample).\n* Be invariant to class label: relabelling ``y = [\"Happy\", \"Sad\"]`` to\n  ``y = [1, 0]`` should not change the indices generated.\n* Stratify based on samples as much as possible while keeping\n  non-overlapping groups constraint. That means that in some cases when\n  there is a small number of groups containing a large number of samples\n  the stratification will not be possible and the behavior will be close\n  to GroupKFold.\n\nSee also\n--------\nStratifiedKFold: Takes class information into account to build folds which\n    retain class distributions (for binary or multiclass classification\n    tasks).\n\nGroupKFold: K-fold iterator variant with non-overlapping groups.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import StratifiedGroupKFold\n>>> X = np.ones((17, 2))\n>>> y = np.array([0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n>>> groups = np.array([1, 1, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5, 6, 6, 7, 8, 8])\n>>> sgkf = StratifiedGroupKFold(n_splits=3)\n>>> sgkf.get_n_splits(X, y)\n3\n>>> print(sgkf)\nStratifiedGroupKFold(n_splits=3, random_state=None, shuffle=False)\n>>> for i, (train_index, test_index) in enumerate(sgkf.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"         group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}\")\n...     print(f\"         group={groups[test_index]}\")\nFold 0:\n  Train: index=[ 0  1  2  3  7  8  9 10 11 15 16]\n         group=[1 1 2 2 4 5 5 5 5 8 8]\n  Test:  index=[ 4  5  6 12 13 14]\n         group=[3 3 3 6 6 7]\nFold 1:\n  Train: index=[ 4  5  6  7  8  9 10 11 12 13 14]\n         group=[3 3 3 4 5 5 5 5 6 6 7]\n  Test:  index=[ 0  1  2  3 15 16]\n         group=[1 1 2 2 8 8]\nFold 2:\n  Train: index=[ 0  1  2  3  4  5  6 12 13 14 15 16]\n         group=[1 1 2 2 3 3 3 6 6 7 8 8]\n  Test:  index=[ 7  8  9 10 11]\n         group=[4 5 5 5 5]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_split_request",
          "signature": "set_split_request(self: sklearn.model_selection._split.StratifiedGroupKFold, *, groups: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._split.StratifiedGroupKFold",
          "docstring": {
            "description": "Request metadata passed to the ``split`` method.\n\nNote that this method is only relevant if\n``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\nPlease see :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.\n\nThe options for each parameter are:\n\n- ``True``: metadata is requested, and passed to ``split`` if provided. The request is ignored if metadata is not provided.\n\n- ``False``: metadata is not requested and the meta-estimator will not pass it to ``split``.\n\n- ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n- ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\nexisting request. This allows you to change the request for some\nparameters and not others.\n\n.. versionadded:: 1.3\n\n.. note::\n    This method is only relevant if this estimator is used as a\n    sub-estimator of a meta-estimator, e.g. used inside a\n    :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.",
            "parameters": {
              "groups": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": "Metadata routing for ``groups`` parameter in ``split``."
              }
            },
            "returns": "self : object\n    The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "The target variable for supervised learning problems."
              },
              "groups": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "Group labels for the samples used while splitting the dataset into\n    train/test set.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "StratifiedKFold",
      "docstring": {
        "description": "Stratified K-Fold cross-validator.\n\nProvides train/test indices to split data in train/test sets.\n\nThis cross-validation object is a variation of KFold that returns\nstratified folds. The folds are made by preserving the percentage of\nsamples for each class.\n\nRead more in the :ref:`User Guide <stratified_k_fold>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of folds. Must be at least 2.\n\n    .. versionchanged:: 0.22\n        ``n_splits`` default value changed from 3 to 5."
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": "Whether to shuffle each class's samples before splitting into batches.\n    Note that the samples within each split will not be shuffled."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "When `shuffle` is True, `random_state` affects the ordering of the\n    indices, which controls the randomness of each fold for each class.\n    Otherwise, leave `random_state` as `None`.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "RepeatedStratifiedKFold : Repeats Stratified K-Fold n times.",
        "notes": "The implementation is designed to:\n\n* Generate test sets such that all contain the same distribution of\n  classes, or as close as possible.\n* Be invariant to class label: relabelling ``y = [\"Happy\", \"Sad\"]`` to\n  ``y = [1, 0]`` should not change the indices generated.\n* Preserve order dependencies in the dataset ordering, when\n  ``shuffle=False``: all samples from class k in some test set were\n  contiguous in y, or separated in y by samples from classes other than k.\n* Generate test sets where the smallest and largest differ by at most one\n  sample.\n\n.. versionchanged:: 0.22\n    The previous implementation did not follow the last constraint.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import StratifiedKFold\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([0, 0, 1, 1])\n>>> skf = StratifiedKFold(n_splits=2)\n>>> skf.get_n_splits(X, y)\n2\n>>> print(skf)\nStratifiedKFold(n_splits=2, random_state=None, shuffle=False)\n>>> for i, (train_index, test_index) in enumerate(skf.split(X, y)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[1 3]\n  Test:  index=[0 2]\nFold 1:\n  Train: index=[0 2]\n  Test:  index=[1 3]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features.\n\n    Note that providing ``y`` is sufficient to generate the splits and\n    hence ``np.zeros(n_samples)`` may be used as a placeholder for\n    ``X`` instead of actual training data."
              },
              "y": {
                "type": "array-like of shape (n_samples,)",
                "description": "The target variable for supervised learning problems.\n    Stratification is done based on the y labels."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "Randomized CV splitters may return different results for each call of\nsplit. You can make the results identical by setting `random_state`\nto an integer.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "StratifiedShuffleSplit",
      "docstring": {
        "description": "Stratified ShuffleSplit cross-validator.\n\nProvides train/test indices to split data in train/test sets.\n\nThis cross-validation object is a merge of :class:`StratifiedKFold` and\n:class:`ShuffleSplit`, which returns stratified randomized folds. The folds\nare made by preserving the percentage of samples for each class.\n\nNote: like the :class:`ShuffleSplit` strategy, stratified random splits\ndo not guarantee that test sets across all folds will be mutually exclusive,\nand might include overlapping samples. However, this is still very likely for\nsizeable datasets.\n\nRead more in the :ref:`User Guide <stratified_shuffle_split>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`",
        "parameters": {
          "n_splits": {
            "type": "int, default=10",
            "description": "Number of re-shuffling & splitting iterations."
          },
          "test_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the proportion\n    of the dataset to include in the test split. If int, represents the\n    absolute number of test samples. If None, the value is set to the\n    complement of the train size. If ``train_size`` is also None, it will\n    be set to 0.1."
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": "If float, should be between 0.0 and 1.0 and represent the\n    proportion of the dataset to include in the train split. If\n    int, represents the absolute number of train samples. If None,\n    the value is automatically set to the complement of the test size."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the randomness of the training and testing indices produced.\n    Pass an int for reproducible output across multiple function calls.\n    See :term:`Glossary <random_state>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import StratifiedShuffleSplit\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([0, 0, 0, 1, 1, 1])\n>>> sss = StratifiedShuffleSplit(n_splits=5, test_size=0.5, random_state=0)\n>>> sss.get_n_splits(X, y)\n5\n>>> print(sss)\nStratifiedShuffleSplit(n_splits=5, random_state=0, ...)\n>>> for i, (train_index, test_index) in enumerate(sss.split(X, y)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[5 2 3]\n  Test:  index=[4 1 0]\nFold 1:\n  Train: index=[5 1 4]\n  Test:  index=[0 2 3]\nFold 2:\n  Train: index=[5 0 2]\n  Test:  index=[4 3 1]\nFold 3:\n  Train: index=[4 1 0]\n  Test:  index=[2 3 5]\nFold 4:\n  Train: index=[0 5 1]\n  Test:  index=[3 4 2]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features.\n\n    Note that providing ``y`` is sufficient to generate the splits and\n    hence ``np.zeros(n_samples)`` may be used as a placeholder for\n    ``X`` instead of actual training data."
              },
              "y": {
                "type": "array-like of shape (n_samples,) or (n_samples, n_labels)",
                "description": "The target variable for supervised learning problems.\n    Stratification is done based on the y labels."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "Randomized CV splitters may return different results for each call of\nsplit. You can make the results identical by setting `random_state`\nto an integer.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "TimeSeriesSplit",
      "docstring": {
        "description": "Time Series cross-validator.\n\nProvides train/test indices to split time series data samples\nthat are observed at fixed time intervals, in train/test sets.\nIn each split, test indices must be higher than before, and thus shuffling\nin cross validator is inappropriate.\n\nThis cross-validation object is a variation of :class:`KFold`.\nIn the kth split, it returns first k folds as train set and the\n(k+1)th fold as test set.\n\nNote that unlike standard cross-validation methods, successive\ntraining sets are supersets of those that come before them.\n\nRead more in the :ref:`User Guide <time_series_split>`.\n\nFor visualisation of cross-validation behaviour and\ncomparison between common scikit-learn split methods\nrefer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n.. versionadded:: 0.18",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": "Number of splits. Must be at least 2.\n\n    .. versionchanged:: 0.22\n        ``n_splits`` default value changed from 3 to 5."
          },
          "max_train_size": {
            "type": "int, default=None",
            "description": "Maximum size for a single training set."
          },
          "test_size": {
            "type": "int, default=None",
            "description": "Used to limit the size of the test set. Defaults to\n    ``n_samples // (n_splits + 1)``, which is the maximum allowed value\n    with ``gap=0``.\n\n    .. versionadded:: 0.24"
          },
          "gap": {
            "type": "int, default=0",
            "description": "Number of samples to exclude from the end of each train set before\n    the test set.\n\n    .. versionadded:: 0.24"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "The training set has size ``i * n_samples // (n_splits + 1)\n+ n_samples % (n_splits + 1)`` in the ``i`` th split,\nwith a test set of size ``n_samples//(n_splits + 1)`` by default,\nwhere ``n_samples`` is the number of samples. Note that this\nformula is only valid when ``test_size`` and ``max_train_size`` are\nleft to their default values.",
        "examples": ">>> import numpy as np\n>>> from sklearn.model_selection import TimeSeriesSplit\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([1, 2, 3, 4, 5, 6])\n>>> tscv = TimeSeriesSplit()\n>>> print(tscv)\nTimeSeriesSplit(gap=0, max_train_size=None, n_splits=5, test_size=None)\n>>> for i, (train_index, test_index) in enumerate(tscv.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[0]\n  Test:  index=[1]\nFold 1:\n  Train: index=[0 1]\n  Test:  index=[2]\nFold 2:\n  Train: index=[0 1 2]\n  Test:  index=[3]\nFold 3:\n  Train: index=[0 1 2 3]\n  Test:  index=[4]\nFold 4:\n  Train: index=[0 1 2 3 4]\n  Test:  index=[5]\n>>> # Fix test_size to 2 with 12 samples\n>>> X = np.random.randn(12, 2)\n>>> y = np.random.randint(0, 2, 12)\n>>> tscv = TimeSeriesSplit(n_splits=3, test_size=2)\n>>> for i, (train_index, test_index) in enumerate(tscv.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[0 1 2 3 4 5]\n  Test:  index=[6 7]\nFold 1:\n  Train: index=[0 1 2 3 4 5 6 7]\n  Test:  index=[8 9]\nFold 2:\n  Train: index=[0 1 2 3 4 5 6 7 8 9]\n  Test:  index=[10 11]\n>>> # Add in a 2 period gap\n>>> tscv = TimeSeriesSplit(n_splits=3, test_size=2, gap=2)\n>>> for i, (train_index, test_index) in enumerate(tscv.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\nFold 0:\n  Train: index=[0 1 2 3]\n  Test:  index=[6 7]\nFold 1:\n  Train: index=[0 1 2 3 4 5]\n  Test:  index=[8 9]\nFold 2:\n  Train: index=[0 1 2 3 4 5 6 7]\n  Test:  index=[10 11]\n\nFor a more extended example see\n:ref:`sphx_glr_auto_examples_applications_plot_cyclical_feature_engineering.py`."
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRequest\n    A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "docstring": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "y": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "object",
                "description": "Always ignored, exists for compatibility."
              }
            },
            "returns": "n_splits : int\n    Returns the number of splitting iterations in the cross-validator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "docstring": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples\n    and `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,)",
                "description": "Always ignored, exists for compatibility."
              },
              "groups": {
                "type": "array-like of shape (n_samples,)",
                "description": "Always ignored, exists for compatibility.\n\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": "The training set indices for that split."
              },
              "test": {
                "type": "ndarray",
                "description": "The testing set indices for that split."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "TunedThresholdClassifierCV",
      "docstring": {
        "description": "Classifier that post-tunes the decision threshold using cross-validation.\n\nThis estimator post-tunes the decision threshold (cut-off point) that is\nused for converting posterior probability estimates (i.e. output of\n`predict_proba`) or decision scores (i.e. output of `decision_function`)\ninto a class label. The tuning is done by optimizing a binary metric,\npotentially constrained by a another metric.\n\nRead more in the :ref:`User Guide <TunedThresholdClassifierCV>`.\n\n.. versionadded:: 1.5",
        "parameters": {
          "estimator": {
            "type": "estimator instance",
            "description": "The classifier, fitted or not, for which we want to optimize\n    the decision threshold used during `predict`."
          },
          "scoring": {
            "type": "str or callable, default=\"balanced_accuracy\"",
            "description": "The objective metric to be optimized. Can be one of:\n\n    * a string associated to a scoring function for binary classification\n      (see :ref:`scoring_parameter`);\n    * a scorer callable object created with :func:`~sklearn.metrics.make_scorer`;"
          },
          "response_method": {
            "type": "{\"auto\", \"decision_function\", \"predict_proba\"}, default=\"auto\"",
            "description": "Methods by the classifier `estimator` corresponding to the\n    decision function for which we want to find a threshold. It can be:\n\n    * if `\"auto\"`, it will try to invoke, for each classifier,\n      `\"predict_proba\"` or `\"decision_function\"` in that order.\n    * otherwise, one of `\"predict_proba\"` or `\"decision_function\"`.\n      If the method is not implemented by the classifier, it will raise an\n      error."
          },
          "thresholds": {
            "type": "int or array-like, default=100",
            "description": "The number of decision threshold to use when discretizing the output of the\n    classifier `method`. Pass an array-like to manually specify the thresholds\n    to use."
          },
          "cv": {
            "type": "int, float, cross-validation generator, iterable or \"prefit\", default=None",
            "description": "Determines the cross-validation splitting strategy to train classifier.\n    Possible inputs for cv are:\n\n    * `None`, to use the default 5-fold stratified K-fold cross validation;\n    * An integer number, to specify the number of folds in a stratified k-fold;\n    * A float number, to specify a single shuffle split. The floating number should\n      be in (0, 1) and represent the size of the validation set;\n    * An object to be used as a cross-validation generator;\n    * An iterable yielding train, test splits;\n    * `\"prefit\"`, to bypass the cross-validation.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here.\n\n    .. warning::\n        Using `cv=\"prefit\"` and passing the same dataset for fitting `estimator`\n        and tuning the cut-off point is subject to undesired overfitting. You can\n        refer to :ref:`TunedThresholdClassifierCV_no_cv` for an example.\n\n        This option should only be used when the set used to fit `estimator` is\n        different from the one used to tune the cut-off point (by calling\n        :meth:`TunedThresholdClassifierCV.fit`)."
          },
          "refit": {
            "type": "bool, default=True",
            "description": "Whether or not to refit the classifier on the entire training set once\n    the decision threshold has been found.\n    Note that forcing `refit=False` on cross-validation having more\n    than a single split will raise an error. Similarly, `refit=True` in\n    conjunction with `cv=\"prefit\"` will raise an error."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": "The number of jobs to run in parallel. When `cv` represents a\n    cross-validation strategy, the fitting and scoring on each data split\n    is done in parallel. ``None`` means 1 unless in a\n    :obj:`joblib.parallel_backend` context. ``-1`` means using all\n    processors. See :term:`Glossary <n_jobs>` for more details."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": "Controls the randomness of cross-validation when `cv` is a float.\n    See :term:`Glossary <random_state>`."
          },
          "store_cv_results": {
            "type": "bool, default=False",
            "description": "Whether to store all scores and thresholds computed during the cross-validation\n    process.\n\nAttributes\n----------"
          },
          "estimator_": {
            "type": "estimator instance",
            "description": "The fitted classifier used when predicting."
          },
          "best_threshold_": {
            "type": "float",
            "description": "The new decision threshold."
          },
          "best_score_": {
            "type": "float or None",
            "description": "The optimal score of the objective metric, evaluated at `best_threshold_`."
          },
          "cv_results_": {
            "type": "dict or None",
            "description": "A dictionary containing the scores and thresholds computed during the\n    cross-validation process. Only exist if `store_cv_results=True`. The\n    keys are `\"thresholds\"` and `\"scores\"`."
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": "The class labels."
          },
          "n_features_in_": {
            "type": "int",
            "description": "Number of features seen during :term:`fit`. Only defined if the\n    underlying estimator exposes such an attribute when fit."
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": "Names of features seen during :term:`fit`. Only defined if the\n    underlying estimator exposes such an attribute when fit."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "sklearn.model_selection.FixedThresholdClassifier : Classifier that uses a\n    constant threshold.\nsklearn.calibration.CalibratedClassifierCV : Estimator that calibrates\n    probabilities.",
        "notes": "",
        "examples": ">>> from sklearn.datasets import make_classification\n>>> from sklearn.ensemble import RandomForestClassifier\n>>> from sklearn.metrics import classification_report\n>>> from sklearn.model_selection import TunedThresholdClassifierCV, train_test_split\n>>> X, y = make_classification(\n...     n_samples=1_000, weights=[0.9, 0.1], class_sep=0.8, random_state=42\n... )\n>>> X_train, X_test, y_train, y_test = train_test_split(\n...     X, y, stratify=y, random_state=42\n... )\n>>> classifier = RandomForestClassifier(random_state=0).fit(X_train, y_train)\n>>> print(classification_report(y_test, classifier.predict(X_test)))\n              precision    recall  f1-score   support\n<BLANKLINE>\n           0       0.94      0.99      0.96       224\n           1       0.80      0.46      0.59        26\n<BLANKLINE>\n    accuracy                           0.93       250\n   macro avg       0.87      0.72      0.77       250\nweighted avg       0.93      0.93      0.92       250\n<BLANKLINE>\n>>> classifier_tuned = TunedThresholdClassifierCV(\n...     classifier, scoring=\"balanced_accuracy\"\n... ).fit(X_train, y_train)\n>>> print(\n...     f\"Cut-off point found at {classifier_tuned.best_threshold_:.3f}\"\n... )\nCut-off point found at 0.342\n>>> print(classification_report(y_test, classifier_tuned.predict(X_test)))\n              precision    recall  f1-score   support\n<BLANKLINE>\n           0       0.96      0.95      0.96       224\n           1       0.61      0.65      0.63        26\n<BLANKLINE>\n    accuracy                           0.92       250\n   macro avg       0.78      0.80      0.79       250\nweighted avg       0.92      0.92      0.92       250\n<BLANKLINE>"
      },
      "methods": [
        {
          "name": "decision_function",
          "signature": "decision_function(self, X)",
          "docstring": {
            "description": "Decision function for samples in `X` using the fitted estimator.",
            "parameters": {
              "X": {
                "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
                "description": "Training vectors, where `n_samples` is the number of samples and\n    `n_features` is the number of features."
              }
            },
            "returns": "decisions : ndarray of shape (n_samples,)\n    The decision function computed the fitted estimator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit",
          "signature": "fit(self, X, y, **params)",
          "docstring": {
            "description": "Fit the classifier.",
            "parameters": {
              "X": {
                "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
                "description": "Training data."
              },
              "y": {
                "type": "array-like of shape (n_samples,)",
                "description": "Target values."
              },
              "**params": {
                "type": "dict",
                "description": "Parameters to pass to the `fit` method of the underlying\n    classifier."
              }
            },
            "returns": "self : object\n    Returns an instance of self.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "docstring": {
            "description": "Get metadata routing of this object.\n\nPlease check :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.",
            "parameters": {},
            "returns": "routing : MetadataRouter\n    A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n    routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "docstring": {
            "description": "Get parameters for this estimator.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": "If True, will return the parameters for this estimator and\n    contained subobjects that are estimators."
              }
            },
            "returns": "params : dict\n    Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict",
          "signature": "predict(self, X)",
          "docstring": {
            "description": "Predict the target of new samples.",
            "parameters": {
              "X": {
                "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
                "description": "The samples, as accepted by `estimator.predict`."
              }
            },
            "returns": "class_labels : ndarray of shape (n_samples,)\n    The predicted class.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_log_proba",
          "signature": "predict_log_proba(self, X)",
          "docstring": {
            "description": "Predict logarithm class probabilities for `X` using the fitted estimator.",
            "parameters": {
              "X": {
                "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
                "description": "Training vectors, where `n_samples` is the number of samples and\n    `n_features` is the number of features."
              }
            },
            "returns": "log_probabilities : ndarray of shape (n_samples, n_classes)\n    The logarithm class probabilities of the input samples.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_proba",
          "signature": "predict_proba(self, X)",
          "docstring": {
            "description": "Predict class probabilities for `X` using the fitted estimator.",
            "parameters": {
              "X": {
                "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
                "description": "Training vectors, where `n_samples` is the number of samples and\n    `n_features` is the number of features."
              }
            },
            "returns": "probabilities : ndarray of shape (n_samples, n_classes)\n    The class probabilities of the input samples.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score",
          "signature": "score(self, X, y, sample_weight=None)",
          "docstring": {
            "description": "Return the mean accuracy on the given test data and labels.\n\nIn multi-label classification, this is the subset accuracy\nwhich is a harsh metric since you require for each sample that\neach label set be correctly predicted.",
            "parameters": {
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Test samples."
              },
              "y": {
                "type": "array-like of shape (n_samples,) or (n_samples, n_outputs)",
                "description": "True labels for `X`."
              },
              "sample_weight": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "Sample weights."
              }
            },
            "returns": "score : float\n    Mean accuracy of ``self.predict(X)`` w.r.t. `y`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "docstring": {
            "description": "Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects\n(such as :class:`~sklearn.pipeline.Pipeline`). The latter have\nparameters of the form ``<component>__<parameter>`` so that it's\npossible to update each component of a nested object.",
            "parameters": {
              "**params": {
                "type": "dict",
                "description": "Estimator parameters."
              }
            },
            "returns": "self : estimator instance\n    Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_score_request",
          "signature": "set_score_request(self: sklearn.model_selection._classification_threshold.TunedThresholdClassifierCV, *, sample_weight: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._classification_threshold.TunedThresholdClassifierCV",
          "docstring": {
            "description": "Request metadata passed to the ``score`` method.\n\nNote that this method is only relevant if\n``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\nPlease see :ref:`User Guide <metadata_routing>` on how the routing\nmechanism works.\n\nThe options for each parameter are:\n\n- ``True``: metadata is requested, and passed to ``score`` if provided. The request is ignored if metadata is not provided.\n\n- ``False``: metadata is not requested and the meta-estimator will not pass it to ``score``.\n\n- ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n- ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\nexisting request. This allows you to change the request for some\nparameters and not others.\n\n.. versionadded:: 1.3\n\n.. note::\n    This method is only relevant if this estimator is used as a\n    sub-estimator of a meta-estimator, e.g. used inside a\n    :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.",
            "parameters": {
              "sample_weight": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": "Metadata routing for ``sample_weight`` parameter in ``score``."
              }
            },
            "returns": "self : object\n    The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ValidationCurveDisplay",
      "docstring": {
        "description": "Validation Curve visualization.\n\nIt is recommended to use\n:meth:`~sklearn.model_selection.ValidationCurveDisplay.from_estimator` to\ncreate a :class:`~sklearn.model_selection.ValidationCurveDisplay` instance.\nAll parameters are stored as attributes.\n\nRead more in the :ref:`User Guide <visualizations>` for general information\nabout the visualization API and :ref:`detailed documentation\n<validation_curve>` regarding the validation curve visualization.\n\n.. versionadded:: 1.3",
        "parameters": {
          "param_name": {
            "type": "str",
            "description": "Name of the parameter that has been varied."
          },
          "param_range": {
            "type": "array-like of shape (n_ticks,)",
            "description": "The values of the parameter that have been evaluated."
          },
          "train_scores": {
            "type": "ndarray of shape (n_ticks, n_cv_folds)",
            "description": "Scores on training sets."
          },
          "test_scores": {
            "type": "ndarray of shape (n_ticks, n_cv_folds)",
            "description": "Scores on test set."
          },
          "score_name": {
            "type": "str, default=None",
            "description": "The name of the score used in `validation_curve`. It will override the name\n    inferred from the `scoring` parameter. If `score` is `None`, we use `\"Score\"` if\n    `negate_score` is `False` and `\"Negative score\"` otherwise. If `scoring` is a\n    string or a callable, we infer the name. We replace `_` by spaces and capitalize\n    the first letter. We remove `neg_` and replace it by `\"Negative\"` if\n    `negate_score` is `False` or just remove it otherwise.\n\nAttributes\n----------"
          },
          "ax_": {
            "type": "matplotlib Axes",
            "description": "Axes with the validation curve."
          },
          "figure_": {
            "type": "matplotlib Figure",
            "description": "Figure containing the validation curve."
          },
          "errorbar_": {
            "type": "list of matplotlib Artist or None",
            "description": "When the `std_display_style` is `\"errorbar\"`, this is a list of\n    `matplotlib.container.ErrorbarContainer` objects. If another style is\n    used, `errorbar_` is `None`."
          },
          "lines_": {
            "type": "list of matplotlib Artist or None",
            "description": "When the `std_display_style` is `\"fill_between\"`, this is a list of\n    `matplotlib.lines.Line2D` objects corresponding to the mean train and\n    test scores. If another style is used, `line_` is `None`."
          },
          "fill_between_": {
            "type": "list of matplotlib Artist or None",
            "description": "When the `std_display_style` is `\"fill_between\"`, this is a list of\n    `matplotlib.collections.PolyCollection` objects. If another style is\n    used, `fill_between_` is `None`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "sklearn.model_selection.validation_curve : Compute the validation curve.",
        "notes": "",
        "examples": ">>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> from sklearn.datasets import make_classification\n>>> from sklearn.model_selection import ValidationCurveDisplay, validation_curve\n>>> from sklearn.linear_model import LogisticRegression\n>>> X, y = make_classification(n_samples=1_000, random_state=0)\n>>> logistic_regression = LogisticRegression()\n>>> param_name, param_range = \"C\", np.logspace(-8, 3, 10)\n>>> train_scores, test_scores = validation_curve(\n...     logistic_regression, X, y, param_name=param_name, param_range=param_range\n... )\n>>> display = ValidationCurveDisplay(\n...     param_name=param_name, param_range=param_range,\n...     train_scores=train_scores, test_scores=test_scores, score_name=\"Score\"\n... )\n>>> display.plot()\n<...>\n>>> plt.show()"
      },
      "methods": [
        {
          "name": "from_estimator",
          "signature": "from_estimator(estimator, X, y, *, param_name, param_range, groups=None, cv=None, scoring=None, n_jobs=None, pre_dispatch='all', verbose=0, error_score=nan, fit_params=None, ax=None, negate_score=False, score_name=None, score_type='both', std_display_style='fill_between', line_kw=None, fill_between_kw=None, errorbar_kw=None)",
          "docstring": {
            "description": "Create a validation curve display from an estimator.\n\nRead more in the :ref:`User Guide <visualizations>` for general\ninformation about the visualization API and :ref:`detailed\ndocumentation <validation_curve>` regarding the validation curve\nvisualization.",
            "parameters": {
              "estimator": {
                "type": "object type that implements the \"fit\" and \"predict\" methods",
                "description": "An object of that type which is cloned for each validation."
              },
              "X": {
                "type": "array-like of shape (n_samples, n_features)",
                "description": "Training data, where `n_samples` is the number of samples and\n    `n_features` is the number of features."
              },
              "y": {
                "type": "array-like of shape (n_samples,) or (n_samples, n_outputs) or None",
                "description": "Target relative to X for classification or regression;\n    None for unsupervised learning."
              },
              "param_name": {
                "type": "str",
                "description": "Name of the parameter that will be varied."
              },
              "param_range": {
                "type": "array-like of shape (n_values,)",
                "description": "The values of the parameter that will be evaluated."
              },
              "groups": {
                "type": "array-like of shape (n_samples,), default=None",
                "description": "Group labels for the samples used while splitting the dataset into\n    train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n    instance (e.g., :class:`GroupKFold`)."
              },
              "cv": {
                "type": "int, cross-validation generator or an iterable, default=None",
                "description": "Determines the cross-validation splitting strategy.\n    Possible inputs for cv are:\n\n    - None, to use the default 5-fold cross validation,\n    - int, to specify the number of folds in a `(Stratified)KFold`,\n    - :term:`CV splitter`,\n    - An iterable yielding (train, test) splits as arrays of indices.\n\n    For int/None inputs, if the estimator is a classifier and `y` is\n    either binary or multiclass,\n    :class:`~sklearn.model_selection.StratifiedKFold` is used. In all\n    other cases, :class:`~sklearn.model_selection.KFold` is used. These\n    splitters are instantiated with `shuffle=False` so the splits will\n    be the same across calls.\n\n    Refer :ref:`User Guide <cross_validation>` for the various\n    cross-validation strategies that can be used here."
              },
              "scoring": {
                "type": "str or callable, default=None",
                "description": "A string (see :ref:`scoring_parameter`) or\n    a scorer callable object / function with signature\n    `scorer(estimator, X, y)` (see :ref:`scoring_callable`)."
              },
              "n_jobs": {
                "type": "int, default=None",
                "description": "Number of jobs to run in parallel. Training the estimator and\n    computing the score are parallelized over the different training\n    and test sets. `None` means 1 unless in a\n    :obj:`joblib.parallel_backend` context. `-1` means using all\n    processors. See :term:`Glossary <n_jobs>` for more details."
              },
              "pre_dispatch": {
                "type": "int or str, default='all'",
                "description": "Number of predispatched jobs for parallel execution (default is\n    all). The option can reduce the allocated memory. The str can\n    be an expression like '2*n_jobs'."
              },
              "verbose": {
                "type": "int, default=0",
                "description": "Controls the verbosity: the higher, the more messages."
              },
              "error_score": {
                "type": "'raise' or numeric, default=np.nan",
                "description": "Value to assign to the score if an error occurs in estimator\n    fitting. If set to 'raise', the error is raised. If a numeric value\n    is given, FitFailedWarning is raised."
              },
              "fit_params": {
                "type": "dict, default=None",
                "description": "Parameters to pass to the fit method of the estimator."
              },
              "ax": {
                "type": "matplotlib Axes, default=None",
                "description": "Axes object to plot on. If `None`, a new figure and axes is\n    created."
              },
              "negate_score": {
                "type": "bool, default=False",
                "description": "Whether or not to negate the scores obtained through\n    :func:`~sklearn.model_selection.validation_curve`. This is\n    particularly useful when using the error denoted by `neg_*` in\n    `scikit-learn`."
              },
              "score_name": {
                "type": "str, default=None",
                "description": "The name of the score used to decorate the y-axis of the plot. It will\n    override the name inferred from the `scoring` parameter. If `score` is\n    `None`, we use `\"Score\"` if `negate_score` is `False` and `\"Negative score\"`\n    otherwise. If `scoring` is a string or a callable, we infer the name. We\n    replace `_` by spaces and capitalize the first letter. We remove `neg_` and\n    replace it by `\"Negative\"` if `negate_score` is\n    `False` or just remove it otherwise."
              },
              "score_type": {
                "type": "{\"test\", \"train\", \"both\"}, default=\"both\"",
                "description": "The type of score to plot. Can be one of `\"test\"`, `\"train\"`, or\n    `\"both\"`."
              },
              "std_display_style": {
                "type": "{\"errorbar\", \"fill_between\"} or None, default=\"fill_between\"",
                "description": "The style used to display the score standard deviation around the\n    mean score. If `None`, no representation of the standard deviation\n    is displayed."
              },
              "line_kw": {
                "type": "dict, default=None",
                "description": "Additional keyword arguments passed to the `plt.plot` used to draw\n    the mean score."
              },
              "fill_between_kw": {
                "type": "dict, default=None",
                "description": "Additional keyword arguments passed to the `plt.fill_between` used\n    to draw the score standard deviation."
              },
              "errorbar_kw": {
                "type": "dict, default=None",
                "description": "Additional keyword arguments passed to the `plt.errorbar` used to\n    draw mean score and standard deviation score."
              }
            },
            "returns": "display : :class:`~sklearn.model_selection.ValidationCurveDisplay`\n    Object that stores computed values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> from sklearn.datasets import make_classification\n>>> from sklearn.model_selection import ValidationCurveDisplay\n>>> from sklearn.linear_model import LogisticRegression\n>>> X, y = make_classification(n_samples=1_000, random_state=0)\n>>> logistic_regression = LogisticRegression()\n>>> param_name, param_range = \"C\", np.logspace(-8, 3, 10)\n>>> ValidationCurveDisplay.from_estimator(\n...     logistic_regression, X, y, param_name=param_name,\n...     param_range=param_range,\n... )\n<...>\n>>> plt.show()"
          }
        },
        {
          "name": "plot",
          "signature": "plot(self, ax=None, *, negate_score=False, score_name=None, score_type='both', std_display_style='fill_between', line_kw=None, fill_between_kw=None, errorbar_kw=None)",
          "docstring": {
            "description": "Plot visualization.",
            "parameters": {
              "ax": {
                "type": "matplotlib Axes, default=None",
                "description": "Axes object to plot on. If `None`, a new figure and axes is\n    created."
              },
              "negate_score": {
                "type": "bool, default=False",
                "description": "Whether or not to negate the scores obtained through\n    :func:`~sklearn.model_selection.validation_curve`. This is\n    particularly useful when using the error denoted by `neg_*` in\n    `scikit-learn`."
              },
              "score_name": {
                "type": "str, default=None",
                "description": "The name of the score used to decorate the y-axis of the plot. It will\n    override the name inferred from the `scoring` parameter. If `score` is\n    `None`, we use `\"Score\"` if `negate_score` is `False` and `\"Negative score\"`\n    otherwise. If `scoring` is a string or a callable, we infer the name. We\n    replace `_` by spaces and capitalize the first letter. We remove `neg_` and\n    replace it by `\"Negative\"` if `negate_score` is\n    `False` or just remove it otherwise."
              },
              "score_type": {
                "type": "{\"test\", \"train\", \"both\"}, default=\"both\"",
                "description": "The type of score to plot. Can be one of `\"test\"`, `\"train\"`, or\n    `\"both\"`."
              },
              "std_display_style": {
                "type": "{\"errorbar\", \"fill_between\"} or None, default=\"fill_between\"",
                "description": "The style used to display the score standard deviation around the\n    mean score. If None, no standard deviation representation is\n    displayed."
              },
              "line_kw": {
                "type": "dict, default=None",
                "description": "Additional keyword arguments passed to the `plt.plot` used to draw\n    the mean score."
              },
              "fill_between_kw": {
                "type": "dict, default=None",
                "description": "Additional keyword arguments passed to the `plt.fill_between` used\n    to draw the score standard deviation."
              },
              "errorbar_kw": {
                "type": "dict, default=None",
                "description": "Additional keyword arguments passed to the `plt.errorbar` used to\n    draw mean score and standard deviation score."
              }
            },
            "returns": "display : :class:`~sklearn.model_selection.ValidationCurveDisplay`\n    Object that stores computed values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    }
  ],
  "constants": []
}