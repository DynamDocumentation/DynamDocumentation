{
  "description": "Tools for model selection, such as cross validation and hyper-parameter tuning.",
  "functions": [
    {
      "name": "check_cv",
      "signature": "check_cv(cv=5, y=None, *, classifier=False)",
      "documentation": {
        "description": "Input checker utility for building a cross-validator.\n\n    Parameters\n    ----------\n    cv : int, cross-validation generator, iterable or None, default=5\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n        - None, to use the default 5-fold cross validation,\n        - integer, to specify the number of folds.\n        - :term:`CV splitter`,\n        - An iterable that generates (train, test) splits as arrays of indices.\n\n        For integer/None inputs, if classifier is True and ``y`` is either\n        binary or multiclass, :class:`StratifiedKFold` is used. In all other\n        cases, :class:`KFold` is used.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value changed from 3-fold to 5-fold.\n\n    y : array-like, default=None\n        The target variable for supervised learning problems.\n\n    classifier : bool, default=False\n        Whether the task is a classification task, in which case\n        stratified KFold will be used.\n\n    Returns\n    -------\n    checked_cv : a cross-validator instance.\n        The return value is a cross-validator which generates the train/test\n        splits via the ``split`` method.",
        "parameters": {
          "cv": {
            "type": "int, cross",
            "description": "validation generator, iterable or None, default=5"
          },
          "Determines": {
            "type": "the cross-validation splitting strategy.",
            "description": ""
          },
          "Possible": {
            "type": "inputs for cv are:",
            "description": "- None, to use the default 5-fold cross validation,\n- integer, to specify the number of folds.\n- :term:`CV splitter`,\n- An iterable that generates (train, test) splits as arrays of indices."
          },
          "For": {
            "type": "integer/None inputs, if classifier is True and ``y`` is either",
            "description": ""
          },
          "binary": {
            "type": "or multiclass, :class:`StratifiedKFold` is used. In all other",
            "description": "cases, :class:`KFold` is used."
          },
          "Refer": {
            "type": "ref:`User Guide <cross_validation>` for the various",
            "description": "cross-validation strategies that can be used here.\n.. versionchanged:: 0.22\n``cv`` default value changed from 3-fold to 5-fold."
          },
          "y": {
            "type": "array",
            "description": "like, default=None"
          },
          "The": {
            "type": "return value is a cross-validator which generates the train/test",
            "description": ""
          },
          "classifier": {
            "type": "bool, default=False",
            "description": ""
          },
          "Whether": {
            "type": "the task is a classification task, in which case",
            "description": ""
          },
          "stratified": {
            "type": "KFold will be used.",
            "description": "Returns\n-------"
          },
          "checked_cv": {
            "type": "a cross",
            "description": "validator instance."
          },
          "splits": {
            "type": "via the ``split`` method.",
            "description": "Examples\n--------\n>>> from sklearn.model_selection import check_cv\n>>> check_cv(cv=5, y=None, classifier=False)"
          },
          "KFold": {
            "type": "...",
            "description": ">>> check_cv(cv=5, y=[1, 1, 0, 0, 0, 0], classifier=True)"
          },
          "StratifiedKFold": {
            "type": "...",
            "description": ""
          }
        },
        "returns": "-------\n    checked_cv : a cross-validator instance.\n        The return value is a cross-validator which generates the train/test\n        splits via the ``split`` method.\n\n    Examples\n    --------\n    >>> from sklearn.model_selection import check_cv\n    >>> check_cv(cv=5, y=None, classifier=False)\n    KFold(...)\n    >>> check_cv(cv=5, y=[1, 1, 0, 0, 0, 0], classifier=True)\n    StratifiedKFold(...)",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n    >>> from sklearn.model_selection import check_cv\n    >>> check_cv(cv=5, y=None, classifier=False)\n    KFold(...)\n    >>> check_cv(cv=5, y=[1, 1, 0, 0, 0, 0], classifier=True)\n    StratifiedKFold(...)"
      }
    },
    {
      "name": "cross_val_predict",
      "signature": "cross_val_predict(estimator, X, y=None, *, groups=None, cv=None, n_jobs=None, verbose=0, params=None, pre_dispatch='2*n_jobs', method='predict')",
      "documentation": {
        "description": "Generate cross-validated estimates for each input data point.\n\n    The data is split according to the cv parameter. Each sample belongs\n    to exactly one test set, and its prediction is computed with an\n    estimator fitted on the corresponding training set.\n\n    Passing these predictions into an evaluation metric may not be a valid\n    way to measure generalization performance. Results can differ from\n    :func:`cross_validate` and :func:`cross_val_score` unless all tests sets\n    have equal size and the metric decomposes over samples.\n\n    Read more in the :ref:`User Guide <cross_validation>`.\n\n    Parameters\n    ----------\n    estimator : estimator\n        The estimator instance to use to fit the data. It must implement a `fit`\n        method and the method given by the `method` parameter.\n\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The data to fit. Can be, for example a list, or an array at least 2d.\n\n    y : {array-like, sparse matrix} of shape (n_samples,) or (n_samples, n_outputs),             default=None\n        The target variable to try to predict in the case of\n        supervised learning.\n\n    groups : array-like of shape (n_samples,), default=None\n        Group labels for the samples used while splitting the dataset into\n        train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n        instance (e.g., :class:`GroupKFold`).\n\n        .. versionchanged:: 1.4\n            ``groups`` can only be passed if metadata routing is not enabled\n            via ``sklearn.set_config(enable_metadata_routing=True)``. When routing\n            is enabled, pass ``groups`` alongside other metadata via the ``params``\n            argument instead. E.g.:\n            ``cross_val_predict(..., params={'groups': groups})``.\n\n    cv : int, cross-validation generator or an iterable, default=None\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - None, to use the default 5-fold cross validation,\n        - int, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable that generates (train, test) splits as arrays of indices.\n\n        For int/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value if None changed from 3-fold to 5-fold.\n\n    n_jobs : int, default=None\n        Number of jobs to run in parallel. Training the estimator and\n        predicting are parallelized over the cross-validation splits.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    verbose : int, default=0\n        The verbosity level.\n\n    params : dict, default=None\n        Parameters to pass to the underlying estimator's ``fit`` and the CV\n        splitter.\n\n        .. versionadded:: 1.4\n\n    pre_dispatch : int or str, default='2*n_jobs'\n        Controls the number of jobs that get dispatched during parallel\n        execution. Reducing this number can be useful to avoid an\n        explosion of memory consumption when more jobs get dispatched\n        than CPUs can process. This parameter can be:\n\n        - None, in which case all the jobs are immediately created and spawned. Use\n          this for lightweight and fast-running jobs, to avoid delays due to on-demand\n          spawning of the jobs\n        - An int, giving the exact number of total jobs that are spawned\n        - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'\n\n    method : {'predict', 'predict_proba', 'predict_log_proba',               'decision_function'}, default='predict'\n        The method to be invoked by `estimator`.\n\n    Returns\n    -------\n    predictions : ndarray\n        This is the result of calling `method`. Shape:\n\n        - When `method` is 'predict' and in special case where `method` is\n          'decision_function' and the target is binary: (n_samples,)\n        - When `method` is one of {'predict_proba', 'predict_log_proba',\n          'decision_function'} (unless special case above):\n          (n_samples, n_classes)\n        - If `estimator` is :term:`multioutput`, an extra dimension\n          'n_outputs' is added to the end of each shape above.\n\n    See Also\n    --------\n    cross_val_score : Calculate score for each CV split.\n    cross_validate : Calculate one or more scores and timings for each CV\n        split.\n\n    Notes\n    -----\n    In the case that one or more classes are absent in a training portion, a\n    default score needs to be assigned to all instances for that class if\n    ``method`` produces columns per class, as in {'decision_function',\n    'predict_proba', 'predict_log_proba'}.  For ``predict_proba`` this value is\n    0.  In order to ensure finite output, we approximate negative infinity by\n    the minimum finite float value for the dtype in other cases.",
        "parameters": {
          "estimator": {
            "type": "estimator",
            "description": ""
          },
          "The": {
            "type": "verbosity level.",
            "description": ""
          },
          "method": {
            "type": "and the method given by the `method` parameter.",
            "description": ""
          },
          "X": {
            "type": "{array",
            "description": "like, sparse matrix} of shape (n_samples, n_features)"
          },
          "y": {
            "type": "{array",
            "description": "like, sparse matrix} of shape (n_samples,) or (n_samples, n_outputs),             default=None"
          },
          "supervised": {
            "type": "learning.",
            "description": ""
          },
          "groups": {
            "type": "array",
            "description": "like of shape (n_samples,), default=None"
          },
          "Group": {
            "type": "labels for the samples used while splitting the dataset into",
            "description": "train/test set. Only used in conjunction with a \"Group\" :term:`cv`"
          },
          "instance": {
            "type": "e.g., :class:`GroupKFold`",
            "description": ".\n.. versionchanged:: 1.4\n``groups`` can only be passed if metadata routing is not enabled"
          },
          "via": {
            "type": "``sklearn.set_config(enable_metadata_routing=True)``. When routing",
            "description": ""
          },
          "is": {
            "type": "enabled, pass ``groups`` alongside other metadata via the ``params``",
            "description": ""
          },
          "argument": {
            "type": "instead. E.g.:",
            "description": "``cross_val_predict(..., params={'groups': groups})``."
          },
          "cv": {
            "type": "int, cross",
            "description": "validation generator or an iterable, default=None"
          },
          "Determines": {
            "type": "the cross-validation splitting strategy.",
            "description": ""
          },
          "Possible": {
            "type": "inputs for cv are:",
            "description": "- None, to use the default 5-fold cross validation,\n- int, to specify the number of folds in a `(Stratified)KFold`,\n- :term:`CV splitter`,\n- An iterable that generates (train, test) splits as arrays of indices."
          },
          "For": {
            "type": "int/None inputs, if the estimator is a classifier and ``y`` is",
            "description": ""
          },
          "either": {
            "type": "binary or multiclass, :class:`StratifiedKFold` is used. In all",
            "description": ""
          },
          "other": {
            "type": "cases, :class:`KFold` is used. These splitters are instantiated",
            "description": ""
          },
          "with": {
            "type": "`shuffle=False` so the splits will be the same across calls.",
            "description": ""
          },
          "Refer": {
            "type": "ref:`User Guide <cross_validation>` for the various",
            "description": "cross-validation strategies that can be used here.\n.. versionchanged:: 0.22\n``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": ""
          },
          "Number": {
            "type": "of jobs to run in parallel. Training the estimator and",
            "description": ""
          },
          "predicting": {
            "type": "are parallelized over the cross-validation splits.",
            "description": "``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n``-1`` means using all processors. See :term:`Glossary <n_jobs>`"
          },
          "for": {
            "type": "more details.",
            "description": ""
          },
          "verbose": {
            "type": "int, default=0",
            "description": ""
          },
          "params": {
            "type": "dict, default=None",
            "description": ""
          }
        },
        "returns": "-------\n    predictions : ndarray\n        This is the result of calling `method`. Shape:\n\n        - When `method` is 'predict' and in special case where `method` is\n          'decision_function' and the target is binary: (n_samples,)\n        - When `method` is one of {'predict_proba', 'predict_log_proba',\n          'decision_function'} (unless special case above):\n          (n_samples, n_classes)\n        - If `estimator` is :term:`multioutput`, an extra dimension\n          'n_outputs' is added to the end of each shape above.\n\n    See Also\n    --------\n    cross_val_score : Calculate score for each CV split.\n    cross_validate : Calculate one or more scores and timings for each CV\n        split.\n\n    Notes\n    -----\n    In the case that one or more classes are absent in a training portion, a\n    default score needs to be assigned to all instances for that class if\n    ``method`` produces columns per class, as in {'decision_function',\n    'predict_proba', 'predict_log_proba'}.  For ``predict_proba`` this value is\n    0.  In order to ensure finite output, we approximate negative infinity by\n    the minimum finite float value for the dtype in other cases.\n\n    Examples\n    --------\n    >>> from sklearn import datasets, linear_model\n    >>> from sklearn.model_selection import cross_val_predict\n    >>> diabetes = datasets.load_diabetes()\n    >>> X = diabetes.data[:150]\n    >>> y = diabetes.target[:150]\n    >>> lasso = linear_model.Lasso()\n    >>> y_pred = cross_val_predict(lasso, X, y, cv=3)",
        "raises": "",
        "see_also": "--------\n    cross_val_score : Calculate score for each CV split.\n    cross_validate : Calculate one or more scores and timings for each CV\n        split.\n\n    Notes\n    -----\n    In the case that one or more classes are absent in a training portion, a\n    default score needs to be assigned to all instances for that class if\n    ``method`` produces columns per class, as in {'decision_function',\n    'predict_proba', 'predict_log_proba'}.  For ``predict_proba`` this value is\n    0.  In order to ensure finite output, we approximate negative infinity by\n    the minimum finite float value for the dtype in other cases.\n\n    Examples\n    --------\n    >>> from sklearn import datasets, linear_model\n    >>> from sklearn.model_selection import cross_val_predict\n    >>> diabetes = datasets.load_diabetes()\n    >>> X = diabetes.data[:150]\n    >>> y = diabetes.target[:150]\n    >>> lasso = linear_model.Lasso()\n    >>> y_pred = cross_val_predict(lasso, X, y, cv=3)",
        "notes": "-----\n    In the case that one or more classes are absent in a training portion, a\n    default score needs to be assigned to all instances for that class if\n    ``method`` produces columns per class, as in {'decision_function',\n    'predict_proba', 'predict_log_proba'}.  For ``predict_proba`` this value is\n    0.  In order to ensure finite output, we approximate negative infinity by\n    the minimum finite float value for the dtype in other cases.\n\n    Examples\n    --------\n    >>> from sklearn import datasets, linear_model\n    >>> from sklearn.model_selection import cross_val_predict\n    >>> diabetes = datasets.load_diabetes()\n    >>> X = diabetes.data[:150]\n    >>> y = diabetes.target[:150]\n    >>> lasso = linear_model.Lasso()\n    >>> y_pred = cross_val_predict(lasso, X, y, cv=3)",
        "examples": "--------\n    >>> from sklearn import datasets, linear_model\n    >>> from sklearn.model_selection import cross_val_predict\n    >>> diabetes = datasets.load_diabetes()\n    >>> X = diabetes.data[:150]\n    >>> y = diabetes.target[:150]\n    >>> lasso = linear_model.Lasso()\n    >>> y_pred = cross_val_predict(lasso, X, y, cv=3)"
      }
    },
    {
      "name": "cross_val_score",
      "signature": "cross_val_score(estimator, X, y=None, *, groups=None, scoring=None, cv=None, n_jobs=None, verbose=0, params=None, pre_dispatch='2*n_jobs', error_score=nan)",
      "documentation": {
        "description": "Evaluate a score by cross-validation.\n\n    Read more in the :ref:`User Guide <cross_validation>`.\n\n    Parameters\n    ----------\n    estimator : estimator object implementing 'fit'\n        The object to use to fit the data.\n\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The data to fit. Can be for example a list, or an array.\n\n    y : array-like of shape (n_samples,) or (n_samples, n_outputs),             default=None\n        The target variable to try to predict in the case of\n        supervised learning.\n\n    groups : array-like of shape (n_samples,), default=None\n        Group labels for the samples used while splitting the dataset into\n        train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n        instance (e.g., :class:`GroupKFold`).\n\n        .. versionchanged:: 1.4\n            ``groups`` can only be passed if metadata routing is not enabled\n            via ``sklearn.set_config(enable_metadata_routing=True)``. When routing\n            is enabled, pass ``groups`` alongside other metadata via the ``params``\n            argument instead. E.g.:\n            ``cross_val_score(..., params={'groups': groups})``.\n\n    scoring : str or callable, default=None\n        A str (see :ref:`scoring_parameter`) or a scorer callable object / function with\n        signature ``scorer(estimator, X, y)`` which should return only a single value.\n\n        Similar to :func:`cross_validate`\n        but only a single metric is permitted.\n\n        If `None`, the estimator's default scorer (if available) is used.\n\n    cv : int, cross-validation generator or an iterable, default=None\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - `None`, to use the default 5-fold cross validation,\n        - int, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable that generates (train, test) splits as arrays of indices.\n\n        For `int`/`None` inputs, if the estimator is a classifier and `y` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            `cv` default value if `None` changed from 3-fold to 5-fold.\n\n    n_jobs : int, default=None\n        Number of jobs to run in parallel. Training the estimator and computing\n        the score are parallelized over the cross-validation splits.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    verbose : int, default=0\n        The verbosity level.\n\n    params : dict, default=None\n        Parameters to pass to the underlying estimator's ``fit``, the scorer,\n        and the CV splitter.\n\n        .. versionadded:: 1.4\n\n    pre_dispatch : int or str, default='2*n_jobs'\n        Controls the number of jobs that get dispatched during parallel\n        execution. Reducing this number can be useful to avoid an\n        explosion of memory consumption when more jobs get dispatched\n        than CPUs can process. This parameter can be:\n\n        - ``None``, in which case all the jobs are immediately created and spawned. Use\n          this for lightweight and fast-running jobs, to avoid delays due to on-demand\n          spawning of the jobs\n        - An int, giving the exact number of total jobs that are spawned\n        - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'\n\n    error_score : 'raise' or numeric, default=np.nan\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised.\n        If a numeric value is given, FitFailedWarning is raised.\n\n        .. versionadded:: 0.20\n\n    Returns\n    -------\n    scores : ndarray of float of shape=(len(list(cv)),)\n        Array of scores of the estimator for each run of the cross validation.\n\n    See Also\n    --------\n    cross_validate : To run cross-validation on multiple metrics and also to\n        return train scores, fit times and score times.\n\n    cross_val_predict : Get predictions from each split of cross-validation for\n        diagnostic purposes.\n\n    sklearn.metrics.make_scorer : Make a scorer from a performance metric or\n        loss function.",
        "parameters": {
          "estimator": {
            "type": "estimator object implementing 'fit'",
            "description": ""
          },
          "The": {
            "type": "verbosity level.",
            "description": ""
          },
          "X": {
            "type": "{array",
            "description": "like, sparse matrix} of shape (n_samples, n_features)"
          },
          "y": {
            "type": "array",
            "description": "like of shape (n_samples,) or (n_samples, n_outputs),             default=None"
          },
          "supervised": {
            "type": "learning.",
            "description": ""
          },
          "groups": {
            "type": "array",
            "description": "like of shape (n_samples,), default=None"
          },
          "Group": {
            "type": "labels for the samples used while splitting the dataset into",
            "description": "train/test set. Only used in conjunction with a \"Group\" :term:`cv`"
          },
          "instance": {
            "type": "e.g., :class:`GroupKFold`",
            "description": ".\n.. versionchanged:: 1.4\n``groups`` can only be passed if metadata routing is not enabled"
          },
          "via": {
            "type": "``sklearn.set_config(enable_metadata_routing=True)``. When routing",
            "description": ""
          },
          "is": {
            "type": "enabled, pass ``groups`` alongside other metadata via the ``params``",
            "description": ""
          },
          "argument": {
            "type": "instead. E.g.:",
            "description": "``cross_val_score(..., params={'groups': groups})``."
          },
          "scoring": {
            "type": "str or callable, default=None",
            "description": ""
          },
          "A": {
            "type": "str (see :ref:`scoring_parameter`) or a scorer callable object / function with",
            "description": ""
          },
          "signature": {
            "type": "``scorer(estimator, X, y)`` which should return only a single value.",
            "description": ""
          },
          "Similar": {
            "type": "to :func:`cross_validate`",
            "description": ""
          },
          "but": {
            "type": "only a single metric is permitted.",
            "description": ""
          },
          "If": {
            "type": "`None`, the estimator's default scorer (if available) is used.",
            "description": ""
          },
          "cv": {
            "type": "int, cross",
            "description": "validation generator or an iterable, default=None"
          },
          "Determines": {
            "type": "the cross-validation splitting strategy.",
            "description": ""
          },
          "Possible": {
            "type": "inputs for cv are:",
            "description": "- `None`, to use the default 5-fold cross validation,\n- int, to specify the number of folds in a `(Stratified)KFold`,\n- :term:`CV splitter`,\n- An iterable that generates (train, test) splits as arrays of indices."
          },
          "For": {
            "type": "`int`/`None` inputs, if the estimator is a classifier and `y` is",
            "description": ""
          },
          "either": {
            "type": "binary or multiclass, :class:`StratifiedKFold` is used. In all",
            "description": ""
          },
          "other": {
            "type": "cases, :class:`KFold` is used. These splitters are instantiated",
            "description": ""
          },
          "with": {
            "type": "`shuffle=False` so the splits will be the same across calls.",
            "description": ""
          },
          "Refer": {
            "type": "ref:`User Guide <cross_validation>` for the various",
            "description": "cross-validation strategies that can be used here.\n.. versionchanged:: 0.22\n`cv` default value if `None` changed from 3-fold to 5-fold."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": ""
          },
          "Number": {
            "type": "of jobs to run in parallel. Training the estimator and computing",
            "description": ""
          },
          "the": {
            "type": "score are parallelized over the cross-validation splits.",
            "description": "``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n``-1`` means using all processors. See :term:`Glossary <n_jobs>`"
          },
          "for": {
            "type": "more details.",
            "description": ""
          },
          "verbose": {
            "type": "int, default=0",
            "description": ""
          },
          "params": {
            "type": "dict, default=None",
            "description": ""
          }
        },
        "returns": "train scores, fit times and score times.\n\n    cross_val_predict : Get predictions from each split of cross-validation for\n        diagnostic purposes.\n\n    sklearn.metrics.make_scorer : Make a scorer from a performance metric or\n        loss function.\n\n    Examples\n    --------\n    >>> from sklearn import datasets, linear_model\n    >>> from sklearn.model_selection import cross_val_score\n    >>> diabetes = datasets.load_diabetes()\n    >>> X = diabetes.data[:150]\n    >>> y = diabetes.target[:150]\n    >>> lasso = linear_model.Lasso()\n    >>> print(cross_val_score(lasso, X, y, cv=3))\n    [0.3315057  0.08022103 0.03531816]",
        "raises": "",
        "see_also": "--------\n    cross_validate : To run cross-validation on multiple metrics and also to\n        return train scores, fit times and score times.\n\n    cross_val_predict : Get predictions from each split of cross-validation for\n        diagnostic purposes.\n\n    sklearn.metrics.make_scorer : Make a scorer from a performance metric or\n        loss function.\n\n    Examples\n    --------\n    >>> from sklearn import datasets, linear_model\n    >>> from sklearn.model_selection import cross_val_score\n    >>> diabetes = datasets.load_diabetes()\n    >>> X = diabetes.data[:150]\n    >>> y = diabetes.target[:150]\n    >>> lasso = linear_model.Lasso()\n    >>> print(cross_val_score(lasso, X, y, cv=3))\n    [0.3315057  0.08022103 0.03531816]",
        "notes": "",
        "examples": "--------\n    >>> from sklearn import datasets, linear_model\n    >>> from sklearn.model_selection import cross_val_score\n    >>> diabetes = datasets.load_diabetes()\n    >>> X = diabetes.data[:150]\n    >>> y = diabetes.target[:150]\n    >>> lasso = linear_model.Lasso()\n    >>> print(cross_val_score(lasso, X, y, cv=3))\n    [0.3315057  0.08022103 0.03531816]"
      }
    },
    {
      "name": "cross_validate",
      "signature": "cross_validate(estimator, X, y=None, *, groups=None, scoring=None, cv=None, n_jobs=None, verbose=0, params=None, pre_dispatch='2*n_jobs', return_train_score=False, return_estimator=False, return_indices=False, error_score=nan)",
      "documentation": {
        "description": "Evaluate metric(s) by cross-validation and also record fit/score times.\n\n    Read more in the :ref:`User Guide <multimetric_cross_validation>`.\n\n    Parameters\n    ----------\n    estimator : estimator object implementing 'fit'\n        The object to use to fit the data.\n\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        The data to fit. Can be for example a list, or an array.\n\n    y : array-like of shape (n_samples,) or (n_samples, n_outputs), default=None\n        The target variable to try to predict in the case of\n        supervised learning.\n\n    groups : array-like of shape (n_samples,), default=None\n        Group labels for the samples used while splitting the dataset into\n        train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n        instance (e.g., :class:`GroupKFold`).\n\n        .. versionchanged:: 1.4\n            ``groups`` can only be passed if metadata routing is not enabled\n            via ``sklearn.set_config(enable_metadata_routing=True)``. When routing\n            is enabled, pass ``groups`` alongside other metadata via the ``params``\n            argument instead. E.g.:\n            ``cross_validate(..., params={'groups': groups})``.\n\n    scoring : str, callable, list, tuple, or dict, default=None\n        Strategy to evaluate the performance of the cross-validated model on\n        the test set. If `None`, the\n        :ref:`default evaluation criterion <scoring_api_overview>` of the estimator\n        is used.\n\n        If `scoring` represents a single score, one can use:\n\n        - a single string (see :ref:`scoring_parameter`);\n        - a callable (see :ref:`scoring_callable`) that returns a single value.\n\n        If `scoring` represents multiple scores, one can use:\n\n        - a list or tuple of unique strings;\n        - a callable returning a dictionary where the keys are the metric\n          names and the values are the metric scores;\n        - a dictionary with metric names as keys and callables a values.\n\n        See :ref:`multimetric_grid_search` for an example.\n\n    cv : int, cross-validation generator or an iterable, default=None\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - None, to use the default 5-fold cross validation,\n        - int, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For int/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value if None changed from 3-fold to 5-fold.\n\n    n_jobs : int, default=None\n        Number of jobs to run in parallel. Training the estimator and computing\n        the score are parallelized over the cross-validation splits.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    verbose : int, default=0\n        The verbosity level.\n\n    params : dict, default=None\n        Parameters to pass to the underlying estimator's ``fit``, the scorer,\n        and the CV splitter.\n\n        .. versionadded:: 1.4\n\n    pre_dispatch : int or str, default='2*n_jobs'\n        Controls the number of jobs that get dispatched during parallel\n        execution. Reducing this number can be useful to avoid an\n        explosion of memory consumption when more jobs get dispatched\n        than CPUs can process. This parameter can be:\n\n        - An int, giving the exact number of total jobs that are spawned\n        - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'\n\n    return_train_score : bool, default=False\n        Whether to include train scores.\n        Computing training scores is used to get insights on how different\n        parameter settings impact the overfitting/underfitting trade-off.\n        However computing the scores on the training set can be computationally\n        expensive and is not strictly required to select the parameters that\n        yield the best generalization performance.\n\n        .. versionadded:: 0.19\n\n        .. versionchanged:: 0.21\n            Default value was changed from ``True`` to ``False``\n\n    return_estimator : bool, default=False\n        Whether to return the estimators fitted on each split.\n\n        .. versionadded:: 0.20\n\n    return_indices : bool, default=False\n        Whether to return the train-test indices selected for each split.\n\n        .. versionadded:: 1.3\n\n    error_score : 'raise' or numeric, default=np.nan\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised.\n        If a numeric value is given, FitFailedWarning is raised.\n\n        .. versionadded:: 0.20\n\n    Returns\n    -------\n    scores : dict of float arrays of shape (n_splits,)\n        Array of scores of the estimator for each run of the cross validation.\n\n        A dict of arrays containing the score/time arrays for each scorer is\n        returned. The possible keys for this ``dict`` are:\n\n        ``test_score``\n            The score array for test scores on each cv split.\n            Suffix ``_score`` in ``test_score`` changes to a specific\n            metric like ``test_r2`` or ``test_auc`` if there are\n            multiple scoring metrics in the scoring parameter.\n        ``train_score``\n            The score array for train scores on each cv split.\n            Suffix ``_score`` in ``train_score`` changes to a specific\n            metric like ``train_r2`` or ``train_auc`` if there are\n            multiple scoring metrics in the scoring parameter.\n            This is available only if ``return_train_score`` parameter\n            is ``True``.\n        ``fit_time``\n            The time for fitting the estimator on the train\n            set for each cv split.\n        ``score_time``\n            The time for scoring the estimator on the test set for each\n            cv split. (Note time for scoring on the train set is not\n            included even if ``return_train_score`` is set to ``True``\n        ``estimator``\n            The estimator objects for each cv split.\n            This is available only if ``return_estimator`` parameter\n            is set to ``True``.\n        ``indices``\n            The train/test positional indices for each cv split. A dictionary\n            is returned where the keys are either `\"train\"` or `\"test\"`\n            and the associated values are a list of integer-dtyped NumPy\n            arrays with the indices. Available only if `return_indices=True`.\n\n    See Also\n    --------\n    cross_val_score : Run cross-validation for single metric evaluation.\n\n    cross_val_predict : Get predictions from each split of cross-validation for\n        diagnostic purposes.\n\n    sklearn.metrics.make_scorer : Make a scorer from a performance metric or\n        loss function.",
        "parameters": {
          "estimator": {
            "type": "estimator object implementing 'fit'",
            "description": ""
          },
          "The": {
            "type": "verbosity level.",
            "description": ""
          },
          "X": {
            "type": "{array",
            "description": "like, sparse matrix} of shape (n_samples, n_features)"
          },
          "y": {
            "type": "array",
            "description": "like of shape (n_samples,) or (n_samples, n_outputs), default=None"
          },
          "supervised": {
            "type": "learning.",
            "description": ""
          },
          "groups": {
            "type": "array",
            "description": "like of shape (n_samples,), default=None"
          },
          "Group": {
            "type": "labels for the samples used while splitting the dataset into",
            "description": "train/test set. Only used in conjunction with a \"Group\" :term:`cv`"
          },
          "instance": {
            "type": "e.g., :class:`GroupKFold`",
            "description": ".\n.. versionchanged:: 1.4\n``groups`` can only be passed if metadata routing is not enabled"
          },
          "via": {
            "type": "``sklearn.set_config(enable_metadata_routing=True)``. When routing",
            "description": ""
          },
          "is": {
            "type": "used.",
            "description": ""
          },
          "argument": {
            "type": "instead. E.g.:",
            "description": "``cross_validate(..., params={'groups': groups})``."
          },
          "scoring": {
            "type": "str, callable, list, tuple, or dict, default=None",
            "description": ""
          },
          "Strategy": {
            "type": "to evaluate the performance of the cross-validated model on",
            "description": ""
          },
          "the": {
            "type": "score are parallelized over the cross-validation splits.",
            "description": "``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n``-1`` means using all processors. See :term:`Glossary <n_jobs>`"
          },
          "If": {
            "type": "`scoring` represents multiple scores, one can use:",
            "description": "- a list or tuple of unique strings;\n- a callable returning a dictionary where the keys are the metric"
          },
          "names": {
            "type": "and the values are the metric scores;",
            "description": "- a dictionary with metric names as keys and callables a values."
          },
          "See": {
            "type": "ref:`multimetric_grid_search` for an example.",
            "description": ""
          },
          "cv": {
            "type": "int, cross",
            "description": "validation generator or an iterable, default=None"
          },
          "Determines": {
            "type": "the cross-validation splitting strategy.",
            "description": ""
          },
          "Possible": {
            "type": "inputs for cv are:",
            "description": "- None, to use the default 5-fold cross validation,\n- int, to specify the number of folds in a `(Stratified)KFold`,\n- :term:`CV splitter`,\n- An iterable yielding (train, test) splits as arrays of indices."
          },
          "For": {
            "type": "int/None inputs, if the estimator is a classifier and ``y`` is",
            "description": ""
          },
          "either": {
            "type": "binary or multiclass, :class:`StratifiedKFold` is used. In all",
            "description": ""
          },
          "other": {
            "type": "cases, :class:`KFold` is used. These splitters are instantiated",
            "description": ""
          },
          "with": {
            "type": "`shuffle=False` so the splits will be the same across calls.",
            "description": ""
          },
          "Refer": {
            "type": "ref:`User Guide <cross_validation>` for the various",
            "description": "cross-validation strategies that can be used here.\n.. versionchanged:: 0.22\n``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": ""
          },
          "Number": {
            "type": "of jobs to run in parallel. Training the estimator and computing",
            "description": ""
          },
          "for": {
            "type": "more details.",
            "description": ""
          },
          "verbose": {
            "type": "int, default=0",
            "description": ""
          },
          "params": {
            "type": "dict, default=None",
            "description": ""
          }
        },
        "returns": "-------\n    scores : dict of float arrays of shape (n_splits,)\n        Array of scores of the estimator for each run of the cross validation.\n\n        A dict of arrays containing the score/time arrays for each scorer is\n        returned. The possible keys for this ``dict`` are:\n\n        ``test_score``\n            The score array for test scores on each cv split.\n            Suffix ``_score`` in ``test_score`` changes to a specific\n            metric like ``test_r2`` or ``test_auc`` if there are\n            multiple scoring metrics in the scoring parameter.\n        ``train_score``\n            The score array for train scores on each cv split.\n            Suffix ``_score`` in ``train_score`` changes to a specific\n            metric like ``train_r2`` or ``train_auc`` if there are\n            multiple scoring metrics in the scoring parameter.\n            This is available only if ``return_train_score`` parameter\n            is ``True``.\n        ``fit_time``\n            The time for fitting the estimator on the train\n            set for each cv split.\n        ``score_time``\n            The time for scoring the estimator on the test set for each\n            cv split. (Note time for scoring on the train set is not\n            included even if ``return_train_score`` is set to ``True``\n        ``estimator``\n            The estimator objects for each cv split.\n            This is available only if ``return_estimator`` parameter\n            is set to ``True``.\n        ``indices``\n            The train/test positional indices for each cv split. A dictionary\n            is returned where the keys are either `\"train\"` or `\"test\"`\n            and the associated values are a list of integer-dtyped NumPy\n            arrays with the indices. Available only if `return_indices=True`.\n\n    See Also\n    --------\n    cross_val_score : Run cross-validation for single metric evaluation.\n\n    cross_val_predict : Get predictions from each split of cross-validation for\n        diagnostic purposes.\n\n    sklearn.metrics.make_scorer : Make a scorer from a performance metric or\n        loss function.\n\n    Examples\n    --------\n    >>> from sklearn import datasets, linear_model\n    >>> from sklearn.model_selection import cross_validate\n    >>> from sklearn.metrics import make_scorer\n    >>> from sklearn.metrics import confusion_matrix\n    >>> from sklearn.svm import LinearSVC\n    >>> diabetes = datasets.load_diabetes()\n    >>> X = diabetes.data[:150]\n    >>> y = diabetes.target[:150]\n    >>> lasso = linear_model.Lasso()\n\n    Single metric evaluation using ``cross_validate``\n\n    >>> cv_results = cross_validate(lasso, X, y, cv=3)\n    >>> sorted(cv_results.keys())\n    ['fit_time', 'score_time', 'test_score']\n    >>> cv_results['test_score']\n    array([0.3315057 , 0.08022103, 0.03531816])\n\n    Multiple metric evaluation using ``cross_validate``\n    (please refer the ``scoring`` parameter doc for more information)\n\n    >>> scores = cross_validate(lasso, X, y, cv=3,\n    ...                         scoring=('r2', 'neg_mean_squared_error'),\n    ...                         return_train_score=True)\n    >>> print(scores['test_neg_mean_squared_error'])\n    [-3635.5... -3573.3... -6114.7...]\n    >>> print(scores['train_r2'])\n    [0.28009951 0.3908844  0.22784907]",
        "raises": "",
        "see_also": "--------\n    cross_val_score : Run cross-validation for single metric evaluation.\n\n    cross_val_predict : Get predictions from each split of cross-validation for\n        diagnostic purposes.\n\n    sklearn.metrics.make_scorer : Make a scorer from a performance metric or\n        loss function.\n\n    Examples\n    --------\n    >>> from sklearn import datasets, linear_model\n    >>> from sklearn.model_selection import cross_validate\n    >>> from sklearn.metrics import make_scorer\n    >>> from sklearn.metrics import confusion_matrix\n    >>> from sklearn.svm import LinearSVC\n    >>> diabetes = datasets.load_diabetes()\n    >>> X = diabetes.data[:150]\n    >>> y = diabetes.target[:150]\n    >>> lasso = linear_model.Lasso()\n\n    Single metric evaluation using ``cross_validate``\n\n    >>> cv_results = cross_validate(lasso, X, y, cv=3)\n    >>> sorted(cv_results.keys())\n    ['fit_time', 'score_time', 'test_score']\n    >>> cv_results['test_score']\n    array([0.3315057 , 0.08022103, 0.03531816])\n\n    Multiple metric evaluation using ``cross_validate``\n    (please refer the ``scoring`` parameter doc for more information)\n\n    >>> scores = cross_validate(lasso, X, y, cv=3,\n    ...                         scoring=('r2', 'neg_mean_squared_error'),\n    ...                         return_train_score=True)\n    >>> print(scores['test_neg_mean_squared_error'])\n    [-3635.5... -3573.3... -6114.7...]\n    >>> print(scores['train_r2'])\n    [0.28009951 0.3908844  0.22784907]",
        "notes": "",
        "examples": "--------\n    >>> from sklearn import datasets, linear_model\n    >>> from sklearn.model_selection import cross_validate\n    >>> from sklearn.metrics import make_scorer\n    >>> from sklearn.metrics import confusion_matrix\n    >>> from sklearn.svm import LinearSVC\n    >>> diabetes = datasets.load_diabetes()\n    >>> X = diabetes.data[:150]\n    >>> y = diabetes.target[:150]\n    >>> lasso = linear_model.Lasso()\n\n    Single metric evaluation using ``cross_validate``\n\n    >>> cv_results = cross_validate(lasso, X, y, cv=3)\n    >>> sorted(cv_results.keys())\n    ['fit_time', 'score_time', 'test_score']\n    >>> cv_results['test_score']\n    array([0.3315057 , 0.08022103, 0.03531816])\n\n    Multiple metric evaluation using ``cross_validate``\n    (please refer the ``scoring`` parameter doc for more information)\n\n    >>> scores = cross_validate(lasso, X, y, cv=3,\n    ...                         scoring=('r2', 'neg_mean_squared_error'),\n    ...                         return_train_score=True)\n    >>> print(scores['test_neg_mean_squared_error'])\n    [-3635.5... -3573.3... -6114.7...]\n    >>> print(scores['train_r2'])\n    [0.28009951 0.3908844  0.22784907]"
      }
    },
    {
      "name": "learning_curve",
      "signature": "learning_curve(estimator, X, y, *, groups=None, train_sizes=array([0.1  , 0.325, 0.55 , 0.775, 1.   ]), cv=None, scoring=None, exploit_incremental_learning=False, n_jobs=None, pre_dispatch='all', verbose=0, shuffle=False, random_state=None, error_score=nan, return_times=False, fit_params=None, params=None)",
      "documentation": {
        "description": "Learning curve.\n\n    Determines cross-validated training and test scores for different training\n    set sizes.\n\n    A cross-validation generator splits the whole dataset k times in training\n    and test data. Subsets of the training set with varying sizes will be used\n    to train the estimator and a score for each training subset size and the\n    test set will be computed. Afterwards, the scores will be averaged over\n    all k runs for each training subset size.\n\n    Read more in the :ref:`User Guide <learning_curve>`.\n\n    Parameters\n    ----------\n    estimator : object type that implements the \"fit\" method\n        An object of that type which is cloned for each validation. It must\n        also implement \"predict\" unless `scoring` is a callable that doesn't\n        rely on \"predict\" to compute a score.\n\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        Training vector, where `n_samples` is the number of samples and\n        `n_features` is the number of features.\n\n    y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None\n        Target relative to X for classification or regression;\n        None for unsupervised learning.\n\n    groups : array-like of shape (n_samples,), default=None\n        Group labels for the samples used while splitting the dataset into\n        train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n        instance (e.g., :class:`GroupKFold`).\n\n        .. versionchanged:: 1.6\n            ``groups`` can only be passed if metadata routing is not enabled\n            via ``sklearn.set_config(enable_metadata_routing=True)``. When routing\n            is enabled, pass ``groups`` alongside other metadata via the ``params``\n            argument instead. E.g.:\n            ``learning_curve(..., params={'groups': groups})``.\n\n    train_sizes : array-like of shape (n_ticks,),             default=np.linspace(0.1, 1.0, 5)\n        Relative or absolute numbers of training examples that will be used to\n        generate the learning curve. If the dtype is float, it is regarded as a\n        fraction of the maximum size of the training set (that is determined\n        by the selected validation method), i.e. it has to be within (0, 1].\n        Otherwise it is interpreted as absolute sizes of the training sets.\n        Note that for classification the number of samples usually has to\n        be big enough to contain at least one sample from each class.\n\n    cv : int, cross-validation generator or an iterable, default=None\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - None, to use the default 5-fold cross validation,\n        - int, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For int/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value if None changed from 3-fold to 5-fold.\n\n    scoring : str or callable, default=None\n        A str (see :ref:`scoring_parameter`) or a scorer callable object / function with\n        signature ``scorer(estimator, X, y)``.\n\n    exploit_incremental_learning : bool, default=False\n        If the estimator supports incremental learning, this will be\n        used to speed up fitting for different training set sizes.\n\n    n_jobs : int, default=None\n        Number of jobs to run in parallel. Training the estimator and computing\n        the score are parallelized over the different training and test sets.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    pre_dispatch : int or str, default='all'\n        Number of predispatched jobs for parallel execution (default is\n        all). The option can reduce the allocated memory. The str can\n        be an expression like '2*n_jobs'.\n\n    verbose : int, default=0\n        Controls the verbosity: the higher, the more messages.\n\n    shuffle : bool, default=False\n        Whether to shuffle training data before taking prefixes of it\n        based on``train_sizes``.\n\n    random_state : int, RandomState instance or None, default=None\n        Used when ``shuffle`` is True. Pass an int for reproducible\n        output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    error_score : 'raise' or numeric, default=np.nan\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised.\n        If a numeric value is given, FitFailedWarning is raised.\n\n        .. versionadded:: 0.20\n\n    return_times : bool, default=False\n        Whether to return the fit and score times.\n\n    fit_params : dict, default=None\n        Parameters to pass to the fit method of the estimator.\n\n        .. deprecated:: 1.6\n            This parameter is deprecated and will be removed in version 1.8. Use\n            ``params`` instead.\n\n    params : dict, default=None\n        Parameters to pass to the `fit` method of the estimator and to the scorer.\n\n        - If `enable_metadata_routing=False` (default): Parameters directly passed to\n          the `fit` method of the estimator.\n\n        - If `enable_metadata_routing=True`: Parameters safely routed to the `fit`\n          method of the estimator. See :ref:`Metadata Routing User Guide\n          <metadata_routing>` for more details.\n\n        .. versionadded:: 1.6\n\n    Returns\n    -------\n    train_sizes_abs : array of shape (n_unique_ticks,)\n        Numbers of training examples that has been used to generate the\n        learning curve. Note that the number of ticks might be less\n        than n_ticks because duplicate entries will be removed.\n\n    train_scores : array of shape (n_ticks, n_cv_folds)\n        Scores on training sets.\n\n    test_scores : array of shape (n_ticks, n_cv_folds)\n        Scores on test set.\n\n    fit_times : array of shape (n_ticks, n_cv_folds)\n        Times spent for fitting in seconds. Only present if ``return_times``\n        is True.\n\n    score_times : array of shape (n_ticks, n_cv_folds)\n        Times spent for scoring in seconds. Only present if ``return_times``\n        is True.",
        "parameters": {
          "estimator": {
            "type": "object type that implements the \"fit\" method",
            "description": ""
          },
          "An": {
            "type": "object of that type which is cloned for each validation. It must",
            "description": ""
          },
          "also": {
            "type": "implement \"predict\" unless `scoring` is a callable that doesn't",
            "description": ""
          },
          "rely": {
            "type": "on \"predict\" to compute a score.",
            "description": ""
          },
          "X": {
            "type": "{array",
            "description": "like, sparse matrix} of shape (n_samples, n_features)"
          },
          "Training": {
            "type": "vector, where `n_samples` is the number of samples and",
            "description": "`n_features` is the number of features."
          },
          "y": {
            "type": "array",
            "description": "like of shape (n_samples,) or (n_samples, n_outputs) or None"
          },
          "Target": {
            "type": "relative to X for classification or regression;",
            "description": ""
          },
          "None": {
            "type": "for unsupervised learning.",
            "description": ""
          },
          "groups": {
            "type": "array",
            "description": "like of shape (n_samples,), default=None"
          },
          "Group": {
            "type": "labels for the samples used while splitting the dataset into",
            "description": "train/test set. Only used in conjunction with a \"Group\" :term:`cv`"
          },
          "instance": {
            "type": "e.g., :class:`GroupKFold`",
            "description": ".\n.. versionchanged:: 1.6\n``groups`` can only be passed if metadata routing is not enabled"
          },
          "via": {
            "type": "``sklearn.set_config(enable_metadata_routing=True)``. When routing",
            "description": ""
          },
          "is": {
            "type": "enabled, pass ``groups`` alongside other metadata via the ``params``",
            "description": ""
          },
          "argument": {
            "type": "instead. E.g.:",
            "description": "``learning_curve(..., params={'groups': groups})``."
          },
          "train_sizes": {
            "type": "array",
            "description": "like of shape (n_ticks,),             default=np.linspace(0.1, 1.0, 5)"
          },
          "Relative": {
            "type": "or absolute numbers of training examples that will be used to",
            "description": ""
          },
          "generate": {
            "type": "the learning curve. If the dtype is float, it is regarded as a",
            "description": ""
          },
          "fraction": {
            "type": "of the maximum size of the training set (that is determined",
            "description": ""
          },
          "by": {
            "type": "the selected validation method), i.e. it has to be within (0, 1].",
            "description": ""
          },
          "Otherwise": {
            "type": "it is interpreted as absolute sizes of the training sets.",
            "description": ""
          },
          "Note": {
            "type": "that for classification the number of samples usually has to",
            "description": ""
          },
          "be": {
            "type": "an expression like '2*n_jobs'.",
            "description": ""
          },
          "cv": {
            "type": "int, cross",
            "description": "validation generator or an iterable, default=None"
          },
          "Determines": {
            "type": "the cross-validation splitting strategy.",
            "description": ""
          },
          "Possible": {
            "type": "inputs for cv are:",
            "description": "- None, to use the default 5-fold cross validation,\n- int, to specify the number of folds in a `(Stratified)KFold`,\n- :term:`CV splitter`,\n- An iterable yielding (train, test) splits as arrays of indices."
          },
          "For": {
            "type": "int/None inputs, if the estimator is a classifier and ``y`` is",
            "description": ""
          },
          "either": {
            "type": "binary or multiclass, :class:`StratifiedKFold` is used. In all",
            "description": ""
          },
          "other": {
            "type": "cases, :class:`KFold` is used. These splitters are instantiated",
            "description": ""
          },
          "with": {
            "type": "`shuffle=False` so the splits will be the same across calls.",
            "description": ""
          },
          "Refer": {
            "type": "ref:`User Guide <cross_validation>` for the various",
            "description": "cross-validation strategies that can be used here.\n.. versionchanged:: 0.22\n``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "scoring": {
            "type": "str or callable, default=None",
            "description": ""
          },
          "A": {
            "type": "str (see :ref:`scoring_parameter`) or a scorer callable object / function with",
            "description": ""
          },
          "signature": {
            "type": "``scorer(estimator, X, y)``.",
            "description": ""
          },
          "exploit_incremental_learning": {
            "type": "bool, default=False",
            "description": ""
          },
          "If": {
            "type": "a numeric value is given, FitFailedWarning is raised.",
            "description": ".. versionadded:: 0.20"
          },
          "used": {
            "type": "to speed up fitting for different training set sizes.",
            "description": ""
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": ""
          },
          "Number": {
            "type": "of predispatched jobs for parallel execution (default is",
            "description": "all). The option can reduce the allocated memory. The str can"
          },
          "the": {
            "type": "score are parallelized over the different training and test sets.",
            "description": "``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n``-1`` means using all processors. See :term:`Glossary <n_jobs>`"
          },
          "for": {
            "type": "more details.",
            "description": ""
          },
          "pre_dispatch": {
            "type": "int or str, default='all'",
            "description": ""
          },
          "verbose": {
            "type": "int, default=0",
            "description": ""
          },
          "Controls": {
            "type": "the verbosity: the higher, the more messages.",
            "description": ""
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": ""
          },
          "Whether": {
            "type": "to return the fit and score times.",
            "description": ""
          },
          "based": {
            "type": "on``train_sizes``.",
            "description": ""
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Used": {
            "type": "when ``shuffle`` is True. Pass an int for reproducible",
            "description": ""
          },
          "output": {
            "type": "across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "term:`Glossary <random_state>`.",
            "description": ""
          },
          "error_score": {
            "type": "'raise' or numeric, default=np.nan",
            "description": ""
          },
          "Value": {
            "type": "to assign to the score if an error occurs in estimator fitting.",
            "description": ""
          },
          "return_times": {
            "type": "bool, default=False",
            "description": ""
          },
          "fit_params": {
            "type": "dict, default=None",
            "description": ""
          }
        },
        "returns": "-------\n    train_sizes_abs : array of shape (n_unique_ticks,)\n        Numbers of training examples that has been used to generate the\n        learning curve. Note that the number of ticks might be less\n        than n_ticks because duplicate entries will be removed.\n\n    train_scores : array of shape (n_ticks, n_cv_folds)\n        Scores on training sets.\n\n    test_scores : array of shape (n_ticks, n_cv_folds)\n        Scores on test set.\n\n    fit_times : array of shape (n_ticks, n_cv_folds)\n        Times spent for fitting in seconds. Only present if ``return_times``\n        is True.\n\n    score_times : array of shape (n_ticks, n_cv_folds)\n        Times spent for scoring in seconds. Only present if ``return_times``\n        is True.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.tree import DecisionTreeClassifier\n    >>> from sklearn.model_selection import learning_curve\n    >>> X, y = make_classification(n_samples=100, n_features=10, random_state=42)\n    >>> tree = DecisionTreeClassifier(max_depth=4, random_state=42)\n    >>> train_size_abs, train_scores, test_scores = learning_curve(\n    ...     tree, X, y, train_sizes=[0.3, 0.6, 0.9]\n    ... )\n    >>> for train_size, cv_train_scores, cv_test_scores in zip(\n    ...     train_size_abs, train_scores, test_scores\n    ... ):\n    ...     print(f\"{train_size} samples were used to train the model\")\n    ...     print(f\"The average train accuracy is {cv_train_scores.mean():.2f}\")\n    ...     print(f\"The average test accuracy is {cv_test_scores.mean():.2f}\")\n    24 samples were used to train the model\n    The average train accuracy is 1.00\n    The average test accuracy is 0.85\n    48 samples were used to train the model\n    The average train accuracy is 1.00\n    The average test accuracy is 0.90\n    72 samples were used to train the model\n    The average train accuracy is 1.00\n    The average test accuracy is 0.93",
        "raises": "",
        "see_also": "",
        "notes": "that for classification the number of samples usually has to\n        be big enough to contain at least one sample from each class.\n\n    cv : int, cross-validation generator or an iterable, default=None\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - None, to use the default 5-fold cross validation,\n        - int, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For int/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value if None changed from 3-fold to 5-fold.\n\n    scoring : str or callable, default=None\n        A str (see :ref:`scoring_parameter`) or a scorer callable object / function with\n        signature ``scorer(estimator, X, y)``.\n\n    exploit_incremental_learning : bool, default=False\n        If the estimator supports incremental learning, this will be\n        used to speed up fitting for different training set sizes.\n\n    n_jobs : int, default=None\n        Number of jobs to run in parallel. Training the estimator and computing\n        the score are parallelized over the different training and test sets.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    pre_dispatch : int or str, default='all'\n        Number of predispatched jobs for parallel execution (default is\n        all). The option can reduce the allocated memory. The str can\n        be an expression like '2*n_jobs'.\n\n    verbose : int, default=0\n        Controls the verbosity: the higher, the more messages.\n\n    shuffle : bool, default=False\n        Whether to shuffle training data before taking prefixes of it\n        based on``train_sizes``.\n\n    random_state : int, RandomState instance or None, default=None\n        Used when ``shuffle`` is True. Pass an int for reproducible\n        output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    error_score : 'raise' or numeric, default=np.nan\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised.\n        If a numeric value is given, FitFailedWarning is raised.\n\n        .. versionadded:: 0.20\n\n    return_times : bool, default=False\n        Whether to return the fit and score times.\n\n    fit_params : dict, default=None\n        Parameters to pass to the fit method of the estimator.\n\n        .. deprecated:: 1.6\n            This parameter is deprecated and will be removed in version 1.8. Use\n            ``params`` instead.\n\n    params : dict, default=None\n        Parameters to pass to the `fit` method of the estimator and to the scorer.\n\n        - If `enable_metadata_routing=False` (default): Parameters directly passed to\n          the `fit` method of the estimator.\n\n        - If `enable_metadata_routing=True`: Parameters safely routed to the `fit`\n          method of the estimator. See :ref:`Metadata Routing User Guide\n          <metadata_routing>` for more details.\n\n        .. versionadded:: 1.6\n\n    Returns\n    -------\n    train_sizes_abs : array of shape (n_unique_ticks,)\n        Numbers of training examples that has been used to generate the\n        learning curve. Note that the number of ticks might be less\n        than n_ticks because duplicate entries will be removed.\n\n    train_scores : array of shape (n_ticks, n_cv_folds)\n        Scores on training sets.\n\n    test_scores : array of shape (n_ticks, n_cv_folds)\n        Scores on test set.\n\n    fit_times : array of shape (n_ticks, n_cv_folds)\n        Times spent for fitting in seconds. Only present if ``return_times``\n        is True.\n\n    score_times : array of shape (n_ticks, n_cv_folds)\n        Times spent for scoring in seconds. Only present if ``return_times``\n        is True.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.tree import DecisionTreeClassifier\n    >>> from sklearn.model_selection import learning_curve\n    >>> X, y = make_classification(n_samples=100, n_features=10, random_state=42)\n    >>> tree = DecisionTreeClassifier(max_depth=4, random_state=42)\n    >>> train_size_abs, train_scores, test_scores = learning_curve(\n    ...     tree, X, y, train_sizes=[0.3, 0.6, 0.9]\n    ... )\n    >>> for train_size, cv_train_scores, cv_test_scores in zip(\n    ...     train_size_abs, train_scores, test_scores\n    ... ):\n    ...     print(f\"{train_size} samples were used to train the model\")\n    ...     print(f\"The average train accuracy is {cv_train_scores.mean():.2f}\")\n    ...     print(f\"The average test accuracy is {cv_test_scores.mean():.2f}\")\n    24 samples were used to train the model\n    The average train accuracy is 1.00\n    The average test accuracy is 0.85\n    48 samples were used to train the model\n    The average train accuracy is 1.00\n    The average test accuracy is 0.90\n    72 samples were used to train the model\n    The average train accuracy is 1.00\n    The average test accuracy is 0.93",
        "examples": "--------\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.tree import DecisionTreeClassifier\n    >>> from sklearn.model_selection import learning_curve\n    >>> X, y = make_classification(n_samples=100, n_features=10, random_state=42)\n    >>> tree = DecisionTreeClassifier(max_depth=4, random_state=42)\n    >>> train_size_abs, train_scores, test_scores = learning_curve(\n    ...     tree, X, y, train_sizes=[0.3, 0.6, 0.9]\n    ... )\n    >>> for train_size, cv_train_scores, cv_test_scores in zip(\n    ...     train_size_abs, train_scores, test_scores\n    ... ):\n    ...     print(f\"{train_size} samples were used to train the model\")\n    ...     print(f\"The average train accuracy is {cv_train_scores.mean():.2f}\")\n    ...     print(f\"The average test accuracy is {cv_test_scores.mean():.2f}\")\n    24 samples were used to train the model\n    The average train accuracy is 1.00\n    The average test accuracy is 0.85\n    48 samples were used to train the model\n    The average train accuracy is 1.00\n    The average test accuracy is 0.90\n    72 samples were used to train the model\n    The average train accuracy is 1.00\n    The average test accuracy is 0.93"
      }
    },
    {
      "name": "permutation_test_score",
      "signature": "permutation_test_score(estimator, X, y, *, groups=None, cv=None, n_permutations=100, n_jobs=None, random_state=0, verbose=0, scoring=None, fit_params=None, params=None)",
      "documentation": {
        "description": "Evaluate the significance of a cross-validated score with permutations.\n\n    Permutes targets to generate 'randomized data' and compute the empirical\n    p-value against the null hypothesis that features and targets are\n    independent.\n\n    The p-value represents the fraction of randomized data sets where the\n    estimator performed as well or better than in the original data. A small\n    p-value suggests that there is a real dependency between features and\n    targets which has been used by the estimator to give good predictions.\n    A large p-value may be due to lack of real dependency between features\n    and targets or the estimator was not able to use the dependency to\n    give good predictions.\n\n    Read more in the :ref:`User Guide <permutation_test_score>`.\n\n    Parameters\n    ----------\n    estimator : estimator object implementing 'fit'\n        The object to use to fit the data.\n\n    X : array-like of shape at least 2D\n        The data to fit.\n\n    y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None\n        The target variable to try to predict in the case of\n        supervised learning.\n\n    groups : array-like of shape (n_samples,), default=None\n        Labels to constrain permutation within groups, i.e. ``y`` values\n        are permuted among samples with the same group identifier.\n        When not specified, ``y`` values are permuted among all samples.\n\n        When a grouped cross-validator is used, the group labels are\n        also passed on to the ``split`` method of the cross-validator. The\n        cross-validator uses them for grouping the samples  while splitting\n        the dataset into train/test set.\n\n        .. versionchanged:: 1.6\n            ``groups`` can only be passed if metadata routing is not enabled\n            via ``sklearn.set_config(enable_metadata_routing=True)``. When routing\n            is enabled, pass ``groups`` alongside other metadata via the ``params``\n            argument instead. E.g.:\n            ``permutation_test_score(..., params={'groups': groups})``.\n\n    cv : int, cross-validation generator or an iterable, default=None\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - `None`, to use the default 5-fold cross validation,\n        - int, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For `int`/`None` inputs, if the estimator is a classifier and `y` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            `cv` default value if `None` changed from 3-fold to 5-fold.\n\n    n_permutations : int, default=100\n        Number of times to permute ``y``.\n\n    n_jobs : int, default=None\n        Number of jobs to run in parallel. Training the estimator and computing\n        the cross-validated score are parallelized over the permutations.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    random_state : int, RandomState instance or None, default=0\n        Pass an int for reproducible output for permutation of\n        ``y`` values among samples. See :term:`Glossary <random_state>`.\n\n    verbose : int, default=0\n        The verbosity level.\n\n    scoring : str or callable, default=None\n        A single str (see :ref:`scoring_parameter`) or a callable\n        (see :ref:`scoring_callable`) to evaluate the predictions on the test set.\n\n        If `None` the estimator's score method is used.\n\n    fit_params : dict, default=None\n        Parameters to pass to the fit method of the estimator.\n\n        .. deprecated:: 1.6\n            This parameter is deprecated and will be removed in version 1.6. Use\n            ``params`` instead.\n\n    params : dict, default=None\n        Parameters to pass to the `fit` method of the estimator, the scorer\n        and the cv splitter.\n\n        - If `enable_metadata_routing=False` (default): Parameters directly passed to\n          the `fit` method of the estimator.\n\n        - If `enable_metadata_routing=True`: Parameters safely routed to the `fit`\n          method of the estimator, `cv` object and `scorer`. See :ref:`Metadata Routing\n          User Guide <metadata_routing>` for more details.\n\n        .. versionadded:: 1.6\n\n    Returns\n    -------\n    score : float\n        The true score without permuting targets.\n\n    permutation_scores : array of shape (n_permutations,)\n        The scores obtained for each permutations.\n\n    pvalue : float\n        The p-value, which approximates the probability that the score would\n        be obtained by chance. This is calculated as:\n\n        `(C + 1) / (n_permutations + 1)`\n\n        Where C is the number of permutations whose score >= the true score.\n\n        The best possible p-value is 1/(n_permutations + 1), the worst is 1.0.\n\n    Notes\n    -----\n    This function implements Test 1 in:\n\n    Ojala and Garriga. `Permutation Tests for Studying Classifier Performance\n    <http://www.jmlr.org/papers/volume11/ojala10a/ojala10a.pdf>`_. The\n    Journal of Machine Learning Research (2010) vol. 11",
        "parameters": {
          "estimator": {
            "type": "estimator object implementing 'fit'",
            "description": ""
          },
          "The": {
            "type": "verbosity level.",
            "description": ""
          },
          "X": {
            "type": "array",
            "description": "like of shape at least 2D"
          },
          "y": {
            "type": "array",
            "description": "like of shape (n_samples,) or (n_samples, n_outputs) or None"
          },
          "supervised": {
            "type": "learning.",
            "description": ""
          },
          "groups": {
            "type": "array",
            "description": "like of shape (n_samples,), default=None"
          },
          "Labels": {
            "type": "to constrain permutation within groups, i.e. ``y`` values",
            "description": ""
          },
          "are": {
            "type": "permuted among samples with the same group identifier.",
            "description": ""
          },
          "When": {
            "type": "a grouped cross-validator is used, the group labels are",
            "description": ""
          },
          "also": {
            "type": "passed on to the ``split`` method of the cross-validator. The",
            "description": "cross-validator uses them for grouping the samples  while splitting"
          },
          "the": {
            "type": "cross-validated score are parallelized over the permutations.",
            "description": "``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n``-1`` means using all processors. See :term:`Glossary <n_jobs>`"
          },
          "via": {
            "type": "``sklearn.set_config(enable_metadata_routing=True)``. When routing",
            "description": ""
          },
          "is": {
            "type": "enabled, pass ``groups`` alongside other metadata via the ``params``",
            "description": ""
          },
          "argument": {
            "type": "instead. E.g.:",
            "description": "``permutation_test_score(..., params={'groups': groups})``."
          },
          "cv": {
            "type": "int, cross",
            "description": "validation generator or an iterable, default=None"
          },
          "Determines": {
            "type": "the cross-validation splitting strategy.",
            "description": ""
          },
          "Possible": {
            "type": "inputs for cv are:",
            "description": "- `None`, to use the default 5-fold cross validation,\n- int, to specify the number of folds in a `(Stratified)KFold`,\n- :term:`CV splitter`,\n- An iterable yielding (train, test) splits as arrays of indices."
          },
          "For": {
            "type": "`int`/`None` inputs, if the estimator is a classifier and `y` is",
            "description": ""
          },
          "either": {
            "type": "binary or multiclass, :class:`StratifiedKFold` is used. In all",
            "description": ""
          },
          "other": {
            "type": "cases, :class:`KFold` is used. These splitters are instantiated",
            "description": ""
          },
          "with": {
            "type": "`shuffle=False` so the splits will be the same across calls.",
            "description": ""
          },
          "Refer": {
            "type": "ref:`User Guide <cross_validation>` for the various",
            "description": "cross-validation strategies that can be used here.\n.. versionchanged:: 0.22\n`cv` default value if `None` changed from 3-fold to 5-fold."
          },
          "n_permutations": {
            "type": "int, default=100",
            "description": ""
          },
          "Number": {
            "type": "of jobs to run in parallel. Training the estimator and computing",
            "description": ""
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": ""
          },
          "for": {
            "type": "more details.",
            "description": ""
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=0",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible output for permutation of",
            "description": "``y`` values among samples. See :term:`Glossary <random_state>`."
          },
          "verbose": {
            "type": "int, default=0",
            "description": ""
          },
          "scoring": {
            "type": "str or callable, default=None",
            "description": ""
          },
          "A": {
            "type": "single str (see :ref:`scoring_parameter`) or a callable",
            "description": "(see :ref:`scoring_callable`) to evaluate the predictions on the test set."
          },
          "If": {
            "type": "`None` the estimator's score method is used.",
            "description": ""
          },
          "fit_params": {
            "type": "dict, default=None",
            "description": ""
          }
        },
        "returns": "-------\n    score : float\n        The true score without permuting targets.\n\n    permutation_scores : array of shape (n_permutations,)\n        The scores obtained for each permutations.\n\n    pvalue : float\n        The p-value, which approximates the probability that the score would\n        be obtained by chance. This is calculated as:\n\n        `(C + 1) / (n_permutations + 1)`\n\n        Where C is the number of permutations whose score >= the true score.\n\n        The best possible p-value is 1/(n_permutations + 1), the worst is 1.0.\n\n    Notes\n    -----\n    This function implements Test 1 in:\n\n    Ojala and Garriga. `Permutation Tests for Studying Classifier Performance\n    <http://www.jmlr.org/papers/volume11/ojala10a/ojala10a.pdf>`_. The\n    Journal of Machine Learning Research (2010) vol. 11\n\n    Examples\n    --------\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.model_selection import permutation_test_score\n    >>> X, y = make_classification(random_state=0)\n    >>> estimator = LogisticRegression()\n    >>> score, permutation_scores, pvalue = permutation_test_score(\n    ...     estimator, X, y, random_state=0\n    ... )\n    >>> print(f\"Original Score: {score:.3f}\")\n    Original Score: 0.810\n    >>> print(\n    ...     f\"Permutation Scores: {permutation_scores.mean():.3f} +/- \"\n    ...     f\"{permutation_scores.std():.3f}\"\n    ... )\n    Permutation Scores: 0.505 +/- 0.057\n    >>> print(f\"P-value: {pvalue:.3f}\")\n    P-value: 0.010",
        "raises": "",
        "see_also": "",
        "notes": "-----\n    This function implements Test 1 in:\n\n    Ojala and Garriga. `Permutation Tests for Studying Classifier Performance\n    <http://www.jmlr.org/papers/volume11/ojala10a/ojala10a.pdf>`_. The\n    Journal of Machine Learning Research (2010) vol. 11\n\n    Examples\n    --------\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.model_selection import permutation_test_score\n    >>> X, y = make_classification(random_state=0)\n    >>> estimator = LogisticRegression()\n    >>> score, permutation_scores, pvalue = permutation_test_score(\n    ...     estimator, X, y, random_state=0\n    ... )\n    >>> print(f\"Original Score: {score:.3f}\")\n    Original Score: 0.810\n    >>> print(\n    ...     f\"Permutation Scores: {permutation_scores.mean():.3f} +/- \"\n    ...     f\"{permutation_scores.std():.3f}\"\n    ... )\n    Permutation Scores: 0.505 +/- 0.057\n    >>> print(f\"P-value: {pvalue:.3f}\")\n    P-value: 0.010",
        "examples": "--------\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.model_selection import permutation_test_score\n    >>> X, y = make_classification(random_state=0)\n    >>> estimator = LogisticRegression()\n    >>> score, permutation_scores, pvalue = permutation_test_score(\n    ...     estimator, X, y, random_state=0\n    ... )\n    >>> print(f\"Original Score: {score:.3f}\")\n    Original Score: 0.810\n    >>> print(\n    ...     f\"Permutation Scores: {permutation_scores.mean():.3f} +/- \"\n    ...     f\"{permutation_scores.std():.3f}\"\n    ... )\n    Permutation Scores: 0.505 +/- 0.057\n    >>> print(f\"P-value: {pvalue:.3f}\")\n    P-value: 0.010"
      }
    },
    {
      "name": "train_test_split",
      "signature": "train_test_split(*arrays, test_size=None, train_size=None, random_state=None, shuffle=True, stratify=None)",
      "documentation": {
        "description": "Split arrays or matrices into random train and test subsets.\n\n    Quick utility that wraps input validation,\n    ``next(ShuffleSplit().split(X, y))``, and application to input data\n    into a single call for splitting (and optionally subsampling) data into a\n    one-liner.\n\n    Read more in the :ref:`User Guide <cross_validation>`.\n\n    Parameters\n    ----------\n    *arrays : sequence of indexables with same length / shape[0]\n        Allowed inputs are lists, numpy arrays, scipy-sparse\n        matrices or pandas dataframes.\n\n    test_size : float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the proportion\n        of the dataset to include in the test split. If int, represents the\n        absolute number of test samples. If None, the value is set to the\n        complement of the train size. If ``train_size`` is also None, it will\n        be set to 0.25.\n\n    train_size : float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the\n        proportion of the dataset to include in the train split. If\n        int, represents the absolute number of train samples. If None,\n        the value is automatically set to the complement of the test size.\n\n    random_state : int, RandomState instance or None, default=None\n        Controls the shuffling applied to the data before applying the split.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    shuffle : bool, default=True\n        Whether or not to shuffle the data before splitting. If shuffle=False\n        then stratify must be None.\n\n    stratify : array-like, default=None\n        If not None, data is split in a stratified fashion, using this as\n        the class labels.\n        Read more in the :ref:`User Guide <stratification>`.\n\n    Returns\n    -------\n    splitting : list, length=2 * len(arrays)\n        List containing train-test split of inputs.\n\n        .. versionadded:: 0.16\n            If the input is sparse, the output will be a\n            ``scipy.sparse.csr_matrix``. Else, output type is the same as the\n            input type.",
        "parameters": {
          "Allowed": {
            "type": "inputs are lists, numpy arrays, scipy-sparse",
            "description": ""
          },
          "matrices": {
            "type": "or pandas dataframes.",
            "description": ""
          },
          "test_size": {
            "type": "float or int, default=None",
            "description": ""
          },
          "If": {
            "type": "the input is sparse, the output will be a",
            "description": "``scipy.sparse.csr_matrix``. Else, output type is the same as the"
          },
          "of": {
            "type": "the dataset to include in the test split. If int, represents the",
            "description": ""
          },
          "absolute": {
            "type": "number of test samples. If None, the value is set to the",
            "description": ""
          },
          "complement": {
            "type": "of the train size. If ``train_size`` is also None, it will",
            "description": ""
          },
          "be": {
            "type": "set to 0.25.",
            "description": ""
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": ""
          },
          "proportion": {
            "type": "of the dataset to include in the train split. If",
            "description": "int, represents the absolute number of train samples. If None,"
          },
          "the": {
            "type": "class labels.",
            "description": ""
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Controls": {
            "type": "the shuffling applied to the data before applying the split.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible output across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "term:`Glossary <random_state>`.",
            "description": ""
          },
          "shuffle": {
            "type": "bool, default=True",
            "description": ""
          },
          "Whether": {
            "type": "or not to shuffle the data before splitting. If shuffle=False",
            "description": ""
          },
          "then": {
            "type": "stratify must be None.",
            "description": ""
          },
          "stratify": {
            "type": "array",
            "description": "like, default=None"
          },
          "Read": {
            "type": "more in the :ref:`User Guide <stratification>`.",
            "description": "Returns\n-------"
          },
          "splitting": {
            "type": "list, length=2 * len(arrays)",
            "description": ""
          },
          "List": {
            "type": "containing train-test split of inputs.",
            "description": ".. versionadded:: 0.16"
          },
          "input": {
            "type": "type.",
            "description": "Examples\n--------\n>>> import numpy as np\n>>> from sklearn.model_selection import train_test_split\n>>> X, y = np.arange(10).reshape((5, 2)), range(5)\n>>> X\narray([[0, 1],\n[2, 3],\n[4, 5],\n[6, 7],\n[8, 9]])\n>>> list(y)\n[0, 1, 2, 3, 4]\n>>> X_train, X_test, y_train, y_test = train_test_split(\n...     X, y, test_size=0.33, random_state=42)\n...\n>>> X_train\narray([[4, 5],\n[0, 1],\n[6, 7]])\n>>> y_train\n[2, 0, 3]\n>>> X_test\narray([[2, 3],\n[8, 9]])\n>>> y_test\n[1, 4]\n>>> train_test_split(y, shuffle=False)\n[[0, 1, 2], [3, 4]]"
          }
        },
        "returns": "-------\n    splitting : list, length=2 * len(arrays)\n        List containing train-test split of inputs.\n\n        .. versionadded:: 0.16\n            If the input is sparse, the output will be a\n            ``scipy.sparse.csr_matrix``. Else, output type is the same as the\n            input type.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import train_test_split\n    >>> X, y = np.arange(10).reshape((5, 2)), range(5)\n    >>> X\n    array([[0, 1],\n           [2, 3],\n           [4, 5],\n           [6, 7],\n           [8, 9]])\n    >>> list(y)\n    [0, 1, 2, 3, 4]\n\n    >>> X_train, X_test, y_train, y_test = train_test_split(\n    ...     X, y, test_size=0.33, random_state=42)\n    ...\n    >>> X_train\n    array([[4, 5],\n           [0, 1],\n           [6, 7]])\n    >>> y_train\n    [2, 0, 3]\n    >>> X_test\n    array([[2, 3],\n           [8, 9]])\n    >>> y_test\n    [1, 4]\n\n    >>> train_test_split(y, shuffle=False)\n    [[0, 1, 2], [3, 4]]",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import train_test_split\n    >>> X, y = np.arange(10).reshape((5, 2)), range(5)\n    >>> X\n    array([[0, 1],\n           [2, 3],\n           [4, 5],\n           [6, 7],\n           [8, 9]])\n    >>> list(y)\n    [0, 1, 2, 3, 4]\n\n    >>> X_train, X_test, y_train, y_test = train_test_split(\n    ...     X, y, test_size=0.33, random_state=42)\n    ...\n    >>> X_train\n    array([[4, 5],\n           [0, 1],\n           [6, 7]])\n    >>> y_train\n    [2, 0, 3]\n    >>> X_test\n    array([[2, 3],\n           [8, 9]])\n    >>> y_test\n    [1, 4]\n\n    >>> train_test_split(y, shuffle=False)\n    [[0, 1, 2], [3, 4]]"
      }
    },
    {
      "name": "validation_curve",
      "signature": "validation_curve(estimator, X, y, *, param_name, param_range, groups=None, cv=None, scoring=None, n_jobs=None, pre_dispatch='all', verbose=0, error_score=nan, fit_params=None, params=None)",
      "documentation": {
        "description": "Validation curve.\n\n    Determine training and test scores for varying parameter values.\n\n    Compute scores for an estimator with different values of a specified\n    parameter. This is similar to grid search with one parameter. However, this\n    will also compute training scores and is merely a utility for plotting the\n    results.\n\n    Read more in the :ref:`User Guide <validation_curve>`.\n\n    Parameters\n    ----------\n    estimator : object type that implements the \"fit\" method\n        An object of that type which is cloned for each validation. It must\n        also implement \"predict\" unless `scoring` is a callable that doesn't\n        rely on \"predict\" to compute a score.\n\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        Training vector, where `n_samples` is the number of samples and\n        `n_features` is the number of features.\n\n    y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None\n        Target relative to X for classification or regression;\n        None for unsupervised learning.\n\n    param_name : str\n        Name of the parameter that will be varied.\n\n    param_range : array-like of shape (n_values,)\n        The values of the parameter that will be evaluated.\n\n    groups : array-like of shape (n_samples,), default=None\n        Group labels for the samples used while splitting the dataset into\n        train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n        instance (e.g., :class:`GroupKFold`).\n\n        .. versionchanged:: 1.6\n            ``groups`` can only be passed if metadata routing is not enabled\n            via ``sklearn.set_config(enable_metadata_routing=True)``. When routing\n            is enabled, pass ``groups`` alongside other metadata via the ``params``\n            argument instead. E.g.:\n            ``validation_curve(..., params={'groups': groups})``.\n\n    cv : int, cross-validation generator or an iterable, default=None\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - None, to use the default 5-fold cross validation,\n        - int, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For int/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value if None changed from 3-fold to 5-fold.\n\n    scoring : str or callable, default=None\n        A str (see :ref:`scoring_parameter`) or a scorer callable object / function with\n        signature ``scorer(estimator, X, y)``.\n\n    n_jobs : int, default=None\n        Number of jobs to run in parallel. Training the estimator and computing\n        the score are parallelized over the combinations of each parameter\n        value and each cross-validation split.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    pre_dispatch : int or str, default='all'\n        Number of predispatched jobs for parallel execution (default is\n        all). The option can reduce the allocated memory. The str can\n        be an expression like '2*n_jobs'.\n\n    verbose : int, default=0\n        Controls the verbosity: the higher, the more messages.\n\n    error_score : 'raise' or numeric, default=np.nan\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised.\n        If a numeric value is given, FitFailedWarning is raised.\n\n        .. versionadded:: 0.20\n\n    fit_params : dict, default=None\n        Parameters to pass to the fit method of the estimator.\n\n        .. deprecated:: 1.6\n            This parameter is deprecated and will be removed in version 1.8. Use\n            ``params`` instead.\n\n    params : dict, default=None\n        Parameters to pass to the estimator, scorer and cross-validation object.\n\n        - If `enable_metadata_routing=False` (default): Parameters directly passed to\n          the `fit` method of the estimator.\n\n        - If `enable_metadata_routing=True`: Parameters safely routed to the `fit`\n          method of the estimator, to the scorer and to the cross-validation object.\n          See :ref:`Metadata Routing User Guide <metadata_routing>` for more details.\n\n        .. versionadded:: 1.6\n\n    Returns\n    -------\n    train_scores : array of shape (n_ticks, n_cv_folds)\n        Scores on training sets.\n\n    test_scores : array of shape (n_ticks, n_cv_folds)\n        Scores on test set.\n\n    Notes\n    -----\n    See :ref:`sphx_glr_auto_examples_model_selection_plot_train_error_vs_test_error.py`",
        "parameters": {
          "estimator": {
            "type": "object type that implements the \"fit\" method",
            "description": ""
          },
          "An": {
            "type": "object of that type which is cloned for each validation. It must",
            "description": ""
          },
          "also": {
            "type": "implement \"predict\" unless `scoring` is a callable that doesn't",
            "description": ""
          },
          "rely": {
            "type": "on \"predict\" to compute a score.",
            "description": ""
          },
          "X": {
            "type": "{array",
            "description": "like, sparse matrix} of shape (n_samples, n_features)"
          },
          "Training": {
            "type": "vector, where `n_samples` is the number of samples and",
            "description": "`n_features` is the number of features."
          },
          "y": {
            "type": "array",
            "description": "like of shape (n_samples,) or (n_samples, n_outputs) or None"
          },
          "Target": {
            "type": "relative to X for classification or regression;",
            "description": ""
          },
          "None": {
            "type": "for unsupervised learning.",
            "description": ""
          },
          "param_name": {
            "type": "str",
            "description": ""
          },
          "Name": {
            "type": "of the parameter that will be varied.",
            "description": ""
          },
          "param_range": {
            "type": "array",
            "description": "like of shape (n_values,)"
          },
          "The": {
            "type": "values of the parameter that will be evaluated.",
            "description": ""
          },
          "groups": {
            "type": "array",
            "description": "like of shape (n_samples,), default=None"
          },
          "Group": {
            "type": "labels for the samples used while splitting the dataset into",
            "description": "train/test set. Only used in conjunction with a \"Group\" :term:`cv`"
          },
          "instance": {
            "type": "e.g., :class:`GroupKFold`",
            "description": ".\n.. versionchanged:: 1.6\n``groups`` can only be passed if metadata routing is not enabled"
          },
          "via": {
            "type": "``sklearn.set_config(enable_metadata_routing=True)``. When routing",
            "description": ""
          },
          "is": {
            "type": "enabled, pass ``groups`` alongside other metadata via the ``params``",
            "description": ""
          },
          "argument": {
            "type": "instead. E.g.:",
            "description": "``validation_curve(..., params={'groups': groups})``."
          },
          "cv": {
            "type": "int, cross",
            "description": "validation generator or an iterable, default=None"
          },
          "Determines": {
            "type": "the cross-validation splitting strategy.",
            "description": ""
          },
          "Possible": {
            "type": "inputs for cv are:",
            "description": "- None, to use the default 5-fold cross validation,\n- int, to specify the number of folds in a `(Stratified)KFold`,\n- :term:`CV splitter`,\n- An iterable yielding (train, test) splits as arrays of indices."
          },
          "For": {
            "type": "int/None inputs, if the estimator is a classifier and ``y`` is",
            "description": ""
          },
          "either": {
            "type": "binary or multiclass, :class:`StratifiedKFold` is used. In all",
            "description": ""
          },
          "other": {
            "type": "cases, :class:`KFold` is used. These splitters are instantiated",
            "description": ""
          },
          "with": {
            "type": "`shuffle=False` so the splits will be the same across calls.",
            "description": ""
          },
          "Refer": {
            "type": "ref:`User Guide <cross_validation>` for the various",
            "description": "cross-validation strategies that can be used here.\n.. versionchanged:: 0.22\n``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "scoring": {
            "type": "str or callable, default=None",
            "description": ""
          },
          "A": {
            "type": "str (see :ref:`scoring_parameter`) or a scorer callable object / function with",
            "description": ""
          },
          "signature": {
            "type": "``scorer(estimator, X, y)``.",
            "description": ""
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": ""
          },
          "Number": {
            "type": "of predispatched jobs for parallel execution (default is",
            "description": "all). The option can reduce the allocated memory. The str can"
          },
          "the": {
            "type": "score are parallelized over the combinations of each parameter",
            "description": ""
          },
          "value": {
            "type": "and each cross-validation split.",
            "description": "``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n``-1`` means using all processors. See :term:`Glossary <n_jobs>`"
          },
          "for": {
            "type": "more details.",
            "description": ""
          },
          "pre_dispatch": {
            "type": "int or str, default='all'",
            "description": ""
          },
          "be": {
            "type": "an expression like '2*n_jobs'.",
            "description": ""
          },
          "verbose": {
            "type": "int, default=0",
            "description": ""
          },
          "Controls": {
            "type": "the verbosity: the higher, the more messages.",
            "description": ""
          },
          "error_score": {
            "type": "'raise' or numeric, default=np.nan",
            "description": ""
          },
          "Value": {
            "type": "to assign to the score if an error occurs in estimator fitting.",
            "description": ""
          },
          "If": {
            "type": "a numeric value is given, FitFailedWarning is raised.",
            "description": ".. versionadded:: 0.20"
          },
          "fit_params": {
            "type": "dict, default=None",
            "description": ""
          }
        },
        "returns": "-------\n    train_scores : array of shape (n_ticks, n_cv_folds)\n        Scores on training sets.\n\n    test_scores : array of shape (n_ticks, n_cv_folds)\n        Scores on test set.\n\n    Notes\n    -----\n    See :ref:`sphx_glr_auto_examples_model_selection_plot_train_error_vs_test_error.py`\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.model_selection import validation_curve\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> X, y = make_classification(n_samples=1_000, random_state=0)\n    >>> logistic_regression = LogisticRegression()\n    >>> param_name, param_range = \"C\", np.logspace(-8, 3, 10)\n    >>> train_scores, test_scores = validation_curve(\n    ...     logistic_regression, X, y, param_name=param_name, param_range=param_range\n    ... )\n    >>> print(f\"The average train accuracy is {train_scores.mean():.2f}\")\n    The average train accuracy is 0.81\n    >>> print(f\"The average test accuracy is {test_scores.mean():.2f}\")\n    The average test accuracy is 0.81",
        "raises": "",
        "see_also": "",
        "notes": "-----\n    See :ref:`sphx_glr_auto_examples_model_selection_plot_train_error_vs_test_error.py`\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.model_selection import validation_curve\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> X, y = make_classification(n_samples=1_000, random_state=0)\n    >>> logistic_regression = LogisticRegression()\n    >>> param_name, param_range = \"C\", np.logspace(-8, 3, 10)\n    >>> train_scores, test_scores = validation_curve(\n    ...     logistic_regression, X, y, param_name=param_name, param_range=param_range\n    ... )\n    >>> print(f\"The average train accuracy is {train_scores.mean():.2f}\")\n    The average train accuracy is 0.81\n    >>> print(f\"The average test accuracy is {test_scores.mean():.2f}\")\n    The average test accuracy is 0.81",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.model_selection import validation_curve\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> X, y = make_classification(n_samples=1_000, random_state=0)\n    >>> logistic_regression = LogisticRegression()\n    >>> param_name, param_range = \"C\", np.logspace(-8, 3, 10)\n    >>> train_scores, test_scores = validation_curve(\n    ...     logistic_regression, X, y, param_name=param_name, param_range=param_range\n    ... )\n    >>> print(f\"The average train accuracy is {train_scores.mean():.2f}\")\n    The average train accuracy is 0.81\n    >>> print(f\"The average test accuracy is {test_scores.mean():.2f}\")\n    The average test accuracy is 0.81"
      }
    }
  ],
  "classes": [
    {
      "name": "BaseCrossValidator",
      "documentation": {
        "description": "Base class for all cross-validators.\n\n    Implementations must define `_iter_test_masks` or `_iter_test_indices`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": ""
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "Group": {
                "type": "labels for the samples used while splitting the dataset into",
                "description": "train/test set.\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "BaseShuffleSplit",
      "documentation": {
        "description": "Base class for *ShuffleSplit.",
        "parameters": {
          "n_splits": {
            "type": "int, default=10",
            "description": ""
          },
          "Number": {
            "type": "of re-shuffling & splitting iterations.",
            "description": ""
          },
          "test_size": {
            "type": "float or int, default=None",
            "description": ""
          },
          "If": {
            "type": "float, should be between 0.0 and 1.0 and represent the",
            "description": ""
          },
          "of": {
            "type": "the dataset to include in the test split. If int, represents the",
            "description": ""
          },
          "absolute": {
            "type": "number of test samples. If None, the value is set to the",
            "description": ""
          },
          "complement": {
            "type": "of the train size. If ``train_size`` is also None, it will",
            "description": ""
          },
          "be": {
            "type": "set to 0.1.",
            "description": ""
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": ""
          },
          "proportion": {
            "type": "of the dataset to include in the train split. If",
            "description": "int, represents the absolute number of train samples. If None,"
          },
          "the": {
            "type": "value is automatically set to the complement of the test size.",
            "description": ""
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Controls": {
            "type": "the randomness of the training and testing indices produced.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible output across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "term:`Glossary <random_state>`.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n\n        y : object\n            Always ignored, exists for compatibility.\n\n        groups : object\n            Always ignored, exists for compatibility.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Training data, where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n\n        y : array-like of shape (n_samples,)\n            The target variable for supervised learning problems.\n\n        groups : array-like of shape (n_samples,), default=None\n            Group labels for the samples used while splitting the dataset into\n            train/test set.\n\n        Yields\n        ------\n        train : ndarray\n            The training set indices for that split.\n\n        test : ndarray\n            The testing set indices for that split.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": "Notes\n-----"
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "Group": {
                "type": "labels for the samples used while splitting the dataset into",
                "description": "train/test set.\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              },
              "Randomized": {
                "type": "CV splitters may return different results for each call of",
                "description": "split. You can make the results identical by setting `random_state`"
              },
              "to": {
                "type": "an integer.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\n        Randomized CV splitters may return different results for each call of\n        split. You can make the results identical by setting `random_state`\n        to an integer.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "FixedThresholdClassifier",
      "documentation": {
        "description": "Binary classifier that manually sets the decision threshold.\n\n    This classifier allows to change the default decision threshold used for\n    converting posterior probability estimates (i.e. output of `predict_proba`) or\n    decision scores (i.e. output of `decision_function`) into a class label.\n\n    Here, the threshold is not optimized and is set to a constant value.\n\n    Read more in the :ref:`User Guide <FixedThresholdClassifier>`.\n\n    .. versionadded:: 1.5\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        The binary classifier, fitted or not, for which we want to optimize\n        the decision threshold used during `predict`.\n\n    threshold : {\"auto\"} or float, default=\"auto\"\n        The decision threshold to use when converting posterior probability estimates\n        (i.e. output of `predict_proba`) or decision scores (i.e. output of\n        `decision_function`) into a class label. When `\"auto\"`, the threshold is set\n        to 0.5 if `predict_proba` is used as `response_method`, otherwise it is set to\n        0 (i.e. the default threshold for `decision_function`).\n\n    pos_label : int, float, bool or str, default=None\n        The label of the positive class. Used to process the output of the\n        `response_method` method. When `pos_label=None`, if `y_true` is in `{-1, 1}` or\n        `{0, 1}`, `pos_label` is set to 1, otherwise an error will be raised.\n\n    response_method : {\"auto\", \"decision_function\", \"predict_proba\"}, default=\"auto\"\n        Methods by the classifier `estimator` corresponding to the\n        decision function for which we want to find a threshold. It can be:\n\n        * if `\"auto\"`, it will try to invoke `\"predict_proba\"` or `\"decision_function\"`\n          in that order.\n        * otherwise, one of `\"predict_proba\"` or `\"decision_function\"`.\n          If the method is not implemented by the classifier, it will raise an\n          error.\n\n    Attributes\n    ----------\n    estimator_ : estimator instance\n        The fitted classifier used when predicting.\n\n    classes_ : ndarray of shape (n_classes,)\n        The class labels.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`. Only defined if the\n        underlying estimator exposes such an attribute when fit.\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Only defined if the\n        underlying estimator exposes such an attribute when fit.\n\n    See Also\n    --------\n    sklearn.model_selection.TunedThresholdClassifierCV : Classifier that post-tunes\n        the decision threshold based on some metrics and using cross-validation.\n    sklearn.calibration.CalibratedClassifierCV : Estimator that calibrates\n        probabilities.",
        "parameters": {
          "estimator": {
            "type": "estimator instance",
            "description": ""
          },
          "The": {
            "type": "class labels.",
            "description": ""
          },
          "the": {
            "type": "decision threshold based on some metrics and using cross-validation.",
            "description": "sklearn.calibration.CalibratedClassifierCV : Estimator that calibrates\nprobabilities.\nExamples\n--------\n>>> from sklearn.datasets import make_classification\n>>> from sklearn.linear_model import LogisticRegression\n>>> from sklearn.metrics import confusion_matrix\n>>> from sklearn.model_selection import FixedThresholdClassifier, train_test_split\n>>> X, y = make_classification(\n...     n_samples=1_000, weights=[0.9, 0.1], class_sep=0.8, random_state=42\n... )\n>>> X_train, X_test, y_train, y_test = train_test_split(\n...     X, y, stratify=y, random_state=42\n... )\n>>> classifier = LogisticRegression(random_state=0).fit(X_train, y_train)\n>>> print(confusion_matrix(y_test, classifier.predict(X_test)))\n[[217   7]\n[ 19   7]]\n>>> classifier_other_threshold = FixedThresholdClassifier(\n...     classifier, threshold=0.1, response_method=\"predict_proba\"\n... ).fit(X_train, y_train)\n>>> print(confusion_matrix(y_test, classifier_other_threshold.predict(X_test)))\n[[184  40]\n[  6  20]]"
          },
          "threshold": {
            "type": "{\"auto\"} or float, default=\"auto\"",
            "description": ""
          },
          "to": {
            "type": "0.5 if `predict_proba` is used as `response_method`, otherwise it is set to",
            "description": ""
          },
          "0": {
            "type": "i.e. the default threshold for `decision_function`",
            "description": "."
          },
          "pos_label": {
            "type": "int, float, bool or str, default=None",
            "description": ""
          },
          "response_method": {
            "type": "{\"auto\", \"decision_function\", \"predict_proba\"}, default=\"auto\"",
            "description": ""
          },
          "Methods": {
            "type": "by the classifier `estimator` corresponding to the",
            "description": ""
          },
          "decision": {
            "type": "function for which we want to find a threshold. It can be:",
            "description": "* if `\"auto\"`, it will try to invoke `\"predict_proba\"` or `\"decision_function\"`"
          },
          "in": {
            "type": "that order.",
            "description": "* otherwise, one of `\"predict_proba\"` or `\"decision_function\"`."
          },
          "If": {
            "type": "the method is not implemented by the classifier, it will raise an",
            "description": "error.\nAttributes\n----------"
          },
          "estimator_": {
            "type": "estimator instance",
            "description": ""
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`. Only defined if the",
            "description": ""
          },
          "underlying": {
            "type": "estimator exposes such an attribute when fit.",
            "description": ""
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Only defined if the",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------\nsklearn.model_selection.TunedThresholdClassifierCV : Classifier that post-tunes"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    sklearn.model_selection.TunedThresholdClassifierCV : Classifier that post-tunes\n        the decision threshold based on some metrics and using cross-validation.\n    sklearn.calibration.CalibratedClassifierCV : Estimator that calibrates\n        probabilities.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.metrics import confusion_matrix\n    >>> from sklearn.model_selection import FixedThresholdClassifier, train_test_split\n    >>> X, y = make_classification(\n    ...     n_samples=1_000, weights=[0.9, 0.1], class_sep=0.8, random_state=42\n    ... )\n    >>> X_train, X_test, y_train, y_test = train_test_split(\n    ...     X, y, stratify=y, random_state=42\n    ... )\n    >>> classifier = LogisticRegression(random_state=0).fit(X_train, y_train)\n    >>> print(confusion_matrix(y_test, classifier.predict(X_test)))\n    [[217   7]\n     [ 19   7]]\n    >>> classifier_other_threshold = FixedThresholdClassifier(\n    ...     classifier, threshold=0.1, response_method=\"predict_proba\"\n    ... ).fit(X_train, y_train)\n    >>> print(confusion_matrix(y_test, classifier_other_threshold.predict(X_test)))\n    [[184  40]\n     [  6  20]]",
        "notes": "",
        "examples": "--------\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.metrics import confusion_matrix\n    >>> from sklearn.model_selection import FixedThresholdClassifier, train_test_split\n    >>> X, y = make_classification(\n    ...     n_samples=1_000, weights=[0.9, 0.1], class_sep=0.8, random_state=42\n    ... )\n    >>> X_train, X_test, y_train, y_test = train_test_split(\n    ...     X, y, stratify=y, random_state=42\n    ... )\n    >>> classifier = LogisticRegression(random_state=0).fit(X_train, y_train)\n    >>> print(confusion_matrix(y_test, classifier.predict(X_test)))\n    [[217   7]\n     [ 19   7]]\n    >>> classifier_other_threshold = FixedThresholdClassifier(\n    ...     classifier, threshold=0.1, response_method=\"predict_proba\"\n    ... ).fit(X_train, y_train)\n    >>> print(confusion_matrix(y_test, classifier_other_threshold.predict(X_test)))\n    [[184  40]\n     [  6  20]]"
      },
      "methods": [
        {
          "name": "decision_function",
          "signature": "decision_function(self, X)",
          "documentation": {
            "description": "Decision function for samples in `X` using the fitted estimator.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Training vectors, where `n_samples` is the number of samples and\n            `n_features` is the number of features.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "vectors, where `n_samples` is the number of samples and",
                "description": "`n_features` is the number of features.\nReturns\n-------"
              },
              "decisions": {
                "type": "ndarray of shape (n_samples,)",
                "description": ""
              },
              "The": {
                "type": "decision function computed the fitted estimator.",
                "description": ""
              }
            },
            "returns": "-------\n        decisions : ndarray of shape (n_samples,)\n            The decision function computed the fitted estimator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit",
          "signature": "fit(self, X, y, **params)",
          "documentation": {
            "description": "Fit the classifier.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Training data.\n\n        y : array-like of shape (n_samples,)\n            Target values.\n\n        **params : dict\n            Parameters to pass to the `fit` method of the underlying\n            classifier.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Target": {
                "type": "values.",
                "description": "**params : dict"
              }
            },
            "returns": "-------\n        self : object",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRouter\n            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict",
          "signature": "predict(self, X)",
          "documentation": {
            "description": "Predict the target of new samples.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The samples, as accepted by `estimator.predict`.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "predicted class.",
                "description": ""
              },
              "class_labels": {
                "type": "ndarray of shape (n_samples,)",
                "description": ""
              }
            },
            "returns": "-------\n        class_labels : ndarray of shape (n_samples,)\n            The predicted class.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_log_proba",
          "signature": "predict_log_proba(self, X)",
          "documentation": {
            "description": "Predict logarithm class probabilities for `X` using the fitted estimator.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Training vectors, where `n_samples` is the number of samples and\n            `n_features` is the number of features.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "vectors, where `n_samples` is the number of samples and",
                "description": "`n_features` is the number of features.\nReturns\n-------"
              },
              "log_probabilities": {
                "type": "ndarray of shape (n_samples, n_classes)",
                "description": ""
              },
              "The": {
                "type": "logarithm class probabilities of the input samples.",
                "description": ""
              }
            },
            "returns": "-------\n        log_probabilities : ndarray of shape (n_samples, n_classes)\n            The logarithm class probabilities of the input samples.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_proba",
          "signature": "predict_proba(self, X)",
          "documentation": {
            "description": "Predict class probabilities for `X` using the fitted estimator.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Training vectors, where `n_samples` is the number of samples and\n            `n_features` is the number of features.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "vectors, where `n_samples` is the number of samples and",
                "description": "`n_features` is the number of features.\nReturns\n-------"
              },
              "probabilities": {
                "type": "ndarray of shape (n_samples, n_classes)",
                "description": ""
              },
              "The": {
                "type": "class probabilities of the input samples.",
                "description": ""
              }
            },
            "returns": "-------\n        probabilities : ndarray of shape (n_samples, n_classes)\n            The class probabilities of the input samples.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score",
          "signature": "score(self, X, y, sample_weight=None)",
          "documentation": {
            "description": "",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Test": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs)"
              },
              "True": {
                "type": "labels for `X`.",
                "description": ""
              },
              "sample_weight": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "Sample": {
                "type": "weights.",
                "description": "Returns\n-------"
              },
              "score": {
                "type": "float",
                "description": ""
              },
              "Mean": {
                "type": "accuracy of ``self.predict(X)`` w.r.t. `y`.",
                "description": ""
              }
            },
            "returns": "the mean accuracy on the given test data and labels.\n\n        In multi-label classification, this is the subset accuracy\n        which is a harsh metric since you require for each sample that\n        each label set be correctly predicted.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Test samples.\n\n        y : array-like of shape (n_samples,) or (n_samples, n_outputs)\n            True labels for `X`.\n\n        sample_weight : array-like of shape (n_samples,), default=None\n            Sample weights.\n\n        Returns\n        -------\n        score : float\n            Mean accuracy of ``self.predict(X)`` w.r.t. `y`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_score_request",
          "signature": "set_score_request(self: sklearn.model_selection._classification_threshold.FixedThresholdClassifier, *, sample_weight: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._classification_threshold.FixedThresholdClassifier",
          "documentation": {
            "description": "Request metadata passed to the ``score`` method.",
            "parameters": {
              "sample_weight": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``sample_weight`` parameter in ``score``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``score`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``score``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        sample_weight : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``sample_weight`` parameter in ``score``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "GridSearchCV",
      "documentation": {
        "description": "Exhaustive search over specified parameter values for an estimator.\n\n    Important members are fit, predict.\n\n    GridSearchCV implements a \"fit\" and a \"score\" method.\n    It also implements \"score_samples\", \"predict\", \"predict_proba\",\n    \"decision_function\", \"transform\" and \"inverse_transform\" if they are\n    implemented in the estimator used.\n\n    The parameters of the estimator used to apply these methods are optimized\n    by cross-validated grid-search over a parameter grid.\n\n    Read more in the :ref:`User Guide <grid_search>`.\n\n    Parameters\n    ----------\n    estimator : estimator object\n        This is assumed to implement the scikit-learn estimator interface.\n        Either estimator needs to provide a ``score`` function,\n        or ``scoring`` must be passed.\n\n    param_grid : dict or list of dictionaries\n        Dictionary with parameters names (`str`) as keys and lists of\n        parameter settings to try as values, or a list of such\n        dictionaries, in which case the grids spanned by each dictionary\n        in the list are explored. This enables searching over any sequence\n        of parameter settings.\n\n    scoring : str, callable, list, tuple or dict, default=None\n        Strategy to evaluate the performance of the cross-validated model on\n        the test set.\n\n        If `scoring` represents a single score, one can use:\n\n        - a single string (see :ref:`scoring_parameter`);\n        - a callable (see :ref:`scoring_callable`) that returns a single value.\n\n        If `scoring` represents multiple scores, one can use:\n\n        - a list or tuple of unique strings;\n        - a callable returning a dictionary where the keys are the metric\n          names and the values are the metric scores;\n        - a dictionary with metric names as keys and callables as values.\n\n        See :ref:`multimetric_grid_search` for an example.\n\n    n_jobs : int, default=None\n        Number of jobs to run in parallel.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n        .. versionchanged:: v0.20\n           `n_jobs` default changed from 1 to None\n\n    refit : bool, str, or callable, default=True\n        Refit an estimator using the best found parameters on the whole\n        dataset.\n\n        For multiple metric evaluation, this needs to be a `str` denoting the\n        scorer that would be used to find the best parameters for refitting\n        the estimator at the end.\n\n        Where there are considerations other than maximum score in\n        choosing a best estimator, ``refit`` can be set to a function which\n        returns the selected ``best_index_`` given ``cv_results_``. In that\n        case, the ``best_estimator_`` and ``best_params_`` will be set\n        according to the returned ``best_index_`` while the ``best_score_``\n        attribute will not be available.\n\n        The refitted estimator is made available at the ``best_estimator_``\n        attribute and permits using ``predict`` directly on this\n        ``GridSearchCV`` instance.\n\n        Also for multiple metric evaluation, the attributes ``best_index_``,\n        ``best_score_`` and ``best_params_`` will only be available if\n        ``refit`` is set and all of them will be determined w.r.t this specific\n        scorer.\n\n        See ``scoring`` parameter to know more about multiple metric\n        evaluation.\n\n        See :ref:`sphx_glr_auto_examples_model_selection_plot_grid_search_digits.py`\n        to see how to design a custom selection strategy using a callable\n        via `refit`.\n\n        .. versionchanged:: 0.20\n            Support for callable added.\n\n    cv : int, cross-validation generator or an iterable, default=None\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - None, to use the default 5-fold cross validation,\n        - integer, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For integer/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value if None changed from 3-fold to 5-fold.\n\n    verbose : int\n        Controls the verbosity: the higher, the more messages.\n\n        - >1 : the computation time for each fold and parameter candidate is\n          displayed;\n        - >2 : the score is also displayed;\n        - >3 : the fold and candidate parameter indexes are also displayed\n          together with the starting time of the computation.\n\n    pre_dispatch : int, or str, default='2*n_jobs'\n        Controls the number of jobs that get dispatched during parallel\n        execution. Reducing this number can be useful to avoid an\n        explosion of memory consumption when more jobs get dispatched\n        than CPUs can process. This parameter can be:\n\n        - None, in which case all the jobs are immediately created and spawned. Use\n          this for lightweight and fast-running jobs, to avoid delays due to on-demand\n          spawning of the jobs\n        - An int, giving the exact number of total jobs that are spawned\n        - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'\n\n    error_score : 'raise' or numeric, default=np.nan\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised. If a numeric value is given,\n        FitFailedWarning is raised. This parameter does not affect the refit\n        step, which will always raise the error.\n\n    return_train_score : bool, default=False\n        If ``False``, the ``cv_results_`` attribute will not include training\n        scores.\n        Computing training scores is used to get insights on how different\n        parameter settings impact the overfitting/underfitting trade-off.\n        However computing the scores on the training set can be computationally\n        expensive and is not strictly required to select the parameters that\n        yield the best generalization performance.\n\n        .. versionadded:: 0.19\n\n        .. versionchanged:: 0.21\n            Default value was changed from ``True`` to ``False``\n\n    Attributes\n    ----------\n    cv_results_ : dict of numpy (masked) ndarrays\n        A dict with keys as column headers and values as columns, that can be\n        imported into a pandas ``DataFrame``.\n\n        For instance the below given table\n\n        +------------+-----------+------------+-----------------+---+---------+\n        |param_kernel|param_gamma|param_degree|split0_test_score|...|rank_t...|\n        +============+===========+============+=================+===+=========+\n        |  'poly'    |     --    |      2     |       0.80      |...|    2    |\n        +------------+-----------+------------+-----------------+---+---------+\n        |  'poly'    |     --    |      3     |       0.70      |...|    4    |\n        +------------+-----------+------------+-----------------+---+---------+\n        |  'rbf'     |     0.1   |     --     |       0.80      |...|    3    |\n        +------------+-----------+------------+-----------------+---+---------+\n        |  'rbf'     |     0.2   |     --     |       0.93      |...|    1    |\n        +------------+-----------+------------+-----------------+---+---------+\n\n        will be represented by a ``cv_results_`` dict of::\n\n            {\n            'param_kernel': masked_array(data = ['poly', 'poly', 'rbf', 'rbf'],\n                                         mask = [False False False False]...)\n            'param_gamma': masked_array(data = [-- -- 0.1 0.2],\n                                        mask = [ True  True False False]...),\n            'param_degree': masked_array(data = [2.0 3.0 -- --],\n                                         mask = [False False  True  True]...),\n            'split0_test_score'  : [0.80, 0.70, 0.80, 0.93],\n            'split1_test_score'  : [0.82, 0.50, 0.70, 0.78],\n            'mean_test_score'    : [0.81, 0.60, 0.75, 0.85],\n            'std_test_score'     : [0.01, 0.10, 0.05, 0.08],\n            'rank_test_score'    : [2, 4, 3, 1],\n            'split0_train_score' : [0.80, 0.92, 0.70, 0.93],\n            'split1_train_score' : [0.82, 0.55, 0.70, 0.87],\n            'mean_train_score'   : [0.81, 0.74, 0.70, 0.90],\n            'std_train_score'    : [0.01, 0.19, 0.00, 0.03],\n            'mean_fit_time'      : [0.73, 0.63, 0.43, 0.49],\n            'std_fit_time'       : [0.01, 0.02, 0.01, 0.01],\n            'mean_score_time'    : [0.01, 0.06, 0.04, 0.04],\n            'std_score_time'     : [0.00, 0.00, 0.00, 0.01],\n            'params'             : [{'kernel': 'poly', 'degree': 2}, ...],\n            }\n\n        NOTE\n\n        The key ``'params'`` is used to store a list of parameter\n        settings dicts for all the parameter candidates.\n\n        The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and\n        ``std_score_time`` are all in seconds.\n\n        For multi-metric evaluation, the scores for all the scorers are\n        available in the ``cv_results_`` dict at the keys ending with that\n        scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\n        above. ('split0_test_precision', 'mean_train_precision' etc.)\n\n    best_estimator_ : estimator\n        Estimator that was chosen by the search, i.e. estimator\n        which gave highest score (or smallest loss if specified)\n        on the left out data. Not available if ``refit=False``.\n\n        See ``refit`` parameter for more information on allowed values.\n\n    best_score_ : float\n        Mean cross-validated score of the best_estimator\n\n        For multi-metric evaluation, this is present only if ``refit`` is\n        specified.\n\n        This attribute is not available if ``refit`` is a function.\n\n    best_params_ : dict\n        Parameter setting that gave the best results on the hold out data.\n\n        For multi-metric evaluation, this is present only if ``refit`` is\n        specified.\n\n    best_index_ : int\n        The index (of the ``cv_results_`` arrays) which corresponds to the best\n        candidate parameter setting.\n\n        The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n        the parameter setting for the best model, that gives the highest\n        mean score (``search.best_score_``).\n\n        For multi-metric evaluation, this is present only if ``refit`` is\n        specified.\n\n    scorer_ : function or a dict\n        Scorer function used on the held out data to choose the best\n        parameters for the model.\n\n        For multi-metric evaluation, this attribute holds the validated\n        ``scoring`` dict which maps the scorer key to the scorer callable.\n\n    n_splits_ : int\n        The number of cross-validation splits (folds/iterations).\n\n    refit_time_ : float\n        Seconds used for refitting the best model on the whole dataset.\n\n        This is present only if ``refit`` is not False.\n\n        .. versionadded:: 0.20\n\n    multimetric_ : bool\n        Whether or not the scorers compute several metrics.\n\n    classes_ : ndarray of shape (n_classes,)\n        The classes labels. This is present only if ``refit`` is specified and\n        the underlying estimator is a classifier.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `n_features_in_` when fit.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `feature_names_in_` when fit.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    ParameterGrid : Generates all the combinations of a hyperparameter grid.\n    train_test_split : Utility function to split the data into a development\n        set usable for fitting a GridSearchCV instance and an evaluation set\n        for its final evaluation.\n    sklearn.metrics.make_scorer : Make a scorer from a performance metric or\n        loss function.\n\n    Notes\n    -----\n    The parameters selected are those that maximize the score of the left out\n    data, unless an explicit score is passed in which case it is used instead.\n\n    If `n_jobs` was set to a value higher than one, the data is copied for each\n    point in the grid (and not `n_jobs` times). This is done for efficiency\n    reasons if individual jobs take very little time, but may raise errors if\n    the dataset is large and not enough memory is available.  A workaround in\n    this case is to set `pre_dispatch`. Then, the memory is copied only\n    `pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\n    n_jobs`.",
        "parameters": {
          "estimator": {
            "type": "estimator object",
            "description": ""
          },
          "This": {
            "type": "attribute is not available if ``refit`` is a function.",
            "description": ""
          },
          "Either": {
            "type": "estimator needs to provide a ``score`` function,",
            "description": ""
          },
          "or": {
            "type": "``scoring`` must be passed.",
            "description": ""
          },
          "param_grid": {
            "type": "dict or list of dictionaries",
            "description": ""
          },
          "Dictionary": {
            "type": "with parameters names (`str`) as keys and lists of",
            "description": ""
          },
          "parameter": {
            "type": "settings impact the overfitting/underfitting trade-off.",
            "description": ""
          },
          "in": {
            "type": "the list are explored. This enables searching over any sequence",
            "description": ""
          },
          "of": {
            "type": "parameter settings.",
            "description": ""
          },
          "scoring": {
            "type": "str, callable, list, tuple or dict, default=None",
            "description": ""
          },
          "Strategy": {
            "type": "to evaluate the performance of the cross-validated model on",
            "description": ""
          },
          "the": {
            "type": "parameter setting for the best model, that gives the highest",
            "description": ""
          },
          "If": {
            "type": "``False``, the ``cv_results_`` attribute will not include training",
            "description": "scores."
          },
          "names": {
            "type": "and the values are the metric scores;",
            "description": "- a dictionary with metric names as keys and callables as values."
          },
          "See": {
            "type": "``refit`` parameter for more information on allowed values.",
            "description": ""
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": ""
          },
          "Number": {
            "type": "of jobs to run in parallel.",
            "description": "``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n``-1`` means using all processors. See :term:`Glossary <n_jobs>`"
          },
          "for": {
            "type": "more details.",
            "description": ".. versionchanged:: v0.20\n`n_jobs` default changed from 1 to None"
          },
          "refit": {
            "type": "bool, str, or callable, default=True",
            "description": ""
          },
          "Refit": {
            "type": "an estimator using the best found parameters on the whole",
            "description": "dataset."
          },
          "For": {
            "type": "multi-metric evaluation, this is present only if ``refit`` is",
            "description": "specified."
          },
          "scorer": {
            "type": "that would be used to find the best parameters for refitting",
            "description": ""
          },
          "Where": {
            "type": "there are considerations other than maximum score in",
            "description": ""
          },
          "choosing": {
            "type": "a best estimator, ``refit`` can be set to a function which",
            "description": ""
          },
          "returns": {
            "type": "the selected ``best_index_`` given ``cv_results_``. In that",
            "description": "case, the ``best_estimator_`` and ``best_params_`` will be set"
          },
          "according": {
            "type": "to the returned ``best_index_`` while the ``best_score_``",
            "description": ""
          },
          "attribute": {
            "type": "and permits using ``predict`` directly on this",
            "description": "``GridSearchCV`` instance."
          },
          "The": {
            "type": "dict at ``search.cv_results_['params'][search.best_index_]`` gives",
            "description": ""
          },
          "Also": {
            "type": "for multiple metric evaluation, the attributes ``best_index_``,",
            "description": "``best_score_`` and ``best_params_`` will only be available if\n``refit`` is set and all of them will be determined w.r.t this specific\nscorer."
          },
          "to": {
            "type": "see how to design a custom selection strategy using a callable",
            "description": ""
          },
          "via": {
            "type": "`refit`.",
            "description": ".. versionchanged:: 0.20"
          },
          "Support": {
            "type": "for callable added.",
            "description": ""
          },
          "cv": {
            "type": "int, cross",
            "description": "validation generator or an iterable, default=None"
          },
          "Determines": {
            "type": "the cross-validation splitting strategy.",
            "description": ""
          },
          "Possible": {
            "type": "inputs for cv are:",
            "description": "- None, to use the default 5-fold cross validation,\n- integer, to specify the number of folds in a `(Stratified)KFold`,\n- :term:`CV splitter`,\n- An iterable yielding (train, test) splits as arrays of indices."
          },
          "either": {
            "type": "binary or multiclass, :class:`StratifiedKFold` is used. In all",
            "description": ""
          },
          "other": {
            "type": "cases, :class:`KFold` is used. These splitters are instantiated",
            "description": ""
          },
          "with": {
            "type": "`shuffle=False` so the splits will be the same across calls.",
            "description": ""
          },
          "Refer": {
            "type": "ref:`User Guide <cross_validation>` for the various",
            "description": "cross-validation strategies that can be used here.\n.. versionchanged:: 0.22\n``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "verbose": {
            "type": "int",
            "description": ""
          },
          "Controls": {
            "type": "the number of jobs that get dispatched during parallel",
            "description": "execution. Reducing this number can be useful to avoid an"
          },
          "together": {
            "type": "with the starting time of the computation.",
            "description": ""
          },
          "pre_dispatch": {
            "type": "int, or str, default='2*n_jobs'",
            "description": ""
          },
          "explosion": {
            "type": "of memory consumption when more jobs get dispatched",
            "description": ""
          },
          "than": {
            "type": "CPUs can process. This parameter can be:",
            "description": "- None, in which case all the jobs are immediately created and spawned. Use"
          },
          "this": {
            "type": "for lightweight and fast-running jobs, to avoid delays due to on-demand",
            "description": ""
          },
          "spawning": {
            "type": "of the jobs",
            "description": "- An int, giving the exact number of total jobs that are spawned\n- A str, giving an expression as a function of n_jobs, as in '2*n_jobs'"
          },
          "error_score": {
            "type": "'raise' or numeric, default=np.nan",
            "description": ""
          },
          "Value": {
            "type": "to assign to the score if an error occurs in estimator fitting.",
            "description": ""
          },
          "FitFailedWarning": {
            "type": "is raised. This parameter does not affect the refit",
            "description": "step, which will always raise the error."
          },
          "return_train_score": {
            "type": "bool, default=False",
            "description": ""
          },
          "Computing": {
            "type": "training scores is used to get insights on how different",
            "description": ""
          },
          "However": {
            "type": "computing the scores on the training set can be computationally",
            "description": ""
          },
          "expensive": {
            "type": "and is not strictly required to select the parameters that",
            "description": ""
          },
          "yield": {
            "type": "the best generalization performance.",
            "description": ".. versionadded:: 0.19\n.. versionchanged:: 0.21"
          },
          "Default": {
            "type": "value was changed from ``True`` to ``False``",
            "description": "Attributes\n----------"
          },
          "cv_results_": {
            "type": "dict of numpy (masked) ndarrays",
            "description": ""
          },
          "A": {
            "type": "dict with keys as column headers and values as columns, that can be",
            "description": ""
          },
          "imported": {
            "type": "into a pandas ``DataFrame``.",
            "description": ""
          },
          "will": {
            "type": "be represented by a ``cv_results_`` dict of::",
            "description": "{\n'param_kernel': masked_array(data = ['poly', 'poly', 'rbf', 'rbf'],"
          },
          "mask": {
            "type": "= [False False  True  True]...),",
            "description": "'split0_test_score'  : [0.80, 0.70, 0.80, 0.93],\n'split1_test_score'  : [0.82, 0.50, 0.70, 0.78],\n'mean_test_score'    : [0.81, 0.60, 0.75, 0.85],\n'std_test_score'     : [0.01, 0.10, 0.05, 0.08],\n'rank_test_score'    : [2, 4, 3, 1],\n'split0_train_score' : [0.80, 0.92, 0.70, 0.93],\n'split1_train_score' : [0.82, 0.55, 0.70, 0.87],\n'mean_train_score'   : [0.81, 0.74, 0.70, 0.90],\n'std_train_score'    : [0.01, 0.19, 0.00, 0.03],\n'mean_fit_time'      : [0.73, 0.63, 0.43, 0.49],\n'std_fit_time'       : [0.01, 0.02, 0.01, 0.01],\n'mean_score_time'    : [0.01, 0.06, 0.04, 0.04],\n'std_score_time'     : [0.00, 0.00, 0.00, 0.01],\n'params'             : [{'kernel': 'poly', 'degree': 2}, ...],\n}\nNOTE"
          },
          "settings": {
            "type": "dicts for all the parameter candidates.",
            "description": ""
          },
          "available": {
            "type": "in the ``cv_results_`` dict at the keys ending with that",
            "description": "scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\nabove. ('split0_test_precision', 'mean_train_precision' etc.)"
          },
          "best_estimator_": {
            "type": "estimator",
            "description": ""
          },
          "Estimator": {
            "type": "that was chosen by the search, i.e. estimator",
            "description": ""
          },
          "which": {
            "type": "gave highest score (or smallest loss if specified)",
            "description": ""
          },
          "on": {
            "type": "the left out data. Not available if ``refit=False``.",
            "description": ""
          },
          "best_score_": {
            "type": "float",
            "description": ""
          },
          "Mean": {
            "type": "cross-validated score of the best_estimator",
            "description": ""
          },
          "best_params_": {
            "type": "dict",
            "description": ""
          },
          "Parameter": {
            "type": "setting that gave the best results on the hold out data.",
            "description": ""
          },
          "best_index_": {
            "type": "int",
            "description": ""
          },
          "candidate": {
            "type": "parameter setting.",
            "description": ""
          },
          "mean": {
            "type": "score (``search.best_score_``).",
            "description": ""
          },
          "scorer_": {
            "type": "function or a dict",
            "description": ""
          },
          "Scorer": {
            "type": "function used on the held out data to choose the best",
            "description": ""
          }
        },
        "returns": "the selected ``best_index_`` given ``cv_results_``. In that\n        case, the ``best_estimator_`` and ``best_params_`` will be set\n        according to the returned ``best_index_`` while the ``best_score_``\n        attribute will not be available.\n\n        The refitted estimator is made available at the ``best_estimator_``\n        attribute and permits using ``predict`` directly on this\n        ``GridSearchCV`` instance.\n\n        Also for multiple metric evaluation, the attributes ``best_index_``,\n        ``best_score_`` and ``best_params_`` will only be available if\n        ``refit`` is set and all of them will be determined w.r.t this specific\n        scorer.\n\n        See ``scoring`` parameter to know more about multiple metric\n        evaluation.\n\n        See :ref:`sphx_glr_auto_examples_model_selection_plot_grid_search_digits.py`\n        to see how to design a custom selection strategy using a callable\n        via `refit`.\n\n        .. versionchanged:: 0.20\n            Support for callable added.\n\n    cv : int, cross-validation generator or an iterable, default=None\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - None, to use the default 5-fold cross validation,\n        - integer, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For integer/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value if None changed from 3-fold to 5-fold.\n\n    verbose : int\n        Controls the verbosity: the higher, the more messages.\n\n        - >1 : the computation time for each fold and parameter candidate is\n          displayed;\n        - >2 : the score is also displayed;\n        - >3 : the fold and candidate parameter indexes are also displayed\n          together with the starting time of the computation.\n\n    pre_dispatch : int, or str, default='2*n_jobs'\n        Controls the number of jobs that get dispatched during parallel\n        execution. Reducing this number can be useful to avoid an\n        explosion of memory consumption when more jobs get dispatched\n        than CPUs can process. This parameter can be:\n\n        - None, in which case all the jobs are immediately created and spawned. Use\n          this for lightweight and fast-running jobs, to avoid delays due to on-demand\n          spawning of the jobs\n        - An int, giving the exact number of total jobs that are spawned\n        - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'\n\n    error_score : 'raise' or numeric, default=np.nan\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised. If a numeric value is given,\n        FitFailedWarning is raised. This parameter does not affect the refit\n        step, which will always raise the error.\n\n    return_train_score : bool, default=False\n        If ``False``, the ``cv_results_`` attribute will not include training\n        scores.\n        Computing training scores is used to get insights on how different\n        parameter settings impact the overfitting/underfitting trade-off.\n        However computing the scores on the training set can be computationally\n        expensive and is not strictly required to select the parameters that\n        yield the best generalization performance.\n\n        .. versionadded:: 0.19\n\n        .. versionchanged:: 0.21\n            Default value was changed from ``True`` to ``False``\n\n    Attributes\n    ----------\n    cv_results_ : dict of numpy (masked) ndarrays\n        A dict with keys as column headers and values as columns, that can be\n        imported into a pandas ``DataFrame``.\n\n        For instance the below given table\n\n        +------------+-----------+------------+-----------------+---+---------+\n        |param_kernel|param_gamma|param_degree|split0_test_score|...|rank_t...|\n        +============+===========+============+=================+===+=========+\n        |  'poly'    |     --    |      2     |       0.80      |...|    2    |\n        +------------+-----------+------------+-----------------+---+---------+\n        |  'poly'    |     --    |      3     |       0.70      |...|    4    |\n        +------------+-----------+------------+-----------------+---+---------+\n        |  'rbf'     |     0.1   |     --     |       0.80      |...|    3    |\n        +------------+-----------+------------+-----------------+---+---------+\n        |  'rbf'     |     0.2   |     --     |       0.93      |...|    1    |\n        +------------+-----------+------------+-----------------+---+---------+\n\n        will be represented by a ``cv_results_`` dict of::\n\n            {\n            'param_kernel': masked_array(data = ['poly', 'poly', 'rbf', 'rbf'],\n                                         mask = [False False False False]...)\n            'param_gamma': masked_array(data = [-- -- 0.1 0.2],\n                                        mask = [ True  True False False]...),\n            'param_degree': masked_array(data = [2.0 3.0 -- --],\n                                         mask = [False False  True  True]...),\n            'split0_test_score'  : [0.80, 0.70, 0.80, 0.93],\n            'split1_test_score'  : [0.82, 0.50, 0.70, 0.78],\n            'mean_test_score'    : [0.81, 0.60, 0.75, 0.85],\n            'std_test_score'     : [0.01, 0.10, 0.05, 0.08],\n            'rank_test_score'    : [2, 4, 3, 1],\n            'split0_train_score' : [0.80, 0.92, 0.70, 0.93],\n            'split1_train_score' : [0.82, 0.55, 0.70, 0.87],\n            'mean_train_score'   : [0.81, 0.74, 0.70, 0.90],\n            'std_train_score'    : [0.01, 0.19, 0.00, 0.03],\n            'mean_fit_time'      : [0.73, 0.63, 0.43, 0.49],\n            'std_fit_time'       : [0.01, 0.02, 0.01, 0.01],\n            'mean_score_time'    : [0.01, 0.06, 0.04, 0.04],\n            'std_score_time'     : [0.00, 0.00, 0.00, 0.01],\n            'params'             : [{'kernel': 'poly', 'degree': 2}, ...],\n            }\n\n        NOTE\n\n        The key ``'params'`` is used to store a list of parameter\n        settings dicts for all the parameter candidates.\n\n        The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and\n        ``std_score_time`` are all in seconds.\n\n        For multi-metric evaluation, the scores for all the scorers are\n        available in the ``cv_results_`` dict at the keys ending with that\n        scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\n        above. ('split0_test_precision', 'mean_train_precision' etc.)\n\n    best_estimator_ : estimator\n        Estimator that was chosen by the search, i.e. estimator\n        which gave highest score (or smallest loss if specified)\n        on the left out data. Not available if ``refit=False``.\n\n        See ``refit`` parameter for more information on allowed values.\n\n    best_score_ : float\n        Mean cross-validated score of the best_estimator\n\n        For multi-metric evaluation, this is present only if ``refit`` is\n        specified.\n\n        This attribute is not available if ``refit`` is a function.\n\n    best_params_ : dict\n        Parameter setting that gave the best results on the hold out data.\n\n        For multi-metric evaluation, this is present only if ``refit`` is\n        specified.\n\n    best_index_ : int\n        The index (of the ``cv_results_`` arrays) which corresponds to the best\n        candidate parameter setting.\n\n        The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n        the parameter setting for the best model, that gives the highest\n        mean score (``search.best_score_``).\n\n        For multi-metric evaluation, this is present only if ``refit`` is\n        specified.\n\n    scorer_ : function or a dict\n        Scorer function used on the held out data to choose the best\n        parameters for the model.\n\n        For multi-metric evaluation, this attribute holds the validated\n        ``scoring`` dict which maps the scorer key to the scorer callable.\n\n    n_splits_ : int\n        The number of cross-validation splits (folds/iterations).\n\n    refit_time_ : float\n        Seconds used for refitting the best model on the whole dataset.\n\n        This is present only if ``refit`` is not False.\n\n        .. versionadded:: 0.20\n\n    multimetric_ : bool\n        Whether or not the scorers compute several metrics.\n\n    classes_ : ndarray of shape (n_classes,)\n        The classes labels. This is present only if ``refit`` is specified and\n        the underlying estimator is a classifier.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `n_features_in_` when fit.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `feature_names_in_` when fit.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    ParameterGrid : Generates all the combinations of a hyperparameter grid.\n    train_test_split : Utility function to split the data into a development\n        set usable for fitting a GridSearchCV instance and an evaluation set\n        for its final evaluation.\n    sklearn.metrics.make_scorer : Make a scorer from a performance metric or\n        loss function.\n\n    Notes\n    -----\n    The parameters selected are those that maximize the score of the left out\n    data, unless an explicit score is passed in which case it is used instead.\n\n    If `n_jobs` was set to a value higher than one, the data is copied for each\n    point in the grid (and not `n_jobs` times). This is done for efficiency\n    reasons if individual jobs take very little time, but may raise errors if\n    the dataset is large and not enough memory is available.  A workaround in\n    this case is to set `pre_dispatch`. Then, the memory is copied only\n    `pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\n    n_jobs`.\n\n    Examples\n    --------\n    >>> from sklearn import svm, datasets\n    >>> from sklearn.model_selection import GridSearchCV\n    >>> iris = datasets.load_iris()\n    >>> parameters = {'kernel':('linear', 'rbf'), 'C':[1, 10]}\n    >>> svc = svm.SVC()\n    >>> clf = GridSearchCV(svc, parameters)\n    >>> clf.fit(iris.data, iris.target)\n    GridSearchCV(estimator=SVC(),\n                 param_grid={'C': [1, 10], 'kernel': ('linear', 'rbf')})\n    >>> sorted(clf.cv_results_.keys())\n    ['mean_fit_time', 'mean_score_time', 'mean_test_score',...\n     'param_C', 'param_kernel', 'params',...\n     'rank_test_score', 'split0_test_score',...\n     'split2_test_score', ...\n     'std_fit_time', 'std_score_time', 'std_test_score']",
        "raises": "",
        "see_also": "--------\n    ParameterGrid : Generates all the combinations of a hyperparameter grid.\n    train_test_split : Utility function to split the data into a development\n        set usable for fitting a GridSearchCV instance and an evaluation set\n        for its final evaluation.\n    sklearn.metrics.make_scorer : Make a scorer from a performance metric or\n        loss function.\n\n    Notes\n    -----\n    The parameters selected are those that maximize the score of the left out\n    data, unless an explicit score is passed in which case it is used instead.\n\n    If `n_jobs` was set to a value higher than one, the data is copied for each\n    point in the grid (and not `n_jobs` times). This is done for efficiency\n    reasons if individual jobs take very little time, but may raise errors if\n    the dataset is large and not enough memory is available.  A workaround in\n    this case is to set `pre_dispatch`. Then, the memory is copied only\n    `pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\n    n_jobs`.\n\n    Examples\n    --------\n    >>> from sklearn import svm, datasets\n    >>> from sklearn.model_selection import GridSearchCV\n    >>> iris = datasets.load_iris()\n    >>> parameters = {'kernel':('linear', 'rbf'), 'C':[1, 10]}\n    >>> svc = svm.SVC()\n    >>> clf = GridSearchCV(svc, parameters)\n    >>> clf.fit(iris.data, iris.target)\n    GridSearchCV(estimator=SVC(),\n                 param_grid={'C': [1, 10], 'kernel': ('linear', 'rbf')})\n    >>> sorted(clf.cv_results_.keys())\n    ['mean_fit_time', 'mean_score_time', 'mean_test_score',...\n     'param_C', 'param_kernel', 'params',...\n     'rank_test_score', 'split0_test_score',...\n     'split2_test_score', ...\n     'std_fit_time', 'std_score_time', 'std_test_score']",
        "notes": "The key ``'params'`` is used to store a list of parameter\n        settings dicts for all the parameter candidates.\n\n        The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and\n        ``std_score_time`` are all in seconds.\n\n        For multi-metric evaluation, the scores for all the scorers are\n        available in the ``cv_results_`` dict at the keys ending with that\n        scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\n        above. ('split0_test_precision', 'mean_train_precision' etc.)\n\n    best_estimator_ : estimator\n        Estimator that was chosen by the search, i.e. estimator\n        which gave highest score (or smallest loss if specified)\n        on the left out data. Not available if ``refit=False``.\n\n        See ``refit`` parameter for more information on allowed values.\n\n    best_score_ : float\n        Mean cross-validated score of the best_estimator\n\n        For multi-metric evaluation, this is present only if ``refit`` is\n        specified.\n\n        This attribute is not available if ``refit`` is a function.\n\n    best_params_ : dict\n        Parameter setting that gave the best results on the hold out data.\n\n        For multi-metric evaluation, this is present only if ``refit`` is\n        specified.\n\n    best_index_ : int\n        The index (of the ``cv_results_`` arrays) which corresponds to the best\n        candidate parameter setting.\n\n        The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n        the parameter setting for the best model, that gives the highest\n        mean score (``search.best_score_``).\n\n        For multi-metric evaluation, this is present only if ``refit`` is\n        specified.\n\n    scorer_ : function or a dict\n        Scorer function used on the held out data to choose the best\n        parameters for the model.\n\n        For multi-metric evaluation, this attribute holds the validated\n        ``scoring`` dict which maps the scorer key to the scorer callable.\n\n    n_splits_ : int\n        The number of cross-validation splits (folds/iterations).\n\n    refit_time_ : float\n        Seconds used for refitting the best model on the whole dataset.\n\n        This is present only if ``refit`` is not False.\n\n        .. versionadded:: 0.20\n\n    multimetric_ : bool\n        Whether or not the scorers compute several metrics.\n\n    classes_ : ndarray of shape (n_classes,)\n        The classes labels. This is present only if ``refit`` is specified and\n        the underlying estimator is a classifier.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `n_features_in_` when fit.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `feature_names_in_` when fit.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    ParameterGrid : Generates all the combinations of a hyperparameter grid.\n    train_test_split : Utility function to split the data into a development\n        set usable for fitting a GridSearchCV instance and an evaluation set\n        for its final evaluation.\n    sklearn.metrics.make_scorer : Make a scorer from a performance metric or\n        loss function.\n\n    Notes\n    -----\n    The parameters selected are those that maximize the score of the left out\n    data, unless an explicit score is passed in which case it is used instead.\n\n    If `n_jobs` was set to a value higher than one, the data is copied for each\n    point in the grid (and not `n_jobs` times). This is done for efficiency\n    reasons if individual jobs take very little time, but may raise errors if\n    the dataset is large and not enough memory is available.  A workaround in\n    this case is to set `pre_dispatch`. Then, the memory is copied only\n    `pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\n    n_jobs`.\n\n    Examples\n    --------\n    >>> from sklearn import svm, datasets\n    >>> from sklearn.model_selection import GridSearchCV\n    >>> iris = datasets.load_iris()\n    >>> parameters = {'kernel':('linear', 'rbf'), 'C':[1, 10]}\n    >>> svc = svm.SVC()\n    >>> clf = GridSearchCV(svc, parameters)\n    >>> clf.fit(iris.data, iris.target)\n    GridSearchCV(estimator=SVC(),\n                 param_grid={'C': [1, 10], 'kernel': ('linear', 'rbf')})\n    >>> sorted(clf.cv_results_.keys())\n    ['mean_fit_time', 'mean_score_time', 'mean_test_score',...\n     'param_C', 'param_kernel', 'params',...\n     'rank_test_score', 'split0_test_score',...\n     'split2_test_score', ...\n     'std_fit_time', 'std_score_time', 'std_test_score']",
        "examples": "--------\n    >>> from sklearn import svm, datasets\n    >>> from sklearn.model_selection import GridSearchCV\n    >>> iris = datasets.load_iris()\n    >>> parameters = {'kernel':('linear', 'rbf'), 'C':[1, 10]}\n    >>> svc = svm.SVC()\n    >>> clf = GridSearchCV(svc, parameters)\n    >>> clf.fit(iris.data, iris.target)\n    GridSearchCV(estimator=SVC(),\n                 param_grid={'C': [1, 10], 'kernel': ('linear', 'rbf')})\n    >>> sorted(clf.cv_results_.keys())\n    ['mean_fit_time', 'mean_score_time', 'mean_test_score',...\n     'param_C', 'param_kernel', 'params',...\n     'rank_test_score', 'split0_test_score',...\n     'split2_test_score', ...\n     'std_fit_time', 'std_score_time', 'std_test_score']"
      },
      "methods": [
        {
          "name": "decision_function",
          "signature": "decision_function(self, X)",
          "documentation": {
            "description": "Call decision_function on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``decision_function``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": ""
              },
              "Must": {
                "type": "fulfill the input assumptions of the",
                "description": ""
              },
              "underlying": {
                "type": "estimator.",
                "description": "Returns\n-------"
              },
              "y_score": {
                "type": "ndarray of shape (n_samples,) or (n_samples, n_classes)                 or (n_samples, n_classes * (n_classes",
                "description": "1) / 2)"
              },
              "Result": {
                "type": "of the decision function for `X` based on the estimator with",
                "description": ""
              },
              "the": {
                "type": "best found parameters.",
                "description": ""
              }
            },
            "returns": "-------\n        y_score : ndarray of shape (n_samples,) or (n_samples, n_classes)                 or (n_samples, n_classes * (n_classes-1) / 2)\n            Result of the decision function for `X` based on the estimator with\n            the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit",
          "signature": "fit(self, X, y=None, **params)",
          "documentation": {
            "description": "Run fit with all sets of parameters.\n\n        Parameters\n        ----------\n\n        X : array-like of shape (n_samples, n_features) or (n_samples, n_samples)\n            Training vectors, where `n_samples` is the number of samples and\n            `n_features` is the number of features. For precomputed kernel or\n            distance matrix, the expected shape of X is (n_samples, n_samples).\n\n        y : array-like of shape (n_samples, n_output)             or (n_samples,), default=None\n            Target relative to X for classification or regression;\n            None for unsupervised learning.\n\n        **params : dict of str -> object\n            Parameters passed to the ``fit`` method of the estimator, the scorer,\n            and the CV splitter.\n\n            If a fit parameter is an array-like whose length is equal to\n            `num_samples` then it will be split by cross-validation along with\n            `X` and `y`. For example, the :term:`sample_weight` parameter is\n            split because `len(sample_weights) = len(X)`. However, this behavior\n            does not apply to `groups` which is passed to the splitter configured\n            via the `cv` parameter of the constructor. Thus, `groups` is used\n            *to perform the split* and determines which samples are\n            assigned to the each side of the a split.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features) or (n_samples, n_samples)"
              },
              "Training": {
                "type": "vectors, where `n_samples` is the number of samples and",
                "description": "`n_features` is the number of features. For precomputed kernel or"
              },
              "distance": {
                "type": "matrix, the expected shape of X is (n_samples, n_samples).",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples, n_output)             or (n_samples,), default=None"
              },
              "Target": {
                "type": "relative to X for classification or regression;",
                "description": ""
              },
              "None": {
                "type": "for unsupervised learning.",
                "description": "**params : dict of str -> object"
              }
            },
            "returns": "-------\n        self : object\n            Instance of fitted estimator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        .. versionadded:: 1.4",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRouter\n            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X=None, Xt=None)",
          "documentation": {
            "description": "Call inverse_transform on the estimator with the best found params.\n\n        Only available if the underlying estimator implements\n        ``inverse_transform`` and ``refit=True``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        Xt : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n            .. deprecated:: 1.5\n                `Xt` was deprecated in 1.5 and will be removed in 1.7. Use `X` instead.",
            "parameters": {
              "X": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
                "description": ""
              },
              "Must": {
                "type": "fulfill the input assumptions of the",
                "description": ""
              },
              "underlying": {
                "type": "estimator.",
                "description": ".. deprecated:: 1.5\n`Xt` was deprecated in 1.5 and will be removed in 1.7. Use `X` instead.\nReturns\n-------"
              },
              "Xt": {
                "type": "indexable, length n_samples",
                "description": ""
              },
              "Result": {
                "type": "of the `inverse_transform` function for `Xt` based on the",
                "description": ""
              },
              "estimator": {
                "type": "with the best found parameters.",
                "description": ""
              }
            },
            "returns": "-------\n        X : {ndarray, sparse matrix} of shape (n_samples, n_features)\n            Result of the `inverse_transform` function for `Xt` based on the\n            estimator with the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict",
          "signature": "predict(self, X)",
          "documentation": {
            "description": "Call predict on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``predict``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": ""
              },
              "Must": {
                "type": "fulfill the input assumptions of the",
                "description": ""
              },
              "underlying": {
                "type": "estimator.",
                "description": "Returns\n-------"
              },
              "y_pred": {
                "type": "ndarray of shape (n_samples,)",
                "description": ""
              },
              "The": {
                "type": "predicted labels or values for `X` based on the estimator with",
                "description": ""
              },
              "the": {
                "type": "best found parameters.",
                "description": ""
              }
            },
            "returns": "-------\n        y_pred : ndarray of shape (n_samples,)\n            The predicted labels or values for `X` based on the estimator with\n            the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_log_proba",
          "signature": "predict_log_proba(self, X)",
          "documentation": {
            "description": "Call predict_log_proba on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``predict_log_proba``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": ""
              },
              "Must": {
                "type": "fulfill the input assumptions of the",
                "description": ""
              },
              "underlying": {
                "type": "estimator.",
                "description": "Returns\n-------"
              },
              "y_pred": {
                "type": "ndarray of shape (n_samples,) or (n_samples, n_classes)",
                "description": ""
              },
              "Predicted": {
                "type": "class log-probabilities for `X` based on the estimator",
                "description": ""
              },
              "with": {
                "type": "the best found parameters. The order of the classes",
                "description": ""
              },
              "corresponds": {
                "type": "to that in the fitted attribute :term:`classes_`.",
                "description": ""
              }
            },
            "returns": "-------\n        y_pred : ndarray of shape (n_samples,) or (n_samples, n_classes)\n            Predicted class log-probabilities for `X` based on the estimator\n            with the best found parameters. The order of the classes\n            corresponds to that in the fitted attribute :term:`classes_`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_proba",
          "signature": "predict_proba(self, X)",
          "documentation": {
            "description": "Call predict_proba on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``predict_proba``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": ""
              },
              "Must": {
                "type": "fulfill the input assumptions of the",
                "description": ""
              },
              "underlying": {
                "type": "estimator.",
                "description": "Returns\n-------"
              },
              "y_pred": {
                "type": "ndarray of shape (n_samples,) or (n_samples, n_classes)",
                "description": ""
              },
              "Predicted": {
                "type": "class probabilities for `X` based on the estimator with",
                "description": ""
              },
              "the": {
                "type": "best found parameters. The order of the classes corresponds",
                "description": ""
              },
              "to": {
                "type": "that in the fitted attribute :term:`classes_`.",
                "description": ""
              }
            },
            "returns": "-------\n        y_pred : ndarray of shape (n_samples,) or (n_samples, n_classes)\n            Predicted class probabilities for `X` based on the estimator with\n            the best found parameters. The order of the classes corresponds\n            to that in the fitted attribute :term:`classes_`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score",
          "signature": "score(self, X, y=None, **params)",
          "documentation": {
            "description": "Return the score on the given data, if the estimator has been refit.\n\n        This uses the score defined by ``scoring`` where provided, and the\n        ``best_estimator_.score`` method otherwise.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input data, where `n_samples` is the number of samples and\n            `n_features` is the number of features.\n\n        y : array-like of shape (n_samples, n_output)             or (n_samples,), default=None\n            Target relative to X for classification or regression;\n            None for unsupervised learning.\n\n        **params : dict\n            Parameters to be passed to the underlying scorer(s).\n\n            .. versionadded:: 1.4\n                Only available if `enable_metadata_routing=True`. See\n                :ref:`Metadata Routing User Guide <metadata_routing>` for more\n                details.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "data, where `n_samples` is the number of samples and",
                "description": "`n_features` is the number of features."
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples, n_output)             or (n_samples,), default=None"
              },
              "Target": {
                "type": "relative to X for classification or regression;",
                "description": ""
              },
              "None": {
                "type": "for unsupervised learning.",
                "description": "**params : dict"
              }
            },
            "returns": "-------\n        score : float\n            The score defined by ``scoring`` if provided, and the\n            ``best_estimator_.score`` method otherwise.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score_samples",
          "signature": "score_samples(self, X)",
          "documentation": {
            "description": "Call score_samples on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``score_samples``.\n\n        .. versionadded:: 0.24\n\n        Parameters\n        ----------\n        X : iterable\n            Data to predict on. Must fulfill input requirements\n            of the underlying estimator.",
            "parameters": {
              "X": {
                "type": "iterable",
                "description": ""
              },
              "Data": {
                "type": "to predict on. Must fulfill input requirements",
                "description": ""
              },
              "of": {
                "type": "the underlying estimator.",
                "description": "Returns\n-------"
              },
              "y_score": {
                "type": "ndarray of shape (n_samples,)",
                "description": ""
              },
              "The": {
                "type": "``best_estimator_.score_samples`` method.",
                "description": ""
              }
            },
            "returns": "-------\n        y_score : ndarray of shape (n_samples,)\n            The ``best_estimator_.score_samples`` method.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Call transform on the estimator with the best found parameters.\n\n        Only available if the underlying estimator supports ``transform`` and\n        ``refit=True``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": ""
              },
              "Must": {
                "type": "fulfill the input assumptions of the",
                "description": ""
              },
              "underlying": {
                "type": "estimator.",
                "description": "Returns\n-------"
              },
              "Xt": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
                "description": "`X` transformed in the new space based on the estimator with"
              },
              "the": {
                "type": "best found parameters.",
                "description": ""
              }
            },
            "returns": "-------\n        Xt : {ndarray, sparse matrix} of shape (n_samples, n_features)\n            `X` transformed in the new space based on the estimator with\n            the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "GroupKFold",
      "documentation": {
        "description": "K-fold iterator variant with non-overlapping groups.\n\n    Each group will appear exactly once in the test set across all folds (the\n    number of distinct groups has to be at least equal to the number of folds).\n\n    The folds are approximately balanced in the sense that the number of\n    samples is approximately the same in each test fold when `shuffle` is True.\n\n    Read more in the :ref:`User Guide <group_k_fold>`.\n\n    For visualisation of cross-validation behaviour and\n    comparison between common scikit-learn split methods\n    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n    Parameters\n    ----------\n    n_splits : int, default=5\n        Number of folds. Must be at least 2.\n\n        .. versionchanged:: 0.22\n            ``n_splits`` default value changed from 3 to 5.\n\n    shuffle : bool, default=False\n        Whether to shuffle the groups before splitting into batches.\n        Note that the samples within each split will not be shuffled.\n\n        .. versionadded:: 1.6\n\n    random_state : int, RandomState instance or None, default=None\n        When `shuffle` is True, `random_state` affects the ordering of the\n        indices, which controls the randomness of each fold. Otherwise, this\n        parameter has no effect.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n        .. versionadded:: 1.6\n\n    Notes\n    -----\n    Groups appear in an arbitrary order throughout the folds.",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": ""
          },
          "Number": {
            "type": "of folds. Must be at least 2.",
            "description": ".. versionchanged:: 0.22\n``n_splits`` default value changed from 3 to 5."
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": ""
          },
          "Whether": {
            "type": "to shuffle the groups before splitting into batches.",
            "description": ""
          },
          "Note": {
            "type": "that the samples within each split will not be shuffled.",
            "description": ".. versionadded:: 1.6"
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "When": {
            "type": "`shuffle` is True, `random_state` affects the ordering of the",
            "description": "indices, which controls the randomness of each fold. Otherwise, this"
          },
          "parameter": {
            "type": "has no effect.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible output across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "Groups": {
            "type": "appear in an arbitrary order throughout the folds.",
            "description": "Examples\n--------\n>>> import numpy as np\n>>> from sklearn.model_selection import GroupKFold\n>>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])\n>>> y = np.array([1, 2, 3, 4, 5, 6])\n>>> groups = np.array([0, 0, 2, 2, 3, 3])\n>>> group_kfold = GroupKFold(n_splits=2)\n>>> group_kfold.get_n_splits(X, y, groups)\n2\n>>> print(group_kfold)"
          },
          "GroupKFold": {
            "type": "n_splits=2, random_state=None, shuffle=False",
            "description": ">>> for i, (train_index, test_index) in enumerate(group_kfold.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")"
          },
          "Fold": {
            "type": "1:",
            "description": ""
          },
          "Train": {
            "type": "index=[0 1 4 5], group=[0 0 3 3]",
            "description": ""
          },
          "Test": {
            "type": "index=[2 3], group=[2 2]",
            "description": ""
          },
          "LeaveOneGroupOut": {
            "type": "For splitting the data according to explicit",
            "description": "domain-specific stratification of the dataset."
          },
          "StratifiedKFold": {
            "type": "Takes class information into account to avoid building",
            "description": ""
          },
          "folds": {
            "type": "with imbalanced class proportions (for binary or multiclass",
            "description": ""
          },
          "classification": {
            "type": "tasks).",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    LeaveOneGroupOut : For splitting the data according to explicit\n        domain-specific stratification of the dataset.\n\n    StratifiedKFold : Takes class information into account to avoid building\n        folds with imbalanced class proportions (for binary or multiclass\n        classification tasks).",
        "notes": "that the samples within each split will not be shuffled.\n\n        .. versionadded:: 1.6\n\n    random_state : int, RandomState instance or None, default=None\n        When `shuffle` is True, `random_state` affects the ordering of the\n        indices, which controls the randomness of each fold. Otherwise, this\n        parameter has no effect.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n        .. versionadded:: 1.6\n\n    Notes\n    -----\n    Groups appear in an arbitrary order throughout the folds.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import GroupKFold\n    >>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])\n    >>> y = np.array([1, 2, 3, 4, 5, 6])\n    >>> groups = np.array([0, 0, 2, 2, 3, 3])\n    >>> group_kfold = GroupKFold(n_splits=2)\n    >>> group_kfold.get_n_splits(X, y, groups)\n    2\n    >>> print(group_kfold)\n    GroupKFold(n_splits=2, random_state=None, shuffle=False)\n    >>> for i, (train_index, test_index) in enumerate(group_kfold.split(X, y, groups)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n    ...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\n    Fold 0:\n      Train: index=[2 3], group=[2 2]\n      Test:  index=[0 1 4 5], group=[0 0 3 3]\n    Fold 1:\n      Train: index=[0 1 4 5], group=[0 0 3 3]\n      Test:  index=[2 3], group=[2 2]\n\n    See Also\n    --------\n    LeaveOneGroupOut : For splitting the data according to explicit\n        domain-specific stratification of the dataset.\n\n    StratifiedKFold : Takes class information into account to avoid building\n        folds with imbalanced class proportions (for binary or multiclass\n        classification tasks).",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import GroupKFold\n    >>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])\n    >>> y = np.array([1, 2, 3, 4, 5, 6])\n    >>> groups = np.array([0, 0, 2, 2, 3, 3])\n    >>> group_kfold = GroupKFold(n_splits=2)\n    >>> group_kfold.get_n_splits(X, y, groups)\n    2\n    >>> print(group_kfold)\n    GroupKFold(n_splits=2, random_state=None, shuffle=False)\n    >>> for i, (train_index, test_index) in enumerate(group_kfold.split(X, y, groups)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n    ...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\n    Fold 0:\n      Train: index=[2 3], group=[2 2]\n      Test:  index=[0 1 4 5], group=[0 0 3 3]\n    Fold 1:\n      Train: index=[0 1 4 5], group=[0 0 3 3]\n      Test:  index=[2 3], group=[2 2]\n\n    See Also\n    --------\n    LeaveOneGroupOut : For splitting the data according to explicit\n        domain-specific stratification of the dataset.\n\n    StratifiedKFold : Takes class information into account to avoid building\n        folds with imbalanced class proportions (for binary or multiclass\n        classification tasks)."
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n\n        y : object\n            Always ignored, exists for compatibility.\n\n        groups : object\n            Always ignored, exists for compatibility.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_split_request",
          "signature": "set_split_request(self: sklearn.model_selection._split.GroupKFold, *, groups: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._split.GroupKFold",
          "documentation": {
            "description": "Request metadata passed to the ``split`` method.",
            "parameters": {
              "groups": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``groups`` parameter in ``split``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``split`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``split``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        groups : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``groups`` parameter in ``split``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": ""
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Group": {
                "type": "labels for the samples used while splitting the dataset into",
                "description": "train/test set.\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "GroupShuffleSplit",
      "documentation": {
        "description": "Shuffle-Group(s)-Out cross-validation iterator.\n\n    Provides randomized train/test indices to split data according to a\n    third-party provided group. This group information can be used to encode\n    arbitrary domain specific stratifications of the samples as integers.\n\n    For instance the groups could be the year of collection of the samples\n    and thus allow for cross-validation against time-based splits.\n\n    The difference between :class:`LeavePGroupsOut` and ``GroupShuffleSplit`` is that\n    the former generates splits using all subsets of size ``p`` unique groups,\n    whereas ``GroupShuffleSplit`` generates a user-determined number of random\n    test splits, each with a user-determined fraction of unique groups.\n\n    For example, a less computationally intensive alternative to\n    ``LeavePGroupsOut(p=10)`` would be\n    ``GroupShuffleSplit(test_size=10, n_splits=100)``.\n\n    Contrary to other cross-validation strategies, the random splits\n    do not guarantee that test sets across all folds will be mutually exclusive,\n    and might include overlapping samples. However, this is still very likely for\n    sizeable datasets.\n\n    Note: The parameters ``test_size`` and ``train_size`` refer to groups, and\n    not to samples as in :class:`ShuffleSplit`.\n\n    Read more in the :ref:`User Guide <group_shuffle_split>`.\n\n    For visualisation of cross-validation behaviour and\n    comparison between common scikit-learn split methods\n    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n    Parameters\n    ----------\n    n_splits : int, default=5\n        Number of re-shuffling & splitting iterations.\n\n    test_size : float, int, default=None\n        If float, should be between 0.0 and 1.0 and represent the proportion\n        of groups to include in the test split (rounded up). If int,\n        represents the absolute number of test groups. If None, the value is\n        set to the complement of the train size. If ``train_size`` is also None,\n        it will be set to 0.2.\n\n    train_size : float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the\n        proportion of the groups to include in the train split. If\n        int, represents the absolute number of train groups. If None,\n        the value is automatically set to the complement of the test size.\n\n    random_state : int, RandomState instance or None, default=None\n        Controls the randomness of the training and testing indices produced.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": ""
          },
          "Number": {
            "type": "of re-shuffling & splitting iterations.",
            "description": ""
          },
          "test_size": {
            "type": "float, int, default=None",
            "description": ""
          },
          "If": {
            "type": "float, should be between 0.0 and 1.0 and represent the",
            "description": ""
          },
          "of": {
            "type": "groups to include in the test split (rounded up). If int,",
            "description": ""
          },
          "represents": {
            "type": "the absolute number of test groups. If None, the value is",
            "description": ""
          },
          "set": {
            "type": "to the complement of the train size. If ``train_size`` is also None,",
            "description": ""
          },
          "it": {
            "type": "will be set to 0.2.",
            "description": ""
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": ""
          },
          "proportion": {
            "type": "of the groups to include in the train split. If",
            "description": "int, represents the absolute number of train groups. If None,"
          },
          "the": {
            "type": "value is automatically set to the complement of the test size.",
            "description": ""
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Controls": {
            "type": "the randomness of the training and testing indices produced.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible output across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "GroupShuffleSplit": {
            "type": "n_splits=2, random_state=42, test_size=None, train_size=0.7",
            "description": ">>> for i, (train_index, test_index) in enumerate(gss.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")"
          },
          "Fold": {
            "type": "1:",
            "description": ""
          },
          "Train": {
            "type": "index=[0 1 5 6 7], group=[1 1 3 3 3]",
            "description": ""
          },
          "Test": {
            "type": "index=[2 3 4], group=[2 2 2]",
            "description": ""
          },
          "ShuffleSplit": {
            "type": "Shuffles samples to create independent test/train sets.",
            "description": ""
          },
          "LeavePGroupsOut": {
            "type": "Train set leaves out all possible subsets of `p` groups.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    ShuffleSplit : Shuffles samples to create independent test/train sets.\n\n    LeavePGroupsOut : Train set leaves out all possible subsets of `p` groups.",
        "notes": "The parameters ``test_size`` and ``train_size`` refer to groups, and\n    not to samples as in :class:`ShuffleSplit`.\n\n    Read more in the :ref:`User Guide <group_shuffle_split>`.\n\n    For visualisation of cross-validation behaviour and\n    comparison between common scikit-learn split methods\n    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n    Parameters\n    ----------\n    n_splits : int, default=5\n        Number of re-shuffling & splitting iterations.\n\n    test_size : float, int, default=None\n        If float, should be between 0.0 and 1.0 and represent the proportion\n        of groups to include in the test split (rounded up). If int,\n        represents the absolute number of test groups. If None, the value is\n        set to the complement of the train size. If ``train_size`` is also None,\n        it will be set to 0.2.\n\n    train_size : float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the\n        proportion of the groups to include in the train split. If\n        int, represents the absolute number of train groups. If None,\n        the value is automatically set to the complement of the test size.\n\n    random_state : int, RandomState instance or None, default=None\n        Controls the randomness of the training and testing indices produced.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import GroupShuffleSplit\n    >>> X = np.ones(shape=(8, 2))\n    >>> y = np.ones(shape=(8, 1))\n    >>> groups = np.array([1, 1, 2, 2, 2, 3, 3, 3])\n    >>> print(groups.shape)\n    (8,)\n    >>> gss = GroupShuffleSplit(n_splits=2, train_size=.7, random_state=42)\n    >>> gss.get_n_splits()\n    2\n    >>> print(gss)\n    GroupShuffleSplit(n_splits=2, random_state=42, test_size=None, train_size=0.7)\n    >>> for i, (train_index, test_index) in enumerate(gss.split(X, y, groups)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n    ...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\n    Fold 0:\n      Train: index=[2 3 4 5 6 7], group=[2 2 2 3 3 3]\n      Test:  index=[0 1], group=[1 1]\n    Fold 1:\n      Train: index=[0 1 5 6 7], group=[1 1 3 3 3]\n      Test:  index=[2 3 4], group=[2 2 2]\n\n    See Also\n    --------\n    ShuffleSplit : Shuffles samples to create independent test/train sets.\n\n    LeavePGroupsOut : Train set leaves out all possible subsets of `p` groups.",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import GroupShuffleSplit\n    >>> X = np.ones(shape=(8, 2))\n    >>> y = np.ones(shape=(8, 1))\n    >>> groups = np.array([1, 1, 2, 2, 2, 3, 3, 3])\n    >>> print(groups.shape)\n    (8,)\n    >>> gss = GroupShuffleSplit(n_splits=2, train_size=.7, random_state=42)\n    >>> gss.get_n_splits()\n    2\n    >>> print(gss)\n    GroupShuffleSplit(n_splits=2, random_state=42, test_size=None, train_size=0.7)\n    >>> for i, (train_index, test_index) in enumerate(gss.split(X, y, groups)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n    ...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\n    Fold 0:\n      Train: index=[2 3 4 5 6 7], group=[2 2 2 3 3 3]\n      Test:  index=[0 1], group=[1 1]\n    Fold 1:\n      Train: index=[0 1 5 6 7], group=[1 1 3 3 3]\n      Test:  index=[2 3 4], group=[2 2 2]\n\n    See Also\n    --------\n    ShuffleSplit : Shuffles samples to create independent test/train sets.\n\n    LeavePGroupsOut : Train set leaves out all possible subsets of `p` groups."
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n\n        y : object\n            Always ignored, exists for compatibility.\n\n        groups : object\n            Always ignored, exists for compatibility.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_split_request",
          "signature": "set_split_request(self: sklearn.model_selection._split.GroupShuffleSplit, *, groups: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._split.GroupShuffleSplit",
          "documentation": {
            "description": "Request metadata passed to the ``split`` method.",
            "parameters": {
              "groups": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``groups`` parameter in ``split``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``split`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``split``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        groups : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``groups`` parameter in ``split``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Training data, where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n\n        y : array-like of shape (n_samples,), default=None\n            The target variable for supervised learning problems.\n\n        groups : array-like of shape (n_samples,)\n            Group labels for the samples used while splitting the dataset into\n            train/test set.\n\n        Yields\n        ------\n        train : ndarray\n            The training set indices for that split.\n\n        test : ndarray\n            The testing set indices for that split.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": "Notes\n-----"
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Group": {
                "type": "labels for the samples used while splitting the dataset into",
                "description": "train/test set.\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              },
              "Randomized": {
                "type": "CV splitters may return different results for each call of",
                "description": "split. You can make the results identical by setting `random_state`"
              },
              "to": {
                "type": "an integer.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "-----\n        Randomized CV splitters may return different results for each call of\n        split. You can make the results identical by setting `random_state`\n        to an integer.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "KFold",
      "documentation": {
        "description": "K-Fold cross-validator.\n\n    Provides train/test indices to split data in train/test sets. Split\n    dataset into k consecutive folds (without shuffling by default).\n\n    Each fold is then used once as a validation while the k - 1 remaining\n    folds form the training set.\n\n    Read more in the :ref:`User Guide <k_fold>`.\n\n    For visualisation of cross-validation behaviour and\n    comparison between common scikit-learn split methods\n    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n    Parameters\n    ----------\n    n_splits : int, default=5\n        Number of folds. Must be at least 2.\n\n        .. versionchanged:: 0.22\n            ``n_splits`` default value changed from 3 to 5.\n\n    shuffle : bool, default=False\n        Whether to shuffle the data before splitting into batches.\n        Note that the samples within each split will not be shuffled.\n\n    random_state : int, RandomState instance or None, default=None\n        When `shuffle` is True, `random_state` affects the ordering of the\n        indices, which controls the randomness of each fold. Otherwise, this\n        parameter has no effect.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": ""
          },
          "Number": {
            "type": "of folds. Must be at least 2.",
            "description": ".. versionchanged:: 0.22\n``n_splits`` default value changed from 3 to 5."
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": ""
          },
          "Whether": {
            "type": "to shuffle the data before splitting into batches.",
            "description": ""
          },
          "Note": {
            "type": "that the samples within each split will not be shuffled.",
            "description": ""
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "When": {
            "type": "`shuffle` is True, `random_state` affects the ordering of the",
            "description": "indices, which controls the randomness of each fold. Otherwise, this"
          },
          "parameter": {
            "type": "has no effect.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible output across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "KFold": {
            "type": "n_splits=2, random_state=None, shuffle=False",
            "description": ">>> for i, (train_index, test_index) in enumerate(kf.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")"
          },
          "Fold": {
            "type": "1:",
            "description": ""
          },
          "Train": {
            "type": "index=[0 1]",
            "description": ""
          },
          "Test": {
            "type": "index=[2 3]",
            "description": "Notes\n-----"
          },
          "The": {
            "type": "first ``n_samples % n_splits`` folds have size",
            "description": "``n_samples // n_splits + 1``, other folds have size\n``n_samples // n_splits``, where ``n_samples`` is the number of samples."
          },
          "Randomized": {
            "type": "CV splitters may return different results for each call of",
            "description": "split. You can make the results identical by setting `random_state`"
          },
          "to": {
            "type": "an integer.",
            "description": ""
          },
          "StratifiedKFold": {
            "type": "Takes class information into account to avoid building",
            "description": ""
          },
          "folds": {
            "type": "with imbalanced class distributions (for binary or multiclass",
            "description": ""
          },
          "classification": {
            "type": "tasks).",
            "description": ""
          },
          "GroupKFold": {
            "type": "K",
            "description": "fold iterator variant with non-overlapping groups."
          },
          "RepeatedKFold": {
            "type": "Repeats K",
            "description": "Fold n times."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    StratifiedKFold : Takes class information into account to avoid building\n        folds with imbalanced class distributions (for binary or multiclass\n        classification tasks).\n\n    GroupKFold : K-fold iterator variant with non-overlapping groups.\n\n    RepeatedKFold : Repeats K-Fold n times.",
        "notes": "that the samples within each split will not be shuffled.\n\n    random_state : int, RandomState instance or None, default=None\n        When `shuffle` is True, `random_state` affects the ordering of the\n        indices, which controls the randomness of each fold. Otherwise, this\n        parameter has no effect.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import KFold\n    >>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n    >>> y = np.array([1, 2, 3, 4])\n    >>> kf = KFold(n_splits=2)\n    >>> kf.get_n_splits(X)\n    2\n    >>> print(kf)\n    KFold(n_splits=2, random_state=None, shuffle=False)\n    >>> for i, (train_index, test_index) in enumerate(kf.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[2 3]\n      Test:  index=[0 1]\n    Fold 1:\n      Train: index=[0 1]\n      Test:  index=[2 3]\n\n    Notes\n    -----\n    The first ``n_samples % n_splits`` folds have size\n    ``n_samples // n_splits + 1``, other folds have size\n    ``n_samples // n_splits``, where ``n_samples`` is the number of samples.\n\n    Randomized CV splitters may return different results for each call of\n    split. You can make the results identical by setting `random_state`\n    to an integer.\n\n    See Also\n    --------\n    StratifiedKFold : Takes class information into account to avoid building\n        folds with imbalanced class distributions (for binary or multiclass\n        classification tasks).\n\n    GroupKFold : K-fold iterator variant with non-overlapping groups.\n\n    RepeatedKFold : Repeats K-Fold n times.",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import KFold\n    >>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n    >>> y = np.array([1, 2, 3, 4])\n    >>> kf = KFold(n_splits=2)\n    >>> kf.get_n_splits(X)\n    2\n    >>> print(kf)\n    KFold(n_splits=2, random_state=None, shuffle=False)\n    >>> for i, (train_index, test_index) in enumerate(kf.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[2 3]\n      Test:  index=[0 1]\n    Fold 1:\n      Train: index=[0 1]\n      Test:  index=[2 3]\n\n    Notes\n    -----\n    The first ``n_samples % n_splits`` folds have size\n    ``n_samples // n_splits + 1``, other folds have size\n    ``n_samples // n_splits``, where ``n_samples`` is the number of samples.\n\n    Randomized CV splitters may return different results for each call of\n    split. You can make the results identical by setting `random_state`\n    to an integer.\n\n    See Also\n    --------\n    StratifiedKFold : Takes class information into account to avoid building\n        folds with imbalanced class distributions (for binary or multiclass\n        classification tasks).\n\n    GroupKFold : K-fold iterator variant with non-overlapping groups.\n\n    RepeatedKFold : Repeats K-Fold n times."
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n\n        y : object\n            Always ignored, exists for compatibility.\n\n        groups : object\n            Always ignored, exists for compatibility.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Yields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "LearningCurveDisplay",
      "documentation": {
        "description": "Learning Curve visualization.\n\n    It is recommended to use\n    :meth:`~sklearn.model_selection.LearningCurveDisplay.from_estimator` to\n    create a :class:`~sklearn.model_selection.LearningCurveDisplay` instance.\n    All parameters are stored as attributes.\n\n    Read more in the :ref:`User Guide <visualizations>` for general information\n    about the visualization API and\n    :ref:`detailed documentation <learning_curve>` regarding the learning\n    curve visualization.\n\n    .. versionadded:: 1.2\n\n    Parameters\n    ----------\n    train_sizes : ndarray of shape (n_unique_ticks,)\n        Numbers of training examples that has been used to generate the\n        learning curve.\n\n    train_scores : ndarray of shape (n_ticks, n_cv_folds)\n        Scores on training sets.\n\n    test_scores : ndarray of shape (n_ticks, n_cv_folds)\n        Scores on test set.\n\n    score_name : str, default=None\n        The name of the score used in `learning_curve`. It will override the name\n        inferred from the `scoring` parameter. If `score` is `None`, we use `\"Score\"` if\n        `negate_score` is `False` and `\"Negative score\"` otherwise. If `scoring` is a\n        string or a callable, we infer the name. We replace `_` by spaces and capitalize\n        the first letter. We remove `neg_` and replace it by `\"Negative\"` if\n        `negate_score` is `False` or just remove it otherwise.\n\n    Attributes\n    ----------\n    ax_ : matplotlib Axes\n        Axes with the learning curve.\n\n    figure_ : matplotlib Figure\n        Figure containing the learning curve.\n\n    errorbar_ : list of matplotlib Artist or None\n        When the `std_display_style` is `\"errorbar\"`, this is a list of\n        `matplotlib.container.ErrorbarContainer` objects. If another style is\n        used, `errorbar_` is `None`.\n\n    lines_ : list of matplotlib Artist or None\n        When the `std_display_style` is `\"fill_between\"`, this is a list of\n        `matplotlib.lines.Line2D` objects corresponding to the mean train and\n        test scores. If another style is used, `line_` is `None`.\n\n    fill_between_ : list of matplotlib Artist or None\n        When the `std_display_style` is `\"fill_between\"`, this is a list of\n        `matplotlib.collections.PolyCollection` objects. If another style is\n        used, `fill_between_` is `None`.\n\n    See Also\n    --------\n    sklearn.model_selection.learning_curve : Compute the learning curve.",
        "parameters": {
          "train_sizes": {
            "type": "ndarray of shape (n_unique_ticks,)",
            "description": ""
          },
          "Numbers": {
            "type": "of training examples that has been used to generate the",
            "description": ""
          },
          "learning": {
            "type": "curve.",
            "description": ""
          },
          "train_scores": {
            "type": "ndarray of shape (n_ticks, n_cv_folds)",
            "description": ""
          },
          "Scores": {
            "type": "on test set.",
            "description": ""
          },
          "test_scores": {
            "type": "ndarray of shape (n_ticks, n_cv_folds)",
            "description": ""
          },
          "score_name": {
            "type": "str, default=None",
            "description": ""
          },
          "The": {
            "type": "name of the score used in `learning_curve`. It will override the name",
            "description": ""
          },
          "inferred": {
            "type": "from the `scoring` parameter. If `score` is `None`, we use `\"Score\"` if",
            "description": "`negate_score` is `False` and `\"Negative score\"` otherwise. If `scoring` is a"
          },
          "string": {
            "type": "or a callable, we infer the name. We replace `_` by spaces and capitalize",
            "description": ""
          },
          "the": {
            "type": "first letter. We remove `neg_` and replace it by `\"Negative\"` if",
            "description": "`negate_score` is `False` or just remove it otherwise.\nAttributes\n----------"
          },
          "ax_": {
            "type": "matplotlib Axes",
            "description": ""
          },
          "Axes": {
            "type": "with the learning curve.",
            "description": ""
          },
          "figure_": {
            "type": "matplotlib Figure",
            "description": ""
          },
          "Figure": {
            "type": "containing the learning curve.",
            "description": ""
          },
          "errorbar_": {
            "type": "list of matplotlib Artist or None",
            "description": ""
          },
          "When": {
            "type": "the `std_display_style` is `\"fill_between\"`, this is a list of",
            "description": "`matplotlib.collections.PolyCollection` objects. If another style is\nused, `fill_between_` is `None`."
          },
          "lines_": {
            "type": "list of matplotlib Artist or None",
            "description": ""
          },
          "test": {
            "type": "scores. If another style is used, `line_` is `None`.",
            "description": ""
          },
          "fill_between_": {
            "type": "list of matplotlib Artist or None",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------\nsklearn.model_selection.learning_curve : Compute the learning curve.\nExamples\n--------\n>>> import matplotlib.pyplot as plt\n>>> from sklearn.datasets import load_iris\n>>> from sklearn.model_selection import LearningCurveDisplay, learning_curve\n>>> from sklearn.tree import DecisionTreeClassifier\n>>> X, y = load_iris(return_X_y=True)\n>>> tree = DecisionTreeClassifier(random_state=0)\n>>> train_sizes, train_scores, test_scores = learning_curve(\n...     tree, X, y)\n>>> display = LearningCurveDisplay(train_sizes=train_sizes,\n...     train_scores=train_scores, test_scores=test_scores, score_name=\"Score\")\n>>> display.plot()\n<...>\n>>> plt.show()"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    sklearn.model_selection.learning_curve : Compute the learning curve.\n\n    Examples\n    --------\n    >>> import matplotlib.pyplot as plt\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.model_selection import LearningCurveDisplay, learning_curve\n    >>> from sklearn.tree import DecisionTreeClassifier\n    >>> X, y = load_iris(return_X_y=True)\n    >>> tree = DecisionTreeClassifier(random_state=0)\n    >>> train_sizes, train_scores, test_scores = learning_curve(\n    ...     tree, X, y)\n    >>> display = LearningCurveDisplay(train_sizes=train_sizes,\n    ...     train_scores=train_scores, test_scores=test_scores, score_name=\"Score\")\n    >>> display.plot()\n    <...>\n    >>> plt.show()",
        "notes": "",
        "examples": "--------\n    >>> import matplotlib.pyplot as plt\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.model_selection import LearningCurveDisplay, learning_curve\n    >>> from sklearn.tree import DecisionTreeClassifier\n    >>> X, y = load_iris(return_X_y=True)\n    >>> tree = DecisionTreeClassifier(random_state=0)\n    >>> train_sizes, train_scores, test_scores = learning_curve(\n    ...     tree, X, y)\n    >>> display = LearningCurveDisplay(train_sizes=train_sizes,\n    ...     train_scores=train_scores, test_scores=test_scores, score_name=\"Score\")\n    >>> display.plot()\n    <...>\n    >>> plt.show()"
      },
      "methods": [
        {
          "name": "from_estimator",
          "signature": "from_estimator(estimator, X, y, *, groups=None, train_sizes=array([0.1  , 0.325, 0.55 , 0.775, 1.   ]), cv=None, scoring=None, exploit_incremental_learning=False, n_jobs=None, pre_dispatch='all', verbose=0, shuffle=False, random_state=None, error_score=nan, fit_params=None, ax=None, negate_score=False, score_name=None, score_type='both', std_display_style='fill_between', line_kw=None, fill_between_kw=None, errorbar_kw=None)",
          "documentation": {
            "description": "Create a learning curve display from an estimator.\n\n        Read more in the :ref:`User Guide <visualizations>` for general\n        information about the visualization API and :ref:`detailed\n        documentation <learning_curve>` regarding the learning curve\n        visualization.\n\n        Parameters\n        ----------\n        estimator : object type that implements the \"fit\" and \"predict\" methods\n            An object of that type which is cloned for each validation.\n\n        X : array-like of shape (n_samples, n_features)\n            Training data, where `n_samples` is the number of samples and\n            `n_features` is the number of features.\n\n        y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None\n            Target relative to X for classification or regression;\n            None for unsupervised learning.\n\n        groups : array-like of shape (n_samples,), default=None\n            Group labels for the samples used while splitting the dataset into\n            train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n            instance (e.g., :class:`GroupKFold`).\n\n        train_sizes : array-like of shape (n_ticks,),                 default=np.linspace(0.1, 1.0, 5)\n            Relative or absolute numbers of training examples that will be used\n            to generate the learning curve. If the dtype is float, it is\n            regarded as a fraction of the maximum size of the training set\n            (that is determined by the selected validation method), i.e. it has\n            to be within (0, 1]. Otherwise it is interpreted as absolute sizes\n            of the training sets. Note that for classification the number of\n            samples usually have to be big enough to contain at least one\n            sample from each class.\n\n        cv : int, cross-validation generator or an iterable, default=None\n            Determines the cross-validation splitting strategy.\n            Possible inputs for cv are:\n\n            - None, to use the default 5-fold cross validation,\n            - int, to specify the number of folds in a `(Stratified)KFold`,\n            - :term:`CV splitter`,\n            - An iterable yielding (train, test) splits as arrays of indices.\n\n            For int/None inputs, if the estimator is a classifier and `y` is\n            either binary or multiclass,\n            :class:`~sklearn.model_selection.StratifiedKFold` is used. In all\n            other cases, :class:`~sklearn.model_selection.KFold` is used. These\n            splitters are instantiated with `shuffle=False` so the splits will\n            be the same across calls.\n\n            Refer :ref:`User Guide <cross_validation>` for the various\n            cross-validation strategies that can be used here.\n\n        scoring : str or callable, default=None\n            A string (see :ref:`scoring_parameter`) or\n            a scorer callable object / function with signature\n            `scorer(estimator, X, y)` (see :ref:`scoring_callable`).\n\n        exploit_incremental_learning : bool, default=False\n            If the estimator supports incremental learning, this will be\n            used to speed up fitting for different training set sizes.\n\n        n_jobs : int, default=None\n            Number of jobs to run in parallel. Training the estimator and\n            computing the score are parallelized over the different training\n            and test sets. `None` means 1 unless in a\n            :obj:`joblib.parallel_backend` context. `-1` means using all\n            processors. See :term:`Glossary <n_jobs>` for more details.\n\n        pre_dispatch : int or str, default='all'\n            Number of predispatched jobs for parallel execution (default is\n            all). The option can reduce the allocated memory. The str can\n            be an expression like '2*n_jobs'.\n\n        verbose : int, default=0\n            Controls the verbosity: the higher, the more messages.\n\n        shuffle : bool, default=False\n            Whether to shuffle training data before taking prefixes of it\n            based on`train_sizes`.\n\n        random_state : int, RandomState instance or None, default=None\n            Used when `shuffle` is True. Pass an int for reproducible\n            output across multiple function calls.\n            See :term:`Glossary <random_state>`.\n\n        error_score : 'raise' or numeric, default=np.nan\n            Value to assign to the score if an error occurs in estimator\n            fitting. If set to 'raise', the error is raised. If a numeric value\n            is given, FitFailedWarning is raised.\n\n        fit_params : dict, default=None\n            Parameters to pass to the fit method of the estimator.\n\n        ax : matplotlib Axes, default=None\n            Axes object to plot on. If `None`, a new figure and axes is\n            created.\n\n        negate_score : bool, default=False\n            Whether or not to negate the scores obtained through\n            :func:`~sklearn.model_selection.learning_curve`. This is\n            particularly useful when using the error denoted by `neg_*` in\n            `scikit-learn`.\n\n        score_name : str, default=None\n            The name of the score used to decorate the y-axis of the plot. It will\n            override the name inferred from the `scoring` parameter. If `score` is\n            `None`, we use `\"Score\"` if `negate_score` is `False` and `\"Negative score\"`\n            otherwise. If `scoring` is a string or a callable, we infer the name. We\n            replace `_` by spaces and capitalize the first letter. We remove `neg_` and\n            replace it by `\"Negative\"` if `negate_score` is\n            `False` or just remove it otherwise.\n\n        score_type : {\"test\", \"train\", \"both\"}, default=\"both\"\n            The type of score to plot. Can be one of `\"test\"`, `\"train\"`, or\n            `\"both\"`.\n\n        std_display_style : {\"errorbar\", \"fill_between\"} or None, default=\"fill_between\"\n            The style used to display the score standard deviation around the\n            mean score. If `None`, no representation of the standard deviation\n            is displayed.\n\n        line_kw : dict, default=None\n            Additional keyword arguments passed to the `plt.plot` used to draw\n            the mean score.\n\n        fill_between_kw : dict, default=None\n            Additional keyword arguments passed to the `plt.fill_between` used\n            to draw the score standard deviation.\n\n        errorbar_kw : dict, default=None\n            Additional keyword arguments passed to the `plt.errorbar` used to\n            draw mean score and standard deviation score.\n\n        Returns\n        -------\n        display : :class:`~sklearn.model_selection.LearningCurveDisplay`\n            Object that stores computed values.",
            "parameters": {
              "estimator": {
                "type": "object type that implements the \"fit\" and \"predict\" methods",
                "description": ""
              },
              "An": {
                "type": "object of that type which is cloned for each validation.",
                "description": ""
              },
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples and",
                "description": "`n_features` is the number of features."
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs) or None"
              },
              "Target": {
                "type": "relative to X for classification or regression;",
                "description": ""
              },
              "None": {
                "type": "for unsupervised learning.",
                "description": ""
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "Group": {
                "type": "labels for the samples used while splitting the dataset into",
                "description": "train/test set. Only used in conjunction with a \"Group\" :term:`cv`"
              },
              "instance": {
                "type": "e.g., :class:`GroupKFold`",
                "description": "."
              },
              "train_sizes": {
                "type": "array",
                "description": "like of shape (n_ticks,),                 default=np.linspace(0.1, 1.0, 5)"
              },
              "Relative": {
                "type": "or absolute numbers of training examples that will be used",
                "description": ""
              },
              "to": {
                "type": "be within (0, 1]. Otherwise it is interpreted as absolute sizes",
                "description": ""
              },
              "regarded": {
                "type": "as a fraction of the maximum size of the training set",
                "description": "(that is determined by the selected validation method), i.e. it has"
              },
              "of": {
                "type": "the training sets. Note that for classification the number of",
                "description": ""
              },
              "samples": {
                "type": "usually have to be big enough to contain at least one",
                "description": ""
              },
              "sample": {
                "type": "from each class.",
                "description": ""
              },
              "cv": {
                "type": "int, cross",
                "description": "validation generator or an iterable, default=None"
              },
              "Determines": {
                "type": "the cross-validation splitting strategy.",
                "description": ""
              },
              "Possible": {
                "type": "inputs for cv are:",
                "description": "- None, to use the default 5-fold cross validation,\n- int, to specify the number of folds in a `(Stratified)KFold`,\n- :term:`CV splitter`,\n- An iterable yielding (train, test) splits as arrays of indices."
              },
              "For": {
                "type": "int/None inputs, if the estimator is a classifier and `y` is",
                "description": ""
              },
              "either": {
                "type": "binary or multiclass,",
                "description": ":class:`~sklearn.model_selection.StratifiedKFold` is used. In all"
              },
              "other": {
                "type": "cases, :class:`~sklearn.model_selection.KFold` is used. These",
                "description": ""
              },
              "splitters": {
                "type": "are instantiated with `shuffle=False` so the splits will",
                "description": ""
              },
              "be": {
                "type": "an expression like '2*n_jobs'.",
                "description": ""
              },
              "Refer": {
                "type": "ref:`User Guide <cross_validation>` for the various",
                "description": "cross-validation strategies that can be used here."
              },
              "scoring": {
                "type": "str or callable, default=None",
                "description": ""
              },
              "A": {
                "type": "string (see :ref:`scoring_parameter`) or",
                "description": ""
              },
              "a": {
                "type": "scorer callable object / function with signature",
                "description": "`scorer(estimator, X, y)` (see :ref:`scoring_callable`)."
              },
              "exploit_incremental_learning": {
                "type": "bool, default=False",
                "description": ""
              },
              "If": {
                "type": "the estimator supports incremental learning, this will be",
                "description": ""
              },
              "used": {
                "type": "to speed up fitting for different training set sizes.",
                "description": ""
              },
              "n_jobs": {
                "type": "int, default=None",
                "description": ""
              },
              "Number": {
                "type": "of predispatched jobs for parallel execution (default is",
                "description": "all). The option can reduce the allocated memory. The str can"
              },
              "computing": {
                "type": "the score are parallelized over the different training",
                "description": ""
              },
              "and": {
                "type": "test sets. `None` means 1 unless in a",
                "description": ":obj:`joblib.parallel_backend` context. `-1` means using all\nprocessors. See :term:`Glossary <n_jobs>` for more details."
              },
              "pre_dispatch": {
                "type": "int or str, default='all'",
                "description": ""
              },
              "verbose": {
                "type": "int, default=0",
                "description": ""
              },
              "Controls": {
                "type": "the verbosity: the higher, the more messages.",
                "description": ""
              },
              "shuffle": {
                "type": "bool, default=False",
                "description": ""
              },
              "Whether": {
                "type": "to shuffle training data before taking prefixes of it",
                "description": ""
              },
              "based": {
                "type": "on`train_sizes`.",
                "description": ""
              },
              "random_state": {
                "type": "int, RandomState instance or None, default=None",
                "description": ""
              },
              "Used": {
                "type": "when `shuffle` is True. Pass an int for reproducible",
                "description": ""
              },
              "output": {
                "type": "across multiple function calls.",
                "description": ""
              },
              "See": {
                "type": "term:`Glossary <random_state>`.",
                "description": ""
              },
              "error_score": {
                "type": "'raise' or numeric, default=np.nan",
                "description": ""
              },
              "Value": {
                "type": "to assign to the score if an error occurs in estimator",
                "description": "fitting. If set to 'raise', the error is raised. If a numeric value"
              },
              "is": {
                "type": "given, FitFailedWarning is raised.",
                "description": ""
              },
              "fit_params": {
                "type": "dict, default=None",
                "description": ""
              }
            },
            "returns": "-------\n        display : :class:`~sklearn.model_selection.LearningCurveDisplay`\n            Object that stores computed values.\n\n        Examples\n        --------\n        >>> import matplotlib.pyplot as plt\n        >>> from sklearn.datasets import load_iris\n        >>> from sklearn.model_selection import LearningCurveDisplay\n        >>> from sklearn.tree import DecisionTreeClassifier\n        >>> X, y = load_iris(return_X_y=True)\n        >>> tree = DecisionTreeClassifier(random_state=0)\n        >>> LearningCurveDisplay.from_estimator(tree, X, y)\n        <...>\n        >>> plt.show()",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n        >>> import matplotlib.pyplot as plt\n        >>> from sklearn.datasets import load_iris\n        >>> from sklearn.model_selection import LearningCurveDisplay\n        >>> from sklearn.tree import DecisionTreeClassifier\n        >>> X, y = load_iris(return_X_y=True)\n        >>> tree = DecisionTreeClassifier(random_state=0)\n        >>> LearningCurveDisplay.from_estimator(tree, X, y)\n        <...>\n        >>> plt.show()"
          }
        },
        {
          "name": "plot",
          "signature": "plot(self, ax=None, *, negate_score=False, score_name=None, score_type='both', std_display_style='fill_between', line_kw=None, fill_between_kw=None, errorbar_kw=None)",
          "documentation": {
            "description": "Plot visualization.\n\n        Parameters\n        ----------\n        ax : matplotlib Axes, default=None\n            Axes object to plot on. If `None`, a new figure and axes is\n            created.\n\n        negate_score : bool, default=False\n            Whether or not to negate the scores obtained through\n            :func:`~sklearn.model_selection.learning_curve`. This is\n            particularly useful when using the error denoted by `neg_*` in\n            `scikit-learn`.\n\n        score_name : str, default=None\n            The name of the score used to decorate the y-axis of the plot. It will\n            override the name inferred from the `scoring` parameter. If `score` is\n            `None`, we use `\"Score\"` if `negate_score` is `False` and `\"Negative score\"`\n            otherwise. If `scoring` is a string or a callable, we infer the name. We\n            replace `_` by spaces and capitalize the first letter. We remove `neg_` and\n            replace it by `\"Negative\"` if `negate_score` is\n            `False` or just remove it otherwise.\n\n        score_type : {\"test\", \"train\", \"both\"}, default=\"both\"\n            The type of score to plot. Can be one of `\"test\"`, `\"train\"`, or\n            `\"both\"`.\n\n        std_display_style : {\"errorbar\", \"fill_between\"} or None, default=\"fill_between\"\n            The style used to display the score standard deviation around the\n            mean score. If None, no standard deviation representation is\n            displayed.\n\n        line_kw : dict, default=None\n            Additional keyword arguments passed to the `plt.plot` used to draw\n            the mean score.\n\n        fill_between_kw : dict, default=None\n            Additional keyword arguments passed to the `plt.fill_between` used\n            to draw the score standard deviation.\n\n        errorbar_kw : dict, default=None\n            Additional keyword arguments passed to the `plt.errorbar` used to\n            draw mean score and standard deviation score.",
            "parameters": {
              "ax": {
                "type": "matplotlib Axes, default=None",
                "description": ""
              },
              "Axes": {
                "type": "object to plot on. If `None`, a new figure and axes is",
                "description": "created."
              },
              "negate_score": {
                "type": "bool, default=False",
                "description": ""
              },
              "Whether": {
                "type": "or not to negate the scores obtained through",
                "description": ":func:`~sklearn.model_selection.learning_curve`. This is"
              },
              "particularly": {
                "type": "useful when using the error denoted by `neg_*` in",
                "description": "`scikit-learn`."
              },
              "score_name": {
                "type": "str, default=None",
                "description": ""
              },
              "The": {
                "type": "style used to display the score standard deviation around the",
                "description": ""
              },
              "override": {
                "type": "the name inferred from the `scoring` parameter. If `score` is",
                "description": "`None`, we use `\"Score\"` if `negate_score` is `False` and `\"Negative score\"`\notherwise. If `scoring` is a string or a callable, we infer the name. We"
              },
              "replace": {
                "type": "it by `\"Negative\"` if `negate_score` is",
                "description": "`False` or just remove it otherwise."
              },
              "score_type": {
                "type": "{\"test\", \"train\", \"both\"}, default=\"both\"",
                "description": ""
              },
              "std_display_style": {
                "type": "{\"errorbar\", \"fill_between\"} or None, default=\"fill_between\"",
                "description": ""
              },
              "mean": {
                "type": "score. If None, no standard deviation representation is",
                "description": "displayed."
              },
              "line_kw": {
                "type": "dict, default=None",
                "description": ""
              },
              "Additional": {
                "type": "keyword arguments passed to the `plt.errorbar` used to",
                "description": ""
              },
              "the": {
                "type": "mean score.",
                "description": ""
              },
              "fill_between_kw": {
                "type": "dict, default=None",
                "description": ""
              },
              "to": {
                "type": "draw the score standard deviation.",
                "description": ""
              },
              "errorbar_kw": {
                "type": "dict, default=None",
                "description": ""
              },
              "draw": {
                "type": "mean score and standard deviation score.",
                "description": "Returns\n-------"
              },
              "display": {
                "type": ":class:`~sklearn.model_selection.LearningCurveDisplay`",
                "description": ""
              },
              "Object": {
                "type": "that stores computed values.",
                "description": ""
              }
            },
            "returns": "-------\n        display : :class:`~sklearn.model_selection.LearningCurveDisplay`\n            Object that stores computed values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "LeaveOneGroupOut",
      "documentation": {
        "description": "Leave One Group Out cross-validator.\n\n    Provides train/test indices to split data such that each training set is\n    comprised of all samples except ones belonging to one specific group.\n    Arbitrary domain specific group information is provided as an array of integers\n    that encodes the group of each sample.\n\n    For instance the groups could be the year of collection of the samples\n    and thus allow for cross-validation against time-based splits.\n\n    Read more in the :ref:`User Guide <leave_one_group_out>`.\n\n    Notes\n    -----\n    Splits are ordered according to the index of the group left out. The first\n    split has testing set consisting of the group whose index in `groups` is\n    lowest, and so on.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\n    GroupKFold: K-fold iterator variant with non-overlapping groups.",
        "notes": "-----\n    Splits are ordered according to the index of the group left out. The first\n    split has testing set consisting of the group whose index in `groups` is\n    lowest, and so on.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import LeaveOneGroupOut\n    >>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\n    >>> y = np.array([1, 2, 1, 2])\n    >>> groups = np.array([1, 1, 2, 2])\n    >>> logo = LeaveOneGroupOut()\n    >>> logo.get_n_splits(X, y, groups)\n    2\n    >>> logo.get_n_splits(groups=groups)  # 'groups' is always required\n    2\n    >>> print(logo)\n    LeaveOneGroupOut()\n    >>> for i, (train_index, test_index) in enumerate(logo.split(X, y, groups)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n    ...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\n    Fold 0:\n      Train: index=[2 3], group=[2 2]\n      Test:  index=[0 1], group=[1 1]\n    Fold 1:\n      Train: index=[0 1], group=[1 1]\n      Test:  index=[2 3], group=[2 2]\n\n    See also\n    --------\n    GroupKFold: K-fold iterator variant with non-overlapping groups.",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import LeaveOneGroupOut\n    >>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\n    >>> y = np.array([1, 2, 1, 2])\n    >>> groups = np.array([1, 1, 2, 2])\n    >>> logo = LeaveOneGroupOut()\n    >>> logo.get_n_splits(X, y, groups)\n    2\n    >>> logo.get_n_splits(groups=groups)  # 'groups' is always required\n    2\n    >>> print(logo)\n    LeaveOneGroupOut()\n    >>> for i, (train_index, test_index) in enumerate(logo.split(X, y, groups)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n    ...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\n    Fold 0:\n      Train: index=[2 3], group=[2 2]\n      Test:  index=[0 1], group=[1 1]\n    Fold 1:\n      Train: index=[0 1], group=[1 1]\n      Test:  index=[2 3], group=[2 2]\n\n    See also\n    --------\n    GroupKFold: K-fold iterator variant with non-overlapping groups."
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n\n        y : object\n            Always ignored, exists for compatibility.\n\n        groups : array-like of shape (n_samples,)\n            Group labels for the samples used while splitting the dataset into\n            train/test set. This 'groups' parameter must always be specified to\n            calculate the number of splits, though the other parameters can be\n            omitted.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": ""
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Group": {
                "type": "labels for the samples used while splitting the dataset into",
                "description": "train/test set. This 'groups' parameter must always be specified to"
              },
              "calculate": {
                "type": "the number of splits, though the other parameters can be",
                "description": "omitted.\nReturns\n-------"
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_split_request",
          "signature": "set_split_request(self: sklearn.model_selection._split.LeaveOneGroupOut, *, groups: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._split.LeaveOneGroupOut",
          "documentation": {
            "description": "Request metadata passed to the ``split`` method.",
            "parameters": {
              "groups": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``groups`` parameter in ``split``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``split`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``split``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        groups : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``groups`` parameter in ``split``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": ""
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Group": {
                "type": "labels for the samples used while splitting the dataset into",
                "description": "train/test set.\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "LeaveOneOut",
      "documentation": {
        "description": "Leave-One-Out cross-validator.\n\n    Provides train/test indices to split data in train/test sets. Each\n    sample is used once as a test set (singleton) while the remaining\n    samples form the training set.\n\n    Note: ``LeaveOneOut()`` is equivalent to ``KFold(n_splits=n)`` and\n    ``LeavePOut(p=1)`` where ``n`` is the number of samples.\n\n    Due to the high number of test sets (which is the same as the\n    number of samples) this cross-validation method can be very costly.\n    For large datasets one should favor :class:`KFold`, :class:`ShuffleSplit`\n    or :class:`StratifiedKFold`.\n\n    Read more in the :ref:`User Guide <leave_one_out>`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "--------\n    LeaveOneGroupOut : For splitting the data according to explicit,\n        domain-specific stratification of the dataset.\n    GroupKFold : K-fold iterator variant with non-overlapping groups.",
        "notes": "``LeaveOneOut()`` is equivalent to ``KFold(n_splits=n)`` and\n    ``LeavePOut(p=1)`` where ``n`` is the number of samples.\n\n    Due to the high number of test sets (which is the same as the\n    number of samples) this cross-validation method can be very costly.\n    For large datasets one should favor :class:`KFold`, :class:`ShuffleSplit`\n    or :class:`StratifiedKFold`.\n\n    Read more in the :ref:`User Guide <leave_one_out>`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import LeaveOneOut\n    >>> X = np.array([[1, 2], [3, 4]])\n    >>> y = np.array([1, 2])\n    >>> loo = LeaveOneOut()\n    >>> loo.get_n_splits(X)\n    2\n    >>> print(loo)\n    LeaveOneOut()\n    >>> for i, (train_index, test_index) in enumerate(loo.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[1]\n      Test:  index=[0]\n    Fold 1:\n      Train: index=[0]\n      Test:  index=[1]\n\n    See Also\n    --------\n    LeaveOneGroupOut : For splitting the data according to explicit,\n        domain-specific stratification of the dataset.\n    GroupKFold : K-fold iterator variant with non-overlapping groups.",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import LeaveOneOut\n    >>> X = np.array([[1, 2], [3, 4]])\n    >>> y = np.array([1, 2])\n    >>> loo = LeaveOneOut()\n    >>> loo.get_n_splits(X)\n    2\n    >>> print(loo)\n    LeaveOneOut()\n    >>> for i, (train_index, test_index) in enumerate(loo.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[1]\n      Test:  index=[0]\n    Fold 1:\n      Train: index=[0]\n      Test:  index=[1]\n\n    See Also\n    --------\n    LeaveOneGroupOut : For splitting the data according to explicit,\n        domain-specific stratification of the dataset.\n    GroupKFold : K-fold iterator variant with non-overlapping groups."
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Training data, where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n\n        y : object\n            Always ignored, exists for compatibility.\n\n        groups : object\n            Always ignored, exists for compatibility.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Returns\n-------"
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Yields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "LeavePGroupsOut",
      "documentation": {
        "description": "Leave P Group(s) Out cross-validator.\n\n    Provides train/test indices to split data according to a third-party\n    provided group. This group information can be used to encode arbitrary\n    domain specific stratifications of the samples as integers.\n\n    For instance the groups could be the year of collection of the samples\n    and thus allow for cross-validation against time-based splits.\n\n    The difference between LeavePGroupsOut and LeaveOneGroupOut is that\n    the former builds the test sets with all the samples assigned to\n    ``p`` different values of the groups while the latter uses samples\n    all assigned the same groups.\n\n    Read more in the :ref:`User Guide <leave_p_groups_out>`.\n\n    Parameters\n    ----------\n    n_groups : int\n        Number of groups (``p``) to leave out in the test split.",
        "parameters": {
          "n_groups": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of groups (``p``) to leave out in the test split.",
            "description": "Examples\n--------\n>>> import numpy as np\n>>> from sklearn.model_selection import LeavePGroupsOut\n>>> X = np.array([[1, 2], [3, 4], [5, 6]])\n>>> y = np.array([1, 2, 1])\n>>> groups = np.array([1, 2, 3])\n>>> lpgo = LeavePGroupsOut(n_groups=2)\n>>> lpgo.get_n_splits(X, y, groups)\n3\n>>> lpgo.get_n_splits(groups=groups)  # 'groups' is always required\n3\n>>> print(lpgo)"
          },
          "LeavePGroupsOut": {
            "type": "n_groups=2",
            "description": ">>> for i, (train_index, test_index) in enumerate(lpgo.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")"
          },
          "Fold": {
            "type": "2:",
            "description": ""
          },
          "Train": {
            "type": "index=[0], group=[1]",
            "description": ""
          },
          "Test": {
            "type": "index=[1 2], group=[2 3]",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "GroupKFold": {
            "type": "K",
            "description": "fold iterator variant with non-overlapping groups."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    GroupKFold : K-fold iterator variant with non-overlapping groups.",
        "notes": "",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import LeavePGroupsOut\n    >>> X = np.array([[1, 2], [3, 4], [5, 6]])\n    >>> y = np.array([1, 2, 1])\n    >>> groups = np.array([1, 2, 3])\n    >>> lpgo = LeavePGroupsOut(n_groups=2)\n    >>> lpgo.get_n_splits(X, y, groups)\n    3\n    >>> lpgo.get_n_splits(groups=groups)  # 'groups' is always required\n    3\n    >>> print(lpgo)\n    LeavePGroupsOut(n_groups=2)\n    >>> for i, (train_index, test_index) in enumerate(lpgo.split(X, y, groups)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}, group={groups[train_index]}\")\n    ...     print(f\"  Test:  index={test_index}, group={groups[test_index]}\")\n    Fold 0:\n      Train: index=[2], group=[3]\n      Test:  index=[0 1], group=[1 2]\n    Fold 1:\n      Train: index=[1], group=[2]\n      Test:  index=[0 2], group=[1 3]\n    Fold 2:\n      Train: index=[0], group=[1]\n      Test:  index=[1 2], group=[2 3]\n\n    See Also\n    --------\n    GroupKFold : K-fold iterator variant with non-overlapping groups."
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n\n        y : object\n            Always ignored, exists for compatibility.\n\n        groups : array-like of shape (n_samples,)\n            Group labels for the samples used while splitting the dataset into\n            train/test set. This 'groups' parameter must always be specified to\n            calculate the number of splits, though the other parameters can be\n            omitted.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": ""
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Group": {
                "type": "labels for the samples used while splitting the dataset into",
                "description": "train/test set. This 'groups' parameter must always be specified to"
              },
              "calculate": {
                "type": "the number of splits, though the other parameters can be",
                "description": "omitted.\nReturns\n-------"
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_split_request",
          "signature": "set_split_request(self: sklearn.model_selection._split.LeavePGroupsOut, *, groups: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._split.LeavePGroupsOut",
          "documentation": {
            "description": "Request metadata passed to the ``split`` method.",
            "parameters": {
              "groups": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``groups`` parameter in ``split``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``split`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``split``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        groups : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``groups`` parameter in ``split``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": ""
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Group": {
                "type": "labels for the samples used while splitting the dataset into",
                "description": "train/test set.\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "LeavePOut",
      "documentation": {
        "description": "Leave-P-Out cross-validator.\n\n    Provides train/test indices to split data in train/test sets. This results\n    in testing on all distinct samples of size p, while the remaining n - p\n    samples form the training set in each iteration.\n\n    Note: ``LeavePOut(p)`` is NOT equivalent to\n    ``KFold(n_splits=n_samples // p)`` which creates non-overlapping test sets.\n\n    Due to the high number of iterations which grows combinatorically with the\n    number of samples this cross-validation method can be very costly. For\n    large datasets one should favor :class:`KFold`, :class:`StratifiedKFold`\n    or :class:`ShuffleSplit`.\n\n    Read more in the :ref:`User Guide <leave_p_out>`.\n\n    Parameters\n    ----------\n    p : int\n        Size of the test sets. Must be strictly less than the number of\n        samples.",
        "parameters": {
          "p": {
            "type": "int",
            "description": ""
          },
          "Size": {
            "type": "of the test sets. Must be strictly less than the number of",
            "description": "samples.\nExamples\n--------\n>>> import numpy as np\n>>> from sklearn.model_selection import LeavePOut\n>>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\n>>> y = np.array([1, 2, 3, 4])\n>>> lpo = LeavePOut(2)\n>>> lpo.get_n_splits(X)\n6\n>>> print(lpo)"
          },
          "LeavePOut": {
            "type": "p=2",
            "description": ">>> for i, (train_index, test_index) in enumerate(lpo.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")"
          },
          "Fold": {
            "type": "5:",
            "description": ""
          },
          "Train": {
            "type": "index=[0 1]",
            "description": ""
          },
          "Test": {
            "type": "index=[2 3]",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "``LeavePOut(p)`` is NOT equivalent to\n    ``KFold(n_splits=n_samples // p)`` which creates non-overlapping test sets.\n\n    Due to the high number of iterations which grows combinatorically with the\n    number of samples this cross-validation method can be very costly. For\n    large datasets one should favor :class:`KFold`, :class:`StratifiedKFold`\n    or :class:`ShuffleSplit`.\n\n    Read more in the :ref:`User Guide <leave_p_out>`.\n\n    Parameters\n    ----------\n    p : int\n        Size of the test sets. Must be strictly less than the number of\n        samples.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import LeavePOut\n    >>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\n    >>> y = np.array([1, 2, 3, 4])\n    >>> lpo = LeavePOut(2)\n    >>> lpo.get_n_splits(X)\n    6\n    >>> print(lpo)\n    LeavePOut(p=2)\n    >>> for i, (train_index, test_index) in enumerate(lpo.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[2 3]\n      Test:  index=[0 1]\n    Fold 1:\n      Train: index=[1 3]\n      Test:  index=[0 2]\n    Fold 2:\n      Train: index=[1 2]\n      Test:  index=[0 3]\n    Fold 3:\n      Train: index=[0 3]\n      Test:  index=[1 2]\n    Fold 4:\n      Train: index=[0 2]\n      Test:  index=[1 3]\n    Fold 5:\n      Train: index=[0 1]\n      Test:  index=[2 3]",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import LeavePOut\n    >>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\n    >>> y = np.array([1, 2, 3, 4])\n    >>> lpo = LeavePOut(2)\n    >>> lpo.get_n_splits(X)\n    6\n    >>> print(lpo)\n    LeavePOut(p=2)\n    >>> for i, (train_index, test_index) in enumerate(lpo.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[2 3]\n      Test:  index=[0 1]\n    Fold 1:\n      Train: index=[1 3]\n      Test:  index=[0 2]\n    Fold 2:\n      Train: index=[1 2]\n      Test:  index=[0 3]\n    Fold 3:\n      Train: index=[0 3]\n      Test:  index=[1 2]\n    Fold 4:\n      Train: index=[0 2]\n      Test:  index=[1 3]\n    Fold 5:\n      Train: index=[0 1]\n      Test:  index=[2 3]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Yields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ParameterGrid",
      "documentation": {
        "description": "Grid of parameters with a discrete number of values for each.\n\n    Can be used to iterate over parameter value combinations with the\n    Python built-in function iter.\n    The order of the generated parameter combinations is deterministic.\n\n    Read more in the :ref:`User Guide <grid_search>`.\n\n    Parameters\n    ----------\n    param_grid : dict of str to sequence, or sequence of such\n        The parameter grid to explore, as a dictionary mapping estimator\n        parameters to sequences of allowed values.\n\n        An empty dict signifies default parameters.\n\n        A sequence of dicts signifies a sequence of grids to search, and is\n        useful to avoid exploring parameter combinations that make no sense\n        or have no effect. See the examples below.",
        "parameters": {
          "param_grid": {
            "type": "dict of str to sequence, or sequence of such",
            "description": ""
          },
          "The": {
            "type": "parameter grid to explore, as a dictionary mapping estimator",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    GridSearchCV : Uses :class:`ParameterGrid` to perform a full parallelized\n        parameter search.",
        "notes": "",
        "examples": "--------\n    >>> from sklearn.model_selection import ParameterGrid\n    >>> param_grid = {'a': [1, 2], 'b': [True, False]}\n    >>> list(ParameterGrid(param_grid)) == (\n    ...    [{'a': 1, 'b': True}, {'a': 1, 'b': False},\n    ...     {'a': 2, 'b': True}, {'a': 2, 'b': False}])\n    True\n\n    >>> grid = [{'kernel': ['linear']}, {'kernel': ['rbf'], 'gamma': [1, 10]}]\n    >>> list(ParameterGrid(grid)) == [{'kernel': 'linear'},\n    ...                               {'kernel': 'rbf', 'gamma': 1},\n    ...                               {'kernel': 'rbf', 'gamma': 10}]\n    True\n    >>> ParameterGrid(grid)[1] == {'kernel': 'rbf', 'gamma': 1}\n    True\n\n    See Also\n    --------\n    GridSearchCV : Uses :class:`ParameterGrid` to perform a full parallelized\n        parameter search."
      },
      "methods": []
    },
    {
      "name": "ParameterSampler",
      "documentation": {
        "description": "Generator on parameters sampled from given distributions.\n\n    Non-deterministic iterable over random candidate combinations for hyper-\n    parameter search. If all parameters are presented as a list,\n    sampling without replacement is performed. If at least one parameter\n    is given as a distribution, sampling with replacement is used.\n    It is highly recommended to use continuous distributions for continuous\n    parameters.\n\n    Read more in the :ref:`User Guide <grid_search>`.\n\n    Parameters\n    ----------\n    param_distributions : dict\n        Dictionary with parameters names (`str`) as keys and distributions\n        or lists of parameters to try. Distributions must provide a ``rvs``\n        method for sampling (such as those from scipy.stats.distributions).\n        If a list is given, it is sampled uniformly.\n        If a list of dicts is given, first a dict is sampled uniformly, and\n        then a parameter is sampled using that dict as above.\n\n    n_iter : int\n        Number of parameter settings that are produced.\n\n    random_state : int, RandomState instance or None, default=None\n        Pseudo random number generator state used for random uniform sampling\n        from lists of possible values instead of scipy.stats distributions.\n        Pass an int for reproducible output across multiple\n        function calls.\n        See :term:`Glossary <random_state>`.\n\n    Returns\n    -------\n    params : dict of str to any\n        **Yields** dictionaries mapping each estimator parameter to\n        as sampled value.",
        "parameters": {
          "param_distributions": {
            "type": "dict",
            "description": ""
          },
          "Dictionary": {
            "type": "with parameters names (`str`) as keys and distributions",
            "description": ""
          },
          "or": {
            "type": "lists of parameters to try. Distributions must provide a ``rvs``",
            "description": ""
          },
          "method": {
            "type": "for sampling (such as those from scipy.stats.distributions).",
            "description": ""
          },
          "If": {
            "type": "a list of dicts is given, first a dict is sampled uniformly, and",
            "description": ""
          },
          "then": {
            "type": "a parameter is sampled using that dict as above.",
            "description": ""
          },
          "n_iter": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of parameter settings that are produced.",
            "description": ""
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Pseudo": {
            "type": "random number generator state used for random uniform sampling",
            "description": ""
          },
          "from": {
            "type": "lists of possible values instead of scipy.stats distributions.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible output across multiple",
            "description": ""
          },
          "function": {
            "type": "calls.",
            "description": ""
          },
          "See": {
            "type": "term:`Glossary <random_state>`.",
            "description": "Returns\n-------"
          },
          "params": {
            "type": "dict of str to any",
            "description": "**Yields** dictionaries mapping each estimator parameter to"
          },
          "as": {
            "type": "sampled value.",
            "description": "Examples\n--------\n>>> from sklearn.model_selection import ParameterSampler\n>>> from scipy.stats.distributions import expon\n>>> import numpy as np\n>>> rng = np.random.RandomState(0)\n>>> param_grid = {'a':[1, 2], 'b': expon()}\n>>> param_list = list(ParameterSampler(param_grid, n_iter=4,\n...                                    random_state=rng))\n>>> rounded_list = [dict((k, round(v, 6)) for (k, v) in d.items())\n...                 for d in param_list]\n>>> rounded_list == [{'b': 0.89856, 'a': 1},\n...                  {'b': 0.923223, 'a': 1},\n...                  {'b': 1.878964, 'a': 2},\n...                  {'b': 1.038159, 'a': 2}]\nTrue"
          }
        },
        "returns": "-------\n    params : dict of str to any\n        **Yields** dictionaries mapping each estimator parameter to\n        as sampled value.\n\n    Examples\n    --------\n    >>> from sklearn.model_selection import ParameterSampler\n    >>> from scipy.stats.distributions import expon\n    >>> import numpy as np\n    >>> rng = np.random.RandomState(0)\n    >>> param_grid = {'a':[1, 2], 'b': expon()}\n    >>> param_list = list(ParameterSampler(param_grid, n_iter=4,\n    ...                                    random_state=rng))\n    >>> rounded_list = [dict((k, round(v, 6)) for (k, v) in d.items())\n    ...                 for d in param_list]\n    >>> rounded_list == [{'b': 0.89856, 'a': 1},\n    ...                  {'b': 0.923223, 'a': 1},\n    ...                  {'b': 1.878964, 'a': 2},\n    ...                  {'b': 1.038159, 'a': 2}]\n    True",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n    >>> from sklearn.model_selection import ParameterSampler\n    >>> from scipy.stats.distributions import expon\n    >>> import numpy as np\n    >>> rng = np.random.RandomState(0)\n    >>> param_grid = {'a':[1, 2], 'b': expon()}\n    >>> param_list = list(ParameterSampler(param_grid, n_iter=4,\n    ...                                    random_state=rng))\n    >>> rounded_list = [dict((k, round(v, 6)) for (k, v) in d.items())\n    ...                 for d in param_list]\n    >>> rounded_list == [{'b': 0.89856, 'a': 1},\n    ...                  {'b': 0.923223, 'a': 1},\n    ...                  {'b': 1.878964, 'a': 2},\n    ...                  {'b': 1.038159, 'a': 2}]\n    True"
      },
      "methods": []
    },
    {
      "name": "PredefinedSplit",
      "documentation": {
        "description": "Predefined split cross-validator.\n\n    Provides train/test indices to split data into train/test sets using a\n    predefined scheme specified by the user with the ``test_fold`` parameter.\n\n    Read more in the :ref:`User Guide <predefined_split>`.\n\n    .. versionadded:: 0.16\n\n    Parameters\n    ----------\n    test_fold : array-like of shape (n_samples,)\n        The entry ``test_fold[i]`` represents the index of the test set that\n        sample ``i`` belongs to. It is possible to exclude sample ``i`` from\n        any test set (i.e. include sample ``i`` in every training set) by\n        setting ``test_fold[i]`` equal to -1.",
        "parameters": {
          "test_fold": {
            "type": "array",
            "description": "like of shape (n_samples,)"
          },
          "The": {
            "type": "entry ``test_fold[i]`` represents the index of the test set that",
            "description": ""
          },
          "sample": {
            "type": "``i`` belongs to. It is possible to exclude sample ``i`` from",
            "description": ""
          },
          "any": {
            "type": "test set (i.e. include sample ``i`` in every training set) by",
            "description": ""
          },
          "setting": {
            "type": "``test_fold[i]`` equal to -1.",
            "description": "Examples\n--------\n>>> import numpy as np\n>>> from sklearn.model_selection import PredefinedSplit\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([0, 0, 1, 1])\n>>> test_fold = [0, 1, -1, 1]\n>>> ps = PredefinedSplit(test_fold)\n>>> ps.get_n_splits()\n2\n>>> print(ps)"
          },
          "PredefinedSplit": {
            "type": "test_fold=array([ 0,  1, -1,  1]",
            "description": ")\n>>> for i, (train_index, test_index) in enumerate(ps.split()):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")"
          },
          "Fold": {
            "type": "1:",
            "description": ""
          },
          "Train": {
            "type": "index=[0 2]",
            "description": ""
          },
          "Test": {
            "type": "index=[1 3]",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import PredefinedSplit\n    >>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n    >>> y = np.array([0, 0, 1, 1])\n    >>> test_fold = [0, 1, -1, 1]\n    >>> ps = PredefinedSplit(test_fold)\n    >>> ps.get_n_splits()\n    2\n    >>> print(ps)\n    PredefinedSplit(test_fold=array([ 0,  1, -1,  1]))\n    >>> for i, (train_index, test_index) in enumerate(ps.split()):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[1 2 3]\n      Test:  index=[0]\n    Fold 1:\n      Train: index=[0 2]\n      Test:  index=[1 3]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n\n        y : object\n            Always ignored, exists for compatibility.\n\n        groups : object\n            Always ignored, exists for compatibility.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Yields\n------"
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "RandomizedSearchCV",
      "documentation": {
        "description": "Randomized search on hyper parameters.\n\n    RandomizedSearchCV implements a \"fit\" and a \"score\" method.\n    It also implements \"score_samples\", \"predict\", \"predict_proba\",\n    \"decision_function\", \"transform\" and \"inverse_transform\" if they are\n    implemented in the estimator used.\n\n    The parameters of the estimator used to apply these methods are optimized\n    by cross-validated search over parameter settings.\n\n    In contrast to GridSearchCV, not all parameter values are tried out, but\n    rather a fixed number of parameter settings is sampled from the specified\n    distributions. The number of parameter settings that are tried is\n    given by n_iter.\n\n    If all parameters are presented as a list,\n    sampling without replacement is performed. If at least one parameter\n    is given as a distribution, sampling with replacement is used.\n    It is highly recommended to use continuous distributions for continuous\n    parameters.\n\n    Read more in the :ref:`User Guide <randomized_parameter_search>`.\n\n    .. versionadded:: 0.14\n\n    Parameters\n    ----------\n    estimator : estimator object\n        An object of that type is instantiated for each grid point.\n        This is assumed to implement the scikit-learn estimator interface.\n        Either estimator needs to provide a ``score`` function,\n        or ``scoring`` must be passed.\n\n    param_distributions : dict or list of dicts\n        Dictionary with parameters names (`str`) as keys and distributions\n        or lists of parameters to try. Distributions must provide a ``rvs``\n        method for sampling (such as those from scipy.stats.distributions).\n        If a list is given, it is sampled uniformly.\n        If a list of dicts is given, first a dict is sampled uniformly, and\n        then a parameter is sampled using that dict as above.\n\n    n_iter : int, default=10\n        Number of parameter settings that are sampled. n_iter trades\n        off runtime vs quality of the solution.\n\n    scoring : str, callable, list, tuple or dict, default=None\n        Strategy to evaluate the performance of the cross-validated model on\n        the test set.\n\n        If `scoring` represents a single score, one can use:\n\n        - a single string (see :ref:`scoring_parameter`);\n        - a callable (see :ref:`scoring_callable`) that returns a single value.\n\n        If `scoring` represents multiple scores, one can use:\n\n        - a list or tuple of unique strings;\n        - a callable returning a dictionary where the keys are the metric\n          names and the values are the metric scores;\n        - a dictionary with metric names as keys and callables as values.\n\n        See :ref:`multimetric_grid_search` for an example.\n\n        If None, the estimator's score method is used.\n\n    n_jobs : int, default=None\n        Number of jobs to run in parallel.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n        .. versionchanged:: v0.20\n           `n_jobs` default changed from 1 to None\n\n    refit : bool, str, or callable, default=True\n        Refit an estimator using the best found parameters on the whole\n        dataset.\n\n        For multiple metric evaluation, this needs to be a `str` denoting the\n        scorer that would be used to find the best parameters for refitting\n        the estimator at the end.\n\n        Where there are considerations other than maximum score in\n        choosing a best estimator, ``refit`` can be set to a function which\n        returns the selected ``best_index_`` given the ``cv_results_``. In that\n        case, the ``best_estimator_`` and ``best_params_`` will be set\n        according to the returned ``best_index_`` while the ``best_score_``\n        attribute will not be available.\n\n        The refitted estimator is made available at the ``best_estimator_``\n        attribute and permits using ``predict`` directly on this\n        ``RandomizedSearchCV`` instance.\n\n        Also for multiple metric evaluation, the attributes ``best_index_``,\n        ``best_score_`` and ``best_params_`` will only be available if\n        ``refit`` is set and all of them will be determined w.r.t this specific\n        scorer.\n\n        See ``scoring`` parameter to know more about multiple metric\n        evaluation.\n\n        .. versionchanged:: 0.20\n            Support for callable added.\n\n    cv : int, cross-validation generator or an iterable, default=None\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - None, to use the default 5-fold cross validation,\n        - integer, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For integer/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value if None changed from 3-fold to 5-fold.\n\n    verbose : int\n        Controls the verbosity: the higher, the more messages.\n\n        - >1 : the computation time for each fold and parameter candidate is\n          displayed;\n        - >2 : the score is also displayed;\n        - >3 : the fold and candidate parameter indexes are also displayed\n          together with the starting time of the computation.\n\n    pre_dispatch : int, or str, default='2*n_jobs'\n        Controls the number of jobs that get dispatched during parallel\n        execution. Reducing this number can be useful to avoid an\n        explosion of memory consumption when more jobs get dispatched\n        than CPUs can process. This parameter can be:\n\n        - None, in which case all the jobs are immediately created and spawned. Use\n          this for lightweight and fast-running jobs, to avoid delays due to on-demand\n          spawning of the jobs\n        - An int, giving the exact number of total jobs that are spawned\n        - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'\n\n    random_state : int, RandomState instance or None, default=None\n        Pseudo random number generator state used for random uniform sampling\n        from lists of possible values instead of scipy.stats distributions.\n        Pass an int for reproducible output across multiple\n        function calls.\n        See :term:`Glossary <random_state>`.\n\n    error_score : 'raise' or numeric, default=np.nan\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised. If a numeric value is given,\n        FitFailedWarning is raised. This parameter does not affect the refit\n        step, which will always raise the error.\n\n    return_train_score : bool, default=False\n        If ``False``, the ``cv_results_`` attribute will not include training\n        scores.\n        Computing training scores is used to get insights on how different\n        parameter settings impact the overfitting/underfitting trade-off.\n        However computing the scores on the training set can be computationally\n        expensive and is not strictly required to select the parameters that\n        yield the best generalization performance.\n\n        .. versionadded:: 0.19\n\n        .. versionchanged:: 0.21\n            Default value was changed from ``True`` to ``False``\n\n    Attributes\n    ----------\n    cv_results_ : dict of numpy (masked) ndarrays\n        A dict with keys as column headers and values as columns, that can be\n        imported into a pandas ``DataFrame``.\n\n        For instance the below given table\n\n        +--------------+-------------+-------------------+---+---------------+\n        | param_kernel | param_gamma | split0_test_score |...|rank_test_score|\n        +==============+=============+===================+===+===============+\n        |    'rbf'     |     0.1     |       0.80        |...|       1       |\n        +--------------+-------------+-------------------+---+---------------+\n        |    'rbf'     |     0.2     |       0.84        |...|       3       |\n        +--------------+-------------+-------------------+---+---------------+\n        |    'rbf'     |     0.3     |       0.70        |...|       2       |\n        +--------------+-------------+-------------------+---+---------------+\n\n        will be represented by a ``cv_results_`` dict of::\n\n            {\n            'param_kernel' : masked_array(data = ['rbf', 'rbf', 'rbf'],\n                                          mask = False),\n            'param_gamma'  : masked_array(data = [0.1 0.2 0.3], mask = False),\n            'split0_test_score'  : [0.80, 0.84, 0.70],\n            'split1_test_score'  : [0.82, 0.50, 0.70],\n            'mean_test_score'    : [0.81, 0.67, 0.70],\n            'std_test_score'     : [0.01, 0.24, 0.00],\n            'rank_test_score'    : [1, 3, 2],\n            'split0_train_score' : [0.80, 0.92, 0.70],\n            'split1_train_score' : [0.82, 0.55, 0.70],\n            'mean_train_score'   : [0.81, 0.74, 0.70],\n            'std_train_score'    : [0.01, 0.19, 0.00],\n            'mean_fit_time'      : [0.73, 0.63, 0.43],\n            'std_fit_time'       : [0.01, 0.02, 0.01],\n            'mean_score_time'    : [0.01, 0.06, 0.04],\n            'std_score_time'     : [0.00, 0.00, 0.00],\n            'params'             : [{'kernel' : 'rbf', 'gamma' : 0.1}, ...],\n            }\n\n        NOTE\n\n        The key ``'params'`` is used to store a list of parameter\n        settings dicts for all the parameter candidates.\n\n        The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and\n        ``std_score_time`` are all in seconds.\n\n        For multi-metric evaluation, the scores for all the scorers are\n        available in the ``cv_results_`` dict at the keys ending with that\n        scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\n        above. ('split0_test_precision', 'mean_train_precision' etc.)\n\n    best_estimator_ : estimator\n        Estimator that was chosen by the search, i.e. estimator\n        which gave highest score (or smallest loss if specified)\n        on the left out data. Not available if ``refit=False``.\n\n        For multi-metric evaluation, this attribute is present only if\n        ``refit`` is specified.\n\n        See ``refit`` parameter for more information on allowed values.\n\n    best_score_ : float\n        Mean cross-validated score of the best_estimator.\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n        This attribute is not available if ``refit`` is a function.\n\n    best_params_ : dict\n        Parameter setting that gave the best results on the hold out data.\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n    best_index_ : int\n        The index (of the ``cv_results_`` arrays) which corresponds to the best\n        candidate parameter setting.\n\n        The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n        the parameter setting for the best model, that gives the highest\n        mean score (``search.best_score_``).\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n    scorer_ : function or a dict\n        Scorer function used on the held out data to choose the best\n        parameters for the model.\n\n        For multi-metric evaluation, this attribute holds the validated\n        ``scoring`` dict which maps the scorer key to the scorer callable.\n\n    n_splits_ : int\n        The number of cross-validation splits (folds/iterations).\n\n    refit_time_ : float\n        Seconds used for refitting the best model on the whole dataset.\n\n        This is present only if ``refit`` is not False.\n\n        .. versionadded:: 0.20\n\n    multimetric_ : bool\n        Whether or not the scorers compute several metrics.\n\n    classes_ : ndarray of shape (n_classes,)\n        The classes labels. This is present only if ``refit`` is specified and\n        the underlying estimator is a classifier.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `n_features_in_` when fit.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `feature_names_in_` when fit.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    GridSearchCV : Does exhaustive search over a grid of parameters.\n    ParameterSampler : A generator over parameter settings, constructed from\n        param_distributions.\n\n    Notes\n    -----\n    The parameters selected are those that maximize the score of the held-out\n    data, according to the scoring parameter.\n\n    If `n_jobs` was set to a value higher than one, the data is copied for each\n    parameter setting(and not `n_jobs` times). This is done for efficiency\n    reasons if individual jobs take very little time, but may raise errors if\n    the dataset is large and not enough memory is available.  A workaround in\n    this case is to set `pre_dispatch`. Then, the memory is copied only\n    `pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\n    n_jobs`.",
        "parameters": {
          "estimator": {
            "type": "estimator object",
            "description": ""
          },
          "An": {
            "type": "object of that type is instantiated for each grid point.",
            "description": ""
          },
          "This": {
            "type": "attribute is not available if ``refit`` is a function.",
            "description": ""
          },
          "Either": {
            "type": "estimator needs to provide a ``score`` function,",
            "description": ""
          },
          "or": {
            "type": "lists of parameters to try. Distributions must provide a ``rvs``",
            "description": ""
          },
          "param_distributions": {
            "type": "dict or list of dicts",
            "description": ""
          },
          "Dictionary": {
            "type": "with parameters names (`str`) as keys and distributions",
            "description": ""
          },
          "method": {
            "type": "for sampling (such as those from scipy.stats.distributions).",
            "description": ""
          },
          "If": {
            "type": "``False``, the ``cv_results_`` attribute will not include training",
            "description": "scores."
          },
          "then": {
            "type": "a parameter is sampled using that dict as above.",
            "description": ""
          },
          "n_iter": {
            "type": "int, default=10",
            "description": ""
          },
          "Number": {
            "type": "of jobs to run in parallel.",
            "description": "``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n``-1`` means using all processors. See :term:`Glossary <n_jobs>`"
          },
          "off": {
            "type": "runtime vs quality of the solution.",
            "description": ""
          },
          "scoring": {
            "type": "str, callable, list, tuple or dict, default=None",
            "description": ""
          },
          "Strategy": {
            "type": "to evaluate the performance of the cross-validated model on",
            "description": ""
          },
          "the": {
            "type": "parameter setting for the best model, that gives the highest",
            "description": ""
          },
          "names": {
            "type": "and the values are the metric scores;",
            "description": "- a dictionary with metric names as keys and callables as values."
          },
          "See": {
            "type": "``refit`` parameter for more information on allowed values.",
            "description": ""
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": ""
          },
          "for": {
            "type": "more details.",
            "description": ".. versionchanged:: v0.20\n`n_jobs` default changed from 1 to None"
          },
          "refit": {
            "type": "bool, str, or callable, default=True",
            "description": ""
          },
          "Refit": {
            "type": "an estimator using the best found parameters on the whole",
            "description": "dataset."
          },
          "For": {
            "type": "multi-metric evaluation, this is not available if ``refit`` is",
            "description": "``False``. See ``refit`` parameter for more information."
          },
          "scorer": {
            "type": "that would be used to find the best parameters for refitting",
            "description": ""
          },
          "Where": {
            "type": "there are considerations other than maximum score in",
            "description": ""
          },
          "choosing": {
            "type": "a best estimator, ``refit`` can be set to a function which",
            "description": ""
          },
          "returns": {
            "type": "the selected ``best_index_`` given the ``cv_results_``. In that",
            "description": "case, the ``best_estimator_`` and ``best_params_`` will be set"
          },
          "according": {
            "type": "to the returned ``best_index_`` while the ``best_score_``",
            "description": ""
          },
          "attribute": {
            "type": "and permits using ``predict`` directly on this",
            "description": "``RandomizedSearchCV`` instance."
          },
          "The": {
            "type": "dict at ``search.cv_results_['params'][search.best_index_]`` gives",
            "description": ""
          },
          "Also": {
            "type": "for multiple metric evaluation, the attributes ``best_index_``,",
            "description": "``best_score_`` and ``best_params_`` will only be available if\n``refit`` is set and all of them will be determined w.r.t this specific\nscorer."
          },
          "Support": {
            "type": "for callable added.",
            "description": ""
          },
          "cv": {
            "type": "int, cross",
            "description": "validation generator or an iterable, default=None"
          },
          "Determines": {
            "type": "the cross-validation splitting strategy.",
            "description": ""
          },
          "Possible": {
            "type": "inputs for cv are:",
            "description": "- None, to use the default 5-fold cross validation,\n- integer, to specify the number of folds in a `(Stratified)KFold`,\n- :term:`CV splitter`,\n- An iterable yielding (train, test) splits as arrays of indices."
          },
          "either": {
            "type": "binary or multiclass, :class:`StratifiedKFold` is used. In all",
            "description": ""
          },
          "other": {
            "type": "cases, :class:`KFold` is used. These splitters are instantiated",
            "description": ""
          },
          "with": {
            "type": "`shuffle=False` so the splits will be the same across calls.",
            "description": ""
          },
          "Refer": {
            "type": "ref:`User Guide <cross_validation>` for the various",
            "description": "cross-validation strategies that can be used here.\n.. versionchanged:: 0.22\n``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "verbose": {
            "type": "int",
            "description": ""
          },
          "Controls": {
            "type": "the number of jobs that get dispatched during parallel",
            "description": "execution. Reducing this number can be useful to avoid an"
          },
          "together": {
            "type": "with the starting time of the computation.",
            "description": ""
          },
          "pre_dispatch": {
            "type": "int, or str, default='2*n_jobs'",
            "description": ""
          },
          "explosion": {
            "type": "of memory consumption when more jobs get dispatched",
            "description": ""
          },
          "than": {
            "type": "CPUs can process. This parameter can be:",
            "description": "- None, in which case all the jobs are immediately created and spawned. Use"
          },
          "this": {
            "type": "for lightweight and fast-running jobs, to avoid delays due to on-demand",
            "description": ""
          },
          "spawning": {
            "type": "of the jobs",
            "description": "- An int, giving the exact number of total jobs that are spawned\n- A str, giving an expression as a function of n_jobs, as in '2*n_jobs'"
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Pseudo": {
            "type": "random number generator state used for random uniform sampling",
            "description": ""
          },
          "from": {
            "type": "lists of possible values instead of scipy.stats distributions.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible output across multiple",
            "description": ""
          },
          "function": {
            "type": "calls.",
            "description": ""
          },
          "error_score": {
            "type": "'raise' or numeric, default=np.nan",
            "description": ""
          },
          "Value": {
            "type": "to assign to the score if an error occurs in estimator fitting.",
            "description": ""
          },
          "FitFailedWarning": {
            "type": "is raised. This parameter does not affect the refit",
            "description": "step, which will always raise the error."
          },
          "return_train_score": {
            "type": "bool, default=False",
            "description": ""
          },
          "Computing": {
            "type": "training scores is used to get insights on how different",
            "description": ""
          },
          "parameter": {
            "type": "settings impact the overfitting/underfitting trade-off.",
            "description": ""
          },
          "However": {
            "type": "computing the scores on the training set can be computationally",
            "description": ""
          },
          "expensive": {
            "type": "and is not strictly required to select the parameters that",
            "description": ""
          },
          "yield": {
            "type": "the best generalization performance.",
            "description": ".. versionadded:: 0.19\n.. versionchanged:: 0.21"
          },
          "Default": {
            "type": "value was changed from ``True`` to ``False``",
            "description": "Attributes\n----------"
          },
          "cv_results_": {
            "type": "dict of numpy (masked) ndarrays",
            "description": ""
          },
          "A": {
            "type": "dict with keys as column headers and values as columns, that can be",
            "description": ""
          },
          "imported": {
            "type": "into a pandas ``DataFrame``.",
            "description": ""
          },
          "will": {
            "type": "be represented by a ``cv_results_`` dict of::",
            "description": "{\n'param_kernel' : masked_array(data = ['rbf', 'rbf', 'rbf'],"
          },
          "mask": {
            "type": "= False),",
            "description": "'param_gamma'  : masked_array(data = [0.1 0.2 0.3], mask = False),\n'split0_test_score'  : [0.80, 0.84, 0.70],\n'split1_test_score'  : [0.82, 0.50, 0.70],\n'mean_test_score'    : [0.81, 0.67, 0.70],\n'std_test_score'     : [0.01, 0.24, 0.00],\n'rank_test_score'    : [1, 3, 2],\n'split0_train_score' : [0.80, 0.92, 0.70],\n'split1_train_score' : [0.82, 0.55, 0.70],\n'mean_train_score'   : [0.81, 0.74, 0.70],\n'std_train_score'    : [0.01, 0.19, 0.00],\n'mean_fit_time'      : [0.73, 0.63, 0.43],\n'std_fit_time'       : [0.01, 0.02, 0.01],\n'mean_score_time'    : [0.01, 0.06, 0.04],\n'std_score_time'     : [0.00, 0.00, 0.00],\n'params'             : [{'kernel' : 'rbf', 'gamma' : 0.1}, ...],\n}\nNOTE"
          },
          "settings": {
            "type": "dicts for all the parameter candidates.",
            "description": ""
          },
          "available": {
            "type": "in the ``cv_results_`` dict at the keys ending with that",
            "description": "scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\nabove. ('split0_test_precision', 'mean_train_precision' etc.)"
          },
          "best_estimator_": {
            "type": "estimator",
            "description": ""
          },
          "Estimator": {
            "type": "that was chosen by the search, i.e. estimator",
            "description": ""
          },
          "which": {
            "type": "gave highest score (or smallest loss if specified)",
            "description": ""
          },
          "on": {
            "type": "the left out data. Not available if ``refit=False``.",
            "description": ""
          },
          "best_score_": {
            "type": "float",
            "description": ""
          },
          "Mean": {
            "type": "cross-validated score of the best_estimator.",
            "description": ""
          },
          "best_params_": {
            "type": "dict",
            "description": ""
          },
          "Parameter": {
            "type": "setting that gave the best results on the hold out data.",
            "description": ""
          },
          "best_index_": {
            "type": "int",
            "description": ""
          },
          "candidate": {
            "type": "parameter setting.",
            "description": ""
          },
          "mean": {
            "type": "score (``search.best_score_``).",
            "description": ""
          },
          "scorer_": {
            "type": "function or a dict",
            "description": ""
          },
          "Scorer": {
            "type": "function used on the held out data to choose the best",
            "description": ""
          }
        },
        "returns": "the selected ``best_index_`` given the ``cv_results_``. In that\n        case, the ``best_estimator_`` and ``best_params_`` will be set\n        according to the returned ``best_index_`` while the ``best_score_``\n        attribute will not be available.\n\n        The refitted estimator is made available at the ``best_estimator_``\n        attribute and permits using ``predict`` directly on this\n        ``RandomizedSearchCV`` instance.\n\n        Also for multiple metric evaluation, the attributes ``best_index_``,\n        ``best_score_`` and ``best_params_`` will only be available if\n        ``refit`` is set and all of them will be determined w.r.t this specific\n        scorer.\n\n        See ``scoring`` parameter to know more about multiple metric\n        evaluation.\n\n        .. versionchanged:: 0.20\n            Support for callable added.\n\n    cv : int, cross-validation generator or an iterable, default=None\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - None, to use the default 5-fold cross validation,\n        - integer, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For integer/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value if None changed from 3-fold to 5-fold.\n\n    verbose : int\n        Controls the verbosity: the higher, the more messages.\n\n        - >1 : the computation time for each fold and parameter candidate is\n          displayed;\n        - >2 : the score is also displayed;\n        - >3 : the fold and candidate parameter indexes are also displayed\n          together with the starting time of the computation.\n\n    pre_dispatch : int, or str, default='2*n_jobs'\n        Controls the number of jobs that get dispatched during parallel\n        execution. Reducing this number can be useful to avoid an\n        explosion of memory consumption when more jobs get dispatched\n        than CPUs can process. This parameter can be:\n\n        - None, in which case all the jobs are immediately created and spawned. Use\n          this for lightweight and fast-running jobs, to avoid delays due to on-demand\n          spawning of the jobs\n        - An int, giving the exact number of total jobs that are spawned\n        - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'\n\n    random_state : int, RandomState instance or None, default=None\n        Pseudo random number generator state used for random uniform sampling\n        from lists of possible values instead of scipy.stats distributions.\n        Pass an int for reproducible output across multiple\n        function calls.\n        See :term:`Glossary <random_state>`.\n\n    error_score : 'raise' or numeric, default=np.nan\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised. If a numeric value is given,\n        FitFailedWarning is raised. This parameter does not affect the refit\n        step, which will always raise the error.\n\n    return_train_score : bool, default=False\n        If ``False``, the ``cv_results_`` attribute will not include training\n        scores.\n        Computing training scores is used to get insights on how different\n        parameter settings impact the overfitting/underfitting trade-off.\n        However computing the scores on the training set can be computationally\n        expensive and is not strictly required to select the parameters that\n        yield the best generalization performance.\n\n        .. versionadded:: 0.19\n\n        .. versionchanged:: 0.21\n            Default value was changed from ``True`` to ``False``\n\n    Attributes\n    ----------\n    cv_results_ : dict of numpy (masked) ndarrays\n        A dict with keys as column headers and values as columns, that can be\n        imported into a pandas ``DataFrame``.\n\n        For instance the below given table\n\n        +--------------+-------------+-------------------+---+---------------+\n        | param_kernel | param_gamma | split0_test_score |...|rank_test_score|\n        +==============+=============+===================+===+===============+\n        |    'rbf'     |     0.1     |       0.80        |...|       1       |\n        +--------------+-------------+-------------------+---+---------------+\n        |    'rbf'     |     0.2     |       0.84        |...|       3       |\n        +--------------+-------------+-------------------+---+---------------+\n        |    'rbf'     |     0.3     |       0.70        |...|       2       |\n        +--------------+-------------+-------------------+---+---------------+\n\n        will be represented by a ``cv_results_`` dict of::\n\n            {\n            'param_kernel' : masked_array(data = ['rbf', 'rbf', 'rbf'],\n                                          mask = False),\n            'param_gamma'  : masked_array(data = [0.1 0.2 0.3], mask = False),\n            'split0_test_score'  : [0.80, 0.84, 0.70],\n            'split1_test_score'  : [0.82, 0.50, 0.70],\n            'mean_test_score'    : [0.81, 0.67, 0.70],\n            'std_test_score'     : [0.01, 0.24, 0.00],\n            'rank_test_score'    : [1, 3, 2],\n            'split0_train_score' : [0.80, 0.92, 0.70],\n            'split1_train_score' : [0.82, 0.55, 0.70],\n            'mean_train_score'   : [0.81, 0.74, 0.70],\n            'std_train_score'    : [0.01, 0.19, 0.00],\n            'mean_fit_time'      : [0.73, 0.63, 0.43],\n            'std_fit_time'       : [0.01, 0.02, 0.01],\n            'mean_score_time'    : [0.01, 0.06, 0.04],\n            'std_score_time'     : [0.00, 0.00, 0.00],\n            'params'             : [{'kernel' : 'rbf', 'gamma' : 0.1}, ...],\n            }\n\n        NOTE\n\n        The key ``'params'`` is used to store a list of parameter\n        settings dicts for all the parameter candidates.\n\n        The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and\n        ``std_score_time`` are all in seconds.\n\n        For multi-metric evaluation, the scores for all the scorers are\n        available in the ``cv_results_`` dict at the keys ending with that\n        scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\n        above. ('split0_test_precision', 'mean_train_precision' etc.)\n\n    best_estimator_ : estimator\n        Estimator that was chosen by the search, i.e. estimator\n        which gave highest score (or smallest loss if specified)\n        on the left out data. Not available if ``refit=False``.\n\n        For multi-metric evaluation, this attribute is present only if\n        ``refit`` is specified.\n\n        See ``refit`` parameter for more information on allowed values.\n\n    best_score_ : float\n        Mean cross-validated score of the best_estimator.\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n        This attribute is not available if ``refit`` is a function.\n\n    best_params_ : dict\n        Parameter setting that gave the best results on the hold out data.\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n    best_index_ : int\n        The index (of the ``cv_results_`` arrays) which corresponds to the best\n        candidate parameter setting.\n\n        The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n        the parameter setting for the best model, that gives the highest\n        mean score (``search.best_score_``).\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n    scorer_ : function or a dict\n        Scorer function used on the held out data to choose the best\n        parameters for the model.\n\n        For multi-metric evaluation, this attribute holds the validated\n        ``scoring`` dict which maps the scorer key to the scorer callable.\n\n    n_splits_ : int\n        The number of cross-validation splits (folds/iterations).\n\n    refit_time_ : float\n        Seconds used for refitting the best model on the whole dataset.\n\n        This is present only if ``refit`` is not False.\n\n        .. versionadded:: 0.20\n\n    multimetric_ : bool\n        Whether or not the scorers compute several metrics.\n\n    classes_ : ndarray of shape (n_classes,)\n        The classes labels. This is present only if ``refit`` is specified and\n        the underlying estimator is a classifier.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `n_features_in_` when fit.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `feature_names_in_` when fit.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    GridSearchCV : Does exhaustive search over a grid of parameters.\n    ParameterSampler : A generator over parameter settings, constructed from\n        param_distributions.\n\n    Notes\n    -----\n    The parameters selected are those that maximize the score of the held-out\n    data, according to the scoring parameter.\n\n    If `n_jobs` was set to a value higher than one, the data is copied for each\n    parameter setting(and not `n_jobs` times). This is done for efficiency\n    reasons if individual jobs take very little time, but may raise errors if\n    the dataset is large and not enough memory is available.  A workaround in\n    this case is to set `pre_dispatch`. Then, the memory is copied only\n    `pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\n    n_jobs`.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.model_selection import RandomizedSearchCV\n    >>> from scipy.stats import uniform\n    >>> iris = load_iris()\n    >>> logistic = LogisticRegression(solver='saga', tol=1e-2, max_iter=200,\n    ...                               random_state=0)\n    >>> distributions = dict(C=uniform(loc=0, scale=4),\n    ...                      penalty=['l2', 'l1'])\n    >>> clf = RandomizedSearchCV(logistic, distributions, random_state=0)\n    >>> search = clf.fit(iris.data, iris.target)\n    >>> search.best_params_\n    {'C': np.float64(2...), 'penalty': 'l1'}",
        "raises": "",
        "see_also": "--------\n    GridSearchCV : Does exhaustive search over a grid of parameters.\n    ParameterSampler : A generator over parameter settings, constructed from\n        param_distributions.\n\n    Notes\n    -----\n    The parameters selected are those that maximize the score of the held-out\n    data, according to the scoring parameter.\n\n    If `n_jobs` was set to a value higher than one, the data is copied for each\n    parameter setting(and not `n_jobs` times). This is done for efficiency\n    reasons if individual jobs take very little time, but may raise errors if\n    the dataset is large and not enough memory is available.  A workaround in\n    this case is to set `pre_dispatch`. Then, the memory is copied only\n    `pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\n    n_jobs`.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.model_selection import RandomizedSearchCV\n    >>> from scipy.stats import uniform\n    >>> iris = load_iris()\n    >>> logistic = LogisticRegression(solver='saga', tol=1e-2, max_iter=200,\n    ...                               random_state=0)\n    >>> distributions = dict(C=uniform(loc=0, scale=4),\n    ...                      penalty=['l2', 'l1'])\n    >>> clf = RandomizedSearchCV(logistic, distributions, random_state=0)\n    >>> search = clf.fit(iris.data, iris.target)\n    >>> search.best_params_\n    {'C': np.float64(2...), 'penalty': 'l1'}",
        "notes": "The key ``'params'`` is used to store a list of parameter\n        settings dicts for all the parameter candidates.\n\n        The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and\n        ``std_score_time`` are all in seconds.\n\n        For multi-metric evaluation, the scores for all the scorers are\n        available in the ``cv_results_`` dict at the keys ending with that\n        scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\n        above. ('split0_test_precision', 'mean_train_precision' etc.)\n\n    best_estimator_ : estimator\n        Estimator that was chosen by the search, i.e. estimator\n        which gave highest score (or smallest loss if specified)\n        on the left out data. Not available if ``refit=False``.\n\n        For multi-metric evaluation, this attribute is present only if\n        ``refit`` is specified.\n\n        See ``refit`` parameter for more information on allowed values.\n\n    best_score_ : float\n        Mean cross-validated score of the best_estimator.\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n        This attribute is not available if ``refit`` is a function.\n\n    best_params_ : dict\n        Parameter setting that gave the best results on the hold out data.\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n    best_index_ : int\n        The index (of the ``cv_results_`` arrays) which corresponds to the best\n        candidate parameter setting.\n\n        The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n        the parameter setting for the best model, that gives the highest\n        mean score (``search.best_score_``).\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n    scorer_ : function or a dict\n        Scorer function used on the held out data to choose the best\n        parameters for the model.\n\n        For multi-metric evaluation, this attribute holds the validated\n        ``scoring`` dict which maps the scorer key to the scorer callable.\n\n    n_splits_ : int\n        The number of cross-validation splits (folds/iterations).\n\n    refit_time_ : float\n        Seconds used for refitting the best model on the whole dataset.\n\n        This is present only if ``refit`` is not False.\n\n        .. versionadded:: 0.20\n\n    multimetric_ : bool\n        Whether or not the scorers compute several metrics.\n\n    classes_ : ndarray of shape (n_classes,)\n        The classes labels. This is present only if ``refit`` is specified and\n        the underlying estimator is a classifier.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `n_features_in_` when fit.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `feature_names_in_` when fit.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    GridSearchCV : Does exhaustive search over a grid of parameters.\n    ParameterSampler : A generator over parameter settings, constructed from\n        param_distributions.\n\n    Notes\n    -----\n    The parameters selected are those that maximize the score of the held-out\n    data, according to the scoring parameter.\n\n    If `n_jobs` was set to a value higher than one, the data is copied for each\n    parameter setting(and not `n_jobs` times). This is done for efficiency\n    reasons if individual jobs take very little time, but may raise errors if\n    the dataset is large and not enough memory is available.  A workaround in\n    this case is to set `pre_dispatch`. Then, the memory is copied only\n    `pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\n    n_jobs`.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.model_selection import RandomizedSearchCV\n    >>> from scipy.stats import uniform\n    >>> iris = load_iris()\n    >>> logistic = LogisticRegression(solver='saga', tol=1e-2, max_iter=200,\n    ...                               random_state=0)\n    >>> distributions = dict(C=uniform(loc=0, scale=4),\n    ...                      penalty=['l2', 'l1'])\n    >>> clf = RandomizedSearchCV(logistic, distributions, random_state=0)\n    >>> search = clf.fit(iris.data, iris.target)\n    >>> search.best_params_\n    {'C': np.float64(2...), 'penalty': 'l1'}",
        "examples": "--------\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.model_selection import RandomizedSearchCV\n    >>> from scipy.stats import uniform\n    >>> iris = load_iris()\n    >>> logistic = LogisticRegression(solver='saga', tol=1e-2, max_iter=200,\n    ...                               random_state=0)\n    >>> distributions = dict(C=uniform(loc=0, scale=4),\n    ...                      penalty=['l2', 'l1'])\n    >>> clf = RandomizedSearchCV(logistic, distributions, random_state=0)\n    >>> search = clf.fit(iris.data, iris.target)\n    >>> search.best_params_\n    {'C': np.float64(2...), 'penalty': 'l1'}"
      },
      "methods": [
        {
          "name": "decision_function",
          "signature": "decision_function(self, X)",
          "documentation": {
            "description": "Call decision_function on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``decision_function``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": ""
              },
              "Must": {
                "type": "fulfill the input assumptions of the",
                "description": ""
              },
              "underlying": {
                "type": "estimator.",
                "description": "Returns\n-------"
              },
              "y_score": {
                "type": "ndarray of shape (n_samples,) or (n_samples, n_classes)                 or (n_samples, n_classes * (n_classes",
                "description": "1) / 2)"
              },
              "Result": {
                "type": "of the decision function for `X` based on the estimator with",
                "description": ""
              },
              "the": {
                "type": "best found parameters.",
                "description": ""
              }
            },
            "returns": "-------\n        y_score : ndarray of shape (n_samples,) or (n_samples, n_classes)                 or (n_samples, n_classes * (n_classes-1) / 2)\n            Result of the decision function for `X` based on the estimator with\n            the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit",
          "signature": "fit(self, X, y=None, **params)",
          "documentation": {
            "description": "Run fit with all sets of parameters.\n\n        Parameters\n        ----------\n\n        X : array-like of shape (n_samples, n_features) or (n_samples, n_samples)\n            Training vectors, where `n_samples` is the number of samples and\n            `n_features` is the number of features. For precomputed kernel or\n            distance matrix, the expected shape of X is (n_samples, n_samples).\n\n        y : array-like of shape (n_samples, n_output)             or (n_samples,), default=None\n            Target relative to X for classification or regression;\n            None for unsupervised learning.\n\n        **params : dict of str -> object\n            Parameters passed to the ``fit`` method of the estimator, the scorer,\n            and the CV splitter.\n\n            If a fit parameter is an array-like whose length is equal to\n            `num_samples` then it will be split by cross-validation along with\n            `X` and `y`. For example, the :term:`sample_weight` parameter is\n            split because `len(sample_weights) = len(X)`. However, this behavior\n            does not apply to `groups` which is passed to the splitter configured\n            via the `cv` parameter of the constructor. Thus, `groups` is used\n            *to perform the split* and determines which samples are\n            assigned to the each side of the a split.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features) or (n_samples, n_samples)"
              },
              "Training": {
                "type": "vectors, where `n_samples` is the number of samples and",
                "description": "`n_features` is the number of features. For precomputed kernel or"
              },
              "distance": {
                "type": "matrix, the expected shape of X is (n_samples, n_samples).",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples, n_output)             or (n_samples,), default=None"
              },
              "Target": {
                "type": "relative to X for classification or regression;",
                "description": ""
              },
              "None": {
                "type": "for unsupervised learning.",
                "description": "**params : dict of str -> object"
              }
            },
            "returns": "-------\n        self : object\n            Instance of fitted estimator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        .. versionadded:: 1.4",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRouter\n            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "inverse_transform",
          "signature": "inverse_transform(self, X=None, Xt=None)",
          "documentation": {
            "description": "Call inverse_transform on the estimator with the best found params.\n\n        Only available if the underlying estimator implements\n        ``inverse_transform`` and ``refit=True``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        Xt : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n            .. deprecated:: 1.5\n                `Xt` was deprecated in 1.5 and will be removed in 1.7. Use `X` instead.",
            "parameters": {
              "X": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
                "description": ""
              },
              "Must": {
                "type": "fulfill the input assumptions of the",
                "description": ""
              },
              "underlying": {
                "type": "estimator.",
                "description": ".. deprecated:: 1.5\n`Xt` was deprecated in 1.5 and will be removed in 1.7. Use `X` instead.\nReturns\n-------"
              },
              "Xt": {
                "type": "indexable, length n_samples",
                "description": ""
              },
              "Result": {
                "type": "of the `inverse_transform` function for `Xt` based on the",
                "description": ""
              },
              "estimator": {
                "type": "with the best found parameters.",
                "description": ""
              }
            },
            "returns": "-------\n        X : {ndarray, sparse matrix} of shape (n_samples, n_features)\n            Result of the `inverse_transform` function for `Xt` based on the\n            estimator with the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict",
          "signature": "predict(self, X)",
          "documentation": {
            "description": "Call predict on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``predict``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": ""
              },
              "Must": {
                "type": "fulfill the input assumptions of the",
                "description": ""
              },
              "underlying": {
                "type": "estimator.",
                "description": "Returns\n-------"
              },
              "y_pred": {
                "type": "ndarray of shape (n_samples,)",
                "description": ""
              },
              "The": {
                "type": "predicted labels or values for `X` based on the estimator with",
                "description": ""
              },
              "the": {
                "type": "best found parameters.",
                "description": ""
              }
            },
            "returns": "-------\n        y_pred : ndarray of shape (n_samples,)\n            The predicted labels or values for `X` based on the estimator with\n            the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_log_proba",
          "signature": "predict_log_proba(self, X)",
          "documentation": {
            "description": "Call predict_log_proba on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``predict_log_proba``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": ""
              },
              "Must": {
                "type": "fulfill the input assumptions of the",
                "description": ""
              },
              "underlying": {
                "type": "estimator.",
                "description": "Returns\n-------"
              },
              "y_pred": {
                "type": "ndarray of shape (n_samples,) or (n_samples, n_classes)",
                "description": ""
              },
              "Predicted": {
                "type": "class log-probabilities for `X` based on the estimator",
                "description": ""
              },
              "with": {
                "type": "the best found parameters. The order of the classes",
                "description": ""
              },
              "corresponds": {
                "type": "to that in the fitted attribute :term:`classes_`.",
                "description": ""
              }
            },
            "returns": "-------\n        y_pred : ndarray of shape (n_samples,) or (n_samples, n_classes)\n            Predicted class log-probabilities for `X` based on the estimator\n            with the best found parameters. The order of the classes\n            corresponds to that in the fitted attribute :term:`classes_`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_proba",
          "signature": "predict_proba(self, X)",
          "documentation": {
            "description": "Call predict_proba on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``predict_proba``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": ""
              },
              "Must": {
                "type": "fulfill the input assumptions of the",
                "description": ""
              },
              "underlying": {
                "type": "estimator.",
                "description": "Returns\n-------"
              },
              "y_pred": {
                "type": "ndarray of shape (n_samples,) or (n_samples, n_classes)",
                "description": ""
              },
              "Predicted": {
                "type": "class probabilities for `X` based on the estimator with",
                "description": ""
              },
              "the": {
                "type": "best found parameters. The order of the classes corresponds",
                "description": ""
              },
              "to": {
                "type": "that in the fitted attribute :term:`classes_`.",
                "description": ""
              }
            },
            "returns": "-------\n        y_pred : ndarray of shape (n_samples,) or (n_samples, n_classes)\n            Predicted class probabilities for `X` based on the estimator with\n            the best found parameters. The order of the classes corresponds\n            to that in the fitted attribute :term:`classes_`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score",
          "signature": "score(self, X, y=None, **params)",
          "documentation": {
            "description": "Return the score on the given data, if the estimator has been refit.\n\n        This uses the score defined by ``scoring`` where provided, and the\n        ``best_estimator_.score`` method otherwise.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Input data, where `n_samples` is the number of samples and\n            `n_features` is the number of features.\n\n        y : array-like of shape (n_samples, n_output)             or (n_samples,), default=None\n            Target relative to X for classification or regression;\n            None for unsupervised learning.\n\n        **params : dict\n            Parameters to be passed to the underlying scorer(s).\n\n            .. versionadded:: 1.4\n                Only available if `enable_metadata_routing=True`. See\n                :ref:`Metadata Routing User Guide <metadata_routing>` for more\n                details.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Input": {
                "type": "data, where `n_samples` is the number of samples and",
                "description": "`n_features` is the number of features."
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples, n_output)             or (n_samples,), default=None"
              },
              "Target": {
                "type": "relative to X for classification or regression;",
                "description": ""
              },
              "None": {
                "type": "for unsupervised learning.",
                "description": "**params : dict"
              }
            },
            "returns": "-------\n        score : float\n            The score defined by ``scoring`` if provided, and the\n            ``best_estimator_.score`` method otherwise.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score_samples",
          "signature": "score_samples(self, X)",
          "documentation": {
            "description": "Call score_samples on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``score_samples``.\n\n        .. versionadded:: 0.24\n\n        Parameters\n        ----------\n        X : iterable\n            Data to predict on. Must fulfill input requirements\n            of the underlying estimator.",
            "parameters": {
              "X": {
                "type": "iterable",
                "description": ""
              },
              "Data": {
                "type": "to predict on. Must fulfill input requirements",
                "description": ""
              },
              "of": {
                "type": "the underlying estimator.",
                "description": "Returns\n-------"
              },
              "y_score": {
                "type": "ndarray of shape (n_samples,)",
                "description": ""
              },
              "The": {
                "type": "``best_estimator_.score_samples`` method.",
                "description": ""
              }
            },
            "returns": "-------\n        y_score : ndarray of shape (n_samples,)\n            The ``best_estimator_.score_samples`` method.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transform",
          "signature": "transform(self, X)",
          "documentation": {
            "description": "Call transform on the estimator with the best found parameters.\n\n        Only available if the underlying estimator supports ``transform`` and\n        ``refit=True``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.",
            "parameters": {
              "X": {
                "type": "indexable, length n_samples",
                "description": ""
              },
              "Must": {
                "type": "fulfill the input assumptions of the",
                "description": ""
              },
              "underlying": {
                "type": "estimator.",
                "description": "Returns\n-------"
              },
              "Xt": {
                "type": "{ndarray, sparse matrix} of shape (n_samples, n_features)",
                "description": "`X` transformed in the new space based on the estimator with"
              },
              "the": {
                "type": "best found parameters.",
                "description": ""
              }
            },
            "returns": "-------\n        Xt : {ndarray, sparse matrix} of shape (n_samples, n_features)\n            `X` transformed in the new space based on the estimator with\n            the best found parameters.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "RepeatedKFold",
      "documentation": {
        "description": "Repeated K-Fold cross validator.\n\n    Repeats K-Fold n times with different randomization in each repetition.\n\n    Read more in the :ref:`User Guide <repeated_k_fold>`.\n\n    Parameters\n    ----------\n    n_splits : int, default=5\n        Number of folds. Must be at least 2.\n\n    n_repeats : int, default=10\n        Number of times cross-validator needs to be repeated.\n\n    random_state : int, RandomState instance or None, default=None\n        Controls the randomness of each repeated cross-validation instance.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": ""
          },
          "Number": {
            "type": "of times cross-validator needs to be repeated.",
            "description": ""
          },
          "n_repeats": {
            "type": "int, default=10",
            "description": ""
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Controls": {
            "type": "the randomness of each repeated cross-validation instance.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible output across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "RepeatedKFold": {
            "type": "n_repeats=2, n_splits=2, random_state=2652124",
            "description": ">>> for i, (train_index, test_index) in enumerate(rkf.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\n..."
          },
          "Fold": {
            "type": "3:",
            "description": ""
          },
          "Train": {
            "type": "index=[0 3]",
            "description": ""
          },
          "Test": {
            "type": "index=[1 2]",
            "description": "Notes\n-----"
          },
          "Randomized": {
            "type": "CV splitters may return different results for each call of",
            "description": "split. You can make the results identical by setting `random_state`"
          },
          "to": {
            "type": "an integer.",
            "description": ""
          },
          "RepeatedStratifiedKFold": {
            "type": "Repeats Stratified K",
            "description": "Fold n times."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    RepeatedStratifiedKFold : Repeats Stratified K-Fold n times.",
        "notes": "-----\n    Randomized CV splitters may return different results for each call of\n    split. You can make the results identical by setting `random_state`\n    to an integer.\n\n    See Also\n    --------\n    RepeatedStratifiedKFold : Repeats Stratified K-Fold n times.",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import RepeatedKFold\n    >>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n    >>> y = np.array([0, 0, 1, 1])\n    >>> rkf = RepeatedKFold(n_splits=2, n_repeats=2, random_state=2652124)\n    >>> rkf.get_n_splits(X, y)\n    4\n    >>> print(rkf)\n    RepeatedKFold(n_repeats=2, n_splits=2, random_state=2652124)\n    >>> for i, (train_index, test_index) in enumerate(rkf.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    ...\n    Fold 0:\n      Train: index=[0 1]\n      Test:  index=[2 3]\n    Fold 1:\n      Train: index=[2 3]\n      Test:  index=[0 1]\n    Fold 2:\n      Train: index=[1 2]\n      Test:  index=[0 3]\n    Fold 3:\n      Train: index=[0 3]\n      Test:  index=[1 2]\n\n    Notes\n    -----\n    Randomized CV splitters may return different results for each call of\n    split. You can make the results identical by setting `random_state`\n    to an integer.\n\n    See Also\n    --------\n    RepeatedStratifiedKFold : Repeats Stratified K-Fold n times."
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n            ``np.zeros(n_samples)`` may be used as a placeholder.\n\n        y : object\n            Always ignored, exists for compatibility.\n            ``np.zeros(n_samples)`` may be used as a placeholder.\n\n        groups : array-like of shape (n_samples,), default=None\n            Group labels for the samples used while splitting the dataset into\n            train/test set.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "``np.zeros(n_samples)`` may be used as a placeholder."
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "Group": {
                "type": "labels for the samples used while splitting the dataset into",
                "description": "train/test set.\nReturns\n-------"
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Yields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "RepeatedStratifiedKFold",
      "documentation": {
        "description": "Repeated Stratified K-Fold cross validator.\n\n    Repeats Stratified K-Fold n times with different randomization in each\n    repetition.\n\n    Read more in the :ref:`User Guide <repeated_k_fold>`.\n\n    Parameters\n    ----------\n    n_splits : int, default=5\n        Number of folds. Must be at least 2.\n\n    n_repeats : int, default=10\n        Number of times cross-validator needs to be repeated.\n\n    random_state : int, RandomState instance or None, default=None\n        Controls the generation of the random states for each repetition.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": ""
          },
          "Number": {
            "type": "of times cross-validator needs to be repeated.",
            "description": ""
          },
          "n_repeats": {
            "type": "int, default=10",
            "description": ""
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Controls": {
            "type": "the generation of the random states for each repetition.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible output across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "RepeatedStratifiedKFold": {
            "type": "n_repeats=2, n_splits=2, random_state=36851234",
            "description": ">>> for i, (train_index, test_index) in enumerate(rskf.split(X, y)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")\n..."
          },
          "Fold": {
            "type": "3:",
            "description": ""
          },
          "Train": {
            "type": "index=[0 2]",
            "description": ""
          },
          "Test": {
            "type": "index=[1 3]",
            "description": "Notes\n-----"
          },
          "Randomized": {
            "type": "CV splitters may return different results for each call of",
            "description": "split. You can make the results identical by setting `random_state`"
          },
          "to": {
            "type": "an integer.",
            "description": ""
          },
          "RepeatedKFold": {
            "type": "Repeats K",
            "description": "Fold n times."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    RepeatedKFold : Repeats K-Fold n times.",
        "notes": "-----\n    Randomized CV splitters may return different results for each call of\n    split. You can make the results identical by setting `random_state`\n    to an integer.\n\n    See Also\n    --------\n    RepeatedKFold : Repeats K-Fold n times.",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import RepeatedStratifiedKFold\n    >>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n    >>> y = np.array([0, 0, 1, 1])\n    >>> rskf = RepeatedStratifiedKFold(n_splits=2, n_repeats=2,\n    ...     random_state=36851234)\n    >>> rskf.get_n_splits(X, y)\n    4\n    >>> print(rskf)\n    RepeatedStratifiedKFold(n_repeats=2, n_splits=2, random_state=36851234)\n    >>> for i, (train_index, test_index) in enumerate(rskf.split(X, y)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    ...\n    Fold 0:\n      Train: index=[1 2]\n      Test:  index=[0 3]\n    Fold 1:\n      Train: index=[0 3]\n      Test:  index=[1 2]\n    Fold 2:\n      Train: index=[1 3]\n      Test:  index=[0 2]\n    Fold 3:\n      Train: index=[0 2]\n      Test:  index=[1 3]\n\n    Notes\n    -----\n    Randomized CV splitters may return different results for each call of\n    split. You can make the results identical by setting `random_state`\n    to an integer.\n\n    See Also\n    --------\n    RepeatedKFold : Repeats K-Fold n times."
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n            ``np.zeros(n_samples)`` may be used as a placeholder.\n\n        y : object\n            Always ignored, exists for compatibility.\n            ``np.zeros(n_samples)`` may be used as a placeholder.\n\n        groups : array-like of shape (n_samples,), default=None\n            Group labels for the samples used while splitting the dataset into\n            train/test set.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "``np.zeros(n_samples)`` may be used as a placeholder."
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "Group": {
                "type": "labels for the samples used while splitting the dataset into",
                "description": "train/test set.\nReturns\n-------"
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Training data, where `n_samples` is the number of samples\n            and `n_features` is the number of features.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "Note": {
                "type": "that providing ``y`` is sufficient to generate the splits and",
                "description": ""
              },
              "hence": {
                "type": "``np.zeros(n_samples)`` may be used as a placeholder for",
                "description": "``X`` instead of actual training data."
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": "Notes\n-----"
              },
              "Stratification": {
                "type": "is done based on the y labels.",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Yields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              },
              "Randomized": {
                "type": "CV splitters may return different results for each call of",
                "description": "split. You can make the results identical by setting `random_state`"
              },
              "to": {
                "type": "an integer.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "that providing ``y`` is sufficient to generate the splits and\n            hence ``np.zeros(n_samples)`` may be used as a placeholder for\n            ``X`` instead of actual training data.\n\n        y : array-like of shape (n_samples,)\n            The target variable for supervised learning problems.\n            Stratification is done based on the y labels.\n\n        groups : object\n            Always ignored, exists for compatibility.\n\n        Yields\n        ------\n        train : ndarray\n            The training set indices for that split.\n\n        test : ndarray\n            The testing set indices for that split.\n\n        Notes\n        -----\n        Randomized CV splitters may return different results for each call of\n        split. You can make the results identical by setting `random_state`\n        to an integer.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ShuffleSplit",
      "documentation": {
        "description": "Random permutation cross-validator.\n\n    Yields indices to split data into training and test sets.\n\n    Note: contrary to other cross-validation strategies, random splits\n    do not guarantee that test sets across all folds will be mutually exclusive,\n    and might include overlapping samples. However, this is still very likely for\n    sizeable datasets.\n\n    Read more in the :ref:`User Guide <ShuffleSplit>`.\n\n    For visualisation of cross-validation behaviour and\n    comparison between common scikit-learn split methods\n    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n    Parameters\n    ----------\n    n_splits : int, default=10\n        Number of re-shuffling & splitting iterations.\n\n    test_size : float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the proportion\n        of the dataset to include in the test split. If int, represents the\n        absolute number of test samples. If None, the value is set to the\n        complement of the train size. If ``train_size`` is also None, it will\n        be set to 0.1.\n\n    train_size : float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the\n        proportion of the dataset to include in the train split. If\n        int, represents the absolute number of train samples. If None,\n        the value is automatically set to the complement of the test size.\n\n    random_state : int, RandomState instance or None, default=None\n        Controls the randomness of the training and testing indices produced.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.",
        "parameters": {
          "n_splits": {
            "type": "int, default=10",
            "description": ""
          },
          "Number": {
            "type": "of re-shuffling & splitting iterations.",
            "description": ""
          },
          "test_size": {
            "type": "float or int, default=None",
            "description": ""
          },
          "If": {
            "type": "float, should be between 0.0 and 1.0 and represent the",
            "description": ""
          },
          "of": {
            "type": "the dataset to include in the test split. If int, represents the",
            "description": ""
          },
          "absolute": {
            "type": "number of test samples. If None, the value is set to the",
            "description": ""
          },
          "complement": {
            "type": "of the train size. If ``train_size`` is also None, it will",
            "description": ""
          },
          "be": {
            "type": "set to 0.1.",
            "description": ""
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": ""
          },
          "proportion": {
            "type": "of the dataset to include in the train split. If",
            "description": "int, represents the absolute number of train samples. If None,"
          },
          "the": {
            "type": "value is automatically set to the complement of the test size.",
            "description": ""
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Controls": {
            "type": "the randomness of the training and testing indices produced.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible output across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "term:`Glossary <random_state>`.",
            "description": "Examples\n--------\n>>> import numpy as np\n>>> from sklearn.model_selection import ShuffleSplit\n>>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [3, 4], [5, 6]])\n>>> y = np.array([1, 2, 1, 2, 1, 2])\n>>> rs = ShuffleSplit(n_splits=5, test_size=.25, random_state=0)\n>>> rs.get_n_splits(X)\n5\n>>> print(rs)"
          },
          "ShuffleSplit": {
            "type": "n_splits=5, random_state=0, test_size=0.25, train_size=None",
            "description": ">>> for i, (train_index, test_index) in enumerate(rs.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")"
          },
          "Fold": {
            "type": "4:",
            "description": ""
          },
          "Train": {
            "type": "index=[3 5 1]",
            "description": ""
          },
          "Test": {
            "type": "index=[2 4]",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "contrary to other cross-validation strategies, random splits\n    do not guarantee that test sets across all folds will be mutually exclusive,\n    and might include overlapping samples. However, this is still very likely for\n    sizeable datasets.\n\n    Read more in the :ref:`User Guide <ShuffleSplit>`.\n\n    For visualisation of cross-validation behaviour and\n    comparison between common scikit-learn split methods\n    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n    Parameters\n    ----------\n    n_splits : int, default=10\n        Number of re-shuffling & splitting iterations.\n\n    test_size : float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the proportion\n        of the dataset to include in the test split. If int, represents the\n        absolute number of test samples. If None, the value is set to the\n        complement of the train size. If ``train_size`` is also None, it will\n        be set to 0.1.\n\n    train_size : float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the\n        proportion of the dataset to include in the train split. If\n        int, represents the absolute number of train samples. If None,\n        the value is automatically set to the complement of the test size.\n\n    random_state : int, RandomState instance or None, default=None\n        Controls the randomness of the training and testing indices produced.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import ShuffleSplit\n    >>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [3, 4], [5, 6]])\n    >>> y = np.array([1, 2, 1, 2, 1, 2])\n    >>> rs = ShuffleSplit(n_splits=5, test_size=.25, random_state=0)\n    >>> rs.get_n_splits(X)\n    5\n    >>> print(rs)\n    ShuffleSplit(n_splits=5, random_state=0, test_size=0.25, train_size=None)\n    >>> for i, (train_index, test_index) in enumerate(rs.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[1 3 0 4]\n      Test:  index=[5 2]\n    Fold 1:\n      Train: index=[4 0 2 5]\n      Test:  index=[1 3]\n    Fold 2:\n      Train: index=[1 2 4 0]\n      Test:  index=[3 5]\n    Fold 3:\n      Train: index=[3 4 1 0]\n      Test:  index=[5 2]\n    Fold 4:\n      Train: index=[3 5 1 0]\n      Test:  index=[2 4]\n    >>> # Specify train and test size\n    >>> rs = ShuffleSplit(n_splits=5, train_size=0.5, test_size=.25,\n    ...                   random_state=0)\n    >>> for i, (train_index, test_index) in enumerate(rs.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[1 3 0]\n      Test:  index=[5 2]\n    Fold 1:\n      Train: index=[4 0 2]\n      Test:  index=[1 3]\n    Fold 2:\n      Train: index=[1 2 4]\n      Test:  index=[3 5]\n    Fold 3:\n      Train: index=[3 4 1]\n      Test:  index=[5 2]\n    Fold 4:\n      Train: index=[3 5 1]\n      Test:  index=[2 4]",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import ShuffleSplit\n    >>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [3, 4], [5, 6]])\n    >>> y = np.array([1, 2, 1, 2, 1, 2])\n    >>> rs = ShuffleSplit(n_splits=5, test_size=.25, random_state=0)\n    >>> rs.get_n_splits(X)\n    5\n    >>> print(rs)\n    ShuffleSplit(n_splits=5, random_state=0, test_size=0.25, train_size=None)\n    >>> for i, (train_index, test_index) in enumerate(rs.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[1 3 0 4]\n      Test:  index=[5 2]\n    Fold 1:\n      Train: index=[4 0 2 5]\n      Test:  index=[1 3]\n    Fold 2:\n      Train: index=[1 2 4 0]\n      Test:  index=[3 5]\n    Fold 3:\n      Train: index=[3 4 1 0]\n      Test:  index=[5 2]\n    Fold 4:\n      Train: index=[3 5 1 0]\n      Test:  index=[2 4]\n    >>> # Specify train and test size\n    >>> rs = ShuffleSplit(n_splits=5, train_size=0.5, test_size=.25,\n    ...                   random_state=0)\n    >>> for i, (train_index, test_index) in enumerate(rs.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[1 3 0]\n      Test:  index=[5 2]\n    Fold 1:\n      Train: index=[4 0 2]\n      Test:  index=[1 3]\n    Fold 2:\n      Train: index=[1 2 4]\n      Test:  index=[3 5]\n    Fold 3:\n      Train: index=[3 4 1]\n      Test:  index=[5 2]\n    Fold 4:\n      Train: index=[3 5 1]\n      Test:  index=[2 4]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n\n        y : object\n            Always ignored, exists for compatibility.\n\n        groups : object\n            Always ignored, exists for compatibility.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Yields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "StratifiedGroupKFold",
      "documentation": {
        "description": "Stratified K-Fold iterator variant with non-overlapping groups.\n\n    This cross-validation object is a variation of StratifiedKFold attempts to\n    return stratified folds with non-overlapping groups. The folds are made by\n    preserving the percentage of samples for each class.\n\n    Each group will appear exactly once in the test set across all folds (the\n    number of distinct groups has to be at least equal to the number of folds).\n\n    The difference between :class:`GroupKFold`\n    and `StratifiedGroupKFold` is that\n    the former attempts to create balanced folds such that the number of\n    distinct groups is approximately the same in each fold, whereas\n    `StratifiedGroupKFold` attempts to create folds which preserve the\n    percentage of samples for each class as much as possible given the\n    constraint of non-overlapping groups between splits.\n\n    Read more in the :ref:`User Guide <stratified_group_k_fold>`.\n\n    For visualisation of cross-validation behaviour and\n    comparison between common scikit-learn split methods\n    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n    Parameters\n    ----------\n    n_splits : int, default=5\n        Number of folds. Must be at least 2.\n\n    shuffle : bool, default=False\n        Whether to shuffle each class's samples before splitting into batches.\n        Note that the samples within each split will not be shuffled.\n        This implementation can only shuffle groups that have approximately the\n        same y distribution, no global shuffle will be performed.\n\n    random_state : int or RandomState instance, default=None\n        When `shuffle` is True, `random_state` affects the ordering of the\n        indices, which controls the randomness of each fold for each class.\n        Otherwise, leave `random_state` as `None`.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": ""
          },
          "Number": {
            "type": "of folds. Must be at least 2.",
            "description": ""
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": ""
          },
          "Whether": {
            "type": "to shuffle each class's samples before splitting into batches.",
            "description": ""
          },
          "Note": {
            "type": "that the samples within each split will not be shuffled.",
            "description": ""
          },
          "This": {
            "type": "implementation can only shuffle groups that have approximately the",
            "description": ""
          },
          "same": {
            "type": "y distribution, no global shuffle will be performed.",
            "description": ""
          },
          "random_state": {
            "type": "int or RandomState instance, default=None",
            "description": ""
          },
          "When": {
            "type": "`shuffle` is True, `random_state` affects the ordering of the",
            "description": "indices, which controls the randomness of each fold for each class.\nOtherwise, leave `random_state` as `None`."
          },
          "Pass": {
            "type": "an int for reproducible output across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "also",
            "description": "--------"
          },
          "StratifiedGroupKFold": {
            "type": "n_splits=3, random_state=None, shuffle=False",
            "description": ">>> for i, (train_index, test_index) in enumerate(sgkf.split(X, y, groups)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"         group={groups[train_index]}\")\n...     print(f\"  Test:  index={test_index}\")\n...     print(f\"         group={groups[test_index]}\")"
          },
          "Fold": {
            "type": "2:",
            "description": ""
          },
          "Train": {
            "type": "index=[ 0  1  2  3  4  5  6 12 13 14 15 16]",
            "description": "group=[1 1 2 2 3 3 3 6 6 7 8 8]"
          },
          "Test": {
            "type": "index=[ 7  8  9 10 11]",
            "description": "group=[4 5 5 5 5]\nNotes\n-----"
          },
          "The": {
            "type": "implementation is designed to:",
            "description": "* Mimic the behavior of StratifiedKFold as much as possible for trivial"
          },
          "groups": {
            "type": "e.g. when each group contains only one sample",
            "description": ".\n* Be invariant to class label: relabelling ``y = [\"Happy\", \"Sad\"]`` to\n``y = [1, 0]`` should not change the indices generated.\n* Stratify based on samples as much as possible while keeping\nnon-overlapping groups constraint. That means that in some cases when"
          },
          "there": {
            "type": "is a small number of groups containing a large number of samples",
            "description": ""
          },
          "the": {
            "type": "stratification will not be possible and the behavior will be close",
            "description": ""
          },
          "to": {
            "type": "GroupKFold.",
            "description": ""
          },
          "StratifiedKFold": {
            "type": "Takes class information into account to build folds which",
            "description": ""
          },
          "retain": {
            "type": "class distributions (for binary or multiclass classification",
            "description": "tasks)."
          },
          "GroupKFold": {
            "type": "K",
            "description": "fold iterator variant with non-overlapping groups."
          }
        },
        "returns": "stratified folds with non-overlapping groups. The folds are made by\n    preserving the percentage of samples for each class.\n\n    Each group will appear exactly once in the test set across all folds (the\n    number of distinct groups has to be at least equal to the number of folds).\n\n    The difference between :class:`GroupKFold`\n    and `StratifiedGroupKFold` is that\n    the former attempts to create balanced folds such that the number of\n    distinct groups is approximately the same in each fold, whereas\n    `StratifiedGroupKFold` attempts to create folds which preserve the\n    percentage of samples for each class as much as possible given the\n    constraint of non-overlapping groups between splits.\n\n    Read more in the :ref:`User Guide <stratified_group_k_fold>`.\n\n    For visualisation of cross-validation behaviour and\n    comparison between common scikit-learn split methods\n    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n    Parameters\n    ----------\n    n_splits : int, default=5\n        Number of folds. Must be at least 2.\n\n    shuffle : bool, default=False\n        Whether to shuffle each class's samples before splitting into batches.\n        Note that the samples within each split will not be shuffled.\n        This implementation can only shuffle groups that have approximately the\n        same y distribution, no global shuffle will be performed.\n\n    random_state : int or RandomState instance, default=None\n        When `shuffle` is True, `random_state` affects the ordering of the\n        indices, which controls the randomness of each fold for each class.\n        Otherwise, leave `random_state` as `None`.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import StratifiedGroupKFold\n    >>> X = np.ones((17, 2))\n    >>> y = np.array([0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    >>> groups = np.array([1, 1, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5, 6, 6, 7, 8, 8])\n    >>> sgkf = StratifiedGroupKFold(n_splits=3)\n    >>> sgkf.get_n_splits(X, y)\n    3\n    >>> print(sgkf)\n    StratifiedGroupKFold(n_splits=3, random_state=None, shuffle=False)\n    >>> for i, (train_index, test_index) in enumerate(sgkf.split(X, y, groups)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"         group={groups[train_index]}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    ...     print(f\"         group={groups[test_index]}\")\n    Fold 0:\n      Train: index=[ 0  1  2  3  7  8  9 10 11 15 16]\n             group=[1 1 2 2 4 5 5 5 5 8 8]\n      Test:  index=[ 4  5  6 12 13 14]\n             group=[3 3 3 6 6 7]\n    Fold 1:\n      Train: index=[ 4  5  6  7  8  9 10 11 12 13 14]\n             group=[3 3 3 4 5 5 5 5 6 6 7]\n      Test:  index=[ 0  1  2  3 15 16]\n             group=[1 1 2 2 8 8]\n    Fold 2:\n      Train: index=[ 0  1  2  3  4  5  6 12 13 14 15 16]\n             group=[1 1 2 2 3 3 3 6 6 7 8 8]\n      Test:  index=[ 7  8  9 10 11]\n             group=[4 5 5 5 5]\n\n    Notes\n    -----\n    The implementation is designed to:\n\n    * Mimic the behavior of StratifiedKFold as much as possible for trivial\n      groups (e.g. when each group contains only one sample).\n    * Be invariant to class label: relabelling ``y = [\"Happy\", \"Sad\"]`` to\n      ``y = [1, 0]`` should not change the indices generated.\n    * Stratify based on samples as much as possible while keeping\n      non-overlapping groups constraint. That means that in some cases when\n      there is a small number of groups containing a large number of samples\n      the stratification will not be possible and the behavior will be close\n      to GroupKFold.\n\n    See also\n    --------\n    StratifiedKFold: Takes class information into account to build folds which\n        retain class distributions (for binary or multiclass classification\n        tasks).\n\n    GroupKFold: K-fold iterator variant with non-overlapping groups.",
        "raises": "",
        "see_also": "--------\n    StratifiedKFold: Takes class information into account to build folds which\n        retain class distributions (for binary or multiclass classification\n        tasks).\n\n    GroupKFold: K-fold iterator variant with non-overlapping groups.",
        "notes": "that the samples within each split will not be shuffled.\n        This implementation can only shuffle groups that have approximately the\n        same y distribution, no global shuffle will be performed.\n\n    random_state : int or RandomState instance, default=None\n        When `shuffle` is True, `random_state` affects the ordering of the\n        indices, which controls the randomness of each fold for each class.\n        Otherwise, leave `random_state` as `None`.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import StratifiedGroupKFold\n    >>> X = np.ones((17, 2))\n    >>> y = np.array([0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    >>> groups = np.array([1, 1, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5, 6, 6, 7, 8, 8])\n    >>> sgkf = StratifiedGroupKFold(n_splits=3)\n    >>> sgkf.get_n_splits(X, y)\n    3\n    >>> print(sgkf)\n    StratifiedGroupKFold(n_splits=3, random_state=None, shuffle=False)\n    >>> for i, (train_index, test_index) in enumerate(sgkf.split(X, y, groups)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"         group={groups[train_index]}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    ...     print(f\"         group={groups[test_index]}\")\n    Fold 0:\n      Train: index=[ 0  1  2  3  7  8  9 10 11 15 16]\n             group=[1 1 2 2 4 5 5 5 5 8 8]\n      Test:  index=[ 4  5  6 12 13 14]\n             group=[3 3 3 6 6 7]\n    Fold 1:\n      Train: index=[ 4  5  6  7  8  9 10 11 12 13 14]\n             group=[3 3 3 4 5 5 5 5 6 6 7]\n      Test:  index=[ 0  1  2  3 15 16]\n             group=[1 1 2 2 8 8]\n    Fold 2:\n      Train: index=[ 0  1  2  3  4  5  6 12 13 14 15 16]\n             group=[1 1 2 2 3 3 3 6 6 7 8 8]\n      Test:  index=[ 7  8  9 10 11]\n             group=[4 5 5 5 5]\n\n    Notes\n    -----\n    The implementation is designed to:\n\n    * Mimic the behavior of StratifiedKFold as much as possible for trivial\n      groups (e.g. when each group contains only one sample).\n    * Be invariant to class label: relabelling ``y = [\"Happy\", \"Sad\"]`` to\n      ``y = [1, 0]`` should not change the indices generated.\n    * Stratify based on samples as much as possible while keeping\n      non-overlapping groups constraint. That means that in some cases when\n      there is a small number of groups containing a large number of samples\n      the stratification will not be possible and the behavior will be close\n      to GroupKFold.\n\n    See also\n    --------\n    StratifiedKFold: Takes class information into account to build folds which\n        retain class distributions (for binary or multiclass classification\n        tasks).\n\n    GroupKFold: K-fold iterator variant with non-overlapping groups.",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import StratifiedGroupKFold\n    >>> X = np.ones((17, 2))\n    >>> y = np.array([0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    >>> groups = np.array([1, 1, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5, 6, 6, 7, 8, 8])\n    >>> sgkf = StratifiedGroupKFold(n_splits=3)\n    >>> sgkf.get_n_splits(X, y)\n    3\n    >>> print(sgkf)\n    StratifiedGroupKFold(n_splits=3, random_state=None, shuffle=False)\n    >>> for i, (train_index, test_index) in enumerate(sgkf.split(X, y, groups)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"         group={groups[train_index]}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    ...     print(f\"         group={groups[test_index]}\")\n    Fold 0:\n      Train: index=[ 0  1  2  3  7  8  9 10 11 15 16]\n             group=[1 1 2 2 4 5 5 5 5 8 8]\n      Test:  index=[ 4  5  6 12 13 14]\n             group=[3 3 3 6 6 7]\n    Fold 1:\n      Train: index=[ 4  5  6  7  8  9 10 11 12 13 14]\n             group=[3 3 3 4 5 5 5 5 6 6 7]\n      Test:  index=[ 0  1  2  3 15 16]\n             group=[1 1 2 2 8 8]\n    Fold 2:\n      Train: index=[ 0  1  2  3  4  5  6 12 13 14 15 16]\n             group=[1 1 2 2 3 3 3 6 6 7 8 8]\n      Test:  index=[ 7  8  9 10 11]\n             group=[4 5 5 5 5]\n\n    Notes\n    -----\n    The implementation is designed to:\n\n    * Mimic the behavior of StratifiedKFold as much as possible for trivial\n      groups (e.g. when each group contains only one sample).\n    * Be invariant to class label: relabelling ``y = [\"Happy\", \"Sad\"]`` to\n      ``y = [1, 0]`` should not change the indices generated.\n    * Stratify based on samples as much as possible while keeping\n      non-overlapping groups constraint. That means that in some cases when\n      there is a small number of groups containing a large number of samples\n      the stratification will not be possible and the behavior will be close\n      to GroupKFold.\n\n    See also\n    --------\n    StratifiedKFold: Takes class information into account to build folds which\n        retain class distributions (for binary or multiclass classification\n        tasks).\n\n    GroupKFold: K-fold iterator variant with non-overlapping groups."
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n\n        y : object\n            Always ignored, exists for compatibility.\n\n        groups : object\n            Always ignored, exists for compatibility.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_split_request",
          "signature": "set_split_request(self: sklearn.model_selection._split.StratifiedGroupKFold, *, groups: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._split.StratifiedGroupKFold",
          "documentation": {
            "description": "Request metadata passed to the ``split`` method.",
            "parameters": {
              "groups": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``groups`` parameter in ``split``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``split`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``split``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        groups : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``groups`` parameter in ``split``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": ""
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "Group": {
                "type": "labels for the samples used while splitting the dataset into",
                "description": "train/test set.\nYields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "StratifiedKFold",
      "documentation": {
        "description": "Stratified K-Fold cross-validator.\n\n    Provides train/test indices to split data in train/test sets.\n\n    This cross-validation object is a variation of KFold that returns\n    stratified folds. The folds are made by preserving the percentage of\n    samples for each class.\n\n    Read more in the :ref:`User Guide <stratified_k_fold>`.\n\n    For visualisation of cross-validation behaviour and\n    comparison between common scikit-learn split methods\n    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n    Parameters\n    ----------\n    n_splits : int, default=5\n        Number of folds. Must be at least 2.\n\n        .. versionchanged:: 0.22\n            ``n_splits`` default value changed from 3 to 5.\n\n    shuffle : bool, default=False\n        Whether to shuffle each class's samples before splitting into batches.\n        Note that the samples within each split will not be shuffled.\n\n    random_state : int, RandomState instance or None, default=None\n        When `shuffle` is True, `random_state` affects the ordering of the\n        indices, which controls the randomness of each fold for each class.\n        Otherwise, leave `random_state` as `None`.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": ""
          },
          "Number": {
            "type": "of folds. Must be at least 2.",
            "description": ".. versionchanged:: 0.22\n``n_splits`` default value changed from 3 to 5."
          },
          "shuffle": {
            "type": "bool, default=False",
            "description": ""
          },
          "Whether": {
            "type": "to shuffle each class's samples before splitting into batches.",
            "description": ""
          },
          "Note": {
            "type": "that the samples within each split will not be shuffled.",
            "description": ""
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "When": {
            "type": "`shuffle` is True, `random_state` affects the ordering of the",
            "description": "indices, which controls the randomness of each fold for each class.\nOtherwise, leave `random_state` as `None`."
          },
          "Pass": {
            "type": "an int for reproducible output across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------"
          },
          "StratifiedKFold": {
            "type": "n_splits=2, random_state=None, shuffle=False",
            "description": ">>> for i, (train_index, test_index) in enumerate(skf.split(X, y)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")"
          },
          "Fold": {
            "type": "1:",
            "description": ""
          },
          "Train": {
            "type": "index=[0 2]",
            "description": ""
          },
          "Test": {
            "type": "index=[1 3]",
            "description": "Notes\n-----"
          },
          "The": {
            "type": "previous implementation did not follow the last constraint.",
            "description": ""
          },
          "contiguous": {
            "type": "in y, or separated in y by samples from classes other than k.",
            "description": "* Generate test sets where the smallest and largest differ by at most one\nsample.\n.. versionchanged:: 0.22"
          },
          "RepeatedStratifiedKFold": {
            "type": "Repeats Stratified K",
            "description": "Fold n times."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    RepeatedStratifiedKFold : Repeats Stratified K-Fold n times.",
        "notes": "that the samples within each split will not be shuffled.\n\n    random_state : int, RandomState instance or None, default=None\n        When `shuffle` is True, `random_state` affects the ordering of the\n        indices, which controls the randomness of each fold for each class.\n        Otherwise, leave `random_state` as `None`.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import StratifiedKFold\n    >>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n    >>> y = np.array([0, 0, 1, 1])\n    >>> skf = StratifiedKFold(n_splits=2)\n    >>> skf.get_n_splits(X, y)\n    2\n    >>> print(skf)\n    StratifiedKFold(n_splits=2, random_state=None, shuffle=False)\n    >>> for i, (train_index, test_index) in enumerate(skf.split(X, y)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[1 3]\n      Test:  index=[0 2]\n    Fold 1:\n      Train: index=[0 2]\n      Test:  index=[1 3]\n\n    Notes\n    -----\n    The implementation is designed to:\n\n    * Generate test sets such that all contain the same distribution of\n      classes, or as close as possible.\n    * Be invariant to class label: relabelling ``y = [\"Happy\", \"Sad\"]`` to\n      ``y = [1, 0]`` should not change the indices generated.\n    * Preserve order dependencies in the dataset ordering, when\n      ``shuffle=False``: all samples from class k in some test set were\n      contiguous in y, or separated in y by samples from classes other than k.\n    * Generate test sets where the smallest and largest differ by at most one\n      sample.\n\n    .. versionchanged:: 0.22\n        The previous implementation did not follow the last constraint.\n\n    See Also\n    --------\n    RepeatedStratifiedKFold : Repeats Stratified K-Fold n times.",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import StratifiedKFold\n    >>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n    >>> y = np.array([0, 0, 1, 1])\n    >>> skf = StratifiedKFold(n_splits=2)\n    >>> skf.get_n_splits(X, y)\n    2\n    >>> print(skf)\n    StratifiedKFold(n_splits=2, random_state=None, shuffle=False)\n    >>> for i, (train_index, test_index) in enumerate(skf.split(X, y)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[1 3]\n      Test:  index=[0 2]\n    Fold 1:\n      Train: index=[0 2]\n      Test:  index=[1 3]\n\n    Notes\n    -----\n    The implementation is designed to:\n\n    * Generate test sets such that all contain the same distribution of\n      classes, or as close as possible.\n    * Be invariant to class label: relabelling ``y = [\"Happy\", \"Sad\"]`` to\n      ``y = [1, 0]`` should not change the indices generated.\n    * Preserve order dependencies in the dataset ordering, when\n      ``shuffle=False``: all samples from class k in some test set were\n      contiguous in y, or separated in y by samples from classes other than k.\n    * Generate test sets where the smallest and largest differ by at most one\n      sample.\n\n    .. versionchanged:: 0.22\n        The previous implementation did not follow the last constraint.\n\n    See Also\n    --------\n    RepeatedStratifiedKFold : Repeats Stratified K-Fold n times."
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n\n        y : object\n            Always ignored, exists for compatibility.\n\n        groups : object\n            Always ignored, exists for compatibility.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Training data, where `n_samples` is the number of samples\n            and `n_features` is the number of features.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "Note": {
                "type": "that providing ``y`` is sufficient to generate the splits and",
                "description": ""
              },
              "hence": {
                "type": "``np.zeros(n_samples)`` may be used as a placeholder for",
                "description": "``X`` instead of actual training data."
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": "Notes\n-----"
              },
              "Stratification": {
                "type": "is done based on the y labels.",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Yields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              },
              "Randomized": {
                "type": "CV splitters may return different results for each call of",
                "description": "split. You can make the results identical by setting `random_state`"
              },
              "to": {
                "type": "an integer.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "that providing ``y`` is sufficient to generate the splits and\n            hence ``np.zeros(n_samples)`` may be used as a placeholder for\n            ``X`` instead of actual training data.\n\n        y : array-like of shape (n_samples,)\n            The target variable for supervised learning problems.\n            Stratification is done based on the y labels.\n\n        groups : object\n            Always ignored, exists for compatibility.\n\n        Yields\n        ------\n        train : ndarray\n            The training set indices for that split.\n\n        test : ndarray\n            The testing set indices for that split.\n\n        Notes\n        -----\n        Randomized CV splitters may return different results for each call of\n        split. You can make the results identical by setting `random_state`\n        to an integer.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "StratifiedShuffleSplit",
      "documentation": {
        "description": "Stratified ShuffleSplit cross-validator.\n\n    Provides train/test indices to split data in train/test sets.\n\n    This cross-validation object is a merge of :class:`StratifiedKFold` and\n    :class:`ShuffleSplit`, which returns stratified randomized folds. The folds\n    are made by preserving the percentage of samples for each class.\n\n    Note: like the :class:`ShuffleSplit` strategy, stratified random splits\n    do not guarantee that test sets across all folds will be mutually exclusive,\n    and might include overlapping samples. However, this is still very likely for\n    sizeable datasets.\n\n    Read more in the :ref:`User Guide <stratified_shuffle_split>`.\n\n    For visualisation of cross-validation behaviour and\n    comparison between common scikit-learn split methods\n    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n    Parameters\n    ----------\n    n_splits : int, default=10\n        Number of re-shuffling & splitting iterations.\n\n    test_size : float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the proportion\n        of the dataset to include in the test split. If int, represents the\n        absolute number of test samples. If None, the value is set to the\n        complement of the train size. If ``train_size`` is also None, it will\n        be set to 0.1.\n\n    train_size : float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the\n        proportion of the dataset to include in the train split. If\n        int, represents the absolute number of train samples. If None,\n        the value is automatically set to the complement of the test size.\n\n    random_state : int, RandomState instance or None, default=None\n        Controls the randomness of the training and testing indices produced.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.",
        "parameters": {
          "n_splits": {
            "type": "int, default=10",
            "description": ""
          },
          "Number": {
            "type": "of re-shuffling & splitting iterations.",
            "description": ""
          },
          "test_size": {
            "type": "float or int, default=None",
            "description": ""
          },
          "If": {
            "type": "float, should be between 0.0 and 1.0 and represent the",
            "description": ""
          },
          "of": {
            "type": "the dataset to include in the test split. If int, represents the",
            "description": ""
          },
          "absolute": {
            "type": "number of test samples. If None, the value is set to the",
            "description": ""
          },
          "complement": {
            "type": "of the train size. If ``train_size`` is also None, it will",
            "description": ""
          },
          "be": {
            "type": "set to 0.1.",
            "description": ""
          },
          "train_size": {
            "type": "float or int, default=None",
            "description": ""
          },
          "proportion": {
            "type": "of the dataset to include in the train split. If",
            "description": "int, represents the absolute number of train samples. If None,"
          },
          "the": {
            "type": "value is automatically set to the complement of the test size.",
            "description": ""
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Controls": {
            "type": "the randomness of the training and testing indices produced.",
            "description": ""
          },
          "Pass": {
            "type": "an int for reproducible output across multiple function calls.",
            "description": ""
          },
          "See": {
            "type": "term:`Glossary <random_state>`.",
            "description": "Examples\n--------\n>>> import numpy as np\n>>> from sklearn.model_selection import StratifiedShuffleSplit\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([0, 0, 0, 1, 1, 1])\n>>> sss = StratifiedShuffleSplit(n_splits=5, test_size=0.5, random_state=0)\n>>> sss.get_n_splits(X, y)\n5\n>>> print(sss)"
          },
          "StratifiedShuffleSplit": {
            "type": "n_splits=5, random_state=0, ...",
            "description": ">>> for i, (train_index, test_index) in enumerate(sss.split(X, y)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")"
          },
          "Fold": {
            "type": "4:",
            "description": ""
          },
          "Train": {
            "type": "index=[0 5 1]",
            "description": ""
          },
          "Test": {
            "type": "index=[3 4 2]",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "like the :class:`ShuffleSplit` strategy, stratified random splits\n    do not guarantee that test sets across all folds will be mutually exclusive,\n    and might include overlapping samples. However, this is still very likely for\n    sizeable datasets.\n\n    Read more in the :ref:`User Guide <stratified_shuffle_split>`.\n\n    For visualisation of cross-validation behaviour and\n    comparison between common scikit-learn split methods\n    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n    Parameters\n    ----------\n    n_splits : int, default=10\n        Number of re-shuffling & splitting iterations.\n\n    test_size : float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the proportion\n        of the dataset to include in the test split. If int, represents the\n        absolute number of test samples. If None, the value is set to the\n        complement of the train size. If ``train_size`` is also None, it will\n        be set to 0.1.\n\n    train_size : float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the\n        proportion of the dataset to include in the train split. If\n        int, represents the absolute number of train samples. If None,\n        the value is automatically set to the complement of the test size.\n\n    random_state : int, RandomState instance or None, default=None\n        Controls the randomness of the training and testing indices produced.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import StratifiedShuffleSplit\n    >>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])\n    >>> y = np.array([0, 0, 0, 1, 1, 1])\n    >>> sss = StratifiedShuffleSplit(n_splits=5, test_size=0.5, random_state=0)\n    >>> sss.get_n_splits(X, y)\n    5\n    >>> print(sss)\n    StratifiedShuffleSplit(n_splits=5, random_state=0, ...)\n    >>> for i, (train_index, test_index) in enumerate(sss.split(X, y)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[5 2 3]\n      Test:  index=[4 1 0]\n    Fold 1:\n      Train: index=[5 1 4]\n      Test:  index=[0 2 3]\n    Fold 2:\n      Train: index=[5 0 2]\n      Test:  index=[4 3 1]\n    Fold 3:\n      Train: index=[4 1 0]\n      Test:  index=[2 3 5]\n    Fold 4:\n      Train: index=[0 5 1]\n      Test:  index=[3 4 2]",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import StratifiedShuffleSplit\n    >>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])\n    >>> y = np.array([0, 0, 0, 1, 1, 1])\n    >>> sss = StratifiedShuffleSplit(n_splits=5, test_size=0.5, random_state=0)\n    >>> sss.get_n_splits(X, y)\n    5\n    >>> print(sss)\n    StratifiedShuffleSplit(n_splits=5, random_state=0, ...)\n    >>> for i, (train_index, test_index) in enumerate(sss.split(X, y)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[5 2 3]\n      Test:  index=[4 1 0]\n    Fold 1:\n      Train: index=[5 1 4]\n      Test:  index=[0 2 3]\n    Fold 2:\n      Train: index=[5 0 2]\n      Test:  index=[4 3 1]\n    Fold 3:\n      Train: index=[4 1 0]\n      Test:  index=[2 3 5]\n    Fold 4:\n      Train: index=[0 5 1]\n      Test:  index=[3 4 2]"
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n\n        y : object\n            Always ignored, exists for compatibility.\n\n        groups : object\n            Always ignored, exists for compatibility.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Training data, where `n_samples` is the number of samples\n            and `n_features` is the number of features.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "Note": {
                "type": "that providing ``y`` is sufficient to generate the splits and",
                "description": ""
              },
              "hence": {
                "type": "``np.zeros(n_samples)`` may be used as a placeholder for",
                "description": "``X`` instead of actual training data."
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_labels)"
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": "Notes\n-----"
              },
              "Stratification": {
                "type": "is done based on the y labels.",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Yields\n------"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              },
              "Randomized": {
                "type": "CV splitters may return different results for each call of",
                "description": "split. You can make the results identical by setting `random_state`"
              },
              "to": {
                "type": "an integer.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "that providing ``y`` is sufficient to generate the splits and\n            hence ``np.zeros(n_samples)`` may be used as a placeholder for\n            ``X`` instead of actual training data.\n\n        y : array-like of shape (n_samples,) or (n_samples, n_labels)\n            The target variable for supervised learning problems.\n            Stratification is done based on the y labels.\n\n        groups : object\n            Always ignored, exists for compatibility.\n\n        Yields\n        ------\n        train : ndarray\n            The training set indices for that split.\n\n        test : ndarray\n            The testing set indices for that split.\n\n        Notes\n        -----\n        Randomized CV splitters may return different results for each call of\n        split. You can make the results identical by setting `random_state`\n        to an integer.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "TimeSeriesSplit",
      "documentation": {
        "description": "Time Series cross-validator.\n\n    Provides train/test indices to split time series data samples\n    that are observed at fixed time intervals, in train/test sets.\n    In each split, test indices must be higher than before, and thus shuffling\n    in cross validator is inappropriate.\n\n    This cross-validation object is a variation of :class:`KFold`.\n    In the kth split, it returns first k folds as train set and the\n    (k+1)th fold as test set.\n\n    Note that unlike standard cross-validation methods, successive\n    training sets are supersets of those that come before them.\n\n    Read more in the :ref:`User Guide <time_series_split>`.\n\n    For visualisation of cross-validation behaviour and\n    comparison between common scikit-learn split methods\n    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_splits : int, default=5\n        Number of splits. Must be at least 2.\n\n        .. versionchanged:: 0.22\n            ``n_splits`` default value changed from 3 to 5.\n\n    max_train_size : int, default=None\n        Maximum size for a single training set.\n\n    test_size : int, default=None\n        Used to limit the size of the test set. Defaults to\n        ``n_samples // (n_splits + 1)``, which is the maximum allowed value\n        with ``gap=0``.\n\n        .. versionadded:: 0.24\n\n    gap : int, default=0\n        Number of samples to exclude from the end of each train set before\n        the test set.\n\n        .. versionadded:: 0.24",
        "parameters": {
          "n_splits": {
            "type": "int, default=5",
            "description": ""
          },
          "Number": {
            "type": "of samples to exclude from the end of each train set before",
            "description": ""
          },
          "max_train_size": {
            "type": "int, default=None",
            "description": ""
          },
          "Maximum": {
            "type": "size for a single training set.",
            "description": ""
          },
          "test_size": {
            "type": "int, default=None",
            "description": ""
          },
          "Used": {
            "type": "to limit the size of the test set. Defaults to",
            "description": "``n_samples // (n_splits + 1)``, which is the maximum allowed value"
          },
          "with": {
            "type": "a test set of size ``n_samples//(n_splits + 1)`` by default,",
            "description": ""
          },
          "gap": {
            "type": "int, default=0",
            "description": ""
          },
          "the": {
            "type": "test set.",
            "description": ".. versionadded:: 0.24\nExamples\n--------\n>>> import numpy as np\n>>> from sklearn.model_selection import TimeSeriesSplit\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([1, 2, 3, 4, 5, 6])\n>>> tscv = TimeSeriesSplit()\n>>> print(tscv)"
          },
          "TimeSeriesSplit": {
            "type": "gap=0, max_train_size=None, n_splits=5, test_size=None",
            "description": ">>> for i, (train_index, test_index) in enumerate(tscv.split(X)):\n...     print(f\"Fold {i}:\")\n...     print(f\"  Train: index={train_index}\")\n...     print(f\"  Test:  index={test_index}\")"
          },
          "Fold": {
            "type": "2:",
            "description": ""
          },
          "Train": {
            "type": "index=[0 1 2 3 4 5 6 7]",
            "description": ""
          },
          "Test": {
            "type": "index=[10 11]",
            "description": ""
          },
          "For": {
            "type": "a more extended example see",
            "description": ":ref:`sphx_glr_auto_examples_applications_plot_cyclical_feature_engineering.py`.\nNotes\n-----"
          },
          "The": {
            "type": "training set has size ``i * n_samples // (n_splits + 1)",
            "description": "+ n_samples % (n_splits + 1)`` in the ``i`` th split,"
          },
          "where": {
            "type": "``n_samples`` is the number of samples. Note that this",
            "description": ""
          },
          "formula": {
            "type": "is only valid when ``test_size`` and ``max_train_size`` are",
            "description": ""
          },
          "left": {
            "type": "to their default values.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "that unlike standard cross-validation methods, successive\n    training sets are supersets of those that come before them.\n\n    Read more in the :ref:`User Guide <time_series_split>`.\n\n    For visualisation of cross-validation behaviour and\n    comparison between common scikit-learn split methods\n    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py`\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_splits : int, default=5\n        Number of splits. Must be at least 2.\n\n        .. versionchanged:: 0.22\n            ``n_splits`` default value changed from 3 to 5.\n\n    max_train_size : int, default=None\n        Maximum size for a single training set.\n\n    test_size : int, default=None\n        Used to limit the size of the test set. Defaults to\n        ``n_samples // (n_splits + 1)``, which is the maximum allowed value\n        with ``gap=0``.\n\n        .. versionadded:: 0.24\n\n    gap : int, default=0\n        Number of samples to exclude from the end of each train set before\n        the test set.\n\n        .. versionadded:: 0.24\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import TimeSeriesSplit\n    >>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])\n    >>> y = np.array([1, 2, 3, 4, 5, 6])\n    >>> tscv = TimeSeriesSplit()\n    >>> print(tscv)\n    TimeSeriesSplit(gap=0, max_train_size=None, n_splits=5, test_size=None)\n    >>> for i, (train_index, test_index) in enumerate(tscv.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[0]\n      Test:  index=[1]\n    Fold 1:\n      Train: index=[0 1]\n      Test:  index=[2]\n    Fold 2:\n      Train: index=[0 1 2]\n      Test:  index=[3]\n    Fold 3:\n      Train: index=[0 1 2 3]\n      Test:  index=[4]\n    Fold 4:\n      Train: index=[0 1 2 3 4]\n      Test:  index=[5]\n    >>> # Fix test_size to 2 with 12 samples\n    >>> X = np.random.randn(12, 2)\n    >>> y = np.random.randint(0, 2, 12)\n    >>> tscv = TimeSeriesSplit(n_splits=3, test_size=2)\n    >>> for i, (train_index, test_index) in enumerate(tscv.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[0 1 2 3 4 5]\n      Test:  index=[6 7]\n    Fold 1:\n      Train: index=[0 1 2 3 4 5 6 7]\n      Test:  index=[8 9]\n    Fold 2:\n      Train: index=[0 1 2 3 4 5 6 7 8 9]\n      Test:  index=[10 11]\n    >>> # Add in a 2 period gap\n    >>> tscv = TimeSeriesSplit(n_splits=3, test_size=2, gap=2)\n    >>> for i, (train_index, test_index) in enumerate(tscv.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[0 1 2 3]\n      Test:  index=[6 7]\n    Fold 1:\n      Train: index=[0 1 2 3 4 5]\n      Test:  index=[8 9]\n    Fold 2:\n      Train: index=[0 1 2 3 4 5 6 7]\n      Test:  index=[10 11]\n\n    For a more extended example see\n    :ref:`sphx_glr_auto_examples_applications_plot_cyclical_feature_engineering.py`.\n\n    Notes\n    -----\n    The training set has size ``i * n_samples // (n_splits + 1)\n    + n_samples % (n_splits + 1)`` in the ``i`` th split,\n    with a test set of size ``n_samples//(n_splits + 1)`` by default,\n    where ``n_samples`` is the number of samples. Note that this\n    formula is only valid when ``test_size`` and ``max_train_size`` are\n    left to their default values.",
        "examples": "--------\n    >>> import numpy as np\n    >>> from sklearn.model_selection import TimeSeriesSplit\n    >>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])\n    >>> y = np.array([1, 2, 3, 4, 5, 6])\n    >>> tscv = TimeSeriesSplit()\n    >>> print(tscv)\n    TimeSeriesSplit(gap=0, max_train_size=None, n_splits=5, test_size=None)\n    >>> for i, (train_index, test_index) in enumerate(tscv.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[0]\n      Test:  index=[1]\n    Fold 1:\n      Train: index=[0 1]\n      Test:  index=[2]\n    Fold 2:\n      Train: index=[0 1 2]\n      Test:  index=[3]\n    Fold 3:\n      Train: index=[0 1 2 3]\n      Test:  index=[4]\n    Fold 4:\n      Train: index=[0 1 2 3 4]\n      Test:  index=[5]\n    >>> # Fix test_size to 2 with 12 samples\n    >>> X = np.random.randn(12, 2)\n    >>> y = np.random.randint(0, 2, 12)\n    >>> tscv = TimeSeriesSplit(n_splits=3, test_size=2)\n    >>> for i, (train_index, test_index) in enumerate(tscv.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[0 1 2 3 4 5]\n      Test:  index=[6 7]\n    Fold 1:\n      Train: index=[0 1 2 3 4 5 6 7]\n      Test:  index=[8 9]\n    Fold 2:\n      Train: index=[0 1 2 3 4 5 6 7 8 9]\n      Test:  index=[10 11]\n    >>> # Add in a 2 period gap\n    >>> tscv = TimeSeriesSplit(n_splits=3, test_size=2, gap=2)\n    >>> for i, (train_index, test_index) in enumerate(tscv.split(X)):\n    ...     print(f\"Fold {i}:\")\n    ...     print(f\"  Train: index={train_index}\")\n    ...     print(f\"  Test:  index={test_index}\")\n    Fold 0:\n      Train: index=[0 1 2 3]\n      Test:  index=[6 7]\n    Fold 1:\n      Train: index=[0 1 2 3 4 5]\n      Test:  index=[8 9]\n    Fold 2:\n      Train: index=[0 1 2 3 4 5 6 7]\n      Test:  index=[10 11]\n\n    For a more extended example see\n    :ref:`sphx_glr_auto_examples_applications_plot_cyclical_feature_engineering.py`.\n\n    Notes\n    -----\n    The training set has size ``i * n_samples // (n_splits + 1)\n    + n_samples % (n_splits + 1)`` in the ``i`` th split,\n    with a test set of size ``n_samples//(n_splits + 1)`` by default,\n    where ``n_samples`` is the number of samples. Note that this\n    formula is only valid when ``test_size`` and ``max_train_size`` are\n    left to their default values."
      },
      "methods": [
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRequest\n            A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_n_splits",
          "signature": "get_n_splits(self, X=None, y=None, groups=None)",
          "documentation": {
            "description": "Returns the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n        X : object\n            Always ignored, exists for compatibility.\n\n        y : object\n            Always ignored, exists for compatibility.\n\n        groups : object\n            Always ignored, exists for compatibility.",
            "parameters": {
              "X": {
                "type": "object",
                "description": ""
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Returns\n-------"
              },
              "y": {
                "type": "object",
                "description": ""
              },
              "groups": {
                "type": "object",
                "description": ""
              },
              "n_splits": {
                "type": "int",
                "description": ""
              },
              "Returns": {
                "type": "the number of splitting iterations in the cross-validator.",
                "description": ""
              }
            },
            "returns": "-------\n        n_splits : int",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "split",
          "signature": "split(self, X, y=None, groups=None)",
          "documentation": {
            "description": "Generate indices to split data into training and test set.",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples",
                "description": ""
              },
              "and": {
                "type": "`n_features` is the number of features.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Always": {
                "type": "ignored, exists for compatibility.",
                "description": "Yields\n------"
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "train": {
                "type": "ndarray",
                "description": ""
              },
              "The": {
                "type": "testing set indices for that split.",
                "description": ""
              },
              "test": {
                "type": "ndarray",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "TunedThresholdClassifierCV",
      "documentation": {
        "description": "Classifier that post-tunes the decision threshold using cross-validation.\n\n    This estimator post-tunes the decision threshold (cut-off point) that is\n    used for converting posterior probability estimates (i.e. output of\n    `predict_proba`) or decision scores (i.e. output of `decision_function`)\n    into a class label. The tuning is done by optimizing a binary metric,\n    potentially constrained by a another metric.\n\n    Read more in the :ref:`User Guide <TunedThresholdClassifierCV>`.\n\n    .. versionadded:: 1.5\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        The classifier, fitted or not, for which we want to optimize\n        the decision threshold used during `predict`.\n\n    scoring : str or callable, default=\"balanced_accuracy\"\n        The objective metric to be optimized. Can be one of:\n\n        * a string associated to a scoring function for binary classification\n          (see :ref:`scoring_parameter`);\n        * a scorer callable object created with :func:`~sklearn.metrics.make_scorer`;\n\n    response_method : {\"auto\", \"decision_function\", \"predict_proba\"}, default=\"auto\"\n        Methods by the classifier `estimator` corresponding to the\n        decision function for which we want to find a threshold. It can be:\n\n        * if `\"auto\"`, it will try to invoke, for each classifier,\n          `\"predict_proba\"` or `\"decision_function\"` in that order.\n        * otherwise, one of `\"predict_proba\"` or `\"decision_function\"`.\n          If the method is not implemented by the classifier, it will raise an\n          error.\n\n    thresholds : int or array-like, default=100\n        The number of decision threshold to use when discretizing the output of the\n        classifier `method`. Pass an array-like to manually specify the thresholds\n        to use.\n\n    cv : int, float, cross-validation generator, iterable or \"prefit\", default=None\n        Determines the cross-validation splitting strategy to train classifier.\n        Possible inputs for cv are:\n\n        * `None`, to use the default 5-fold stratified K-fold cross validation;\n        * An integer number, to specify the number of folds in a stratified k-fold;\n        * A float number, to specify a single shuffle split. The floating number should\n          be in (0, 1) and represent the size of the validation set;\n        * An object to be used as a cross-validation generator;\n        * An iterable yielding train, test splits;\n        * `\"prefit\"`, to bypass the cross-validation.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. warning::\n            Using `cv=\"prefit\"` and passing the same dataset for fitting `estimator`\n            and tuning the cut-off point is subject to undesired overfitting. You can\n            refer to :ref:`TunedThresholdClassifierCV_no_cv` for an example.\n\n            This option should only be used when the set used to fit `estimator` is\n            different from the one used to tune the cut-off point (by calling\n            :meth:`TunedThresholdClassifierCV.fit`).\n\n    refit : bool, default=True\n        Whether or not to refit the classifier on the entire training set once\n        the decision threshold has been found.\n        Note that forcing `refit=False` on cross-validation having more\n        than a single split will raise an error. Similarly, `refit=True` in\n        conjunction with `cv=\"prefit\"` will raise an error.\n\n    n_jobs : int, default=None\n        The number of jobs to run in parallel. When `cv` represents a\n        cross-validation strategy, the fitting and scoring on each data split\n        is done in parallel. ``None`` means 1 unless in a\n        :obj:`joblib.parallel_backend` context. ``-1`` means using all\n        processors. See :term:`Glossary <n_jobs>` for more details.\n\n    random_state : int, RandomState instance or None, default=None\n        Controls the randomness of cross-validation when `cv` is a float.\n        See :term:`Glossary <random_state>`.\n\n    store_cv_results : bool, default=False\n        Whether to store all scores and thresholds computed during the cross-validation\n        process.\n\n    Attributes\n    ----------\n    estimator_ : estimator instance\n        The fitted classifier used when predicting.\n\n    best_threshold_ : float\n        The new decision threshold.\n\n    best_score_ : float or None\n        The optimal score of the objective metric, evaluated at `best_threshold_`.\n\n    cv_results_ : dict or None\n        A dictionary containing the scores and thresholds computed during the\n        cross-validation process. Only exist if `store_cv_results=True`. The\n        keys are `\"thresholds\"` and `\"scores\"`.\n\n    classes_ : ndarray of shape (n_classes,)\n        The class labels.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`. Only defined if the\n        underlying estimator exposes such an attribute when fit.\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Only defined if the\n        underlying estimator exposes such an attribute when fit.\n\n    See Also\n    --------\n    sklearn.model_selection.FixedThresholdClassifier : Classifier that uses a\n        constant threshold.\n    sklearn.calibration.CalibratedClassifierCV : Estimator that calibrates\n        probabilities.",
        "parameters": {
          "estimator": {
            "type": "estimator instance",
            "description": ""
          },
          "The": {
            "type": "class labels.",
            "description": ""
          },
          "the": {
            "type": "decision threshold has been found.",
            "description": ""
          },
          "scoring": {
            "type": "str or callable, default=\"balanced_accuracy\"",
            "description": ""
          },
          "response_method": {
            "type": "{\"auto\", \"decision_function\", \"predict_proba\"}, default=\"auto\"",
            "description": ""
          },
          "Methods": {
            "type": "by the classifier `estimator` corresponding to the",
            "description": ""
          },
          "decision": {
            "type": "function for which we want to find a threshold. It can be:",
            "description": "* if `\"auto\"`, it will try to invoke, for each classifier,\n`\"predict_proba\"` or `\"decision_function\"` in that order.\n* otherwise, one of `\"predict_proba\"` or `\"decision_function\"`."
          },
          "If": {
            "type": "the method is not implemented by the classifier, it will raise an",
            "description": "error."
          },
          "thresholds": {
            "type": "int or array",
            "description": "like, default=100"
          },
          "classifier": {
            "type": "`method`. Pass an array-like to manually specify the thresholds",
            "description": ""
          },
          "to": {
            "type": "use.",
            "description": ""
          },
          "cv": {
            "type": "int, float, cross",
            "description": "validation generator, iterable or \"prefit\", default=None"
          },
          "Determines": {
            "type": "the cross-validation splitting strategy to train classifier.",
            "description": ""
          },
          "Possible": {
            "type": "inputs for cv are:",
            "description": "* `None`, to use the default 5-fold stratified K-fold cross validation;\n* An integer number, to specify the number of folds in a stratified k-fold;\n* A float number, to specify a single shuffle split. The floating number should"
          },
          "be": {
            "type": "in (0, 1) and represent the size of the validation set;",
            "description": "* An object to be used as a cross-validation generator;\n* An iterable yielding train, test splits;\n* `\"prefit\"`, to bypass the cross-validation."
          },
          "Refer": {
            "type": "ref:`User Guide <cross_validation>` for the various",
            "description": "cross-validation strategies that can be used here.\n.. warning::"
          },
          "Using": {
            "type": "`cv=\"prefit\"` and passing the same dataset for fitting `estimator`",
            "description": ""
          },
          "and": {
            "type": "tuning the cut-off point is subject to undesired overfitting. You can",
            "description": ""
          },
          "refer": {
            "type": "to :ref:`TunedThresholdClassifierCV_no_cv` for an example.",
            "description": ""
          },
          "This": {
            "type": "option should only be used when the set used to fit `estimator` is",
            "description": ""
          },
          "different": {
            "type": "from the one used to tune the cut-off point (by calling",
            "description": ":meth:`TunedThresholdClassifierCV.fit`)."
          },
          "refit": {
            "type": "bool, default=True",
            "description": ""
          },
          "Whether": {
            "type": "to store all scores and thresholds computed during the cross-validation",
            "description": "process.\nAttributes\n----------"
          },
          "Note": {
            "type": "that forcing `refit=False` on cross-validation having more",
            "description": ""
          },
          "than": {
            "type": "a single split will raise an error. Similarly, `refit=True` in",
            "description": ""
          },
          "conjunction": {
            "type": "with `cv=\"prefit\"` will raise an error.",
            "description": ""
          },
          "n_jobs": {
            "type": "int, default=None",
            "description": ""
          },
          "is": {
            "type": "done in parallel. ``None`` means 1 unless in a",
            "description": ":obj:`joblib.parallel_backend` context. ``-1`` means using all\nprocessors. See :term:`Glossary <n_jobs>` for more details."
          },
          "random_state": {
            "type": "int, RandomState instance or None, default=None",
            "description": ""
          },
          "Controls": {
            "type": "the randomness of cross-validation when `cv` is a float.",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------\nsklearn.model_selection.FixedThresholdClassifier : Classifier that uses a"
          },
          "store_cv_results": {
            "type": "bool, default=False",
            "description": ""
          },
          "estimator_": {
            "type": "estimator instance",
            "description": ""
          },
          "best_threshold_": {
            "type": "float",
            "description": ""
          },
          "best_score_": {
            "type": "float or None",
            "description": ""
          },
          "cv_results_": {
            "type": "dict or None",
            "description": ""
          },
          "A": {
            "type": "dictionary containing the scores and thresholds computed during the",
            "description": "cross-validation process. Only exist if `store_cv_results=True`. The"
          },
          "keys": {
            "type": "are `\"thresholds\"` and `\"scores\"`.",
            "description": ""
          },
          "classes_": {
            "type": "ndarray of shape (n_classes,)",
            "description": ""
          },
          "n_features_in_": {
            "type": "int",
            "description": ""
          },
          "Number": {
            "type": "of features seen during :term:`fit`. Only defined if the",
            "description": ""
          },
          "underlying": {
            "type": "estimator exposes such an attribute when fit.",
            "description": ""
          },
          "feature_names_in_": {
            "type": "ndarray of shape (`n_features_in_`,)",
            "description": ""
          },
          "Names": {
            "type": "of features seen during :term:`fit`. Only defined if the",
            "description": ""
          },
          "constant": {
            "type": "threshold.",
            "description": "sklearn.calibration.CalibratedClassifierCV : Estimator that calibrates\nprobabilities.\nExamples\n--------\n>>> from sklearn.datasets import make_classification\n>>> from sklearn.ensemble import RandomForestClassifier\n>>> from sklearn.metrics import classification_report\n>>> from sklearn.model_selection import TunedThresholdClassifierCV, train_test_split\n>>> X, y = make_classification(\n...     n_samples=1_000, weights=[0.9, 0.1], class_sep=0.8, random_state=42\n... )\n>>> X_train, X_test, y_train, y_test = train_test_split(\n...     X, y, stratify=y, random_state=42\n... )\n>>> classifier = RandomForestClassifier(random_state=0).fit(X_train, y_train)\n>>> print(classification_report(y_test, classifier.predict(X_test)))"
          },
          "precision": {
            "type": "recall  f1-score   support",
            "description": "<BLANKLINE>"
          },
          "0": {
            "type": "0.96      0.95      0.96       224",
            "description": ""
          },
          "1": {
            "type": "0.61      0.65      0.63        26",
            "description": "<BLANKLINE>"
          },
          "accuracy": {
            "type": "0.92       250",
            "description": ""
          },
          "macro": {
            "type": "avg       0.78      0.80      0.79       250",
            "description": ""
          },
          "weighted": {
            "type": "avg       0.92      0.92      0.92       250",
            "description": "<BLANKLINE>"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    sklearn.model_selection.FixedThresholdClassifier : Classifier that uses a\n        constant threshold.\n    sklearn.calibration.CalibratedClassifierCV : Estimator that calibrates\n        probabilities.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.ensemble import RandomForestClassifier\n    >>> from sklearn.metrics import classification_report\n    >>> from sklearn.model_selection import TunedThresholdClassifierCV, train_test_split\n    >>> X, y = make_classification(\n    ...     n_samples=1_000, weights=[0.9, 0.1], class_sep=0.8, random_state=42\n    ... )\n    >>> X_train, X_test, y_train, y_test = train_test_split(\n    ...     X, y, stratify=y, random_state=42\n    ... )\n    >>> classifier = RandomForestClassifier(random_state=0).fit(X_train, y_train)\n    >>> print(classification_report(y_test, classifier.predict(X_test)))\n                  precision    recall  f1-score   support\n    <BLANKLINE>\n               0       0.94      0.99      0.96       224\n               1       0.80      0.46      0.59        26\n    <BLANKLINE>\n        accuracy                           0.93       250\n       macro avg       0.87      0.72      0.77       250\n    weighted avg       0.93      0.93      0.92       250\n    <BLANKLINE>\n    >>> classifier_tuned = TunedThresholdClassifierCV(\n    ...     classifier, scoring=\"balanced_accuracy\"\n    ... ).fit(X_train, y_train)\n    >>> print(\n    ...     f\"Cut-off point found at {classifier_tuned.best_threshold_:.3f}\"\n    ... )\n    Cut-off point found at 0.342\n    >>> print(classification_report(y_test, classifier_tuned.predict(X_test)))\n                  precision    recall  f1-score   support\n    <BLANKLINE>\n               0       0.96      0.95      0.96       224\n               1       0.61      0.65      0.63        26\n    <BLANKLINE>\n        accuracy                           0.92       250\n       macro avg       0.78      0.80      0.79       250\n    weighted avg       0.92      0.92      0.92       250\n    <BLANKLINE>",
        "notes": "that forcing `refit=False` on cross-validation having more\n        than a single split will raise an error. Similarly, `refit=True` in\n        conjunction with `cv=\"prefit\"` will raise an error.\n\n    n_jobs : int, default=None\n        The number of jobs to run in parallel. When `cv` represents a\n        cross-validation strategy, the fitting and scoring on each data split\n        is done in parallel. ``None`` means 1 unless in a\n        :obj:`joblib.parallel_backend` context. ``-1`` means using all\n        processors. See :term:`Glossary <n_jobs>` for more details.\n\n    random_state : int, RandomState instance or None, default=None\n        Controls the randomness of cross-validation when `cv` is a float.\n        See :term:`Glossary <random_state>`.\n\n    store_cv_results : bool, default=False\n        Whether to store all scores and thresholds computed during the cross-validation\n        process.\n\n    Attributes\n    ----------\n    estimator_ : estimator instance\n        The fitted classifier used when predicting.\n\n    best_threshold_ : float\n        The new decision threshold.\n\n    best_score_ : float or None\n        The optimal score of the objective metric, evaluated at `best_threshold_`.\n\n    cv_results_ : dict or None\n        A dictionary containing the scores and thresholds computed during the\n        cross-validation process. Only exist if `store_cv_results=True`. The\n        keys are `\"thresholds\"` and `\"scores\"`.\n\n    classes_ : ndarray of shape (n_classes,)\n        The class labels.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`. Only defined if the\n        underlying estimator exposes such an attribute when fit.\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Only defined if the\n        underlying estimator exposes such an attribute when fit.\n\n    See Also\n    --------\n    sklearn.model_selection.FixedThresholdClassifier : Classifier that uses a\n        constant threshold.\n    sklearn.calibration.CalibratedClassifierCV : Estimator that calibrates\n        probabilities.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.ensemble import RandomForestClassifier\n    >>> from sklearn.metrics import classification_report\n    >>> from sklearn.model_selection import TunedThresholdClassifierCV, train_test_split\n    >>> X, y = make_classification(\n    ...     n_samples=1_000, weights=[0.9, 0.1], class_sep=0.8, random_state=42\n    ... )\n    >>> X_train, X_test, y_train, y_test = train_test_split(\n    ...     X, y, stratify=y, random_state=42\n    ... )\n    >>> classifier = RandomForestClassifier(random_state=0).fit(X_train, y_train)\n    >>> print(classification_report(y_test, classifier.predict(X_test)))\n                  precision    recall  f1-score   support\n    <BLANKLINE>\n               0       0.94      0.99      0.96       224\n               1       0.80      0.46      0.59        26\n    <BLANKLINE>\n        accuracy                           0.93       250\n       macro avg       0.87      0.72      0.77       250\n    weighted avg       0.93      0.93      0.92       250\n    <BLANKLINE>\n    >>> classifier_tuned = TunedThresholdClassifierCV(\n    ...     classifier, scoring=\"balanced_accuracy\"\n    ... ).fit(X_train, y_train)\n    >>> print(\n    ...     f\"Cut-off point found at {classifier_tuned.best_threshold_:.3f}\"\n    ... )\n    Cut-off point found at 0.342\n    >>> print(classification_report(y_test, classifier_tuned.predict(X_test)))\n                  precision    recall  f1-score   support\n    <BLANKLINE>\n               0       0.96      0.95      0.96       224\n               1       0.61      0.65      0.63        26\n    <BLANKLINE>\n        accuracy                           0.92       250\n       macro avg       0.78      0.80      0.79       250\n    weighted avg       0.92      0.92      0.92       250\n    <BLANKLINE>",
        "examples": "--------\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.ensemble import RandomForestClassifier\n    >>> from sklearn.metrics import classification_report\n    >>> from sklearn.model_selection import TunedThresholdClassifierCV, train_test_split\n    >>> X, y = make_classification(\n    ...     n_samples=1_000, weights=[0.9, 0.1], class_sep=0.8, random_state=42\n    ... )\n    >>> X_train, X_test, y_train, y_test = train_test_split(\n    ...     X, y, stratify=y, random_state=42\n    ... )\n    >>> classifier = RandomForestClassifier(random_state=0).fit(X_train, y_train)\n    >>> print(classification_report(y_test, classifier.predict(X_test)))\n                  precision    recall  f1-score   support\n    <BLANKLINE>\n               0       0.94      0.99      0.96       224\n               1       0.80      0.46      0.59        26\n    <BLANKLINE>\n        accuracy                           0.93       250\n       macro avg       0.87      0.72      0.77       250\n    weighted avg       0.93      0.93      0.92       250\n    <BLANKLINE>\n    >>> classifier_tuned = TunedThresholdClassifierCV(\n    ...     classifier, scoring=\"balanced_accuracy\"\n    ... ).fit(X_train, y_train)\n    >>> print(\n    ...     f\"Cut-off point found at {classifier_tuned.best_threshold_:.3f}\"\n    ... )\n    Cut-off point found at 0.342\n    >>> print(classification_report(y_test, classifier_tuned.predict(X_test)))\n                  precision    recall  f1-score   support\n    <BLANKLINE>\n               0       0.96      0.95      0.96       224\n               1       0.61      0.65      0.63        26\n    <BLANKLINE>\n        accuracy                           0.92       250\n       macro avg       0.78      0.80      0.79       250\n    weighted avg       0.92      0.92      0.92       250\n    <BLANKLINE>"
      },
      "methods": [
        {
          "name": "decision_function",
          "signature": "decision_function(self, X)",
          "documentation": {
            "description": "Decision function for samples in `X` using the fitted estimator.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Training vectors, where `n_samples` is the number of samples and\n            `n_features` is the number of features.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "vectors, where `n_samples` is the number of samples and",
                "description": "`n_features` is the number of features.\nReturns\n-------"
              },
              "decisions": {
                "type": "ndarray of shape (n_samples,)",
                "description": ""
              },
              "The": {
                "type": "decision function computed the fitted estimator.",
                "description": ""
              }
            },
            "returns": "-------\n        decisions : ndarray of shape (n_samples,)\n            The decision function computed the fitted estimator.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fit",
          "signature": "fit(self, X, y, **params)",
          "documentation": {
            "description": "Fit the classifier.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Training data.\n\n        y : array-like of shape (n_samples,)\n            Target values.\n\n        **params : dict\n            Parameters to pass to the `fit` method of the underlying\n            classifier.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,)"
              },
              "Target": {
                "type": "values.",
                "description": "**params : dict"
              }
            },
            "returns": "-------\n        self : object",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_metadata_routing",
          "signature": "get_metadata_routing(self)",
          "documentation": {
            "description": "Get metadata routing of this object.\n\n        Please check :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.",
            "parameters": {},
            "returns": "-------\n        routing : MetadataRouter\n            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating\n            routing information.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_params",
          "signature": "get_params(self, deep=True)",
          "documentation": {
            "description": "Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.",
            "parameters": {
              "deep": {
                "type": "bool, default=True",
                "description": ""
              },
              "If": {
                "type": "True, will return the parameters for this estimator and",
                "description": ""
              },
              "contained": {
                "type": "subobjects that are estimators.",
                "description": "Returns\n-------"
              },
              "params": {
                "type": "dict",
                "description": ""
              },
              "Parameter": {
                "type": "names mapped to their values.",
                "description": ""
              }
            },
            "returns": "-------\n        params : dict\n            Parameter names mapped to their values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict",
          "signature": "predict(self, X)",
          "documentation": {
            "description": "Predict the target of new samples.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The samples, as accepted by `estimator.predict`.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "The": {
                "type": "predicted class.",
                "description": ""
              },
              "class_labels": {
                "type": "ndarray of shape (n_samples,)",
                "description": ""
              }
            },
            "returns": "-------\n        class_labels : ndarray of shape (n_samples,)\n            The predicted class.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_log_proba",
          "signature": "predict_log_proba(self, X)",
          "documentation": {
            "description": "Predict logarithm class probabilities for `X` using the fitted estimator.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Training vectors, where `n_samples` is the number of samples and\n            `n_features` is the number of features.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "vectors, where `n_samples` is the number of samples and",
                "description": "`n_features` is the number of features.\nReturns\n-------"
              },
              "log_probabilities": {
                "type": "ndarray of shape (n_samples, n_classes)",
                "description": ""
              },
              "The": {
                "type": "logarithm class probabilities of the input samples.",
                "description": ""
              }
            },
            "returns": "-------\n        log_probabilities : ndarray of shape (n_samples, n_classes)\n            The logarithm class probabilities of the input samples.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "predict_proba",
          "signature": "predict_proba(self, X)",
          "documentation": {
            "description": "Predict class probabilities for `X` using the fitted estimator.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Training vectors, where `n_samples` is the number of samples and\n            `n_features` is the number of features.",
            "parameters": {
              "X": {
                "type": "{array",
                "description": "like, sparse matrix} of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "vectors, where `n_samples` is the number of samples and",
                "description": "`n_features` is the number of features.\nReturns\n-------"
              },
              "probabilities": {
                "type": "ndarray of shape (n_samples, n_classes)",
                "description": ""
              },
              "The": {
                "type": "class probabilities of the input samples.",
                "description": ""
              }
            },
            "returns": "-------\n        probabilities : ndarray of shape (n_samples, n_classes)\n            The class probabilities of the input samples.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "score",
          "signature": "score(self, X, y, sample_weight=None)",
          "documentation": {
            "description": "",
            "parameters": {
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Test": {
                "type": "samples.",
                "description": ""
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs)"
              },
              "True": {
                "type": "labels for `X`.",
                "description": ""
              },
              "sample_weight": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "Sample": {
                "type": "weights.",
                "description": "Returns\n-------"
              },
              "score": {
                "type": "float",
                "description": ""
              },
              "Mean": {
                "type": "accuracy of ``self.predict(X)`` w.r.t. `y`.",
                "description": ""
              }
            },
            "returns": "the mean accuracy on the given test data and labels.\n\n        In multi-label classification, this is the subset accuracy\n        which is a harsh metric since you require for each sample that\n        each label set be correctly predicted.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Test samples.\n\n        y : array-like of shape (n_samples,) or (n_samples, n_outputs)\n            True labels for `X`.\n\n        sample_weight : array-like of shape (n_samples,), default=None\n            Sample weights.\n\n        Returns\n        -------\n        score : float\n            Mean accuracy of ``self.predict(X)`` w.r.t. `y`.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_params",
          "signature": "set_params(self, **params)",
          "documentation": {
            "description": "Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have\n        parameters of the form ``<component>__<parameter>`` so that it's\n        possible to update each component of a nested object.\n\n        Parameters\n        ----------\n        **params : dict\n            Estimator parameters.",
            "parameters": {
              "Estimator": {
                "type": "instance.",
                "description": ""
              },
              "self": {
                "type": "estimator instance",
                "description": ""
              },
              "of": {
                "type": "the form ``<component>__<parameter>`` so that it's",
                "description": ""
              },
              "possible": {
                "type": "to update each component of a nested object.",
                "description": ""
              }
            },
            "returns": "-------\n        self : estimator instance\n            Estimator instance.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_score_request",
          "signature": "set_score_request(self: sklearn.model_selection._classification_threshold.TunedThresholdClassifierCV, *, sample_weight: Union[bool, NoneType, str] = '$UNCHANGED$') -> sklearn.model_selection._classification_threshold.TunedThresholdClassifierCV",
          "documentation": {
            "description": "Request metadata passed to the ``score`` method.",
            "parameters": {
              "sample_weight": {
                "type": "str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED",
                "description": ""
              },
              "Metadata": {
                "type": "routing for ``sample_weight`` parameter in ``score``.",
                "description": "Returns\n-------"
              },
              "self": {
                "type": "object",
                "description": ""
              },
              "The": {
                "type": "updated object.",
                "description": ""
              },
              "and": {
                "type": "not others.",
                "description": ".. versionadded:: 1.3\n.. note::"
              },
              "This": {
                "type": "method is only relevant if this estimator is used as a",
                "description": "sub-estimator of a meta-estimator, e.g. used inside a\n:class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect."
              }
            },
            "returns": "-------\n        self : object\n            The updated object.",
            "raises": "",
            "see_also": "",
            "notes": "that this method is only relevant if\n        ``enable_metadata_routing=True`` (see :func:`sklearn.set_config`).\n        Please see :ref:`User Guide <metadata_routing>` on how the routing\n        mechanism works.\n\n        The options for each parameter are:\n\n        - ``True``: metadata is requested, and passed to ``score`` if provided. The request is ignored if metadata is not provided.\n\n        - ``False``: metadata is not requested and the meta-estimator will not pass it to ``score``.\n\n        - ``None``: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\n        - ``str``: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\n        The default (``sklearn.utils.metadata_routing.UNCHANGED``) retains the\n        existing request. This allows you to change the request for some\n        parameters and not others.\n\n        .. versionadded:: 1.3\n\n        .. note::\n            This method is only relevant if this estimator is used as a\n            sub-estimator of a meta-estimator, e.g. used inside a\n            :class:`~sklearn.pipeline.Pipeline`. Otherwise it has no effect.\n\n        Parameters\n        ----------\n        sample_weight : str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED\n            Metadata routing for ``sample_weight`` parameter in ``score``.\n\n        Returns\n        -------\n        self : object\n            The updated object.",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "ValidationCurveDisplay",
      "documentation": {
        "description": "Validation Curve visualization.\n\n    It is recommended to use\n    :meth:`~sklearn.model_selection.ValidationCurveDisplay.from_estimator` to\n    create a :class:`~sklearn.model_selection.ValidationCurveDisplay` instance.\n    All parameters are stored as attributes.\n\n    Read more in the :ref:`User Guide <visualizations>` for general information\n    about the visualization API and :ref:`detailed documentation\n    <validation_curve>` regarding the validation curve visualization.\n\n    .. versionadded:: 1.3\n\n    Parameters\n    ----------\n    param_name : str\n        Name of the parameter that has been varied.\n\n    param_range : array-like of shape (n_ticks,)\n        The values of the parameter that have been evaluated.\n\n    train_scores : ndarray of shape (n_ticks, n_cv_folds)\n        Scores on training sets.\n\n    test_scores : ndarray of shape (n_ticks, n_cv_folds)\n        Scores on test set.\n\n    score_name : str, default=None\n        The name of the score used in `validation_curve`. It will override the name\n        inferred from the `scoring` parameter. If `score` is `None`, we use `\"Score\"` if\n        `negate_score` is `False` and `\"Negative score\"` otherwise. If `scoring` is a\n        string or a callable, we infer the name. We replace `_` by spaces and capitalize\n        the first letter. We remove `neg_` and replace it by `\"Negative\"` if\n        `negate_score` is `False` or just remove it otherwise.\n\n    Attributes\n    ----------\n    ax_ : matplotlib Axes\n        Axes with the validation curve.\n\n    figure_ : matplotlib Figure\n        Figure containing the validation curve.\n\n    errorbar_ : list of matplotlib Artist or None\n        When the `std_display_style` is `\"errorbar\"`, this is a list of\n        `matplotlib.container.ErrorbarContainer` objects. If another style is\n        used, `errorbar_` is `None`.\n\n    lines_ : list of matplotlib Artist or None\n        When the `std_display_style` is `\"fill_between\"`, this is a list of\n        `matplotlib.lines.Line2D` objects corresponding to the mean train and\n        test scores. If another style is used, `line_` is `None`.\n\n    fill_between_ : list of matplotlib Artist or None\n        When the `std_display_style` is `\"fill_between\"`, this is a list of\n        `matplotlib.collections.PolyCollection` objects. If another style is\n        used, `fill_between_` is `None`.\n\n    See Also\n    --------\n    sklearn.model_selection.validation_curve : Compute the validation curve.",
        "parameters": {
          "param_name": {
            "type": "str",
            "description": ""
          },
          "Name": {
            "type": "of the parameter that has been varied.",
            "description": ""
          },
          "param_range": {
            "type": "array",
            "description": "like of shape (n_ticks,)"
          },
          "The": {
            "type": "name of the score used in `validation_curve`. It will override the name",
            "description": ""
          },
          "train_scores": {
            "type": "ndarray of shape (n_ticks, n_cv_folds)",
            "description": ""
          },
          "Scores": {
            "type": "on test set.",
            "description": ""
          },
          "test_scores": {
            "type": "ndarray of shape (n_ticks, n_cv_folds)",
            "description": ""
          },
          "score_name": {
            "type": "str, default=None",
            "description": ""
          },
          "inferred": {
            "type": "from the `scoring` parameter. If `score` is `None`, we use `\"Score\"` if",
            "description": "`negate_score` is `False` and `\"Negative score\"` otherwise. If `scoring` is a"
          },
          "string": {
            "type": "or a callable, we infer the name. We replace `_` by spaces and capitalize",
            "description": ""
          },
          "the": {
            "type": "first letter. We remove `neg_` and replace it by `\"Negative\"` if",
            "description": "`negate_score` is `False` or just remove it otherwise.\nAttributes\n----------"
          },
          "ax_": {
            "type": "matplotlib Axes",
            "description": ""
          },
          "Axes": {
            "type": "with the validation curve.",
            "description": ""
          },
          "figure_": {
            "type": "matplotlib Figure",
            "description": ""
          },
          "Figure": {
            "type": "containing the validation curve.",
            "description": ""
          },
          "errorbar_": {
            "type": "list of matplotlib Artist or None",
            "description": ""
          },
          "When": {
            "type": "the `std_display_style` is `\"fill_between\"`, this is a list of",
            "description": "`matplotlib.collections.PolyCollection` objects. If another style is\nused, `fill_between_` is `None`."
          },
          "lines_": {
            "type": "list of matplotlib Artist or None",
            "description": ""
          },
          "test": {
            "type": "scores. If another style is used, `line_` is `None`.",
            "description": ""
          },
          "fill_between_": {
            "type": "list of matplotlib Artist or None",
            "description": ""
          },
          "See": {
            "type": "Also",
            "description": "--------\nsklearn.model_selection.validation_curve : Compute the validation curve.\nExamples\n--------\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> from sklearn.datasets import make_classification\n>>> from sklearn.model_selection import ValidationCurveDisplay, validation_curve\n>>> from sklearn.linear_model import LogisticRegression\n>>> X, y = make_classification(n_samples=1_000, random_state=0)\n>>> logistic_regression = LogisticRegression()\n>>> param_name, param_range = \"C\", np.logspace(-8, 3, 10)\n>>> train_scores, test_scores = validation_curve(\n...     logistic_regression, X, y, param_name=param_name, param_range=param_range\n... )\n>>> display = ValidationCurveDisplay(\n...     param_name=param_name, param_range=param_range,\n...     train_scores=train_scores, test_scores=test_scores, score_name=\"Score\"\n... )\n>>> display.plot()\n<...>\n>>> plt.show()"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "--------\n    sklearn.model_selection.validation_curve : Compute the validation curve.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> import matplotlib.pyplot as plt\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.model_selection import ValidationCurveDisplay, validation_curve\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> X, y = make_classification(n_samples=1_000, random_state=0)\n    >>> logistic_regression = LogisticRegression()\n    >>> param_name, param_range = \"C\", np.logspace(-8, 3, 10)\n    >>> train_scores, test_scores = validation_curve(\n    ...     logistic_regression, X, y, param_name=param_name, param_range=param_range\n    ... )\n    >>> display = ValidationCurveDisplay(\n    ...     param_name=param_name, param_range=param_range,\n    ...     train_scores=train_scores, test_scores=test_scores, score_name=\"Score\"\n    ... )\n    >>> display.plot()\n    <...>\n    >>> plt.show()",
        "notes": "",
        "examples": "--------\n    >>> import numpy as np\n    >>> import matplotlib.pyplot as plt\n    >>> from sklearn.datasets import make_classification\n    >>> from sklearn.model_selection import ValidationCurveDisplay, validation_curve\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> X, y = make_classification(n_samples=1_000, random_state=0)\n    >>> logistic_regression = LogisticRegression()\n    >>> param_name, param_range = \"C\", np.logspace(-8, 3, 10)\n    >>> train_scores, test_scores = validation_curve(\n    ...     logistic_regression, X, y, param_name=param_name, param_range=param_range\n    ... )\n    >>> display = ValidationCurveDisplay(\n    ...     param_name=param_name, param_range=param_range,\n    ...     train_scores=train_scores, test_scores=test_scores, score_name=\"Score\"\n    ... )\n    >>> display.plot()\n    <...>\n    >>> plt.show()"
      },
      "methods": [
        {
          "name": "from_estimator",
          "signature": "from_estimator(estimator, X, y, *, param_name, param_range, groups=None, cv=None, scoring=None, n_jobs=None, pre_dispatch='all', verbose=0, error_score=nan, fit_params=None, ax=None, negate_score=False, score_name=None, score_type='both', std_display_style='fill_between', line_kw=None, fill_between_kw=None, errorbar_kw=None)",
          "documentation": {
            "description": "Create a validation curve display from an estimator.\n\n        Read more in the :ref:`User Guide <visualizations>` for general\n        information about the visualization API and :ref:`detailed\n        documentation <validation_curve>` regarding the validation curve\n        visualization.\n\n        Parameters\n        ----------\n        estimator : object type that implements the \"fit\" and \"predict\" methods\n            An object of that type which is cloned for each validation.\n\n        X : array-like of shape (n_samples, n_features)\n            Training data, where `n_samples` is the number of samples and\n            `n_features` is the number of features.\n\n        y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None\n            Target relative to X for classification or regression;\n            None for unsupervised learning.\n\n        param_name : str\n            Name of the parameter that will be varied.\n\n        param_range : array-like of shape (n_values,)\n            The values of the parameter that will be evaluated.\n\n        groups : array-like of shape (n_samples,), default=None\n            Group labels for the samples used while splitting the dataset into\n            train/test set. Only used in conjunction with a \"Group\" :term:`cv`\n            instance (e.g., :class:`GroupKFold`).\n\n        cv : int, cross-validation generator or an iterable, default=None\n            Determines the cross-validation splitting strategy.\n            Possible inputs for cv are:\n\n            - None, to use the default 5-fold cross validation,\n            - int, to specify the number of folds in a `(Stratified)KFold`,\n            - :term:`CV splitter`,\n            - An iterable yielding (train, test) splits as arrays of indices.\n\n            For int/None inputs, if the estimator is a classifier and `y` is\n            either binary or multiclass,\n            :class:`~sklearn.model_selection.StratifiedKFold` is used. In all\n            other cases, :class:`~sklearn.model_selection.KFold` is used. These\n            splitters are instantiated with `shuffle=False` so the splits will\n            be the same across calls.\n\n            Refer :ref:`User Guide <cross_validation>` for the various\n            cross-validation strategies that can be used here.\n\n        scoring : str or callable, default=None\n            A string (see :ref:`scoring_parameter`) or\n            a scorer callable object / function with signature\n            `scorer(estimator, X, y)` (see :ref:`scoring_callable`).\n\n        n_jobs : int, default=None\n            Number of jobs to run in parallel. Training the estimator and\n            computing the score are parallelized over the different training\n            and test sets. `None` means 1 unless in a\n            :obj:`joblib.parallel_backend` context. `-1` means using all\n            processors. See :term:`Glossary <n_jobs>` for more details.\n\n        pre_dispatch : int or str, default='all'\n            Number of predispatched jobs for parallel execution (default is\n            all). The option can reduce the allocated memory. The str can\n            be an expression like '2*n_jobs'.\n\n        verbose : int, default=0\n            Controls the verbosity: the higher, the more messages.\n\n        error_score : 'raise' or numeric, default=np.nan\n            Value to assign to the score if an error occurs in estimator\n            fitting. If set to 'raise', the error is raised. If a numeric value\n            is given, FitFailedWarning is raised.\n\n        fit_params : dict, default=None\n            Parameters to pass to the fit method of the estimator.\n\n        ax : matplotlib Axes, default=None\n            Axes object to plot on. If `None`, a new figure and axes is\n            created.\n\n        negate_score : bool, default=False\n            Whether or not to negate the scores obtained through\n            :func:`~sklearn.model_selection.validation_curve`. This is\n            particularly useful when using the error denoted by `neg_*` in\n            `scikit-learn`.\n\n        score_name : str, default=None\n            The name of the score used to decorate the y-axis of the plot. It will\n            override the name inferred from the `scoring` parameter. If `score` is\n            `None`, we use `\"Score\"` if `negate_score` is `False` and `\"Negative score\"`\n            otherwise. If `scoring` is a string or a callable, we infer the name. We\n            replace `_` by spaces and capitalize the first letter. We remove `neg_` and\n            replace it by `\"Negative\"` if `negate_score` is\n            `False` or just remove it otherwise.\n\n        score_type : {\"test\", \"train\", \"both\"}, default=\"both\"\n            The type of score to plot. Can be one of `\"test\"`, `\"train\"`, or\n            `\"both\"`.\n\n        std_display_style : {\"errorbar\", \"fill_between\"} or None, default=\"fill_between\"\n            The style used to display the score standard deviation around the\n            mean score. If `None`, no representation of the standard deviation\n            is displayed.\n\n        line_kw : dict, default=None\n            Additional keyword arguments passed to the `plt.plot` used to draw\n            the mean score.\n\n        fill_between_kw : dict, default=None\n            Additional keyword arguments passed to the `plt.fill_between` used\n            to draw the score standard deviation.\n\n        errorbar_kw : dict, default=None\n            Additional keyword arguments passed to the `plt.errorbar` used to\n            draw mean score and standard deviation score.\n\n        Returns\n        -------\n        display : :class:`~sklearn.model_selection.ValidationCurveDisplay`\n            Object that stores computed values.",
            "parameters": {
              "estimator": {
                "type": "object type that implements the \"fit\" and \"predict\" methods",
                "description": ""
              },
              "An": {
                "type": "object of that type which is cloned for each validation.",
                "description": ""
              },
              "X": {
                "type": "array",
                "description": "like of shape (n_samples, n_features)"
              },
              "Training": {
                "type": "data, where `n_samples` is the number of samples and",
                "description": "`n_features` is the number of features."
              },
              "y": {
                "type": "array",
                "description": "like of shape (n_samples,) or (n_samples, n_outputs) or None"
              },
              "Target": {
                "type": "relative to X for classification or regression;",
                "description": ""
              },
              "None": {
                "type": "for unsupervised learning.",
                "description": ""
              },
              "param_name": {
                "type": "str",
                "description": ""
              },
              "Name": {
                "type": "of the parameter that will be varied.",
                "description": ""
              },
              "param_range": {
                "type": "array",
                "description": "like of shape (n_values,)"
              },
              "The": {
                "type": "values of the parameter that will be evaluated.",
                "description": ""
              },
              "groups": {
                "type": "array",
                "description": "like of shape (n_samples,), default=None"
              },
              "Group": {
                "type": "labels for the samples used while splitting the dataset into",
                "description": "train/test set. Only used in conjunction with a \"Group\" :term:`cv`"
              },
              "instance": {
                "type": "e.g., :class:`GroupKFold`",
                "description": "."
              },
              "cv": {
                "type": "int, cross",
                "description": "validation generator or an iterable, default=None"
              },
              "Determines": {
                "type": "the cross-validation splitting strategy.",
                "description": ""
              },
              "Possible": {
                "type": "inputs for cv are:",
                "description": "- None, to use the default 5-fold cross validation,\n- int, to specify the number of folds in a `(Stratified)KFold`,\n- :term:`CV splitter`,\n- An iterable yielding (train, test) splits as arrays of indices."
              },
              "For": {
                "type": "int/None inputs, if the estimator is a classifier and `y` is",
                "description": ""
              },
              "either": {
                "type": "binary or multiclass,",
                "description": ":class:`~sklearn.model_selection.StratifiedKFold` is used. In all"
              },
              "other": {
                "type": "cases, :class:`~sklearn.model_selection.KFold` is used. These",
                "description": ""
              },
              "splitters": {
                "type": "are instantiated with `shuffle=False` so the splits will",
                "description": ""
              },
              "be": {
                "type": "an expression like '2*n_jobs'.",
                "description": ""
              },
              "Refer": {
                "type": "ref:`User Guide <cross_validation>` for the various",
                "description": "cross-validation strategies that can be used here."
              },
              "scoring": {
                "type": "str or callable, default=None",
                "description": ""
              },
              "A": {
                "type": "string (see :ref:`scoring_parameter`) or",
                "description": ""
              },
              "a": {
                "type": "scorer callable object / function with signature",
                "description": "`scorer(estimator, X, y)` (see :ref:`scoring_callable`)."
              },
              "n_jobs": {
                "type": "int, default=None",
                "description": ""
              },
              "Number": {
                "type": "of predispatched jobs for parallel execution (default is",
                "description": "all). The option can reduce the allocated memory. The str can"
              },
              "computing": {
                "type": "the score are parallelized over the different training",
                "description": ""
              },
              "and": {
                "type": "test sets. `None` means 1 unless in a",
                "description": ":obj:`joblib.parallel_backend` context. `-1` means using all\nprocessors. See :term:`Glossary <n_jobs>` for more details."
              },
              "pre_dispatch": {
                "type": "int or str, default='all'",
                "description": ""
              },
              "verbose": {
                "type": "int, default=0",
                "description": ""
              },
              "Controls": {
                "type": "the verbosity: the higher, the more messages.",
                "description": ""
              },
              "error_score": {
                "type": "'raise' or numeric, default=np.nan",
                "description": ""
              },
              "Value": {
                "type": "to assign to the score if an error occurs in estimator",
                "description": "fitting. If set to 'raise', the error is raised. If a numeric value"
              },
              "is": {
                "type": "given, FitFailedWarning is raised.",
                "description": ""
              },
              "fit_params": {
                "type": "dict, default=None",
                "description": ""
              }
            },
            "returns": "-------\n        display : :class:`~sklearn.model_selection.ValidationCurveDisplay`\n            Object that stores computed values.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> import matplotlib.pyplot as plt\n        >>> from sklearn.datasets import make_classification\n        >>> from sklearn.model_selection import ValidationCurveDisplay\n        >>> from sklearn.linear_model import LogisticRegression\n        >>> X, y = make_classification(n_samples=1_000, random_state=0)\n        >>> logistic_regression = LogisticRegression()\n        >>> param_name, param_range = \"C\", np.logspace(-8, 3, 10)\n        >>> ValidationCurveDisplay.from_estimator(\n        ...     logistic_regression, X, y, param_name=param_name,\n        ...     param_range=param_range,\n        ... )\n        <...>\n        >>> plt.show()",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": "--------\n        >>> import numpy as np\n        >>> import matplotlib.pyplot as plt\n        >>> from sklearn.datasets import make_classification\n        >>> from sklearn.model_selection import ValidationCurveDisplay\n        >>> from sklearn.linear_model import LogisticRegression\n        >>> X, y = make_classification(n_samples=1_000, random_state=0)\n        >>> logistic_regression = LogisticRegression()\n        >>> param_name, param_range = \"C\", np.logspace(-8, 3, 10)\n        >>> ValidationCurveDisplay.from_estimator(\n        ...     logistic_regression, X, y, param_name=param_name,\n        ...     param_range=param_range,\n        ... )\n        <...>\n        >>> plt.show()"
          }
        },
        {
          "name": "plot",
          "signature": "plot(self, ax=None, *, negate_score=False, score_name=None, score_type='both', std_display_style='fill_between', line_kw=None, fill_between_kw=None, errorbar_kw=None)",
          "documentation": {
            "description": "Plot visualization.\n\n        Parameters\n        ----------\n        ax : matplotlib Axes, default=None\n            Axes object to plot on. If `None`, a new figure and axes is\n            created.\n\n        negate_score : bool, default=False\n            Whether or not to negate the scores obtained through\n            :func:`~sklearn.model_selection.validation_curve`. This is\n            particularly useful when using the error denoted by `neg_*` in\n            `scikit-learn`.\n\n        score_name : str, default=None\n            The name of the score used to decorate the y-axis of the plot. It will\n            override the name inferred from the `scoring` parameter. If `score` is\n            `None`, we use `\"Score\"` if `negate_score` is `False` and `\"Negative score\"`\n            otherwise. If `scoring` is a string or a callable, we infer the name. We\n            replace `_` by spaces and capitalize the first letter. We remove `neg_` and\n            replace it by `\"Negative\"` if `negate_score` is\n            `False` or just remove it otherwise.\n\n        score_type : {\"test\", \"train\", \"both\"}, default=\"both\"\n            The type of score to plot. Can be one of `\"test\"`, `\"train\"`, or\n            `\"both\"`.\n\n        std_display_style : {\"errorbar\", \"fill_between\"} or None, default=\"fill_between\"\n            The style used to display the score standard deviation around the\n            mean score. If None, no standard deviation representation is\n            displayed.\n\n        line_kw : dict, default=None\n            Additional keyword arguments passed to the `plt.plot` used to draw\n            the mean score.\n\n        fill_between_kw : dict, default=None\n            Additional keyword arguments passed to the `plt.fill_between` used\n            to draw the score standard deviation.\n\n        errorbar_kw : dict, default=None\n            Additional keyword arguments passed to the `plt.errorbar` used to\n            draw mean score and standard deviation score.",
            "parameters": {
              "ax": {
                "type": "matplotlib Axes, default=None",
                "description": ""
              },
              "Axes": {
                "type": "object to plot on. If `None`, a new figure and axes is",
                "description": "created."
              },
              "negate_score": {
                "type": "bool, default=False",
                "description": ""
              },
              "Whether": {
                "type": "or not to negate the scores obtained through",
                "description": ":func:`~sklearn.model_selection.validation_curve`. This is"
              },
              "particularly": {
                "type": "useful when using the error denoted by `neg_*` in",
                "description": "`scikit-learn`."
              },
              "score_name": {
                "type": "str, default=None",
                "description": ""
              },
              "The": {
                "type": "style used to display the score standard deviation around the",
                "description": ""
              },
              "override": {
                "type": "the name inferred from the `scoring` parameter. If `score` is",
                "description": "`None`, we use `\"Score\"` if `negate_score` is `False` and `\"Negative score\"`\notherwise. If `scoring` is a string or a callable, we infer the name. We"
              },
              "replace": {
                "type": "it by `\"Negative\"` if `negate_score` is",
                "description": "`False` or just remove it otherwise."
              },
              "score_type": {
                "type": "{\"test\", \"train\", \"both\"}, default=\"both\"",
                "description": ""
              },
              "std_display_style": {
                "type": "{\"errorbar\", \"fill_between\"} or None, default=\"fill_between\"",
                "description": ""
              },
              "mean": {
                "type": "score. If None, no standard deviation representation is",
                "description": "displayed."
              },
              "line_kw": {
                "type": "dict, default=None",
                "description": ""
              },
              "Additional": {
                "type": "keyword arguments passed to the `plt.errorbar` used to",
                "description": ""
              },
              "the": {
                "type": "mean score.",
                "description": ""
              },
              "fill_between_kw": {
                "type": "dict, default=None",
                "description": ""
              },
              "to": {
                "type": "draw the score standard deviation.",
                "description": ""
              },
              "errorbar_kw": {
                "type": "dict, default=None",
                "description": ""
              },
              "draw": {
                "type": "mean score and standard deviation score.",
                "description": "Returns\n-------"
              },
              "display": {
                "type": ":class:`~sklearn.model_selection.ValidationCurveDisplay`",
                "description": ""
              },
              "Object": {
                "type": "that stores computed values.",
                "description": ""
              }
            },
            "returns": "-------\n        display : :class:`~sklearn.model_selection.ValidationCurveDisplay`\n            Object that stores computed values.",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    }
  ]
}