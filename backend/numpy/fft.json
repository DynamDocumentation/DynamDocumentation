{
  "description": "Discrete Fourier Transform (:mod:`numpy.fft`)\n=============================================\n\n.. currentmodule:: numpy.fft\n\nThe SciPy module `scipy.fft` is a more comprehensive superset\nof ``numpy.fft``, which includes only a basic set of routines.\n\nStandard FFTs\n-------------\n\n.. autosummary::\n   :toctree: generated/\n\n   fft       Discrete Fourier transform.\n   ifft      Inverse discrete Fourier transform.\n   fft2      Discrete Fourier transform in two dimensions.\n   ifft2     Inverse discrete Fourier transform in two dimensions.\n   fftn      Discrete Fourier transform in N-dimensions.\n   ifftn     Inverse discrete Fourier transform in N dimensions.\n\nReal FFTs\n---------\n\n.. autosummary::\n   :toctree: generated/\n\n   rfft      Real discrete Fourier transform.\n   irfft     Inverse real discrete Fourier transform.\n   rfft2     Real discrete Fourier transform in two dimensions.\n   irfft2    Inverse real discrete Fourier transform in two dimensions.\n   rfftn     Real discrete Fourier transform in N dimensions.\n   irfftn    Inverse real discrete Fourier transform in N dimensions.\n\nHermitian FFTs\n--------------\n\n.. autosummary::\n   :toctree: generated/\n\n   hfft      Hermitian discrete Fourier transform.\n   ihfft     Inverse Hermitian discrete Fourier transform.\n\nHelper routines\n---------------\n\n.. autosummary::\n   :toctree: generated/\n\n   fftfreq   Discrete Fourier Transform sample frequencies.\n   rfftfreq  DFT sample frequencies (for usage with rfft, irfft).\n   fftshift  Shift zero-frequency component to center of spectrum.\n   ifftshift Inverse of fftshift.\n\n\nBackground information\n----------------------\n\nFourier analysis is fundamentally a method for expressing a function as a\nsum of periodic components, and for recovering the function from those\ncomponents.  When both the function and its Fourier transform are\nreplaced with discretized counterparts, it is called the discrete Fourier\ntransform (DFT).  The DFT has become a mainstay of numerical computing in\npart because of a very fast algorithm for computing it, called the Fast\nFourier Transform (FFT), which was known to Gauss (1805) and was brought\nto light in its current form by Cooley and Tukey [CT]_.  Press et al. [NR]_\nprovide an accessible introduction to Fourier analysis and its\napplications.\n\nBecause the discrete Fourier transform separates its input into\ncomponents that contribute at discrete frequencies, it has a great number\nof applications in digital signal processing, e.g., for filtering, and in\nthis context the discretized input to the transform is customarily\nreferred to as a *signal*, which exists in the *time domain*.  The output\nis called a *spectrum* or *transform* and exists in the *frequency\ndomain*.\n\nImplementation details\n----------------------\n\nThere are many ways to define the DFT, varying in the sign of the\nexponent, normalization, etc.  In this implementation, the DFT is defined\nas\n\n.. math::\n   A_k =  \\sum_{m=0}^{n-1} a_m \\exp\\left\\{-2\\pi i{mk \\over n}\\right\\}\n   \\qquad k = 0,\\ldots,n-1.\n\nThe DFT is in general defined for complex inputs and outputs, and a\nsingle-frequency component at linear frequency :math:`f` is\nrepresented by a complex exponential\n:math:`a_m = \\exp\\{2\\pi i\\,f m\\Delta t\\}`, where :math:`\\Delta t`\nis the sampling interval.\n\nThe values in the result follow so-called \"standard\" order: If ``A =\nfft(a, n)``, then ``A[0]`` contains the zero-frequency term (the sum of\nthe signal), which is always purely real for real inputs. Then ``A[1:n/2]``\ncontains the positive-frequency terms, and ``A[n/2+1:]`` contains the\nnegative-frequency terms, in order of decreasingly negative frequency.\nFor an even number of input points, ``A[n/2]`` represents both positive and\nnegative Nyquist frequency, and is also purely real for real input.  For\nan odd number of input points, ``A[(n-1)/2]`` contains the largest positive\nfrequency, while ``A[(n+1)/2]`` contains the largest negative frequency.\nThe routine ``np.fft.fftfreq(n)`` returns an array giving the frequencies\nof corresponding elements in the output.  The routine\n``np.fft.fftshift(A)`` shifts transforms and their frequencies to put the\nzero-frequency components in the middle, and ``np.fft.ifftshift(A)`` undoes\nthat shift.\n\nWhen the input `a` is a time-domain signal and ``A = fft(a)``, ``np.abs(A)``\nis its amplitude spectrum and ``np.abs(A)**2`` is its power spectrum.\nThe phase spectrum is obtained by ``np.angle(A)``.\n\nThe inverse DFT is defined as\n\n.. math::\n   a_m = \\frac{1}{n}\\sum_{k=0}^{n-1}A_k\\exp\\left\\{2\\pi i{mk\\over n}\\right\\}\n   \\qquad m = 0,\\ldots,n-1.\n\nIt differs from the forward transform by the sign of the exponential\nargument and the default normalization by :math:`1/n`.\n\nType Promotion\n--------------\n\n`numpy.fft` promotes ``float32`` and ``complex64`` arrays to ``float64`` and\n``complex128`` arrays respectively. For an FFT implementation that does not\npromote input arrays, see `scipy.fftpack`.\n\nNormalization\n-------------\n\nThe argument ``norm`` indicates which direction of the pair of direct/inverse\ntransforms is scaled and with what normalization factor.\nThe default normalization (``\"backward\"``) has the direct (forward) transforms\nunscaled and the inverse (backward) transforms scaled by :math:`1/n`. It is\npossible to obtain unitary transforms by setting the keyword argument ``norm``\nto ``\"ortho\"`` so that both direct and inverse transforms are scaled by\n:math:`1/\\sqrt{n}`. Finally, setting the keyword argument ``norm`` to\n``\"forward\"`` has the direct transforms scaled by :math:`1/n` and the inverse\ntransforms unscaled (i.e. exactly opposite to the default ``\"backward\"``).\n`None` is an alias of the default option ``\"backward\"`` for backward\ncompatibility.\n\nReal and Hermitian transforms\n-----------------------------\n\nWhen the input is purely real, its transform is Hermitian, i.e., the\ncomponent at frequency :math:`f_k` is the complex conjugate of the\ncomponent at frequency :math:`-f_k`, which means that for real\ninputs there is no information in the negative frequency components that\nis not already available from the positive frequency components.\nThe family of `rfft` functions is\ndesigned to operate on real inputs, and exploits this symmetry by\ncomputing only the positive frequency components, up to and including the\nNyquist frequency.  Thus, ``n`` input points produce ``n/2+1`` complex\noutput points.  The inverses of this family assumes the same symmetry of\nits input, and for an output of ``n`` points uses ``n/2+1`` input points.\n\nCorrespondingly, when the spectrum is purely real, the signal is\nHermitian.  The `hfft` family of functions exploits this symmetry by\nusing ``n/2+1`` complex points in the input (time) domain for ``n`` real\npoints in the frequency domain.\n\nIn higher dimensions, FFTs are used, e.g., for image analysis and\nfiltering.  The computational efficiency of the FFT means that it can\nalso be a faster way to compute large convolutions, using the property\nthat a convolution in the time domain is equivalent to a point-by-point\nmultiplication in the frequency domain.\n\nHigher dimensions\n-----------------\n\nIn two dimensions, the DFT is defined as\n\n.. math::\n   A_{kl} =  \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1}\n   a_{mn}\\exp\\left\\{-2\\pi i \\left({mk\\over M}+{nl\\over N}\\right)\\right\\}\n   \\qquad k = 0, \\ldots, M-1;\\quad l = 0, \\ldots, N-1,\n\nwhich extends in the obvious way to higher dimensions, and the inverses\nin higher dimensions also extend in the same way.\n\nReferences\n----------\n\n.. [CT] Cooley, James W., and John W. Tukey, 1965, \"An algorithm for the\n        machine calculation of complex Fourier series,\" *Math. Comput.*\n        19: 297-301.\n\n.. [NR] Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P.,\n        2007, *Numerical Recipes: The Art of Scientific Computing*, ch.\n        12-13.  Cambridge Univ. Press, Cambridge, UK.\n\nExamples\n--------\n\nFor examples, see the various functions.",
  "functions": [
    {
      "name": "fft",
      "signature": "fft(a, n=None, axis=-1, norm=None)",
      "documentation": {
        "description": "Compute the one-dimensional discrete Fourier Transform.\n\n    This function computes the one-dimensional *n*-point discrete Fourier\n    Transform (DFT) with the efficient Fast Fourier Transform (FFT)\n    algorithm [CT].",
        "parameters": {
          "n": {
            "type": "int",
            "description": "Length of the transformed axis of the output.\n        If `n` is smaller than the length of the input, the input is cropped.\n        If it is larger, the input is padded with zeros.  If `n` is not given,\n        the length of the input along the axis specified by `axis` is used."
          },
          "axis": {
            "type": "int",
            "description": "Axis over which to compute the FFT.  If not given, the last axis is\n        used."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          },
          "ifft": {
            "type": "The inverse of `fft`.",
            "description": ""
          },
          "fft2": {
            "type": "The two-dimensional FFT.",
            "description": ""
          },
          "fftn": {
            "type": "The *n*-dimensional FFT.",
            "description": ""
          },
          "rfftn": {
            "type": "The *n*-dimensional FFT of real input.",
            "description": ""
          },
          "fftfreq": {
            "type": "Frequency bins for given FFT parameters.",
            "description": ""
          },
          "19": {
            "type": "297-301.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fft2",
      "signature": "fft2(a, s=None, axes=(-2, -1), norm=None)",
      "documentation": {
        "description": "Compute the 2-dimensional discrete Fourier Transform.\n\n    This function computes the *n*-dimensional discrete Fourier Transform\n    over any axes in an *M*-dimensional array by means of the\n    Fast Fourier Transform (FFT).  By default, the transform is computed over\n    the last two axes of the input array, i.e., a 2-dimensional FFT.",
        "parameters": {
          "s": {
            "type": "sequence of ints",
            "description": "Shape (length of each transformed axis) of the output\n        (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).\n        This corresponds to ``n`` for ``fft(x, n)``.\n        Along each axis, if the given shape is smaller than that of the input,\n        the input is cropped.  If it is larger, the input is padded with zeros.\n        if `s` is not given, the shape of the input along the axes specified\n        by `axes` is used."
          },
          "axes": {
            "type": "sequence of ints",
            "description": "Axes over which to compute the FFT.  If not given, the last two\n        axes are used.  A repeated index in `axes` means the transform over\n        that axis is performed multiple times.  A one-element sequence means\n        that a one-dimensional FFT is performed."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          },
          "ifft2": {
            "type": "The inverse two-dimensional FFT.",
            "description": ""
          },
          "fft": {
            "type": "The one-dimensional FFT.",
            "description": ""
          },
          "fftn": {
            "type": "The *n*-dimensional FFT.",
            "description": ""
          },
          "fftshift": {
            "type": "Shifts zero-frequency terms to the center of the array.",
            "description": "For two-dimensional input, swaps first and third quadrants, and second\n        and fourth quadrants."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fftfreq",
      "signature": "fftfreq(n, d=1.0)",
      "documentation": {
        "description": "Return the Discrete Fourier Transform sample frequencies.\n\n    The returned float array `f` contains the frequency bin centers in cycles\n    per unit of the sample spacing (with zero at the start).  For instance, if\n    the sample spacing is in seconds, then the frequency unit is cycles/second.\n\n    Given a window length `n` and a sample spacing `d`::\n\n      f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d*n)   if n is even\n      f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd",
        "parameters": {
          "d": {
            "type": "scalar",
            "description": "Sample spacing (inverse of the sampling rate). Defaults to 1."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fftn",
      "signature": "fftn(a, s=None, axes=None, norm=None)",
      "documentation": {
        "description": "Compute the N-dimensional discrete Fourier Transform.\n\n    This function computes the *N*-dimensional discrete Fourier Transform over\n    any number of axes in an *M*-dimensional array by means of the Fast Fourier\n    Transform (FFT).",
        "parameters": {
          "s": {
            "type": "sequence of ints",
            "description": "Shape (length of each transformed axis) of the output\n        (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).\n        This corresponds to ``n`` for ``fft(x, n)``.\n        Along any axis, if the given shape is smaller than that of the input,\n        the input is cropped.  If it is larger, the input is padded with zeros.\n        if `s` is not given, the shape of the input along the axes specified\n        by `axes` is used."
          },
          "axes": {
            "type": "sequence of ints",
            "description": "Axes over which to compute the FFT.  If not given, the last ``len(s)``\n        axes are used, or all axes if `s` is also not specified.\n        Repeated indices in `axes` means that the transform over that axis is\n        performed multiple times."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          },
          "ifftn": {
            "type": "The inverse of `fftn`",
            "description": ", the inverse *n*-dimensional FFT."
          },
          "fft": {
            "type": "The one-dimensional FFT",
            "description": ", with definitions and conventions used."
          },
          "rfftn": {
            "type": "The *n*-dimensional FFT of real input.",
            "description": ""
          },
          "fft2": {
            "type": "The two-dimensional FFT.",
            "description": ""
          },
          "fftshift": {
            "type": "Shifts zero-frequency terms to centre of array",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fftshift",
      "signature": "fftshift(x, axes=None)",
      "documentation": {
        "description": "Shift the zero-frequency component to the center of the spectrum.\n\n    This function swaps half-spaces for all axes listed (defaults to all).\n    Note that ``y[0]`` is the Nyquist component only if ``len(x)`` is even.",
        "parameters": {
          "axes": {
            "type": "int or shape tuple",
            "description": "Axes over which to shift.  Default is None, which shifts all axes."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "hfft",
      "signature": "hfft(a, n=None, axis=-1, norm=None)",
      "documentation": {
        "description": "Compute the FFT of a signal that has Hermitian symmetry, i.e., a real\n    spectrum.",
        "parameters": {
          "n": {
            "type": "int",
            "description": "Length of the transformed axis of the output. For `n` output\n        points, ``n//2 + 1`` input points are necessary.  If the input is\n        longer than this, it is cropped.  If it is shorter than this, it is\n        padded with zeros.  If `n` is not given, it is taken to be ``2*(m-1)``\n        where ``m`` is the length of the input along the axis specified by\n        `axis`."
          },
          "axis": {
            "type": "int",
            "description": "Axis over which to compute the FFT. If not given, the last\n        axis is used."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          },
          "rfft": {
            "type": "Compute the one-dimensional FFT for real input.",
            "description": ""
          },
          "ihfft": {
            "type": "The inverse of `hfft`.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ifft",
      "signature": "ifft(a, n=None, axis=-1, norm=None)",
      "documentation": {
        "description": "Compute the one-dimensional inverse discrete Fourier Transform.\n\n    This function computes the inverse of the one-dimensional *n*-point\n    discrete Fourier transform computed by `fft`.  In other words,\n    ``ifft(fft(a)) == a`` to within numerical accuracy.\n    For a general description of the algorithm and definitions,\n    see `numpy.fft`.\n\n    The input should be ordered in the same way as is returned by `fft`,\n    i.e.,\n\n    * ``a[0]`` should contain the zero frequency term,\n    * ``a[1:n//2]`` should contain the positive-frequency terms,\n    * ``a[n//2 + 1:]`` should contain the negative-frequency terms, in\n      increasing order starting from the most negative frequency.\n\n    For an even number of input points, ``A[n//2]`` represents the sum of\n    the values at the positive and negative Nyquist frequencies, as the two\n    are aliased together. See `numpy.fft` for details.",
        "parameters": {
          "n": {
            "type": "int",
            "description": "Length of the transformed axis of the output.\n        If `n` is smaller than the length of the input, the input is cropped.\n        If it is larger, the input is padded with zeros.  If `n` is not given,\n        the length of the input along the axis specified by `axis` is used.\n        See notes about padding issues."
          },
          "axis": {
            "type": "int",
            "description": "Axis over which to compute the inverse DFT.  If not given, the last\n        axis is used."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          },
          "fft": {
            "type": "The one-dimensional (forward) FFT",
            "description": ", of which `ifft` is the inverse"
          },
          "ifft2": {
            "type": "The two-dimensional inverse FFT.",
            "description": ""
          },
          "ifftn": {
            "type": "The n-dimensional inverse FFT.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ifft2",
      "signature": "ifft2(a, s=None, axes=(-2, -1), norm=None)",
      "documentation": {
        "description": "Compute the 2-dimensional inverse discrete Fourier Transform.\n\n    This function computes the inverse of the 2-dimensional discrete Fourier\n    Transform over any number of axes in an M-dimensional array by means of\n    the Fast Fourier Transform (FFT).  In other words, ``ifft2(fft2(a)) == a``\n    to within numerical accuracy.  By default, the inverse transform is\n    computed over the last two axes of the input array.\n\n    The input, analogously to `ifft`, should be ordered in the same way as is\n    returned by `fft2`, i.e. it should have the term for zero frequency\n    in the low-order corner of the two axes, the positive frequency terms in\n    the first half of these axes, the term for the Nyquist frequency in the\n    middle of the axes and the negative frequency terms in the second half of\n    both axes, in order of decreasingly negative frequency.",
        "parameters": {
          "s": {
            "type": "sequence of ints",
            "description": "Shape (length of each axis) of the output (``s[0]`` refers to axis 0,\n        ``s[1]`` to axis 1, etc.).  This corresponds to `n` for ``ifft(x, n)``.\n        Along each axis, if the given shape is smaller than that of the input,\n        the input is cropped.  If it is larger, the input is padded with zeros.\n        if `s` is not given, the shape of the input along the axes specified\n        by `axes` is used.  See notes for issue on `ifft` zero padding."
          },
          "axes": {
            "type": "sequence of ints",
            "description": "Axes over which to compute the FFT.  If not given, the last two\n        axes are used.  A repeated index in `axes` means the transform over\n        that axis is performed multiple times.  A one-element sequence means\n        that a one-dimensional FFT is performed."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          },
          "fft2": {
            "type": "The forward 2-dimensional FFT",
            "description": ", of which `ifft2` is the inverse."
          },
          "ifftn": {
            "type": "The inverse of the *n*-dimensional FFT.",
            "description": ""
          },
          "fft": {
            "type": "The one-dimensional FFT.",
            "description": ""
          },
          "ifft": {
            "type": "The one-dimensional inverse FFT.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ifftn",
      "signature": "ifftn(a, s=None, axes=None, norm=None)",
      "documentation": {
        "description": "Compute the N-dimensional inverse discrete Fourier Transform.\n\n    This function computes the inverse of the N-dimensional discrete\n    Fourier Transform over any number of axes in an M-dimensional array by\n    means of the Fast Fourier Transform (FFT).  In other words,\n    ``ifftn(fftn(a)) == a`` to within numerical accuracy.\n    For a description of the definitions and conventions used, see `numpy.fft`.\n\n    The input, analogously to `ifft`, should be ordered in the same way as is\n    returned by `fftn`, i.e. it should have the term for zero frequency\n    in all axes in the low-order corner, the positive frequency terms in the\n    first half of all axes, the term for the Nyquist frequency in the middle\n    of all axes and the negative frequency terms in the second half of all\n    axes, in order of decreasingly negative frequency.",
        "parameters": {
          "s": {
            "type": "sequence of ints",
            "description": "Shape (length of each transformed axis) of the output\n        (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).\n        This corresponds to ``n`` for ``ifft(x, n)``.\n        Along any axis, if the given shape is smaller than that of the input,\n        the input is cropped.  If it is larger, the input is padded with zeros.\n        if `s` is not given, the shape of the input along the axes specified\n        by `axes` is used.  See notes for issue on `ifft` zero padding."
          },
          "axes": {
            "type": "sequence of ints",
            "description": "Axes over which to compute the IFFT.  If not given, the last ``len(s)``\n        axes are used, or all axes if `s` is also not specified.\n        Repeated indices in `axes` means that the inverse transform over that\n        axis is performed multiple times."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          },
          "fftn": {
            "type": "The forward *n*-dimensional FFT",
            "description": ", of which `ifftn` is the inverse."
          },
          "ifft": {
            "type": "The one-dimensional inverse FFT.",
            "description": ""
          },
          "ifft2": {
            "type": "The two-dimensional inverse FFT.",
            "description": ""
          },
          "ifftshift": {
            "type": "Undoes `fftshift`",
            "description": ", shifts zero-frequency terms to beginning\n        of array."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ifftshift",
      "signature": "ifftshift(x, axes=None)",
      "documentation": {
        "description": "The inverse of `fftshift`. Although identical for even-length `x`, the\n    functions differ by one sample for odd-length `x`.",
        "parameters": {
          "axes": {
            "type": "int or shape tuple",
            "description": "Axes over which to calculate.  Defaults to None, which shifts all axes."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ihfft",
      "signature": "ihfft(a, n=None, axis=-1, norm=None)",
      "documentation": {
        "description": "Compute the inverse FFT of a signal that has Hermitian symmetry.",
        "parameters": {
          "n": {
            "type": "int",
            "description": "Length of the inverse FFT, the number of points along\n        transformation axis in the input to use.  If `n` is smaller than\n        the length of the input, the input is cropped.  If it is larger,\n        the input is padded with zeros. If `n` is not given, the length of\n        the input along the axis specified by `axis` is used."
          },
          "axis": {
            "type": "int",
            "description": "Axis over which to compute the inverse FFT. If not given, the last\n        axis is used."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "irfft",
      "signature": "irfft(a, n=None, axis=-1, norm=None)",
      "documentation": {
        "description": "Computes the inverse of `rfft`.\n\n    This function computes the inverse of the one-dimensional *n*-point\n    discrete Fourier Transform of real input computed by `rfft`.\n    In other words, ``irfft(rfft(a), len(a)) == a`` to within numerical\n    accuracy. (See Notes below for why ``len(a)`` is necessary here.)\n\n    The input is expected to be in the form returned by `rfft`, i.e. the\n    real zero-frequency term followed by the complex positive frequency terms\n    in order of increasing frequency.  Since the discrete Fourier Transform of\n    real input is Hermitian-symmetric, the negative frequency terms are taken\n    to be the complex conjugates of the corresponding positive frequency terms.",
        "parameters": {
          "n": {
            "type": "int",
            "description": "Length of the transformed axis of the output.\n        For `n` output points, ``n//2+1`` input points are necessary.  If the\n        input is longer than this, it is cropped.  If it is shorter than this,\n        it is padded with zeros.  If `n` is not given, it is taken to be\n        ``2*(m-1)`` where ``m`` is the length of the input along the axis\n        specified by `axis`."
          },
          "axis": {
            "type": "int",
            "description": "Axis over which to compute the inverse FFT. If not given, the last\n        axis is used."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          },
          "rfft": {
            "type": "The one-dimensional FFT of real input",
            "description": ", of which `irfft` is inverse."
          },
          "fft": {
            "type": "The one-dimensional FFT.",
            "description": ""
          },
          "irfft2": {
            "type": "The inverse of the two-dimensional FFT of real input.",
            "description": ""
          },
          "irfftn": {
            "type": "The inverse of the *n*-dimensional FFT of real input.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "irfft2",
      "signature": "irfft2(a, s=None, axes=(-2, -1), norm=None)",
      "documentation": {
        "description": "Computes the inverse of `rfft2`.",
        "parameters": {
          "s": {
            "type": "sequence of ints",
            "description": "Shape of the real output to the inverse FFT."
          },
          "axes": {
            "type": "sequence of ints",
            "description": "The axes over which to compute the inverse fft.\n        Default is the last two axes."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          },
          "rfft": {
            "type": "The one-dimensional FFT for real input.",
            "description": ""
          },
          "irfft": {
            "type": "The inverse of the one-dimensional FFT of real input.",
            "description": ""
          },
          "irfftn": {
            "type": "Compute the inverse of the N-dimensional FFT of real input.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "irfftn",
      "signature": "irfftn(a, s=None, axes=None, norm=None)",
      "documentation": {
        "description": "Computes the inverse of `rfftn`.\n\n    This function computes the inverse of the N-dimensional discrete\n    Fourier Transform for real input over any number of axes in an\n    M-dimensional array by means of the Fast Fourier Transform (FFT).  In\n    other words, ``irfftn(rfftn(a), a.shape) == a`` to within numerical\n    accuracy. (The ``a.shape`` is necessary like ``len(a)`` is for `irfft`,\n    and for the same reason.)\n\n    The input should be ordered in the same way as is returned by `rfftn`,\n    i.e. as for `irfft` for the final transformation axis, and as for `ifftn`\n    along all the other axes.",
        "parameters": {
          "s": {
            "type": "sequence of ints",
            "description": "Shape (length of each transformed axis) of the output\n        (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.). `s` is also the\n        number of input points used along this axis, except for the last axis,\n        where ``s[-1]//2+1`` points of the input are used.\n        Along any axis, if the shape indicated by `s` is smaller than that of\n        the input, the input is cropped.  If it is larger, the input is padded\n        with zeros. If `s` is not given, the shape of the input along the axes\n        specified by axes is used. Except for the last axis which is taken to\n        be ``2*(m-1)`` where ``m`` is the length of the input along that axis."
          },
          "axes": {
            "type": "sequence of ints",
            "description": "Axes over which to compute the inverse FFT. If not given, the last\n        `len(s)` axes are used, or all axes if `s` is also not specified.\n        Repeated indices in `axes` means that the inverse transform over that\n        axis is performed multiple times."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          },
          "fft": {
            "type": "The one-dimensional FFT",
            "description": ", with definitions and conventions used."
          },
          "irfft": {
            "type": "The inverse of the one-dimensional FFT of real input.",
            "description": ""
          },
          "irfft2": {
            "type": "The inverse of the two-dimensional FFT of real input.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "rfft",
      "signature": "rfft(a, n=None, axis=-1, norm=None)",
      "documentation": {
        "description": "Compute the one-dimensional discrete Fourier Transform for real input.\n\n    This function computes the one-dimensional *n*-point discrete Fourier\n    Transform (DFT) of a real-valued array by means of an efficient algorithm\n    called the Fast Fourier Transform (FFT).",
        "parameters": {
          "n": {
            "type": "int",
            "description": "Number of points along transformation axis in the input to use.\n        If `n` is smaller than the length of the input, the input is cropped.\n        If it is larger, the input is padded with zeros. If `n` is not given,\n        the length of the input along the axis specified by `axis` is used."
          },
          "axis": {
            "type": "int",
            "description": "Axis over which to compute the FFT. If not given, the last axis is\n        used."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          },
          "irfft": {
            "type": "The inverse of `rfft`.",
            "description": ""
          },
          "fft": {
            "type": "The one-dimensional FFT of general (complex) input.",
            "description": ""
          },
          "fftn": {
            "type": "The *n*-dimensional FFT.",
            "description": ""
          },
          "rfftn": {
            "type": "The *n*-dimensional FFT of real input.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "rfft2",
      "signature": "rfft2(a, s=None, axes=(-2, -1), norm=None)",
      "documentation": {
        "description": "Compute the 2-dimensional FFT of a real array.",
        "parameters": {
          "s": {
            "type": "sequence of ints",
            "description": "Shape of the FFT."
          },
          "axes": {
            "type": "sequence of ints",
            "description": "Axes over which to compute the FFT."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "rfftfreq",
      "signature": "rfftfreq(n, d=1.0)",
      "documentation": {
        "description": "Return the Discrete Fourier Transform sample frequencies\n    (for usage with rfft, irfft).\n\n    The returned float array `f` contains the frequency bin centers in cycles\n    per unit of the sample spacing (with zero at the start).  For instance, if\n    the sample spacing is in seconds, then the frequency unit is cycles/second.\n\n    Given a window length `n` and a sample spacing `d`::\n\n      f = [0, 1, ...,     n/2-1,     n/2] / (d*n)   if n is even\n      f = [0, 1, ..., (n-1)/2-1, (n-1)/2] / (d*n)   if n is odd\n\n    Unlike `fftfreq` (but like `scipy.fftpack.rfftfreq`)\n    the Nyquist frequency component is considered to be positive.",
        "parameters": {
          "d": {
            "type": "scalar",
            "description": "Sample spacing (inverse of the sampling rate). Defaults to 1."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "rfftn",
      "signature": "rfftn(a, s=None, axes=None, norm=None)",
      "documentation": {
        "description": "Compute the N-dimensional discrete Fourier Transform for real input.\n\n    This function computes the N-dimensional discrete Fourier Transform over\n    any number of axes in an M-dimensional real array by means of the Fast\n    Fourier Transform (FFT).  By default, all axes are transformed, with the\n    real transform performed over the last axis, while the remaining\n    transforms are complex.",
        "parameters": {
          "s": {
            "type": "sequence of ints",
            "description": "Shape (length along each transformed axis) to use from the input.\n        (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).\n        The final element of `s` corresponds to `n` for ``rfft(x, n)``, while\n        for the remaining axes, it corresponds to `n` for ``fft(x, n)``.\n        Along any axis, if the given shape is smaller than that of the input,\n        the input is cropped.  If it is larger, the input is padded with zeros.\n        if `s` is not given, the shape of the input along the axes specified\n        by `axes` is used."
          },
          "axes": {
            "type": "sequence of ints",
            "description": "Axes over which to compute the FFT.  If not given, the last ``len(s)``\n        axes are used, or all axes if `s` is also not specified."
          },
          "norm": {
            "type": "{\"backward\"",
            "description": ", \"ortho\", \"forward\"}, optional\n        .. versionadded:: 1.10.0\n\n        Normalization mode (see `numpy.fft`). Default is \"backward\".\n        Indicates which direction of the forward/backward pair of transforms\n        is scaled and with what normalization factor.\n\n        .. versionadded:: 1.20.0\n\n            The \"backward\", \"forward\" values were added."
          },
          "fft": {
            "type": "The one-dimensional FFT",
            "description": ", with definitions and conventions used."
          },
          "rfft": {
            "type": "The one-dimensional FFT of real input.",
            "description": ""
          },
          "fftn": {
            "type": "The n-dimensional FFT.",
            "description": ""
          },
          "rfft2": {
            "type": "The two-dimensional FFT of real input.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": []
}