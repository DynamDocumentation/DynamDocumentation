{
  "description": "=============\nMasked Arrays\n=============\n\nArrays sometimes contain invalid or missing data.  When doing operations\non such arrays, we wish to suppress invalid values, which is the purpose masked\narrays fulfill (an example of typical use is given below).\n\nFor example, examine the following array:\n\n>>> x = np.array([2, 1, 3, np.nan, 5, 2, 3, np.nan])\n\nWhen we try to calculate the mean of the data, the result is undetermined:\n\n>>> np.mean(x)\nnan\n\nThe mean is calculated using roughly ``np.sum(x)/len(x)``, but since\nany number added to ``NaN`` [1]_ produces ``NaN``, this doesn't work.  Enter\nmasked arrays:\n\n>>> m = np.ma.masked_array(x, np.isnan(x))\n>>> m\nmasked_array(data = [2.0 1.0 3.0 -- 5.0 2.0 3.0 --],\n      mask = [False False False  True False False False  True],\n      fill_value=1e+20)\n\nHere, we construct a masked array that suppress all ``NaN`` values.  We\nmay now proceed to calculate the mean of the other values:\n\n>>> np.mean(m)\n2.6666666666666665\n\n.. [1] Not-a-Number, a floating point value that is the result of an\n       invalid operation.\n\n.. moduleauthor:: Pierre Gerard-Marchant\n.. moduleauthor:: Jarrod Millman",
  "functions": [
    {
      "name": "abs",
      "signature": "absolute(a, *args, **kwargs)",
      "documentation": {
        "description": "absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate the absolute value element-wise.\n\n``np.abs`` is a shorthand for this function.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "absolute": {
            "type": "ndarray",
            "description": "An ndarray containing the absolute value of\n    each element in `x`.  For complex input, ``a + ib``, the\n    absolute value is :math:`\\sqrt{ a^2 + b^2 }`.\n    This is a scalar if `x` is a scalar."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "absolute",
      "signature": "absolute(a, *args, **kwargs)",
      "documentation": {
        "description": "absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate the absolute value element-wise.\n\n``np.abs`` is a shorthand for this function.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "absolute": {
            "type": "ndarray",
            "description": "An ndarray containing the absolute value of\n    each element in `x`.  For complex input, ``a + ib``, the\n    absolute value is :math:`\\sqrt{ a^2 + b^2 }`.\n    This is a scalar if `x` is a scalar."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "add",
      "signature": "add(a, b, *args, **kwargs)",
      "documentation": {
        "description": "add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nAdd arguments element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "add": {
            "type": "ndarray or scalar",
            "description": "The sum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "all",
      "signature": "all(a, *args, **params)",
      "documentation": {
        "description": "all(self, axis=None, out=None, keepdims=<no value>)\n\n        Returns True if all elements evaluate to True.\n\n        The output array is masked where all the values along the given axis\n        are masked: if the output would have been a scalar and that all the\n        values are masked, then the output is `masked`.\n\n        Refer to `numpy.all` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> np.ma.array([1,2,3]).all()\n        True\n        >>> a = np.ma.array([1,2,3], mask=True)\n        >>> (a.all() is np.ma.masked)\n        True",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "allclose",
      "signature": "allclose(a, b, masked_equal=True, rtol=1e-05, atol=1e-08)",
      "documentation": {
        "description": "Returns True if two arrays are element-wise equal within a tolerance.\n\n    This function is equivalent to `allclose` except that masked values\n    are treated as equal (default) or unequal, depending on the `masked_equal`\n    argument.",
        "parameters": {
          "masked_equal": {
            "type": "bool",
            "description": "Whether masked values in `a` and `b` are considered equal (True) or not\n        (False). They are considered equal by default."
          },
          "rtol": {
            "type": "float",
            "description": "Relative tolerance. The relative difference is equal to ``rtol * b``.\n        Default is 1e-5."
          },
          "atol": {
            "type": "float",
            "description": "Absolute tolerance. The absolute difference is equal to `atol`.\n        Default is 1e-8."
          },
          "True": {
            "type": ":",
            "description": "absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    Return True if all elements of `a` and `b` are equal subject to\n    given tolerances."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "allequal",
      "signature": "allequal(a, b, fill_value=True)",
      "documentation": {
        "description": "Return True if all entries of a and b are equal, using\n    fill_value as a truth value where either or both are masked.",
        "parameters": {
          "fill_value": {
            "type": "bool",
            "description": "Whether masked values in a or b are considered equal (True) or not\n        (False)."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "alltrue",
      "signature": "reduce(target, axis=0, dtype=None)",
      "documentation": {
        "description": "Reduce `target` along the given `axis`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "amax",
      "signature": "amax(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)",
      "documentation": {
        "description": "Return the maximum of an array or maximum along an axis.\n\n    `amax` is an alias of `~numpy.max`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "max : alias of this function\n    ndarray.max : equivalent method",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "amin",
      "signature": "amin(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)",
      "documentation": {
        "description": "Return the minimum of an array or minimum along an axis.\n\n    `amin` is an alias of `~numpy.min`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "min : alias of this function\n    ndarray.min : equivalent method",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "angle",
      "signature": "angle(a, *args, **kwargs)",
      "documentation": {
        "description": "Return the angle of the complex argument.",
        "parameters": {
          "deg": {
            "type": "bool",
            "description": "Return angle in degrees if True, radians if False (default)."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "anom",
      "signature": "anom(a, *args, **params)",
      "documentation": {
        "description": "anom(self, axis=None, dtype=None)\n\n        Compute the anomalies (deviations from the arithmetic mean)\n        along the given axis.\n\n        Returns an array of anomalies, with the same shape as the input and\n        where the arithmetic mean is computed along the given axis.",
        "parameters": {
          "dtype": {
            "type": "dtype",
            "description": "Type to use in computing the variance. For arrays of integer type\n             the default is float32; for arrays of float types it is the same as\n             the array type."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "anomalies",
      "signature": "anom(a, *args, **params)",
      "documentation": {
        "description": "anom(self, axis=None, dtype=None)\n\n        Compute the anomalies (deviations from the arithmetic mean)\n        along the given axis.\n\n        Returns an array of anomalies, with the same shape as the input and\n        where the arithmetic mean is computed along the given axis.",
        "parameters": {
          "dtype": {
            "type": "dtype",
            "description": "Type to use in computing the variance. For arrays of integer type\n             the default is float32; for arrays of float types it is the same as\n             the array type."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "any",
      "signature": "any(a, *args, **params)",
      "documentation": {
        "description": "any(self, axis=None, out=None, keepdims=<no value>)\n\n        Returns True if any of the elements of `a` evaluate to True.\n\n        Masked values are considered as False during computation.\n\n        Refer to `numpy.any` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.ndarray.any : corresponding function for ndarrays\n        numpy.any : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "append",
      "signature": "append(a, b, axis=None)",
      "documentation": {
        "description": "Append values to the end of an array.\n\n    .. versionadded:: 1.9.0",
        "parameters": {
          "b": {
            "type": "array_like",
            "description": "These values are appended to a copy of `a`.  It must be of the\n        correct shape (the same shape as `a`, excluding `axis`).  If `axis`\n        is not specified, `b` can be any shape and will be flattened\n        before use."
          },
          "axis": {
            "type": "int",
            "description": "The axis along which `v` are appended.  If `axis` is not given,\n        both `a` and `b` are flattened before use."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "apply_along_axis",
      "signature": "apply_along_axis(func1d, axis, arr, *args, **kwargs)",
      "documentation": {
        "description": "Apply a function to 1-D slices along the given axis.\n\n    Execute `func1d(a, *args, **kwargs)` where `func1d` operates on 1-D arrays\n    and `a` is a 1-D slice of `arr` along `axis`.\n\n    This is equivalent to (but faster than) the following use of `ndindex` and\n    `s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices::\n\n        Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n        for ii in ndindex(Ni):\n            for kk in ndindex(Nk):\n                f = func1d(arr[ii + s_[:,] + kk])\n                Nj = f.shape\n                for jj in ndindex(Nj):\n                    out[ii + jj + kk] = f[jj]\n\n    Equivalently, eliminating the inner loop, this can be expressed as::\n\n        Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n        for ii in ndindex(Ni):\n            for kk in ndindex(Nk):\n                out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])",
        "parameters": {
          "axis": {
            "type": "integer",
            "description": "Axis along which `arr` is sliced."
          },
          "arr": {
            "type": "ndarray (Ni...",
            "description": ", M, Nk...)\n        Input array."
          },
          "args": {
            "type": "any",
            "description": "Additional arguments to `func1d`."
          },
          "kwargs": {
            "type": "any",
            "description": "Additional named arguments to `func1d`.\n\n        .. versionadded:: 1.9.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "apply_over_axes",
      "signature": "apply_over_axes(func, a, axes)",
      "documentation": {
        "description": "Apply a function repeatedly over multiple axes.\n\n    `func` is called as `res = func(a, axis)`, where `axis` is the first\n    element of `axes`.  The result `res` of the function call must have\n    either the same dimensions as `a` or one less dimension.  If `res`\n    has one less dimension than `a`, a dimension is inserted before\n    `axis`.  The call to `func` is then repeated for each axis in `axes`,\n    with `res` as the first argument.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Input array."
          },
          "axes": {
            "type": "array_like",
            "description": "Axes over which `func` is applied; the elements must be integers."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "arccos",
      "signature": "arccos(a, *args, **kwargs)",
      "documentation": {
        "description": "arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTrigonometric inverse cosine, element-wise.\n\nThe inverse of `cos` so that, if ``y = cos(x)``, then ``x = arccos(y)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "`x`-coordinate on the unit circle.\n    For real arguments, the domain is [-1, 1]."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "angle": {
            "type": "ndarray",
            "description": "The angle of the ray intersecting the unit circle at the given\n    `x`-coordinate in radians [0, pi].\n    This is a scalar if `x` is a scalar."
          },
          "https": {
            "type": "//personal.math.ubc.ca/~cbm/aands/page_79.htm",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "arccosh",
      "signature": "arccosh(a, *args, **kwargs)",
      "documentation": {
        "description": "arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nInverse hyperbolic cosine, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "arccosh": {
            "type": "ndarray",
            "description": "Array of the same shape as `x`.\n    This is a scalar if `x` is a scalar."
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Arccosh",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "arcsin",
      "signature": "arcsin(a, *args, **kwargs)",
      "documentation": {
        "description": "arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nInverse sine, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "`y`-coordinate on the unit circle."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "angle": {
            "type": "ndarray",
            "description": "The inverse sine of each element in `x`, in radians and in the\n    closed interval ``[-pi/2, pi/2]``.\n    This is a scalar if `x` is a scalar."
          },
          "https": {
            "type": "//personal.math.ubc.ca/~cbm/aands/page_79.htm",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "arcsinh",
      "signature": "arcsinh(a, *args, **kwargs)",
      "documentation": {
        "description": "arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nInverse hyperbolic sine element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray or scalar",
            "description": "Array of the same shape as `x`.\n    This is a scalar if `x` is a scalar."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Arcsinh",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "arctan",
      "signature": "arctan(a, *args, **kwargs)",
      "documentation": {
        "description": "arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTrigonometric inverse tangent, element-wise.\n\nThe inverse of tan, so that if ``y = tan(x)`` then ``x = arctan(y)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": ""
          },
          "out": {
            "type": "ndarray or scalar",
            "description": "Out has the same shape as `x`.  Its real part is in\n    ``[-pi/2, pi/2]`` (``arctan(+/-inf)`` returns ``+/-pi/2``).\n    This is a scalar if `x` is a scalar."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "arctan2": {
            "type": "The \"four quadrant\" arctan of the angle formed by (`x`",
            "description": ", `y`)\n    and the positive `x`-axis."
          },
          "angle": {
            "type": "Argument of complex values.",
            "description": ""
          },
          "https": {
            "type": "//personal.math.ubc.ca/~cbm/aands/page_79.htm",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "arctan2",
      "signature": "arctan2(a, b, *args, **kwargs)",
      "documentation": {
        "description": "arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise arc tangent of ``x1/x2`` choosing the quadrant correctly.\n\nThe quadrant (i.e., branch) is chosen so that ``arctan2(x1, x2)`` is\nthe signed angle in radians between the ray ending at the origin and\npassing through the point (1,0), and the ray ending at the origin and\npassing through the point (`x2`, `x1`).  (Note the role reversal: the\n\"`y`-coordinate\" is the first function parameter, the \"`x`-coordinate\"\nis the second.)  By IEEE convention, this function is defined for\n`x2` = +/-0 and for either or both of `x1` and `x2` = +/-inf (see\nNotes for specific values).\n\nThis function is not defined for complex-valued arguments; for the\nso-called argument of complex values, use `angle`.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": ", real-valued\n    `y`-coordinates."
          },
          "x2": {
            "type": "array_like",
            "description": ", real-valued\n    `x`-coordinates.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "angle": {
            "type": "ndarray",
            "description": "Array of angles in radians, in the range ``[-pi, pi]``.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "standard": {
            "type": "[1]_",
            "description": "====== ====== ================\n`x1`   `x2`   `arctan2(x1,x2)`\n====== ====== ================\n+/- 0  +0     +/- 0\n+/- 0  -0     +/- pi\n > 0   +/-inf +0 / +pi\n < 0   +/-inf -0 / -pi\n+/-inf +inf   +/- (pi/4)\n+/-inf -inf   +/- (3*pi/4)\n====== ====== ================\n\nNote that +0 and -0 are distinct floating point numbers, as are +inf\nand -inf.\n\nReferences\n----------\n.. [1] ISO/IEC standard 9899:1999, \"Programming language C.\""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "arctanh",
      "signature": "arctanh(a, *args, **kwargs)",
      "documentation": {
        "description": "arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nInverse hyperbolic tangent element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray or scalar",
            "description": "Array of the same shape as `x`.\n    This is a scalar if `x` is a scalar."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Arctanh",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "argmax",
      "signature": "argmax(a, *args, **params)",
      "documentation": {
        "description": "argmax(self, axis=None, fill_value=None, out=None)\n\n        Returns array of indices of the maximum values along the given axis.\n        Masked values are treated as if they had the value fill_value.",
        "parameters": {
          "fill_value": {
            "type": "scalar or None",
            "description": "Value used to fill in the masked values.  If None, the output of\n            maximum_fill_value(self._data) is used instead."
          },
          "out": {
            "type": "{None",
            "description": ", array}, optional\n            Array into which the result can be placed. Its type is preserved\n            and it must be of the right shape to hold the output."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "argmin",
      "signature": "argmin(a, *args, **params)",
      "documentation": {
        "description": "argmin(self, axis=None, fill_value=None, out=None)\n\n        Return array of indices to the minimum values along the given axis.",
        "parameters": {
          "fill_value": {
            "type": "scalar or None",
            "description": "Value used to fill in the masked values.  If None, the output of\n            minimum_fill_value(self._data) is used instead."
          },
          "out": {
            "type": "{None",
            "description": ", array}, optional\n            Array into which the result can be placed. Its type is preserved\n            and it must be of the right shape to hold the output."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "argsort",
      "signature": "argsort(a, axis=<no value>, kind=None, order=None, endwith=True, fill_value=None)",
      "documentation": {
        "description": "Return an ndarray of indices that sort the array along the\n        specified axis.  Masked values are filled beforehand to\n        `fill_value`.",
        "parameters": {
          "kind": {
            "type": "{'quicksort'",
            "description": ", 'mergesort', 'heapsort', 'stable'}, optional\n            The sorting algorithm used."
          },
          "order": {
            "type": "list",
            "description": "When `a` is an array with fields defined, this argument specifies\n            which fields to compare first, second, etc.  Not all fields need be\n            specified."
          },
          "endwith": {
            "type": "{True",
            "description": ", False}, optional\n            Whether missing values (if any) should be treated as the largest values\n            (True) or the smallest values (False)\n            When the array contains unmasked values at the same extremes of the\n            datatype, the ordering of these values and the masked values is\n            undefined."
          },
          "fill_value": {
            "type": "scalar or None",
            "description": "Value used internally for the masked values.\n            If ``fill_value`` is not None, it supersedes ``endwith``."
          },
          "lexsort": {
            "type": "Indirect stable sort with multiple keys.",
            "description": "numpy.ndarray.sort : Inplace sort."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "around",
      "signature": "round_(a, *args, **kwargs)",
      "documentation": {
        "description": "Round an array to the given number of decimals.\n\n    `~numpy.round_` is a disrecommended backwards-compatibility\n    alias of `~numpy.around` and `~numpy.round`.\n\n    .. deprecated:: 1.25.0\n        ``round_`` is deprecated as of NumPy 1.25.0, and will be\n        removed in NumPy 2.0. Please use `round` instead.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "around : equivalent function; see for details.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "array",
      "signature": "array(data, dtype=None, copy=False, order=None, mask=False, fill_value=None, keep_mask=True, hard_mask=False, shrink=True, subok=True, ndmin=0)",
      "documentation": {
        "description": "An array class with possibly masked values.\n\n    Masked values of True exclude the corresponding element from any\n    computation.\n\n    Construction::\n\n      x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\n                      ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\n                      shrink=True, order=None)",
        "parameters": {
          "mask": {
            "type": "sequence",
            "description": "Mask. Must be convertible to an array of booleans with the same\n        shape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "dtype": {
            "type": "dtype",
            "description": "Data type of the output.\n        If `dtype` is None, the type of the data argument (``data.dtype``)\n        is used. If `dtype` is not None and different from ``data.dtype``,\n        a copy is performed."
          },
          "copy": {
            "type": "bool",
            "description": "Whether to copy the input data (True), or to use a reference instead.\n        Default is False."
          },
          "subok": {
            "type": "bool",
            "description": "Whether to return a subclass of `MaskedArray` if possible (True) or a\n        plain `MaskedArray`. Default is True."
          },
          "ndmin": {
            "type": "int",
            "description": "Minimum number of dimensions. Default is 0."
          },
          "fill_value": {
            "type": "scalar",
            "description": "Value used to fill in the masked values when necessary.\n        If None, a default based on the data-type is used."
          },
          "keep_mask": {
            "type": "bool",
            "description": "Whether to combine `mask` with the mask of the input data, if any\n        (True), or to use only `mask` for the output (False). Default is True."
          },
          "hard_mask": {
            "type": "bool",
            "description": "Whether to use a hard mask or not. With a hard mask, masked values\n        cannot be unmasked. Default is False."
          },
          "shrink": {
            "type": "bool",
            "description": "Whether to force compression of an empty mask. Default is True."
          },
          "order": {
            "type": "{'C'",
            "description": ", 'F', 'A'}, optional\n        Specify the order of the array.  If order is 'C', then the array\n        will be in C-contiguous order (last-index varies the fastest).\n        If order is 'F', then the returned array will be in\n        Fortran-contiguous order (first-index varies the fastest).\n        If order is 'A' (default), then the returned array may be\n        in any order (either C-, Fortran-contiguous, or even discontiguous),\n        unless a copy is required, in which case it will be C-contiguous."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "asanyarray",
      "signature": "asanyarray(a, dtype=None)",
      "documentation": {
        "description": "Convert the input to a masked array, conserving subclasses.\n\n    If `a` is a subclass of `MaskedArray`, its class is conserved.\n    No copy is performed if the input is already an `ndarray`.",
        "parameters": {
          "dtype": {
            "type": "dtype",
            "description": "By default, the data-type is inferred from the input data."
          },
          "order": {
            "type": "{'C'",
            "description": ", 'F'}, optional\n        Whether to use row-major ('C') or column-major ('FORTRAN') memory\n        representation.  Default is 'C'."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "asarray",
      "signature": "asarray(a, dtype=None, order=None)",
      "documentation": {
        "description": "Convert the input to a masked array of the given data-type.\n\n    No copy is performed if the input is already an `ndarray`. If `a` is\n    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.",
        "parameters": {
          "dtype": {
            "type": "dtype",
            "description": "By default, the data-type is inferred from the input data."
          },
          "order": {
            "type": "{'C'",
            "description": ", 'F'}, optional\n        Whether to use row-major ('C') or column-major ('FORTRAN') memory\n        representation.  Default is 'C'."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "atleast_1d",
      "signature": "atleast_1d(*args, **params)",
      "documentation": {
        "description": "atleast_1d\n\nConvert inputs to arrays with at least one dimension.\n\nScalar inputs are converted to 1-dimensional arrays, whilst\nhigher-dimensional inputs are preserved.",
        "parameters": {
          "ret": {
            "type": "ndarray",
            "description": "An array, or list of arrays, each with ``a.ndim >= 1``.\n    Copies are made only if necessary."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "atleast_2d",
      "signature": "atleast_2d(*args, **params)",
      "documentation": {
        "description": "atleast_2d\n\nView inputs as arrays with at least two dimensions.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "atleast_3d",
      "signature": "atleast_3d(*args, **params)",
      "documentation": {
        "description": "atleast_3d\n\nView inputs as arrays with at least three dimensions.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "average",
      "signature": "average(a, axis=None, weights=None, returned=False, *, keepdims=<no value>)",
      "documentation": {
        "description": "Return the weighted average of array over the given axis.",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "Axis along which to average `a`. If None, averaging is done over\n        the flattened array."
          },
          "weights": {
            "type": "array_like",
            "description": "The importance that each element has in the computation of the average.\n        The weights array can either be 1-D (in which case its length must be\n        the size of `a` along the given axis) or of the same shape as `a`.\n        If ``weights=None``, then all data in `a` are assumed to have a\n        weight equal to one.  The 1-D calculation is::\n\n            avg = sum(a * weights) / sum(weights)\n\n        The only constraint on `weights` is that `sum(weights)` must not be 0."
          },
          "returned": {
            "type": "bool",
            "description": "Flag indicating whether a tuple ``(result, sum of weights)``\n        should be returned as output (True), or just the result (False).\n        Default is False."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n        *Note:* `keepdims` will not work with instances of `numpy.matrix`\n        or other classes whose methods do not support `keepdims`.\n\n        .. versionadded:: 1.23.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "bitwise_and",
      "signature": "bitwise_and(a, b, *args, **kwargs)",
      "documentation": {
        "description": "bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the bit-wise AND of two arrays element-wise.\n\nComputes the bit-wise AND of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``&``.",
        "parameters": {
          "out": {
            "type": "ndarray or scalar",
            "description": "Result.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "binary_repr": {
            "type": "Return the binary representation of the input number as a string.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "bitwise_or",
      "signature": "bitwise_or(a, b, *args, **kwargs)",
      "documentation": {
        "description": "bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the bit-wise OR of two arrays element-wise.\n\nComputes the bit-wise OR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``|``.",
        "parameters": {
          "out": {
            "type": "ndarray or scalar",
            "description": "Result.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "binary_repr": {
            "type": "Return the binary representation of the input number as a string.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "bitwise_xor",
      "signature": "bitwise_xor(a, b, *args, **kwargs)",
      "documentation": {
        "description": "bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the bit-wise XOR of two arrays element-wise.\n\nComputes the bit-wise XOR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``^``.",
        "parameters": {
          "out": {
            "type": "ndarray or scalar",
            "description": "Result.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "binary_repr": {
            "type": "Return the binary representation of the input number as a string.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ceil",
      "signature": "ceil(a, *args, **kwargs)",
      "documentation": {
        "description": "ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the ceiling of the input, element-wise.\n\nThe ceil of the scalar `x` is the smallest integer `i`, such that\n``i >= x``.  It is often denoted as :math:`\\lceil x \\rceil`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input data."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray or scalar",
            "description": "The ceiling of each element in `x`, with `float` dtype.\n    This is a scalar if `x` is a scalar."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "choose",
      "signature": "choose(indices, choices, out=None, mode='raise')",
      "documentation": {
        "description": "Use an index array to construct a new array from a list of choices.\n\n    Given an array of integers and a list of n choice arrays, this method\n    will create a new array that merges each of the choice arrays.  Where a\n    value in `index` is i, the new array will have the value that choices[i]\n    contains in the same place.",
        "parameters": {
          "choices": {
            "type": "sequence of arrays",
            "description": "Choice arrays. The index array and all of the choices should be\n        broadcastable to the same shape."
          },
          "out": {
            "type": "array",
            "description": "If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and `dtype`."
          },
          "mode": {
            "type": "{'raise'",
            "description": ", 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' : raise an error\n        * 'wrap' : wrap around\n        * 'clip' : clip to the range"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "clump_masked",
      "signature": "clump_masked(a)",
      "documentation": {
        "description": "Returns a list of slices corresponding to the masked clumps of a 1-D array.\n    (A \"clump\" is defined as a contiguous region of the array).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "clump_unmasked",
      "signature": "clump_unmasked(a)",
      "documentation": {
        "description": "Return list of slices corresponding to the unmasked clumps of a 1-D array.\n    (A \"clump\" is defined as a contiguous region of the array).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "column_stack",
      "signature": "column_stack(x, *args, **params)",
      "documentation": {
        "description": "column_stack\n\nStack 1-D arrays as columns into a 2-D array.\n\nTake a sequence of 1-D arrays and stack them as columns\nto make a single 2-D array. 2-D arrays are stacked as-is,\njust like with `hstack`.  1-D arrays are turned into 2-D columns\nfirst.",
        "parameters": {
          "tup": {
            "type": "sequence of 1-D or 2-D arrays.",
            "description": "Arrays to stack. All of them must have the same first dimension."
          },
          "stacked": {
            "type": "2-D array",
            "description": "The array formed by stacking the given arrays."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "common_fill_value",
      "signature": "common_fill_value(a, b)",
      "documentation": {
        "description": "Return the common filling value of two masked arrays, if any.\n\n    If ``a.fill_value == b.fill_value``, return the fill value,\n    otherwise return None.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compress",
      "signature": "compress(a, *args, **params)",
      "documentation": {
        "description": "compress(self, condition, axis=None, out=None)\n\n        Return `a` where condition is ``True``.\n\n        If condition is a `~ma.MaskedArray`, missing values are considered\n        as ``False``.",
        "parameters": {
          "axis": {
            "type": "{None",
            "description": ", int}, optional\n            Axis along which the operation must be performed."
          },
          "out": {
            "type": "{None",
            "description": ", ndarray}, optional\n            Alternative output array in which to place the result. It must have\n            the same shape as the expected output but the type will be cast if\n            necessary."
          },
          "A": {
            "type": "class:`~ma.MaskedArray` object.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compress_cols",
      "signature": "compress_cols(a)",
      "documentation": {
        "description": "Suppress whole columns of a 2-D array that contain masked values.\n\n    This is equivalent to ``np.ma.compress_rowcols(a, 1)``, see\n    `compress_rowcols` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "compress_rowcols",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compress_nd",
      "signature": "compress_nd(x, axis=None)",
      "documentation": {
        "description": "Suppress slices from multiple dimensions which contain masked values.",
        "parameters": {
          "axis": {
            "type": "tuple of ints or int",
            "description": "Which dimensions to suppress slices from can be configured with this\n        parameter.\n        - If axis is a tuple of ints, those are the axes to suppress slices from.\n        - If axis is an int, then that is the only axis to suppress slices from.\n        - If axis is None, all axis are selected."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compress_rowcols",
      "signature": "compress_rowcols(x, axis=None)",
      "documentation": {
        "description": "Suppress the rows and/or columns of a 2-D array that contain\n    masked values.\n\n    The suppression behavior is selected with the `axis` parameter.\n\n    - If axis is None, both rows and columns are suppressed.\n    - If axis is 0, only rows are suppressed.\n    - If axis is 1 or -1, only columns are suppressed.",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "Axis along which to perform the operation. Default is None."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compress_rows",
      "signature": "compress_rows(a)",
      "documentation": {
        "description": "Suppress whole rows of a 2-D array that contain masked values.\n\n    This is equivalent to ``np.ma.compress_rowcols(a, 0)``, see\n    `compress_rowcols` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "compress_rowcols",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "compressed",
      "signature": "compressed(x)",
      "documentation": {
        "description": "Return all the non-masked data as a 1-D array.\n\n    This function is equivalent to calling the \"compressed\" method of a\n    `ma.MaskedArray`, see `ma.MaskedArray.compressed` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "Create an array with negative values masked:\n\n    >>> import numpy as np\n    >>> x = np.array([[1, -1, 0], [2, -1, 3], [7, 4, -1]])\n    >>> masked_x = np.ma.masked_array(x, mask=x < 0)\n    >>> masked_x\n    masked_array(\n      data=[[1, --, 0],\n            [2, --, 3],\n            [7, 4, --]],\n      mask=[[False,  True, False],\n            [False,  True, False],\n            [False, False,  True]],\n      fill_value=999999)\n\n    Compress the masked array into a 1-D array of non-masked values:\n\n    >>> np.ma.compressed(masked_x)\n    array([1, 0, 2, 3, 7, 4])",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "concatenate",
      "signature": "concatenate(arrays, axis=0)",
      "documentation": {
        "description": "Concatenate a sequence of arrays along the given axis.",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "The axis along which the arrays will be joined. Default is 0."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "conjugate",
      "signature": "conjugate(a, *args, **kwargs)",
      "documentation": {
        "description": "conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the complex conjugate, element-wise.\n\nThe complex conjugate of a complex number is obtained by changing the\nsign of its imaginary part.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input value."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "The complex conjugate of `x`, with same dtype as `y`.\n    This is a scalar if `x` is a scalar."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "convolve",
      "signature": "convolve(a, v, mode='full', propagate_mask=True)",
      "documentation": {
        "description": "Returns the discrete, linear convolution of two one-dimensional sequences.",
        "parameters": {
          "mode": {
            "type": "{'valid'",
            "description": ", 'same', 'full'}, optional\n        Refer to the `np.convolve` docstring."
          },
          "propagate_mask": {
            "type": "bool",
            "description": "If True, then if any masked element is included in the sum for a result\n        element, then the result is masked.\n        If False, then the result element is only masked if no non-masked cells\n        contribute towards it"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "copy",
      "signature": "copy(a, *args, **params)",
      "documentation": {
        "description": "copy(self, *args, **params)\na.copy(order='C')\n\n    Return a copy of the array.",
        "parameters": {
          "function": {
            "type": "func:`numpy.copy` is similar",
            "description": ", but it defaults to using order 'K',\n    and will not pass sub-classes through by default."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "corrcoef",
      "signature": "corrcoef(x, y=None, rowvar=True, bias=<no value>, allow_masked=True, ddof=<no value>)",
      "documentation": {
        "description": "Return Pearson product-moment correlation coefficients.\n\n    Except for the handling of missing data this function does the same as\n    `numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`.",
        "parameters": {
          "y": {
            "type": "array_like",
            "description": "An additional set of variables and observations. `y` has the same\n        shape as `x`."
          },
          "rowvar": {
            "type": "bool",
            "description": "If `rowvar` is True (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations."
          },
          "bias": {
            "type": "_NoValue",
            "description": "Has no effect, do not use.\n\n        .. deprecated:: 1.10.0"
          },
          "allow_masked": {
            "type": "bool",
            "description": "If True, masked values are propagated pair-wise: if a value is masked\n        in `x`, the corresponding value is masked in `y`.\n        If False, raises an exception.  Because `bias` is deprecated, this\n        argument needs to be treated as keyword only to avoid a warning."
          },
          "ddof": {
            "type": "_NoValue",
            "description": "Has no effect, do not use.\n\n        .. deprecated:: 1.10.0"
          },
          "cov": {
            "type": "Estimate the covariance matrix.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "correlate",
      "signature": "correlate(a, v, mode='valid', propagate_mask=True)",
      "documentation": {
        "description": "Cross-correlation of two 1-dimensional sequences.",
        "parameters": {
          "mode": {
            "type": "{'valid'",
            "description": ", 'same', 'full'}, optional\n        Refer to the `np.convolve` docstring.  Note that the default\n        is 'valid', unlike `convolve`, which uses 'full'."
          },
          "propagate_mask": {
            "type": "bool",
            "description": "If True, then a result element is masked if any masked element contributes towards it.\n        If False, then a result element is only masked if no non-masked element\n        contribute towards it"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cos",
      "signature": "cos(a, *args, **kwargs)",
      "documentation": {
        "description": "cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCosine element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array in radians."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "The corresponding cosine values.\n    This is a scalar if `x` is a scalar."
          },
          "ValueError": {
            "type": "operands could not be broadcast together with shapes (3",
            "description": ",3) (2,2)"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cosh",
      "signature": "cosh(a, *args, **kwargs)",
      "documentation": {
        "description": "cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nHyperbolic cosine, element-wise.\n\nEquivalent to ``1/2 * (np.exp(x) + np.exp(-x))`` and ``np.cos(1j*x)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray or scalar",
            "description": "Output array of same shape as `x`.\n    This is a scalar if `x` is a scalar."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "count",
      "signature": "count(a, *args, **params)",
      "documentation": {
        "description": "count(self, axis=None, keepdims=<no value>)\n\n        Count the non-masked elements of the array along the given axis.",
        "parameters": {
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "count_masked",
      "signature": "count_masked(arr, axis=None)",
      "documentation": {
        "description": "Count the number of masked elements along the given axis.",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "Axis along which to count. If None (default), a flattened\n        version of the array is used."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cov",
      "signature": "cov(x, y=None, rowvar=True, bias=False, allow_masked=True, ddof=None)",
      "documentation": {
        "description": "Estimate the covariance matrix.\n\n    Except for the handling of missing data this function does the same as\n    `numpy.cov`. For more details and examples, see `numpy.cov`.\n\n    By default, masked values are recognized as such. If `x` and `y` have the\n    same shape, a common mask is allocated: if ``x[i,j]`` is masked, then\n    ``y[i,j]`` will also be masked.\n    Setting `allow_masked` to False will raise an exception if values are\n    missing in either of the input arrays.",
        "parameters": {
          "y": {
            "type": "array_like",
            "description": "An additional set of variables and observations. `y` has the same\n        shape as `x`."
          },
          "rowvar": {
            "type": "bool",
            "description": "If `rowvar` is True (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations."
          },
          "bias": {
            "type": "bool",
            "description": "Default normalization (False) is by ``(N-1)``, where ``N`` is the\n        number of observations given (unbiased estimate). If `bias` is True,\n        then normalization is by ``N``. This keyword can be overridden by\n        the keyword ``ddof`` in numpy versions >= 1.5."
          },
          "allow_masked": {
            "type": "bool",
            "description": "If True, masked values are propagated pair-wise: if a value is masked\n        in `x`, the corresponding value is masked in `y`.\n        If False, raises a `ValueError` exception when some values are missing."
          },
          "ddof": {
            "type": "{None",
            "description": ", int}, optional\n        If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is\n        the number of observations; this overrides the value implied by\n        ``bias``. The default value is ``None``.\n\n        .. versionadded:: 1.5"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "cumprod",
      "signature": "cumprod(a, *args, **params)",
      "documentation": {
        "description": "cumprod(self, axis=None, dtype=None, out=None)\n\n        Return the cumulative product of the array elements over the given axis.\n\n        Masked values are set to 1 internally during the computation.\n        However, their position is saved, and the result will be masked at\n        the same locations.\n\n        Refer to `numpy.cumprod` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "numpy.ndarray.cumprod : corresponding function for ndarrays\n        numpy.cumprod : equivalent function",
        "examples": ""
      }
    },
    {
      "name": "cumsum",
      "signature": "cumsum(a, *args, **params)",
      "documentation": {
        "description": "cumsum(self, axis=None, dtype=None, out=None)\n\n        Return the cumulative sum of the array elements over the given axis.\n\n        Masked values are set to 0 internally during the computation.\n        However, their position is saved, and the result will be masked at\n        the same locations.\n\n        Refer to `numpy.cumsum` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": ">>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n        >>> marr.cumsum()\n        masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n                     mask=[False, False, False,  True,  True,  True, False, False,\n                           False, False],\n               fill_value=999999)",
        "examples": ""
      }
    },
    {
      "name": "default_fill_value",
      "signature": "default_fill_value(obj)",
      "documentation": {
        "description": "Return the default fill value for the argument object.\n\n    The default filling value depends on the datatype of the input\n    array or the type of the input scalar:\n\n       ========  ========\n       datatype  default\n       ========  ========\n       bool      True\n       int       999999\n       float     1.e20\n       complex   1.e20+0j\n       object    '?'\n       string    'N/A'\n       ========  ========\n\n    For structured types, a structured scalar is returned, with each field the\n    default fill value for its type.\n\n    For subarray types, the fill value is an array of the same size containing\n    the default scalar fill value.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "diag",
      "signature": "diag(v, k=0)",
      "documentation": {
        "description": "Extract a diagonal or construct a diagonal array.\n\n    This function is the equivalent of `numpy.diag` that takes masked\n    values into account, see `numpy.diag` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "Create an array with negative values masked:\n\n    >>> import numpy as np\n    >>> x = np.array([[11.2, -3.973, 18], [0.801, -1.41, 12], [7, 33, -12]])\n    >>> masked_x = np.ma.masked_array(x, mask=x < 0)\n    >>> masked_x\n    masked_array(\n      data=[[11.2, --, 18.0],\n            [0.801, --, 12.0],\n            [7.0, 33.0, --]],\n      mask=[[False,  True, False],\n            [False,  True, False],\n            [False, False,  True]],\n      fill_value=1e+20)\n\n    Isolate the main diagonal from the masked array:\n\n    >>> np.ma.diag(masked_x)\n    masked_array(data=[11.2, --, --],\n                 mask=[False,  True,  True],\n           fill_value=1e+20)\n\n    Isolate the first diagonal below the main diagonal:\n\n    >>> np.ma.diag(masked_x, -1)\n    masked_array(data=[0.801, 33.0],\n                 mask=[False, False],\n           fill_value=1e+20)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "diagflat",
      "signature": "diagflat(x, *args, **params)",
      "documentation": {
        "description": "diagflat\n\nCreate a two-dimensional array with the flattened input as a diagonal.",
        "parameters": {
          "v": {
            "type": "array_like",
            "description": "Input data, which is flattened and set as the `k`-th\n    diagonal of the output."
          },
          "k": {
            "type": "int",
            "description": "Diagonal to set; 0, the default, corresponds to the \"main\" diagonal,\n    a positive (negative) `k` giving the number of the diagonal above\n    (below) the main."
          },
          "out": {
            "type": "ndarray",
            "description": "The 2-D output array."
          },
          "diag": {
            "type": "MATLAB work-alike for 1-D and 2-D arrays.",
            "description": ""
          },
          "diagonal": {
            "type": "Return specified diagonals.",
            "description": ""
          },
          "trace": {
            "type": "Sum along diagonals.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "diagonal",
      "signature": "diagonal(a, *args, **params)",
      "documentation": {
        "description": "diagonal(self, *args, **params)\na.diagonal(offset=0, axis1=0, axis2=1)\n\n    Return specified diagonals. In NumPy 1.9 the returned array is a\n    read-only view instead of a copy as in previous NumPy versions.  In\n    a future version the read-only restriction will be removed.\n\n    Refer to :func:`numpy.diagonal` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.diagonal : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "diff",
      "signature": "diff(a, /, n=1, axis=-1, prepend=<no value>, append=<no value>)",
      "documentation": {
        "description": "Calculate the n-th discrete difference along the given axis.\n    The first difference is given by ``out[i] = a[i+1] - a[i]`` along\n    the given axis, higher differences are calculated by using `diff`\n    recursively.\n    Preserves the input mask.",
        "parameters": {
          "n": {
            "type": "int",
            "description": "The number of times values are differenced. If zero, the input\n        is returned as-is."
          },
          "axis": {
            "type": "int",
            "description": "The axis along which the difference is taken, default is the\n        last axis.\n    prepend, append : array_like, optional\n        Values to prepend or append to `a` along axis prior to\n        performing the difference.  Scalar values are expanded to\n        arrays with length 1 in the direction of axis and the shape\n        of the input array in along all other axes.  Otherwise the\n        dimension and shape must match `a` except along axis."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "divide",
      "signature": "divide(a, b, *args, **kwargs)",
      "documentation": {
        "description": "divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nDivide arguments element-wise.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend array."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor array.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray or scalar",
            "description": "The quotient ``x1/x2``, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "seterr": {
            "type": "Set whether to raise or warn on overflow",
            "description": ", underflow and\n         division by zero."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "dot",
      "signature": "dot(a, b, strict=False, out=None)",
      "documentation": {
        "description": "Return the dot product of two arrays.\n\n    This function is the equivalent of `numpy.dot` that takes masked values\n    into account. Note that `strict` and `out` are in different position\n    than in the method version. In order to maintain compatibility with the\n    corresponding method, it is recommended that the optional arguments be\n    treated as keyword only.  At some point that may be mandatory.",
        "parameters": {
          "strict": {
            "type": "bool",
            "description": "Whether masked data are propagated (True) or set to 0 (False) for\n        the computation. Default is False.  Propagating the mask means that\n        if a masked value appears in a row or column, the whole row or\n        column is considered masked."
          },
          "out": {
            "type": "masked_array",
            "description": "Output argument. This must have the exact kind that would be returned\n        if it was not used. In particular, it must have the right type, must be\n        C-contiguous, and its dtype must be the dtype that would be returned\n        for `dot(a,b)`. This is a performance feature. Therefore, if these\n        conditions are not met, an exception is raised, instead of attempting\n        to be flexible.\n\n        .. versionadded:: 1.10.2"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "dstack",
      "signature": "dstack(x, *args, **params)",
      "documentation": {
        "description": "dstack\n\nStack arrays in sequence depth wise (along third axis).\n\nThis is equivalent to concatenation along the third axis after 2-D arrays\nof shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape\n`(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by\n`dsplit`.\n\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.",
        "parameters": {
          "tup": {
            "type": "sequence of arrays",
            "description": "The arrays must have the same shape along all but the third axis.\n    1-D or 2-D arrays must have the same shape."
          },
          "stacked": {
            "type": "ndarray",
            "description": "The array formed by stacking the given arrays, will be at least 3-D."
          },
          "concatenate": {
            "type": "Join a sequence of arrays along an existing axis.",
            "description": ""
          },
          "stack": {
            "type": "Join a sequence of arrays along a new axis.",
            "description": ""
          },
          "block": {
            "type": "Assemble an nd-array from nested lists of blocks.",
            "description": ""
          },
          "vstack": {
            "type": "Stack arrays in sequence vertically (row wise).",
            "description": ""
          },
          "hstack": {
            "type": "Stack arrays in sequence horizontally (column wise).",
            "description": ""
          },
          "column_stack": {
            "type": "Stack 1-D arrays as columns into a 2-D array.",
            "description": ""
          },
          "dsplit": {
            "type": "Split array along third axis.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ediff1d",
      "signature": "ediff1d(arr, to_end=None, to_begin=None)",
      "documentation": {
        "description": "Compute the differences between consecutive elements of an array.\n\n    This function is the equivalent of `numpy.ediff1d` that takes masked\n    values into account, see `numpy.ediff1d` for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.ediff1d : Equivalent function for ndarrays.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "equal",
      "signature": "equal(a, b, *args, **kwargs)",
      "documentation": {
        "description": "equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn (x1 == x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray or scalar",
            "description": "Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "exp",
      "signature": "exp(a, *args, **kwargs)",
      "documentation": {
        "description": "exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate the exponential of all elements in the input array.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input values."
          },
          "out": {
            "type": "ndarray or scalar",
            "description": "Output array, element-wise exponential of `x`.\n    This is a scalar if `x` is a scalar."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "expm1": {
            "type": "Calculate ``exp(x) - 1`` for all elements in the array.",
            "description": ""
          },
          "exp2": {
            "type": "Calculate ``2**x`` for all elements in the array.",
            "description": ""
          },
          "then": {
            "type": "math:`e^x = y`. For real input",
            "description": ", ``exp(x)`` is always positive.\n\nFor complex arguments, ``x = a + ib``, we can write\n:math:`e^x = e^a e^{ib}`.  The first term, :math:`e^a`, is already\nknown (it is the real argument, described above).  The second term,\n:math:`e^{ib}`, is :math:`\\cos b + i \\sin b`, a function with\nmagnitude 1 and a periodic phase.\n\nReferences\n----------\n.. [1] Wikipedia, \"Exponential function\","
          },
          "https": {
            "type": "//personal.math.ubc.ca/~cbm/aands/page_69.htm",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "expand_dims",
      "signature": "expand_dims(a, axis)",
      "documentation": {
        "description": "Expand the shape of an array.\n\n    Insert a new axis that will appear at the `axis` position in the expanded\n    array shape.",
        "parameters": {
          "axis": {
            "type": "int or tuple of ints",
            "description": "Position in the expanded axes where the new axis (or axes) is placed.\n\n        .. deprecated:: 1.13.0\n            Passing an axis where ``axis > a.ndim`` will be treated as\n            ``axis == a.ndim``, and passing ``axis < -a.ndim - 1`` will\n            be treated as ``axis == 0``. This behavior is deprecated.\n\n        .. versionchanged:: 1.18.0\n            A tuple of axes is now supported.  Out of range axes as\n            described above are now forbidden and raise an `AxisError`."
          },
          "reshape": {
            "type": "Insert",
            "description": ", remove, and combine dimensions, and resize existing ones\n    doc.indexing, atleast_1d, atleast_2d, atleast_3d"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fabs",
      "signature": "fabs(a, *args, **kwargs)",
      "documentation": {
        "description": "fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the absolute values element-wise.\n\nThis function returns the absolute values (positive magnitude) of the\ndata in `x`. Complex values are not handled, use `absolute` to find the\nabsolute values of complex data.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "The array of numbers for which the absolute values are required. If\n    `x` is a scalar, the result `y` will also be a scalar."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray or scalar",
            "description": "The absolute values of `x`, the returned values are always floats.\n    This is a scalar if `x` is a scalar."
          },
          "absolute": {
            "type": "Absolute values including `complex` types.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "filled",
      "signature": "filled(a, fill_value=None)",
      "documentation": {
        "description": "Return input as an array with masked data replaced by a fill value.\n\n    If `a` is not a `MaskedArray`, `a` itself is returned.\n    If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to\n    ``a.fill_value``.",
        "parameters": {
          "fill_value": {
            "type": "array_like",
            "description": ".\n        Can be scalar or non-scalar. If non-scalar, the\n        resulting filled array should be broadcastable\n        over input array. Default is None."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fix_invalid",
      "signature": "fix_invalid(a, mask=False, copy=True, fill_value=None)",
      "documentation": {
        "description": "Return input with invalid data masked and replaced by a fill value.\n\n    Invalid data means values of `nan`, `inf`, etc.",
        "parameters": {
          "mask": {
            "type": "sequence",
            "description": "Mask. Must be convertible to an array of booleans with the same\n        shape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "copy": {
            "type": "bool",
            "description": "Whether to use a copy of `a` (True) or to fix `a` in place (False).\n        Default is True."
          },
          "fill_value": {
            "type": "scalar",
            "description": "Value used for fixing invalid data. Default is None, in which case\n        the ``a.fill_value`` is used."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "flatnotmasked_contiguous",
      "signature": "flatnotmasked_contiguous(a)",
      "documentation": {
        "description": "Find contiguous unmasked data in a masked array.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "flatnotmasked_edges",
      "signature": "flatnotmasked_edges(a)",
      "documentation": {
        "description": "Find the indices of the first and last unmasked values.\n\n    Expects a 1-D `MaskedArray`, returns None if all values are masked.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "flatten_mask",
      "signature": "flatten_mask(mask)",
      "documentation": {
        "description": "Returns a completely flattened version of the mask, where nested fields\n    are collapsed.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "flatten_structured_array",
      "signature": "flatten_structured_array(a)",
      "documentation": {
        "description": "Flatten a structured array.\n\n    The data type of the output is chosen such that it can represent all of the\n    (nested) fields.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "floor",
      "signature": "floor(a, *args, **kwargs)",
      "documentation": {
        "description": "floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the floor of the input, element-wise.\n\nThe floor of the scalar `x` is the largest integer `i`, such that\n`i <= x`.  It is often denoted as :math:`\\lfloor x \\rfloor`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input data."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray or scalar",
            "description": "The floor of each element in `x`.\n    This is a scalar if `x` is a scalar."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "floor_divide",
      "signature": "floor_divide(a, b, *args, **kwargs)",
      "documentation": {
        "description": "floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the largest integer smaller or equal to the division of the inputs.\nIt is equivalent to the Python ``//`` operator and pairs with the\nPython ``%`` (`remainder`), function so that ``a = a % b + b * (a // b)``\nup to roundoff.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Numerator."
          },
          "x2": {
            "type": "array_like",
            "description": "Denominator.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "y = floor(`x1`/`x2`)\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "remainder": {
            "type": "Remainder complementary to floor_divide.",
            "description": ""
          },
          "divmod": {
            "type": "Simultaneous floor division and remainder.",
            "description": ""
          },
          "divide": {
            "type": "Standard division.",
            "description": ""
          },
          "floor": {
            "type": "Round a number to the nearest integer toward minus infinity.",
            "description": ""
          },
          "ceil": {
            "type": "Round a number to the nearest integer toward infinity.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fmod",
      "signature": "fmod(a, b, *args, **kwargs)",
      "documentation": {
        "description": "fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns the element-wise remainder of division.\n\nThis is the NumPy implementation of the C library function fmod, the\nremainder has the same sign as the dividend `x1`. It is equivalent to\nthe Matlab(TM) ``rem`` function and should not be confused with the\nPython modulus operator ``x1 % x2``.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "array_like",
            "description": "The remainder of the division of `x1` by `x2`.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "remainder": {
            "type": "Equivalent to the Python ``%`` operator.",
            "description": "divide"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "fromflex",
      "signature": "fromflex(fxarray)",
      "documentation": {
        "description": "Build a masked array from a suitable flexible-type array.\n\n    The input array has to have a data-type with ``_data`` and ``_mask``\n    fields. This type of array is output by `MaskedArray.toflex`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "getdata",
      "signature": "getdata(a, subok=True)",
      "documentation": {
        "description": "Return the data of a masked array as an ndarray.\n\n    Return the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,\n    else return `a` as a ndarray or subclass (depending on `subok`) if not.",
        "parameters": {
          "subok": {
            "type": "bool",
            "description": "Whether to force the output to be a `pure` ndarray (False) or to\n        return a subclass of ndarray if appropriate (True, default)."
          },
          "getmaskarray": {
            "type": "Return the mask of a masked array",
            "description": ", or full array of False."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "getmask",
      "signature": "getmask(a)",
      "documentation": {
        "description": "Return the mask of a masked array, or nomask.\n\n    Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the\n    mask is not `nomask`, else return `nomask`. To guarantee a full array\n    of booleans of the same shape as a, use `getmaskarray`.",
        "parameters": {
          "getmaskarray": {
            "type": "Return the mask of a masked array",
            "description": ", or full array of False."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "getmaskarray",
      "signature": "getmaskarray(arr)",
      "documentation": {
        "description": "Return the mask of a masked array, or full boolean array of False.\n\n    Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and\n    the mask is not `nomask`, else return a full boolean array of False of\n    the same shape as `arr`.",
        "parameters": {
          "getdata": {
            "type": "Return the data of a masked array as an ndarray.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "greater",
      "signature": "greater(a, b, *args, **kwargs)",
      "documentation": {
        "description": "greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 > x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray or scalar",
            "description": "Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "greater_equal",
      "signature": "greater_equal(a, b, *args, **kwargs)",
      "documentation": {
        "description": "greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 >= x2) element-wise.",
        "parameters": {
          "out": {
            "type": "bool or ndarray of bool",
            "description": "Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "harden_mask",
      "signature": "harden_mask(a, *args, **params)",
      "documentation": {
        "description": "harden_mask(self)\n\n        Force the mask to hard, preventing unmasking by assignment.\n\n        Whether the mask of a masked array is hard or soft is determined by\n        its `~ma.MaskedArray.hardmask` property. `harden_mask` sets\n        `~ma.MaskedArray.hardmask` to ``True`` (and returns the modified\n        self).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "ma.MaskedArray.hardmask\n        ma.MaskedArray.soften_mask",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "hsplit",
      "signature": "hsplit(x, *args, **params)",
      "documentation": {
        "description": "hsplit\n\nSplit an array into multiple sub-arrays horizontally (column-wise).\n\nPlease refer to the `split` documentation.  `hsplit` is equivalent\nto `split` with ``axis=1``, the array is always split along the second\naxis except for 1-D arrays, where it is split at ``axis=0``.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "The function is applied to both the _data and the _mask, if any.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "hstack",
      "signature": "hstack(x, *args, **params)",
      "documentation": {
        "description": "hstack\n\nStack arrays in sequence horizontally (column wise).\n\nThis is equivalent to concatenation along the second axis, except for 1-D\narrays where it concatenates along the first axis. Rebuilds arrays divided\nby `hsplit`.\n\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.",
        "parameters": {
          "tup": {
            "type": "sequence of ndarrays",
            "description": "The arrays must have the same shape along all but the second axis,\n    except 1-D arrays which can be any length."
          },
          "dtype": {
            "type": "str or dtype",
            "description": "If provided, the destination array will have this dtype. Cannot be\n    provided together with `out`.\n\n.. versionadded:: 1.24"
          },
          "casting": {
            "type": "{'no'",
            "description": ", 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n    Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n.. versionadded:: 1.24"
          },
          "stacked": {
            "type": "ndarray",
            "description": "The array formed by stacking the given arrays."
          },
          "concatenate": {
            "type": "Join a sequence of arrays along an existing axis.",
            "description": ""
          },
          "stack": {
            "type": "Join a sequence of arrays along a new axis.",
            "description": ""
          },
          "block": {
            "type": "Assemble an nd-array from nested lists of blocks.",
            "description": ""
          },
          "vstack": {
            "type": "Stack arrays in sequence vertically (row wise).",
            "description": ""
          },
          "dstack": {
            "type": "Stack arrays in sequence depth wise (along third axis).",
            "description": ""
          },
          "column_stack": {
            "type": "Stack 1-D arrays as columns into a 2-D array.",
            "description": ""
          },
          "hsplit": {
            "type": "Split an array into multiple sub-arrays horizontally (column-wise).",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "hypot",
      "signature": "hypot(a, b, *args, **kwargs)",
      "documentation": {
        "description": "hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nGiven the \"legs\" of a right triangle, return its hypotenuse.\n\nEquivalent to ``sqrt(x1**2 + x2**2)``, element-wise.  If `x1` or\n`x2` is scalar_like (i.e., unambiguously cast-able to a scalar type),\nit is broadcast for use with each element of the other argument.\n(See Examples)",
        "parameters": {
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "z": {
            "type": "ndarray",
            "description": "The hypotenuse of the triangle(s).\n    This is a scalar if both `x1` and `x2` are scalars."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ids",
      "signature": "ids(a, *args, **params)",
      "documentation": {
        "description": "ids(self)\n\n        Return the addresses of the data and mask areas.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "in1d",
      "signature": "in1d(ar1, ar2, assume_unique=False, invert=False)",
      "documentation": {
        "description": "Test whether each element of an array is also present in a second\n    array.\n\n    The output is always a masked array. See `numpy.in1d` for more details.\n\n    We recommend using :func:`isin` instead of `in1d` for new code.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ".. versionadded:: 1.4.0",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "inner",
      "signature": "inner(a, b)",
      "documentation": {
        "description": "inner(a, b, /)\n\nInner product of two arrays.\n\nOrdinary inner product of vectors for 1-D arrays (without complex\nconjugation), in higher dimensions a sum product over the last axes.",
        "parameters": {
          "out": {
            "type": "ndarray",
            "description": "If `a` and `b` are both\n    scalars or both 1-D arrays then a scalar is returned; otherwise\n    an array is returned.\n    ``out.shape = (*a.shape[:-1], *b.shape[:-1])``"
          },
          "tensordot": {
            "type": "Sum products over arbitrary axes.",
            "description": ""
          },
          "dot": {
            "type": "Generalised matrix product",
            "description": ", using second last dimension of `b`."
          },
          "einsum": {
            "type": "Einstein summation convention.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "innerproduct",
      "signature": "inner(a, b)",
      "documentation": {
        "description": "inner(a, b, /)\n\nInner product of two arrays.\n\nOrdinary inner product of vectors for 1-D arrays (without complex\nconjugation), in higher dimensions a sum product over the last axes.",
        "parameters": {
          "out": {
            "type": "ndarray",
            "description": "If `a` and `b` are both\n    scalars or both 1-D arrays then a scalar is returned; otherwise\n    an array is returned.\n    ``out.shape = (*a.shape[:-1], *b.shape[:-1])``"
          },
          "tensordot": {
            "type": "Sum products over arbitrary axes.",
            "description": ""
          },
          "dot": {
            "type": "Generalised matrix product",
            "description": ", using second last dimension of `b`."
          },
          "einsum": {
            "type": "Einstein summation convention.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "intersect1d",
      "signature": "intersect1d(ar1, ar2, assume_unique=False)",
      "documentation": {
        "description": "Returns the unique elements common to both arrays.\n\n    Masked values are considered equal one to the other.\n    The output is always a masked array.\n\n    See `numpy.intersect1d` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> x = np.ma.array([1, 3, 3, 3], mask=[0, 0, 0, 1])\n    >>> y = np.ma.array([3, 1, 1, 1], mask=[0, 0, 0, 1])\n    >>> np.ma.intersect1d(x, y)\n    masked_array(data=[1, 3, --],\n                 mask=[False, False,  True],\n           fill_value=999999)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "isMA",
      "signature": "isMaskedArray(x)",
      "documentation": {
        "description": "Test whether input is an instance of MaskedArray.\n\n    This function returns True if `x` is an instance of MaskedArray\n    and returns False otherwise.  Any object is accepted as input.",
        "parameters": {
          "isarray": {
            "type": "Alias to isMaskedArray.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "isMaskedArray",
      "signature": "isMaskedArray(x)",
      "documentation": {
        "description": "Test whether input is an instance of MaskedArray.\n\n    This function returns True if `x` is an instance of MaskedArray\n    and returns False otherwise.  Any object is accepted as input.",
        "parameters": {
          "isarray": {
            "type": "Alias to isMaskedArray.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "is_mask",
      "signature": "is_mask(m)",
      "documentation": {
        "description": "Return True if m is a valid, standard mask.\n\n    This function does not check the contents of the input, only that the\n    type is MaskType. In particular, this function returns False if the\n    mask has a flexible dtype.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "is_masked",
      "signature": "is_masked(x)",
      "documentation": {
        "description": "Determine whether input has masked values.\n\n    Accepts any object as input, but always returns False unless the\n    input is a MaskedArray containing masked values.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "isarray",
      "signature": "isMaskedArray(x)",
      "documentation": {
        "description": "Test whether input is an instance of MaskedArray.\n\n    This function returns True if `x` is an instance of MaskedArray\n    and returns False otherwise.  Any object is accepted as input.",
        "parameters": {
          "isarray": {
            "type": "Alias to isMaskedArray.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "isin",
      "signature": "isin(element, test_elements, assume_unique=False, invert=False)",
      "documentation": {
        "description": "Calculates `element in test_elements`, broadcasting over\n    `element` only.\n\n    The output is always a masked array of the same shape as `element`.\n    See `numpy.isin` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ".. versionadded:: 1.13.0",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "left_shift",
      "signature": "left_shift(a, n)",
      "documentation": {
        "description": "Shift the bits of an integer to the left.\n\n    This is the masked array version of `numpy.left_shift`, for details\n    see that function.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.left_shift",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "less",
      "signature": "less(a, b, *args, **kwargs)",
      "documentation": {
        "description": "less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 < x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray or scalar",
            "description": "Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "less_equal",
      "signature": "less_equal(a, b, *args, **kwargs)",
      "documentation": {
        "description": "less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 <= x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray or scalar",
            "description": "Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "log",
      "signature": "log(a, *args, **kwargs)",
      "documentation": {
        "description": "log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nNatural logarithm, element-wise.\n\nThe natural logarithm `log` is the inverse of the exponential function,\nso that `log(exp(x)) = x`. The natural logarithm is logarithm in base\n`e`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input value."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "The natural logarithm of `x`, element-wise.\n    This is a scalar if `x` is a scalar."
          },
          "https": {
            "type": "//personal.math.ubc.ca/~cbm/aands/page_67.htm",
            "description": ".. [2] Wikipedia, \"Logarithm\". https://en.wikipedia.org/wiki/Logarithm"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "log10",
      "signature": "log10(a, *args, **kwargs)",
      "documentation": {
        "description": "log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the base 10 logarithm of the input array, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input values."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "The logarithm to the base 10 of `x`, element-wise. NaNs are\n    returned where x is negative.\n    This is a scalar if `x` is a scalar."
          },
          "https": {
            "type": "//personal.math.ubc.ca/~cbm/aands/page_67.htm",
            "description": ".. [2] Wikipedia, \"Logarithm\". https://en.wikipedia.org/wiki/Logarithm"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "log2",
      "signature": "log2(a, *args, **kwargs)",
      "documentation": {
        "description": "log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nBase-2 logarithm of `x`.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input values."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "Base-2 logarithm of `x`.\n    This is a scalar if `x` is a scalar."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "logical_and",
      "signature": "logical_and(a, b, *args, **kwargs)",
      "documentation": {
        "description": "logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of x1 AND x2 element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray or bool",
            "description": "Boolean result of the logical AND operation applied to the elements\n    of `x1` and `x2`; the shape is determined by broadcasting.\n    This is a scalar if both `x1` and `x2` are scalars."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "logical_not",
      "signature": "logical_not(a, *args, **kwargs)",
      "documentation": {
        "description": "logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of NOT x element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Logical NOT is applied to the elements of `x`."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "bool or ndarray of bool",
            "description": "Boolean result with the same shape as `x` of the NOT operation\n    on elements of `x`.\n    This is a scalar if `x` is a scalar."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "logical_or",
      "signature": "logical_or(a, b, *args, **kwargs)",
      "documentation": {
        "description": "logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of x1 OR x2 element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray or bool",
            "description": "Boolean result of the logical OR operation applied to the elements\n    of `x1` and `x2`; the shape is determined by broadcasting.\n    This is a scalar if both `x1` and `x2` are scalars."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "logical_xor",
      "signature": "logical_xor(a, b, *args, **kwargs)",
      "documentation": {
        "description": "logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of x1 XOR x2, element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "bool or ndarray of bool",
            "description": "Boolean result of the logical XOR operation applied to the elements\n    of `x1` and `x2`; the shape is determined by broadcasting.\n    This is a scalar if both `x1` and `x2` are scalars."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "make_mask",
      "signature": "make_mask(m, copy=False, shrink=True, dtype=<class 'numpy.bool_'>)",
      "documentation": {
        "description": "Create a boolean mask from an array.\n\n    Return `m` as a boolean mask, creating a copy if necessary or requested.\n    The function can accept any sequence that is convertible to integers,\n    or ``nomask``.  Does not require that contents must be 0s and 1s, values\n    of 0 are interpreted as False, everything else as True.",
        "parameters": {
          "copy": {
            "type": "bool",
            "description": "Whether to return a copy of `m` (True) or `m` itself (False)."
          },
          "shrink": {
            "type": "bool",
            "description": "Whether to shrink `m` to ``nomask`` if all its values are False."
          },
          "dtype": {
            "type": "dtype",
            "description": "Data-type of the output mask. By default, the output mask has a\n        dtype of MaskType (bool). If the dtype is flexible, each field has\n        a boolean dtype. This is ignored when `m` is ``nomask``, in which\n        case ``nomask`` is always returned."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "make_mask_descr",
      "signature": "make_mask_descr(ndtype)",
      "documentation": {
        "description": "Construct a dtype description list from a given dtype.\n\n    Returns a new dtype object, with the type of all fields in `ndtype` to a\n    boolean type. Field names are not altered.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "make_mask_none",
      "signature": "make_mask_none(newshape, dtype=None)",
      "documentation": {
        "description": "Return a boolean mask of the given shape, filled with False.\n\n    This function returns a boolean ndarray with all entries False, that can\n    be used in common mask manipulations. If a complex dtype is specified, the\n    type of each field is converted to a boolean type.",
        "parameters": {
          "dtype": {
            "type": "{None",
            "description": ", dtype}, optional\n        If None, use a MaskType instance. Otherwise, use a new datatype with\n        the same fields as `dtype`, converted to boolean types."
          },
          "make_mask_descr": {
            "type": "Construct a dtype description list from a given dtype.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "mask_cols",
      "signature": "mask_cols(a, axis=<no value>)",
      "documentation": {
        "description": "Mask columns of a 2D array that contain masked values.\n\n    This function is a shortcut to ``mask_rowcols`` with `axis` equal to 1.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> a = np.zeros((3, 3), dtype=int)\n    >>> a[1, 1] = 1\n    >>> a\n    array([[0, 0, 0],\n           [0, 1, 0],\n           [0, 0, 0]])\n    >>> a = ma.masked_equal(a, 1)\n    >>> a\n    masked_array(\n      data=[[0, 0, 0],\n            [0, --, 0],\n            [0, 0, 0]],\n      mask=[[False, False, False],\n            [False,  True, False],\n            [False, False, False]],\n      fill_value=1)\n    >>> ma.mask_cols(a)\n    masked_array(\n      data=[[0, --, 0],\n            [0, --, 0],\n            [0, --, 0]],\n      mask=[[False,  True, False],\n            [False,  True, False],\n            [False,  True, False]],\n      fill_value=1)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "mask_or",
      "signature": "mask_or(m1, m2, copy=False, shrink=True)",
      "documentation": {
        "description": "Combine two masks with the ``logical_or`` operator.\n\n    The result may be a view on `m1` or `m2` if the other is `nomask`\n    (i.e. False).",
        "parameters": {
          "copy": {
            "type": "bool",
            "description": "If copy is False and one of the inputs is `nomask`, return a view\n        of the other input mask. Defaults to False."
          },
          "shrink": {
            "type": "bool",
            "description": "Whether to shrink the output to `nomask` if all its values are\n        False. Defaults to True."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "mask_rowcols",
      "signature": "mask_rowcols(a, axis=None)",
      "documentation": {
        "description": "Mask rows and/or columns of a 2D array that contain masked values.\n\n    Mask whole rows and/or columns of a 2D array that contain\n    masked values.  The masking behavior is selected using the\n    `axis` parameter.\n\n      - If `axis` is None, rows *and* columns are masked.\n      - If `axis` is 0, only rows are masked.\n      - If `axis` is 1 or -1, only columns are masked.",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "Axis along which to perform the operation. If None, applies to a\n        flattened version of the array."
          },
          "mask_cols": {
            "type": "Mask cols of a 2D array that contain masked values.",
            "description": ""
          },
          "masked_where": {
            "type": "Mask where a condition is met.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "mask_rows",
      "signature": "mask_rows(a, axis=<no value>)",
      "documentation": {
        "description": "Mask rows of a 2D array that contain masked values.\n\n    This function is a shortcut to ``mask_rowcols`` with `axis` equal to 0.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> a = np.zeros((3, 3), dtype=int)\n    >>> a[1, 1] = 1\n    >>> a\n    array([[0, 0, 0],\n           [0, 1, 0],\n           [0, 0, 0]])\n    >>> a = ma.masked_equal(a, 1)\n    >>> a\n    masked_array(\n      data=[[0, 0, 0],\n            [0, --, 0],\n            [0, 0, 0]],\n      mask=[[False, False, False],\n            [False,  True, False],\n            [False, False, False]],\n      fill_value=1)\n\n    >>> ma.mask_rows(a)\n    masked_array(\n      data=[[0, 0, 0],\n            [--, --, --],\n            [0, 0, 0]],\n      mask=[[False, False, False],\n            [ True,  True,  True],\n            [False, False, False]],\n      fill_value=1)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_all",
      "signature": "masked_all(shape, dtype=<class 'float'>)",
      "documentation": {
        "description": "Empty masked array with all elements masked.\n\n    Return an empty masked array of the given shape and dtype, where all the\n    data are masked.",
        "parameters": {
          "dtype": {
            "type": "dtype",
            "description": "Data type of the output."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_all_like",
      "signature": "masked_all_like(arr)",
      "documentation": {
        "description": "Empty masked array with the properties of an existing array.\n\n    Return an empty masked array of the same shape and dtype as\n    the array `arr`, where all the data are masked.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_equal",
      "signature": "masked_equal(x, value, copy=True)",
      "documentation": {
        "description": "Mask an array where equal to a given value.\n\n    Return a MaskedArray, masked where the data in array `x` are\n    equal to `value`. The fill_value of the returned MaskedArray\n    is set to `value`.\n\n    For floating point arrays, consider using ``masked_values(x, value)``.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> a = np.arange(4)\n    >>> a\n    array([0, 1, 2, 3])\n    >>> ma.masked_equal(a, 2)\n    masked_array(data=[0, 1, --, 3],\n                 mask=[False, False,  True, False],\n           fill_value=2)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_greater",
      "signature": "masked_greater(x, value, copy=True)",
      "documentation": {
        "description": "Mask an array where greater than a given value.\n\n    This function is a shortcut to ``masked_where``, with\n    `condition` = (x > value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> a = np.arange(4)\n    >>> a\n    array([0, 1, 2, 3])\n    >>> ma.masked_greater(a, 2)\n    masked_array(data=[0, 1, 2, --],\n                 mask=[False, False, False,  True],\n           fill_value=999999)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_greater_equal",
      "signature": "masked_greater_equal(x, value, copy=True)",
      "documentation": {
        "description": "Mask an array where greater than or equal to a given value.\n\n    This function is a shortcut to ``masked_where``, with\n    `condition` = (x >= value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> a = np.arange(4)\n    >>> a\n    array([0, 1, 2, 3])\n    >>> ma.masked_greater_equal(a, 2)\n    masked_array(data=[0, 1, --, --],\n                 mask=[False, False,  True,  True],\n           fill_value=999999)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_inside",
      "signature": "masked_inside(x, v1, v2, copy=True)",
      "documentation": {
        "description": "Mask an array inside a given interval.\n\n    Shortcut to ``masked_where``, where `condition` is True for `x` inside\n    the interval [v1,v2] (v1 <= x <= v2).  The boundaries `v1` and `v2`\n    can be given in either order.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n    >>> ma.masked_inside(x, -0.3, 0.3)\n    masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n                 mask=[False, False,  True,  True, False, False],\n           fill_value=1e+20)\n\n    The order of `v1` and `v2` doesn't matter.\n\n    >>> ma.masked_inside(x, 0.3, -0.3)\n    masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n                 mask=[False, False,  True,  True, False, False],\n           fill_value=1e+20)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_invalid",
      "signature": "masked_invalid(a, copy=True)",
      "documentation": {
        "description": "Mask an array where invalid values occur (NaNs or infs).\n\n    This function is a shortcut to ``masked_where``, with\n    `condition` = ~(np.isfinite(a)). Any pre-existing mask is conserved.\n    Only applies to arrays with a dtype where NaNs or infs make sense\n    (i.e. floating point types), but accepts any array_like object.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> a = np.arange(5, dtype=float)\n    >>> a[2] = np.NaN\n    >>> a[3] = np.PINF\n    >>> a\n    array([ 0.,  1., nan, inf,  4.])\n    >>> ma.masked_invalid(a)\n    masked_array(data=[0.0, 1.0, --, --, 4.0],\n                 mask=[False, False,  True,  True, False],\n           fill_value=1e+20)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_less",
      "signature": "masked_less(x, value, copy=True)",
      "documentation": {
        "description": "Mask an array where less than a given value.\n\n    This function is a shortcut to ``masked_where``, with\n    `condition` = (x < value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> a = np.arange(4)\n    >>> a\n    array([0, 1, 2, 3])\n    >>> ma.masked_less(a, 2)\n    masked_array(data=[--, --, 2, 3],\n                 mask=[ True,  True, False, False],\n           fill_value=999999)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_less_equal",
      "signature": "masked_less_equal(x, value, copy=True)",
      "documentation": {
        "description": "Mask an array where less than or equal to a given value.\n\n    This function is a shortcut to ``masked_where``, with\n    `condition` = (x <= value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> a = np.arange(4)\n    >>> a\n    array([0, 1, 2, 3])\n    >>> ma.masked_less_equal(a, 2)\n    masked_array(data=[--, --, --, 3],\n                 mask=[ True,  True,  True, False],\n           fill_value=999999)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_not_equal",
      "signature": "masked_not_equal(x, value, copy=True)",
      "documentation": {
        "description": "Mask an array where `not` equal to a given value.\n\n    This function is a shortcut to ``masked_where``, with\n    `condition` = (x != value).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> a = np.arange(4)\n    >>> a\n    array([0, 1, 2, 3])\n    >>> ma.masked_not_equal(a, 2)\n    masked_array(data=[--, --, 2, --],\n                 mask=[ True,  True, False,  True],\n           fill_value=999999)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_object",
      "signature": "masked_object(x, value, copy=True, shrink=True)",
      "documentation": {
        "description": "Mask the array `x` where the data are exactly equal to value.\n\n    This function is similar to `masked_values`, but only suitable\n    for object arrays: for floating point, use `masked_values` instead.",
        "parameters": {
          "value": {
            "type": "object",
            "description": "Comparison value"
          },
          "copy": {
            "type": "{True",
            "description": ", False}, optional\n        Whether to return a copy of `x`."
          },
          "shrink": {
            "type": "{True",
            "description": ", False}, optional\n        Whether to collapse a mask full of False to nomask"
          },
          "masked_equal": {
            "type": "Mask where equal to a given value (integers).",
            "description": ""
          },
          "masked_values": {
            "type": "Mask using floating point equality.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_outside",
      "signature": "masked_outside(x, v1, v2, copy=True)",
      "documentation": {
        "description": "Mask an array outside a given interval.\n\n    Shortcut to ``masked_where``, where `condition` is True for `x` outside\n    the interval [v1,v2] (x < v1)|(x > v2).\n    The boundaries `v1` and `v2` can be given in either order.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n    >>> ma.masked_outside(x, -0.3, 0.3)\n    masked_array(data=[--, --, 0.01, 0.2, --, --],\n                 mask=[ True,  True, False, False,  True,  True],\n           fill_value=1e+20)\n\n    The order of `v1` and `v2` doesn't matter.\n\n    >>> ma.masked_outside(x, 0.3, -0.3)\n    masked_array(data=[--, --, 0.01, 0.2, --, --],\n                 mask=[ True,  True, False, False,  True,  True],\n           fill_value=1e+20)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_values",
      "signature": "masked_values(x, value, rtol=1e-05, atol=1e-08, copy=True, shrink=True)",
      "documentation": {
        "description": "Mask using floating point equality.\n\n    Return a MaskedArray, masked where the data in array `x` are approximately\n    equal to `value`, determined using `isclose`. The default tolerances for\n    `masked_values` are the same as those for `isclose`.\n\n    For integer types, exact equality is used, in the same way as\n    `masked_equal`.\n\n    The fill_value is set to `value` and the mask is set to ``nomask`` if\n    possible.",
        "parameters": {
          "value": {
            "type": "float",
            "description": "Masking value.\n    rtol, atol : float, optional\n        Tolerance parameters passed on to `isclose`"
          },
          "copy": {
            "type": "bool",
            "description": "Whether to return a copy of `x`."
          },
          "shrink": {
            "type": "bool",
            "description": "Whether to collapse a mask full of False to ``nomask``."
          },
          "masked_equal": {
            "type": "Mask where equal to a given value (integers).",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "masked_where",
      "signature": "masked_where(condition, a, copy=True)",
      "documentation": {
        "description": "Mask an array where a condition is met.\n\n    Return `a` as an array masked where `condition` is True.\n    Any masked values of `a` or `condition` are also masked in the output.",
        "parameters": {
          "a": {
            "type": "array_like",
            "description": "Array to mask."
          },
          "copy": {
            "type": "bool",
            "description": "If True (default) make a copy of `a` in the result.  If False modify\n        `a` in place and return a view."
          },
          "masked_equal": {
            "type": "Mask where equal to a given value.",
            "description": ""
          },
          "masked_not_equal": {
            "type": "Mask where `not` equal to a given value.",
            "description": ""
          },
          "masked_less_equal": {
            "type": "Mask where less than or equal to a given value.",
            "description": ""
          },
          "masked_greater_equal": {
            "type": "Mask where greater than or equal to a given value.",
            "description": ""
          },
          "masked_less": {
            "type": "Mask where less than a given value.",
            "description": ""
          },
          "masked_greater": {
            "type": "Mask where greater than a given value.",
            "description": ""
          },
          "masked_inside": {
            "type": "Mask inside a given interval.",
            "description": ""
          },
          "masked_outside": {
            "type": "Mask outside a given interval.",
            "description": ""
          },
          "masked_invalid": {
            "type": "Mask invalid values (NaNs or infs).",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "max",
      "signature": "max(obj, axis=None, out=None, fill_value=None, keepdims=<no value>)",
      "documentation": {
        "description": "Return the maximum along a given axis.",
        "parameters": {
          "out": {
            "type": "array_like",
            "description": "Alternative output array in which to place the result.  Must\n            be of the same shape and buffer length as the expected output."
          },
          "fill_value": {
            "type": "scalar or None",
            "description": "Value used to fill in the masked values.\n            If None, use the output of maximum_fill_value()."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "maximum",
      "signature": "maximum(a, b)",
      "documentation": {
        "description": "maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise maximum of array elements.\n\nCompare two arrays and return a new array containing the element-wise\nmaxima. If one of the elements being compared is a NaN, then that\nelement is returned. If both elements are NaNs then the first is\nreturned. The latter distinction is important for complex NaNs, which\nare defined as at least one of the real or imaginary parts being a NaN.\nThe net effect is that NaNs are propagated.",
        "parameters": {
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray or scalar",
            "description": "The maximum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "minimum": {
            "type": "Element-wise minimum of two arrays",
            "description": ", propagates NaNs."
          },
          "fmax": {
            "type": "Element-wise maximum of two arrays",
            "description": ", ignores NaNs."
          },
          "amax": {
            "type": "The maximum value of an array along a given axis",
            "description": ", propagates NaNs."
          },
          "nanmax": {
            "type": "The maximum value of an array along a given axis",
            "description": ", ignores NaNs.\n\nfmin, amin, nanmin"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "maximum_fill_value",
      "signature": "maximum_fill_value(obj)",
      "documentation": {
        "description": "Return the minimum value that can be represented by the dtype of an object.\n\n    This function is useful for calculating a fill value suitable for\n    taking the maximum of an array with a given dtype.",
        "parameters": {
          "set_fill_value": {
            "type": "Set the filling value of a masked array.",
            "description": "MaskedArray.fill_value : Return current fill value."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "mean",
      "signature": "mean(a, *args, **params)",
      "documentation": {
        "description": "mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)\n\n        Returns the average of the array elements along given axis.\n\n        Masked entries are ignored, and result elements which are not\n        finite will be masked.\n\n        Refer to `numpy.mean` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> a = np.ma.array([1,2,3], mask=[False, False, True])\n        >>> a\n        masked_array(data=[1, 2, --],\n                     mask=[False, False,  True],\n               fill_value=999999)\n        >>> a.mean()\n        1.5",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "median",
      "signature": "median(a, axis=None, out=None, overwrite_input=False, keepdims=False)",
      "documentation": {
        "description": "Compute the median along the specified axis.\n\n    Returns the median of the array elements.",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "Axis along which the medians are computed. The default (None) is\n        to compute the median along a flattened version of the array."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type will be cast if necessary."
          },
          "overwrite_input": {
            "type": "bool",
            "description": "If True, then allow use of memory of input array (a) for\n        calculations. The input array will be modified by the call to\n        median. This will save memory when you do not need to preserve\n        the contents of the input array. Treat the input as undefined,\n        but it will probably be fully or partially sorted. Default is\n        False. Note that, if `overwrite_input` is True, and the input\n        is not already an `ndarray`, an error will be raised."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        .. versionadded:: 1.10.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "min",
      "signature": "min(obj, axis=None, out=None, fill_value=None, keepdims=<no value>)",
      "documentation": {
        "description": "Return the minimum along a given axis.",
        "parameters": {
          "out": {
            "type": "array_like",
            "description": "Alternative output array in which to place the result.  Must be of\n            the same shape and buffer length as the expected output."
          },
          "fill_value": {
            "type": "scalar or None",
            "description": "Value used to fill in the masked values.\n            If None, use the output of `minimum_fill_value`."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "minimum",
      "signature": "minimum(a, b)",
      "documentation": {
        "description": "minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise minimum of array elements.\n\nCompare two arrays and return a new array containing the element-wise\nminima. If one of the elements being compared is a NaN, then that\nelement is returned. If both elements are NaNs then the first is\nreturned. The latter distinction is important for complex NaNs, which\nare defined as at least one of the real or imaginary parts being a NaN.\nThe net effect is that NaNs are propagated.",
        "parameters": {
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray or scalar",
            "description": "The minimum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "maximum": {
            "type": "Element-wise maximum of two arrays",
            "description": ", propagates NaNs."
          },
          "fmin": {
            "type": "Element-wise minimum of two arrays",
            "description": ", ignores NaNs."
          },
          "amin": {
            "type": "The minimum value of an array along a given axis",
            "description": ", propagates NaNs."
          },
          "nanmin": {
            "type": "The minimum value of an array along a given axis",
            "description": ", ignores NaNs.\n\nfmax, amax, nanmax"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "minimum_fill_value",
      "signature": "minimum_fill_value(obj)",
      "documentation": {
        "description": "Return the maximum value that can be represented by the dtype of an object.\n\n    This function is useful for calculating a fill value suitable for\n    taking the minimum of an array with a given dtype.",
        "parameters": {
          "set_fill_value": {
            "type": "Set the filling value of a masked array.",
            "description": "MaskedArray.fill_value : Return current fill value."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "mod",
      "signature": "remainder(a, b, *args, **kwargs)",
      "documentation": {
        "description": "remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns the element-wise remainder of division.\n\nComputes the remainder complementary to the `floor_divide` function.  It is\nequivalent to the Python modulus operator``x1 % x2`` and has the same sign\nas the divisor `x2`. The MATLAB function equivalent to ``np.remainder``\nis ``mod``.\n\n.. warning::\n\n    This should not be confused with:\n\n    * Python 3.7's `math.remainder` and C's ``remainder``, which\n      computes the IEEE remainder, which are the complement to\n      ``round(x1 / x2)``.\n    * The MATLAB ``rem`` function and or the C ``%`` operator which is the\n      complement to ``int(x1 / x2)``.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend array."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor array.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "The element-wise remainder of the quotient ``floor_divide(x1, x2)``.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "floor_divide": {
            "type": "Equivalent of Python ``//`` operator.",
            "description": ""
          },
          "divmod": {
            "type": "Simultaneous floor division and remainder.",
            "description": ""
          },
          "fmod": {
            "type": "Equivalent of the MATLAB ``rem`` function.",
            "description": "divide, floor"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "multiply",
      "signature": "multiply(a, b, *args, **kwargs)",
      "documentation": {
        "description": "multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nMultiply arguments element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "The product of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ndenumerate",
      "signature": "ndenumerate(a, compressed=True)",
      "documentation": {
        "description": "Multidimensional index iterator.\n\n    Return an iterator yielding pairs of array coordinates and values,\n    skipping elements that are masked. With `compressed=False`,\n    `ma.masked` is yielded as the value of masked elements. This\n    behavior differs from that of `numpy.ndenumerate`, which yields the\n    value of the underlying data array.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": ">>> a = np.ma.arange(9).reshape((3, 3))\n    >>> a[1, 0] = np.ma.masked\n    >>> a[1, 2] = np.ma.masked\n    >>> a[2, 1] = np.ma.masked\n    >>> a\n    masked_array(\n      data=[[0, 1, 2],\n            [--, 4, --],\n            [6, --, 8]],\n      mask=[[False, False, False],\n            [ True, False,  True],\n            [False,  True, False]],\n      fill_value=999999)\n    >>> for index, x in np.ma.ndenumerate(a):\n    ...     print(index, x)\n    (0, 0) 0\n    (0, 1) 1\n    (0, 2) 2\n    (1, 1) 4\n    (2, 0) 6\n    (2, 2) 8\n\n    >>> for index, x in np.ma.ndenumerate(a, compressed=False):\n    ...     print(index, x)\n    (0, 0) 0\n    (0, 1) 1\n    (0, 2) 2\n    (1, 0) --\n    (1, 1) 4\n    (1, 2) --\n    (2, 0) 6\n    (2, 1) --\n    (2, 2) 8",
        "examples": ""
      }
    },
    {
      "name": "ndim",
      "signature": "ndim(obj)",
      "documentation": {
        "description": "Return the number of dimensions of an array.",
        "parameters": {
          "shape": {
            "type": "dimensions of array",
            "description": "ndarray.shape : dimensions of array"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "negative",
      "signature": "negative(a, *args, **kwargs)",
      "documentation": {
        "description": "negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nNumerical negative, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like or scalar",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray or scalar",
            "description": "Returned array or scalar: `y = -x`.\n    This is a scalar if `x` is a scalar."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "nonzero",
      "signature": "nonzero(a, *args, **params)",
      "documentation": {
        "description": "nonzero(self)\n\n        Return the indices of unmasked elements that are not zero.\n\n        Returns a tuple of arrays, one for each dimension, containing the\n        indices of the non-zero elements in that dimension. The corresponding\n        non-zero values can be obtained with::\n\n            a[a.nonzero()]\n\n        To group the indices by element, rather than dimension, use\n        instead::\n\n            np.transpose(a.nonzero())\n\n        The result of this is always a 2d array, with a row for each non-zero\n        element.",
        "parameters": {
          "flatnonzero": {
            "type": "Return indices that are non-zero in the flattened version of the input",
            "description": "array.\n        numpy.ndarray.nonzero :\n            Equivalent ndarray method."
          },
          "count_nonzero": {
            "type": "Counts the number of non-zero elements in the input array.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "not_equal",
      "signature": "not_equal(a, b, *args, **kwargs)",
      "documentation": {
        "description": "not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn (x1 != x2) element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray or scalar",
            "description": "Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "notmasked_contiguous",
      "signature": "notmasked_contiguous(a, axis=None)",
      "documentation": {
        "description": "Find contiguous unmasked data in a masked array along the given axis.",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "Axis along which to perform the operation.\n        If None (default), applies to a flattened version of the array, and this\n        is the same as `flatnotmasked_contiguous`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "notmasked_edges",
      "signature": "notmasked_edges(a, axis=None)",
      "documentation": {
        "description": "Find the indices of the first and last unmasked values along an axis.\n\n    If all values are masked, return None.  Otherwise, return a list\n    of two tuples, corresponding to the indices of the first and last\n    unmasked values respectively.",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "Axis along which to perform the operation.\n        If None (default), applies to a flattened version of the array."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "outer",
      "signature": "outer(a, b)",
      "documentation": {
        "description": "Compute the outer product of two vectors.\n\nGiven two vectors `a` and `b` of length ``M`` and ``N``, repsectively,\nthe outer product [1]_ is::\n\n  [[a_0*b_0  a_0*b_1 ... a_0*b_{N-1} ]\n   [a_1*b_0    .\n   [ ...          .\n   [a_{M-1}*b_0            a_{M-1}*b_{N-1} ]]",
        "parameters": {
          "a": {
            "type": "(M",
            "description": ",) array_like\n    First input vector.  Input is flattened if\n    not already 1-dimensional."
          },
          "b": {
            "type": "(N",
            "description": ",) array_like\n    Second input vector.  Input is flattened if\n    not already 1-dimensional."
          },
          "out": {
            "type": "(M",
            "description": ", N) ndarray\n    ``out[i, j] = a[i] * b[j]``\n\nSee also\n--------\ninner"
          },
          "einsum": {
            "type": "``einsum('i",
            "description": ",j->ij', a.ravel(), b.ravel())`` is the equivalent.\nufunc.outer : A generalization to dimensions other than 1D and other\n              operations. ``np.multiply.outer(a.ravel(), b.ravel())``\n              is the equivalent."
          },
          "tensordot": {
            "type": "``np.tensordot(a.ravel()",
            "description": ", b.ravel(), axes=((), ()))``\n            is the equivalent.\n\nReferences\n----------\n.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd\n       ed., Baltimore, MD, Johns Hopkins University Press, 1996,\n       pg. 8."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "outerproduct",
      "signature": "outer(a, b)",
      "documentation": {
        "description": "Compute the outer product of two vectors.\n\nGiven two vectors `a` and `b` of length ``M`` and ``N``, repsectively,\nthe outer product [1]_ is::\n\n  [[a_0*b_0  a_0*b_1 ... a_0*b_{N-1} ]\n   [a_1*b_0    .\n   [ ...          .\n   [a_{M-1}*b_0            a_{M-1}*b_{N-1} ]]",
        "parameters": {
          "a": {
            "type": "(M",
            "description": ",) array_like\n    First input vector.  Input is flattened if\n    not already 1-dimensional."
          },
          "b": {
            "type": "(N",
            "description": ",) array_like\n    Second input vector.  Input is flattened if\n    not already 1-dimensional."
          },
          "out": {
            "type": "(M",
            "description": ", N) ndarray\n    ``out[i, j] = a[i] * b[j]``\n\nSee also\n--------\ninner"
          },
          "einsum": {
            "type": "``einsum('i",
            "description": ",j->ij', a.ravel(), b.ravel())`` is the equivalent.\nufunc.outer : A generalization to dimensions other than 1D and other\n              operations. ``np.multiply.outer(a.ravel(), b.ravel())``\n              is the equivalent."
          },
          "tensordot": {
            "type": "``np.tensordot(a.ravel()",
            "description": ", b.ravel(), axes=((), ()))``\n            is the equivalent.\n\nReferences\n----------\n.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd\n       ed., Baltimore, MD, Johns Hopkins University Press, 1996,\n       pg. 8."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "polyfit",
      "signature": "polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False)",
      "documentation": {
        "description": "Least squares polynomial fit.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nFit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`\nto points `(x, y)`. Returns a vector of coefficients `p` that minimises\nthe squared error in the order `deg`, `deg-1`, ... `0`.\n\nThe `Polynomial.fit <numpy.polynomial.polynomial.Polynomial.fit>` class\nmethod is recommended for new code as it is more stable numerically. See\nthe documentation of the method for more information.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": ", shape (M,)\n    x-coordinates of the M sample points ``(x[i], y[i])``."
          },
          "y": {
            "type": "array_like",
            "description": ", shape (M,) or (M, K)\n    y-coordinates of the sample points. Several data sets of sample\n    points sharing the same x-coordinates can be fitted at once by\n    passing in a 2D-array that contains one dataset per column."
          },
          "deg": {
            "type": "int",
            "description": "Degree of the fitting polynomial"
          },
          "rcond": {
            "type": "float",
            "description": "Relative condition number of the fit. Singular values smaller than\n    this relative to the largest singular value will be ignored. The\n    default value is len(x)*eps, where eps is the relative precision of\n    the float type, about 2e-16 in most cases."
          },
          "full": {
            "type": "bool",
            "description": "Switch determining nature of return value. When it is False (the\n    default) just the coefficients are returned, when True diagnostic\n    information from the singular value decomposition is also returned."
          },
          "w": {
            "type": "array_like",
            "description": ", shape (M,), optional\n    Weights. If not None, the weight ``w[i]`` applies to the unsquared\n    residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are\n    chosen so that the errors of the products ``w[i]*y[i]`` all have the\n    same variance.  When using inverse-variance weighting, use\n    ``w[i] = 1/sigma(y[i])``.  The default value is None."
          },
          "cov": {
            "type": "bool or str",
            "description": "If given and not `False`, return not just the estimate but also its\n    covariance matrix. By default, the covariance are scaled by\n    chi2/dof, where dof = M - (deg + 1), i.e., the weights are presumed\n    to be unreliable except in a relative sense and everything is scaled\n    such that the reduced chi2 is unity. This scaling is omitted if\n    ``cov='unscaled'``, as is relevant for the case that the weights are\n    w = 1/sigma, with sigma known to be a reliable estimate of the\n    uncertainty."
          },
          "p": {
            "type": "ndarray",
            "description": ", shape (deg + 1,) or (deg + 1, K)\n    Polynomial coefficients, highest power first.  If `y` was 2-D, the\n    coefficients for `k`-th data set are in ``p[:,k]``.\n\nresiduals, rank, singular_values, rcond\n    These values are only returned if ``full == True``\n\n    - residuals -- sum of squared residuals of the least squares fit\n    - rank -- the effective rank of the scaled Vandermonde\n       coefficient matrix\n    - singular_values -- singular values of the scaled Vandermonde\n       coefficient matrix\n    - rcond -- value of `rcond`.\n\n    For more details, see `numpy.linalg.lstsq`."
          },
          "V": {
            "type": "ndarray",
            "description": ", shape (M,M) or (M,M,K)\n    Present only if ``full == False`` and ``cov == True``.  The covariance\n    matrix of the polynomial coefficient estimates.  The diagonal of\n    this matrix are the variance estimates for each coefficient.  If y\n    is a 2-D array, then the covariance matrix for the `k`-th data set\n    are in ``V[:,:,k]``\n\n\nWarns\n-----\nRankWarning\n    The rank of the coefficient matrix in the least-squares fit is\n    deficient. The warning is only raised if ``full == False``.\n\n    The warnings can be turned off by\n\n    >>> import warnings\n    >>> warnings.simplefilter('ignore', np.RankWarning)"
          },
          "polyval": {
            "type": "Compute polynomial values.",
            "description": "linalg.lstsq : Computes a least-squares fit.\nscipy.interpolate.UnivariateSpline : Computes spline fits."
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Polynomial_interpolation",
            "description": ""
          },
          "Illustration": {
            "type": ">>> import matplotlib.pyplot as plt",
            "description": ">>> xp = np.linspace(-2, 6, 100)\n>>> _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n>>> plt.ylim(-2,2)\n(-2, 2)\n>>> plt.show()"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "power",
      "signature": "power(a, b, third=None)",
      "documentation": {
        "description": "Returns element-wise base array raised to power from second array.\n\n    This is the masked array version of `numpy.power`. For details see\n    `numpy.power`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> x = [11.2, -3.973, 0.801, -1.41]\n    >>> mask = [0, 0, 0, 1]\n    >>> masked_x = ma.masked_array(x, mask)\n    >>> masked_x\n    masked_array(data=[11.2, -3.973, 0.801, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)\n    >>> ma.power(masked_x, 2)\n    masked_array(data=[125.43999999999998, 15.784728999999999,\n                   0.6416010000000001, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)\n    >>> y = [-0.5, 2, 0, 17]\n    >>> masked_y = ma.masked_array(y, mask)\n    >>> masked_y\n    masked_array(data=[-0.5, 2.0, 0.0, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)\n    >>> ma.power(masked_x, masked_y)\n    masked_array(data=[0.29880715233359845, 15.784728999999999, 1.0, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "prod",
      "signature": "prod(a, *args, **params)",
      "documentation": {
        "description": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)\n\n        Return the product of the array elements over the given axis.\n\n        Masked elements are set to 1 internally for computation.\n\n        Refer to `numpy.prod` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "numpy.ndarray.prod : corresponding function for ndarrays\n        numpy.prod : equivalent function",
        "examples": ""
      }
    },
    {
      "name": "product",
      "signature": "prod(a, *args, **params)",
      "documentation": {
        "description": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)\n\n        Return the product of the array elements over the given axis.\n\n        Masked elements are set to 1 internally for computation.\n\n        Refer to `numpy.prod` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "numpy.ndarray.prod : corresponding function for ndarrays\n        numpy.prod : equivalent function",
        "examples": ""
      }
    },
    {
      "name": "ptp",
      "signature": "ptp(obj, axis=None, out=None, fill_value=None, keepdims=<no value>)",
      "documentation": {
        "description": "Return (maximum - minimum) along the given dimension\n        (i.e. peak-to-peak value).\n\n        .. warning::\n            `ptp` preserves the data type of the array. This means the\n            return value for an input of signed integers with n bits\n            (e.g. `np.int8`, `np.int16`, etc) is also a signed integer\n            with n bits.  In that case, peak-to-peak values greater than\n            ``2**(n-1)-1`` will be returned as negative values. An example\n            with a work-around is shown below.",
        "parameters": {
          "out": {
            "type": "{None",
            "description": ", array_like}, optional\n            Alternative output array in which to place the result. It must\n            have the same shape and buffer length as the expected output\n            but the type will be cast if necessary."
          },
          "fill_value": {
            "type": "scalar or None",
            "description": "Value used to fill in the masked values."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "put",
      "signature": "put(a, indices, values, mode='raise')",
      "documentation": {
        "description": "Set storage-indexed locations to corresponding values.\n\n    This function is equivalent to `MaskedArray.put`, see that method\n    for details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "MaskedArray.put",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "putmask",
      "signature": "putmask(a, mask, values)",
      "documentation": {
        "description": "Changes elements of an array based on conditional and input values.\n\n    This is the masked array version of `numpy.putmask`, for details see\n    `numpy.putmask`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "Using a masked array as `values` will **not** transform a `ndarray` into\n    a `MaskedArray`.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "ravel",
      "signature": "ravel(a, *args, **params)",
      "documentation": {
        "description": "ravel(self, order='C')\n\n        Returns a 1D version of self, as a view.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "remainder",
      "signature": "remainder(a, b, *args, **kwargs)",
      "documentation": {
        "description": "remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns the element-wise remainder of division.\n\nComputes the remainder complementary to the `floor_divide` function.  It is\nequivalent to the Python modulus operator``x1 % x2`` and has the same sign\nas the divisor `x2`. The MATLAB function equivalent to ``np.remainder``\nis ``mod``.\n\n.. warning::\n\n    This should not be confused with:\n\n    * Python 3.7's `math.remainder` and C's ``remainder``, which\n      computes the IEEE remainder, which are the complement to\n      ``round(x1 / x2)``.\n    * The MATLAB ``rem`` function and or the C ``%`` operator which is the\n      complement to ``int(x1 / x2)``.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend array."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor array.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "The element-wise remainder of the quotient ``floor_divide(x1, x2)``.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "floor_divide": {
            "type": "Equivalent of Python ``//`` operator.",
            "description": ""
          },
          "divmod": {
            "type": "Simultaneous floor division and remainder.",
            "description": ""
          },
          "fmod": {
            "type": "Equivalent of the MATLAB ``rem`` function.",
            "description": "divide, floor"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "repeat",
      "signature": "repeat(a, *args, **params)",
      "documentation": {
        "description": "repeat(self, *args, **params)\na.repeat(repeats, axis=None)\n\n    Repeat elements of an array.\n\n    Refer to `numpy.repeat` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.repeat : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "reshape",
      "signature": "reshape(a, new_shape, order='C')",
      "documentation": {
        "description": "Returns an array containing the same data with a new shape.\n\n    Refer to `MaskedArray.reshape` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "MaskedArray.reshape : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "resize",
      "signature": "resize(x, new_shape)",
      "documentation": {
        "description": "Return a new masked array with the specified size and shape.\n\n    This is the masked equivalent of the `numpy.resize` function. The new\n    array is filled with repeated copies of `x` (in the order that the\n    data are stored in memory). If `x` is masked, the new array will be\n    masked, and the new mask will be a repetition of the old one.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> a = ma.array([[1, 2] ,[3, 4]])\n    >>> a[0, 1] = ma.masked\n    >>> a\n    masked_array(\n      data=[[1, --],\n            [3, 4]],\n      mask=[[False,  True],\n            [False, False]],\n      fill_value=999999)\n    >>> np.resize(a, (3, 3))\n    masked_array(\n      data=[[1, 2, 3],\n            [4, 1, 2],\n            [3, 4, 1]],\n      mask=False,\n      fill_value=999999)\n    >>> ma.resize(a, (3, 3))\n    masked_array(\n      data=[[1, --, 3],\n            [4, 1, --],\n            [3, 4, 1]],\n      mask=[[False,  True, False],\n            [False, False,  True],\n            [False, False, False]],\n      fill_value=999999)\n\n    A MaskedArray is always returned, regardless of the input type.\n\n    >>> a = np.array([[1, 2] ,[3, 4]])\n    >>> ma.resize(a, (3, 3))\n    masked_array(\n      data=[[1, 2, 3],\n            [4, 1, 2],\n            [3, 4, 1]],\n      mask=False,\n      fill_value=999999)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "right_shift",
      "signature": "right_shift(a, n)",
      "documentation": {
        "description": "Shift the bits of an integer to the right.\n\n    This is the masked array version of `numpy.right_shift`, for details\n    see that function.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> x = [11, 3, 8, 1]\n    >>> mask = [0, 0, 0, 1]\n    >>> masked_x = ma.masked_array(x, mask)\n    >>> masked_x\n    masked_array(data=[11, 3, 8, --],\n                 mask=[False, False, False,  True],\n           fill_value=999999)\n    >>> ma.right_shift(masked_x,1)\n    masked_array(data=[5, 1, 4, --],\n                 mask=[False, False, False,  True],\n           fill_value=999999)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "round",
      "signature": "round_(a, decimals=0, out=None)",
      "documentation": {
        "description": "Return a copy of a, rounded to 'decimals' places.\n\n    When 'decimals' is negative, it specifies the number of positions\n    to the left of the decimal point.  The real and imaginary parts of\n    complex numbers are rounded separately. Nothing is done if the\n    array is not of float type and 'decimals' is greater than or equal\n    to 0.",
        "parameters": {
          "out": {
            "type": "array_like",
            "description": "Existing array to use for output.\n        If not given, returns a default copy of a."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "round_",
      "signature": "round_(a, decimals=0, out=None)",
      "documentation": {
        "description": "Return a copy of a, rounded to 'decimals' places.\n\n    When 'decimals' is negative, it specifies the number of positions\n    to the left of the decimal point.  The real and imaginary parts of\n    complex numbers are rounded separately. Nothing is done if the\n    array is not of float type and 'decimals' is greater than or equal\n    to 0.",
        "parameters": {
          "out": {
            "type": "array_like",
            "description": "Existing array to use for output.\n        If not given, returns a default copy of a."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "row_stack",
      "signature": "vstack(x, *args, **params)",
      "documentation": {
        "description": "vstack\n\nStack arrays in sequence vertically (row wise).\n\nThis is equivalent to concatenation along the first axis after 1-D arrays\nof shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by\n`vsplit`.\n\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.\n\n``np.row_stack`` is an alias for `vstack`. They are the same function.",
        "parameters": {
          "tup": {
            "type": "sequence of ndarrays",
            "description": "The arrays must have the same shape along all but the first axis.\n    1-D arrays must have the same length."
          },
          "dtype": {
            "type": "str or dtype",
            "description": "If provided, the destination array will have this dtype. Cannot be\n    provided together with `out`.\n\n.. versionadded:: 1.24"
          },
          "casting": {
            "type": "{'no'",
            "description": ", 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n    Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n.. versionadded:: 1.24"
          },
          "stacked": {
            "type": "ndarray",
            "description": "The array formed by stacking the given arrays, will be at least 2-D."
          },
          "concatenate": {
            "type": "Join a sequence of arrays along an existing axis.",
            "description": ""
          },
          "stack": {
            "type": "Join a sequence of arrays along a new axis.",
            "description": ""
          },
          "block": {
            "type": "Assemble an nd-array from nested lists of blocks.",
            "description": ""
          },
          "hstack": {
            "type": "Stack arrays in sequence horizontally (column wise).",
            "description": ""
          },
          "dstack": {
            "type": "Stack arrays in sequence depth wise (along third axis).",
            "description": ""
          },
          "column_stack": {
            "type": "Stack 1-D arrays as columns into a 2-D array.",
            "description": ""
          },
          "vsplit": {
            "type": "Split an array into multiple sub-arrays vertically (row-wise).",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "set_fill_value",
      "signature": "set_fill_value(a, fill_value)",
      "documentation": {
        "description": "Set the filling value of a, if a is a masked array.\n\n    This function changes the fill value of the masked array `a` in place.\n    If `a` is not a masked array, the function returns silently, without\n    doing anything.",
        "parameters": {
          "fill_value": {
            "type": "dtype",
            "description": "Filling value. A consistency test is performed to make sure\n        the value is compatible with the dtype of `a`."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "setdiff1d",
      "signature": "setdiff1d(ar1, ar2, assume_unique=False)",
      "documentation": {
        "description": "Set difference of 1D arrays with unique elements.\n\n    The output is always a masked array. See `numpy.setdiff1d` for more\n    details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])\n    >>> np.ma.setdiff1d(x, [1, 2])\n    masked_array(data=[3, --],\n                 mask=[False,  True],\n           fill_value=999999)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "setxor1d",
      "signature": "setxor1d(ar1, ar2, assume_unique=False)",
      "documentation": {
        "description": "Set exclusive-or of 1-D arrays with unique elements.\n\n    The output is always a masked array. See `numpy.setxor1d` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.setxor1d : Equivalent function for ndarrays.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "shape",
      "signature": "shape(obj)",
      "documentation": {
        "description": "Return the shape of an array.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sin",
      "signature": "sin(a, *args, **kwargs)",
      "documentation": {
        "description": "sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTrigonometric sine, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Angle, in radians (:math:`2 \\pi` rad equals 360 degrees)."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "array_like",
            "description": "The sine of each element of x.\n    This is a scalar if `x` is a scalar."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sinh",
      "signature": "sinh(a, *args, **kwargs)",
      "documentation": {
        "description": "sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nHyperbolic sine, element-wise.\n\nEquivalent to ``1/2 * (np.exp(x) - np.exp(-x))`` or\n``-1j * np.sin(1j*x)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "The corresponding hyperbolic sine values.\n    This is a scalar if `x` is a scalar."
          },
          "ValueError": {
            "type": "operands could not be broadcast together with shapes (3",
            "description": ",3) (2,2)"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "size",
      "signature": "size(obj, axis=None)",
      "documentation": {
        "description": "Return the number of elements along a given axis.",
        "parameters": {
          "axis": {
            "type": "int",
            "description": "Axis along which the elements are counted.  By default, give\n        the total number of elements."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "soften_mask",
      "signature": "soften_mask(a, *args, **params)",
      "documentation": {
        "description": "soften_mask(self)\n\n        Force the mask to soft (default), allowing unmasking by assignment.\n\n        Whether the mask of a masked array is hard or soft is determined by\n        its `~ma.MaskedArray.hardmask` property. `soften_mask` sets\n        `~ma.MaskedArray.hardmask` to ``False`` (and returns the modified\n        self).",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "ma.MaskedArray.hardmask\n        ma.MaskedArray.harden_mask",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sometrue",
      "signature": "reduce(target, axis=0, dtype=None)",
      "documentation": {
        "description": "Reduce `target` along the given `axis`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sort",
      "signature": "sort(a, axis=-1, kind=None, order=None, endwith=True, fill_value=None)",
      "documentation": {
        "description": "Return a sorted copy of the masked array.\n\n    Equivalent to creating a copy of the array\n    and applying the  MaskedArray ``sort()`` method.\n\n    Refer to ``MaskedArray.sort`` for the full documentation",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> x = [11.2, -3.973, 0.801, -1.41]\n    >>> mask = [0, 0, 0, 1]\n    >>> masked_x = ma.masked_array(x, mask)\n    >>> masked_x\n    masked_array(data=[11.2, -3.973, 0.801, --],\n                 mask=[False, False, False,  True],\n           fill_value=1e+20)\n    >>> ma.sort(masked_x)\n    masked_array(data=[-3.973, 0.801, 11.2, --],\n                 mask=[False, False, False,  True],\n           fill_value=1e+20)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sqrt",
      "signature": "sqrt(a, *args, **kwargs)",
      "documentation": {
        "description": "sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the non-negative square-root of an array, element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "The values whose square-roots are required."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "An array of the same shape as `x`, containing the positive\n    square-root of each element in `x`.  If any element in `x` is\n    complex, a complex array is returned (and the square-roots of\n    negative reals are calculated).  If all of the elements in `x`\n    are real, so is `y`, with negative elements returning ``nan``.\n    If `out` was provided, `y` is a reference to it.\n    This is a scalar if `x` is a scalar."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "stack",
      "signature": "stack(x, *args, **params)",
      "documentation": {
        "description": "stack\n\nJoin a sequence of arrays along a new axis.\n\nThe ``axis`` parameter specifies the index of the new axis in the\ndimensions of the result. For example, if ``axis=0`` it will be the first\ndimension and if ``axis=-1`` it will be the last dimension.\n\n.. versionadded:: 1.10.0",
        "parameters": {
          "arrays": {
            "type": "sequence of array_like",
            "description": "Each array must have the same shape."
          },
          "axis": {
            "type": "int",
            "description": "The axis in the result array along which the input arrays are stacked."
          },
          "out": {
            "type": "ndarray",
            "description": "If provided, the destination to place the result. The shape must be\n    correct, matching that of what stack would have returned if no\n    out argument were specified."
          },
          "dtype": {
            "type": "str or dtype",
            "description": "If provided, the destination array will have this dtype. Cannot be\n    provided together with `out`.\n\n    .. versionadded:: 1.24"
          },
          "casting": {
            "type": "{'no'",
            "description": ", 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n    Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n    .. versionadded:: 1.24"
          },
          "stacked": {
            "type": "ndarray",
            "description": "The stacked array has one more dimension than the input arrays."
          },
          "concatenate": {
            "type": "Join a sequence of arrays along an existing axis.",
            "description": ""
          },
          "block": {
            "type": "Assemble an nd-array from nested lists of blocks.",
            "description": ""
          },
          "split": {
            "type": "Split array into a list of multiple sub-arrays of equal size.",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "std",
      "signature": "std(a, *args, **params)",
      "documentation": {
        "description": "std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)\n\n        Returns the standard deviation of the array elements along given axis.\n\n        Masked entries are ignored.\n\n        Refer to `numpy.std` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.ndarray.std : corresponding function for ndarrays\n        numpy.std : Equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "subtract",
      "signature": "subtract(a, b, *args, **kwargs)",
      "documentation": {
        "description": "subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nSubtract arguments, element-wise.",
        "parameters": {
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "The difference of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "sum",
      "signature": "sum(a, *args, **params)",
      "documentation": {
        "description": "sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)\n\n        Return the sum of the array elements over the given axis.\n\n        Masked elements are set to 0 internally.\n\n        Refer to `numpy.sum` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n        >>> x\n        masked_array(\n          data=[[1, --, 3],\n                [--, 5, --],\n                [7, --, 9]],\n          mask=[[False,  True, False],\n                [ True, False,  True],\n                [False,  True, False]],\n          fill_value=999999)\n        >>> x.sum()\n        25\n        >>> x.sum(axis=1)\n        masked_array(data=[4, 5, 16],\n                     mask=[False, False, False],\n               fill_value=999999)\n        >>> x.sum(axis=0)\n        masked_array(data=[8, 5, 12],\n                     mask=[False, False, False],\n               fill_value=999999)\n        >>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n        <class 'numpy.int64'>",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "swapaxes",
      "signature": "swapaxes(a, *args, **params)",
      "documentation": {
        "description": "swapaxes(self, *args, **params)\na.swapaxes(axis1, axis2)\n\n    Return a view of the array with `axis1` and `axis2` interchanged.\n\n    Refer to `numpy.swapaxes` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.swapaxes : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "take",
      "signature": "take(a, indices, axis=None, out=None, mode='raise')",
      "documentation": {
        "description": "",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "tan",
      "signature": "tan(a, *args, **kwargs)",
      "documentation": {
        "description": "tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute tangent element-wise.\n\nEquivalent to ``np.sin(x)/np.cos(x)`` element-wise.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "The corresponding tangent values.\n    This is a scalar if `x` is a scalar."
          },
          "ValueError": {
            "type": "operands could not be broadcast together with shapes (3",
            "description": ",3) (2,2)"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "tanh",
      "signature": "tanh(a, *args, **kwargs)",
      "documentation": {
        "description": "tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute hyperbolic tangent element-wise.\n\nEquivalent to ``np.sinh(x)/np.cosh(x)`` or ``-1j * np.tan(1j*x)``.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "Input array."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray",
            "description": "The corresponding hyperbolic tangent values.\n    This is a scalar if `x` is a scalar."
          },
          "https": {
            "type": "//en.wikipedia.org/wiki/Hyperbolic_function",
            "description": ""
          },
          "ValueError": {
            "type": "operands could not be broadcast together with shapes (3",
            "description": ",3) (2,2)"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "trace",
      "signature": "trace(a, *args, **params)",
      "documentation": {
        "description": "trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)\na.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\n\n    Return the sum along diagonals of the array.\n\n    Refer to `numpy.trace` for full documentation.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.trace : equivalent function",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "transpose",
      "signature": "transpose(a, axes=None)",
      "documentation": {
        "description": "Permute the dimensions of an array.\n\n    This function is exactly equivalent to `numpy.transpose`.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> x = ma.arange(4).reshape((2,2))\n    >>> x[1, 1] = ma.masked\n    >>> x\n    masked_array(\n      data=[[0, 1],\n            [2, --]],\n      mask=[[False, False],\n            [False,  True]],\n      fill_value=999999)\n\n    >>> ma.transpose(x)\n    masked_array(\n      data=[[0, 2],\n            [1, --]],\n      mask=[[False, False],\n            [False,  True]],\n      fill_value=999999)",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "true_divide",
      "signature": "divide(a, b, *args, **kwargs)",
      "documentation": {
        "description": "divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nDivide arguments element-wise.",
        "parameters": {
          "x1": {
            "type": "array_like",
            "description": "Dividend array."
          },
          "x2": {
            "type": "array_like",
            "description": "Divisor array.\n    If ``x1.shape != x2.shape``, they must be broadcastable to a common\n    shape (which becomes the shape of the output)."
          },
          "out": {
            "type": "ndarray",
            "description": ", None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs."
          },
          "where": {
            "type": "array_like",
            "description": "This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`."
          },
          "y": {
            "type": "ndarray or scalar",
            "description": "The quotient ``x1/x2``, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars."
          },
          "seterr": {
            "type": "Set whether to raise or warn on overflow",
            "description": ", underflow and\n         division by zero."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "union1d",
      "signature": "union1d(ar1, ar2)",
      "documentation": {
        "description": "Union of two arrays.\n\n    The output is always a masked array. See `numpy.union1d` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "numpy.union1d : Equivalent function for ndarrays.",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "unique",
      "signature": "unique(ar1, return_index=False, return_inverse=False)",
      "documentation": {
        "description": "Finds the unique elements of an array.\n\n    Masked values are considered the same element (masked). The output array\n    is always a masked array. See `numpy.unique` for more details.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": ">>> import numpy.ma as ma\n    >>> a = [1, 2, 1000, 2, 3]\n    >>> mask = [0, 0, 1, 0, 0]\n    >>> masked_a = ma.masked_array(a, mask)\n    >>> masked_a\n    masked_array(data=[1, 2, --, 2, 3],\n                mask=[False, False,  True, False, False],\n        fill_value=999999)\n    >>> ma.unique(masked_a)\n    masked_array(data=[1, 2, 3, --],\n                mask=[False, False, False,  True],\n        fill_value=999999)\n    >>> ma.unique(masked_a, return_index=True)\n    (masked_array(data=[1, 2, 3, --],\n                mask=[False, False, False,  True],\n        fill_value=999999), array([0, 1, 4, 2]))\n    >>> ma.unique(masked_a, return_inverse=True)\n    (masked_array(data=[1, 2, 3, --],\n                mask=[False, False, False,  True],\n        fill_value=999999), array([0, 1, 3, 1, 2]))\n    >>> ma.unique(masked_a, return_index=True, return_inverse=True)\n    (masked_array(data=[1, 2, 3, --],\n                mask=[False, False, False,  True],\n        fill_value=999999), array([0, 1, 4, 2]), array([0, 1, 3, 1, 2]))",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "vander",
      "signature": "vander(x, n=None)",
      "documentation": {
        "description": "Generate a Vandermonde matrix.\n\nThe columns of the output matrix are powers of the input vector. The\norder of the powers is determined by the `increasing` boolean argument.\nSpecifically, when `increasing` is False, the `i`-th output column is\nthe input vector raised element-wise to the power of ``N - i - 1``. Such\na matrix with a geometric progression in each row is named for Alexandre-\nTheophile Vandermonde.",
        "parameters": {
          "x": {
            "type": "array_like",
            "description": "1-D input array."
          },
          "N": {
            "type": "int",
            "description": "Number of columns in the output.  If `N` is not specified, a square\n    array is returned (``N = len(x)``)."
          },
          "increasing": {
            "type": "bool",
            "description": "Order of the powers of the columns.  If True, the powers increase\n    from left to right, if False (the default) they are reversed.\n\n    .. versionadded:: 1.9.0"
          },
          "out": {
            "type": "ndarray",
            "description": "Vandermonde matrix.  If `increasing` is False, the first column is\n    ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is\n    True, the columns are ``x^0, x^1, ..., x^(N-1)``."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "var",
      "signature": "var(a, *args, **params)",
      "documentation": {
        "description": "var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)\n\n    Compute the variance along the specified axis.\n\n    Returns the variance of the array elements, a measure of the spread of a\n    distribution.  The variance is computed for the flattened array by\n    default, otherwise over the specified axis.",
        "parameters": {
          "axis": {
            "type": "None or int or tuple of ints",
            "description": "Axis or axes along which the variance is computed.  The default is to\n        compute the variance of the flattened array.\n\n        .. versionadded:: 1.7.0\n\n        If this is a tuple of ints, a variance is performed over multiple axes,\n        instead of a single axis or all the axes as before."
          },
          "dtype": {
            "type": "data-type",
            "description": "Type to use in computing the variance.  For arrays of integer type\n        the default is `float64`; for arrays of float types it is the same as\n        the array type."
          },
          "out": {
            "type": "ndarray",
            "description": "Alternate output array in which to place the result.  It must have\n        the same shape as the expected output, but the type is cast if\n        necessary."
          },
          "ddof": {
            "type": "int",
            "description": "\"Delta Degrees of Freedom\": the divisor used in the calculation is\n        ``N - ddof``, where ``N`` represents the number of elements. By\n        default `ddof` is zero."
          },
          "keepdims": {
            "type": "bool",
            "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `var` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised."
          },
          "where": {
            "type": "array_like of bool",
            "description": "Elements to include in the variance. See `~numpy.ufunc.reduce` for\n        details.\n\n        .. versionadded:: 1.20.0"
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "vstack",
      "signature": "vstack(x, *args, **params)",
      "documentation": {
        "description": "vstack\n\nStack arrays in sequence vertically (row wise).\n\nThis is equivalent to concatenation along the first axis after 1-D arrays\nof shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by\n`vsplit`.\n\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.\n\n``np.row_stack`` is an alias for `vstack`. They are the same function.",
        "parameters": {
          "tup": {
            "type": "sequence of ndarrays",
            "description": "The arrays must have the same shape along all but the first axis.\n    1-D arrays must have the same length."
          },
          "dtype": {
            "type": "str or dtype",
            "description": "If provided, the destination array will have this dtype. Cannot be\n    provided together with `out`.\n\n.. versionadded:: 1.24"
          },
          "casting": {
            "type": "{'no'",
            "description": ", 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n    Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n.. versionadded:: 1.24"
          },
          "stacked": {
            "type": "ndarray",
            "description": "The array formed by stacking the given arrays, will be at least 2-D."
          },
          "concatenate": {
            "type": "Join a sequence of arrays along an existing axis.",
            "description": ""
          },
          "stack": {
            "type": "Join a sequence of arrays along a new axis.",
            "description": ""
          },
          "block": {
            "type": "Assemble an nd-array from nested lists of blocks.",
            "description": ""
          },
          "hstack": {
            "type": "Stack arrays in sequence horizontally (column wise).",
            "description": ""
          },
          "dstack": {
            "type": "Stack arrays in sequence depth wise (along third axis).",
            "description": ""
          },
          "column_stack": {
            "type": "Stack 1-D arrays as columns into a 2-D array.",
            "description": ""
          },
          "vsplit": {
            "type": "Split an array into multiple sub-arrays vertically (row-wise).",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    },
    {
      "name": "where",
      "signature": "where(condition, x=<no value>, y=<no value>)",
      "documentation": {
        "description": "Return a masked array with elements from `x` or `y`, depending on condition.\n\n    .. note::\n        When only `condition` is provided, this function is identical to\n        `nonzero`. The rest of this documentation covers only the case where\n        all three arguments are provided.",
        "parameters": {
          "nonzero": {
            "type": "The function that is called when x and y are omitted",
            "description": ""
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      }
    }
  ],
  "classes": [
    {
      "name": "MAError",
      "documentation": {
        "description": "Class for masked array related errors.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(note)",
          "documentation": {
            "description": "Exception.add_note(note) --\n    add a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(tb)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\n    set self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "MaskError",
      "documentation": {
        "description": "Class for mask related errors.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "add_note",
          "signature": "add_note(note)",
          "documentation": {
            "description": "Exception.add_note(note) --\n    add a note to the exception",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "with_traceback",
          "signature": "with_traceback(tb)",
          "documentation": {
            "description": "Exception.with_traceback(tb) --\n    set self.__traceback__ to tb and return self.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "MaskType",
      "documentation": {
        "description": "Boolean type (True or False), stored as a byte.\n\n    .. warning::\n\n       The :class:`bool_` type is not a subclass of the :class:`int_` type\n       (the :class:`bool_` is not even a number type). This is different\n       than Python's default implementation of :class:`bool` as a\n       sub-class of :class:`int`.\n\n    :Character code: ``'?'``",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\n\n    Return a new `dtype` with a different byte order.\n\n    Changes are also made in all fields and sub-arrays of the data type.\n\n    The `new_order` code can be any from the following:\n\n    * 'S' - swap dtype from current to opposite endian\n    * {'<', 'little'} - little endian\n    * {'>', 'big'} - big endian\n    * {'=', 'native'} - native order\n    * {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "MaskedArray",
      "documentation": {
        "description": "An array class with possibly masked values.\n\n    Masked values of True exclude the corresponding element from any\n    computation.\n\n    Construction::\n\n      x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\n                      ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\n                      shrink=True, order=None)",
        "parameters": {
          "mask": {
            "type": "sequence",
            "description": "Mask. Must be convertible to an array of booleans with the same\n        shape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "dtype": {
            "type": "dtype",
            "description": "Data type of the output.\n        If `dtype` is None, the type of the data argument (``data.dtype``)\n        is used. If `dtype` is not None and different from ``data.dtype``,\n        a copy is performed."
          },
          "copy": {
            "type": "bool",
            "description": "Whether to copy the input data (True), or to use a reference instead.\n        Default is False."
          },
          "subok": {
            "type": "bool",
            "description": "Whether to return a subclass of `MaskedArray` if possible (True) or a\n        plain `MaskedArray`. Default is True."
          },
          "ndmin": {
            "type": "int",
            "description": "Minimum number of dimensions. Default is 0."
          },
          "fill_value": {
            "type": "scalar",
            "description": "Value used to fill in the masked values when necessary.\n        If None, a default based on the data-type is used."
          },
          "keep_mask": {
            "type": "bool",
            "description": "Whether to combine `mask` with the mask of the input data, if any\n        (True), or to use only `mask` for the output (False). Default is True."
          },
          "hard_mask": {
            "type": "bool",
            "description": "Whether to use a hard mask or not. With a hard mask, masked values\n        cannot be unmasked. Default is False."
          },
          "shrink": {
            "type": "bool",
            "description": "Whether to force compression of an empty mask. Default is True."
          },
          "order": {
            "type": "{'C'",
            "description": ", 'F', 'A'}, optional\n        Specify the order of the array.  If order is 'C', then the array\n        will be in C-contiguous order (last-index varies the fastest).\n        If order is 'F', then the returned array will be in\n        Fortran-contiguous order (first-index varies the fastest).\n        If order is 'A' (default), then the returned array may be\n        in any order (either C-, Fortran-contiguous, or even discontiguous),\n        unless a copy is required, in which case it will be C-contiguous."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(self, axis=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Returns True if all elements evaluate to True.\n\n        The output array is masked where all the values along the given axis\n        are masked: if the output would have been a scalar and that all the\n        values are masked, then the output is `masked`.\n\n        Refer to `numpy.all` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> np.ma.array([1,2,3]).all()\n        True\n        >>> a = np.ma.array([1,2,3], mask=True)\n        >>> (a.all() is np.ma.masked)\n        True",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "anom",
          "signature": "anom(self, axis=None, dtype=None)",
          "documentation": {
            "description": "Compute the anomalies (deviations from the arithmetic mean)\n        along the given axis.\n\n        Returns an array of anomalies, with the same shape as the input and\n        where the arithmetic mean is computed along the given axis.",
            "parameters": {
              "dtype": {
                "type": "dtype",
                "description": "Type to use in computing the variance. For arrays of integer type\n             the default is float32; for arrays of float types it is the same as\n             the array type."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(self, axis=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Returns True if any of the elements of `a` evaluate to True.\n\n        Masked values are considered as False during computation.\n\n        Refer to `numpy.any` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.any : corresponding function for ndarrays\n        numpy.any : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "documentation": {
            "description": "Returns array of indices of the maximum values along the given axis.\n        Masked values are treated as if they had the value fill_value.",
            "parameters": {
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values.  If None, the output of\n            maximum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None",
                "description": ", array}, optional\n            Array into which the result can be placed. Its type is preserved\n            and it must be of the right shape to hold the output."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "documentation": {
            "description": "Return array of indices to the minimum values along the given axis.",
            "parameters": {
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values.  If None, the output of\n            minimum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None",
                "description": ", array}, optional\n            Array into which the result can be placed. Its type is preserved\n            and it must be of the right shape to hold the output."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argpartition",
          "signature": "argpartition(self, *args, **kwargs)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(self, axis=<no value>, kind=None, order=None, endwith=True, fill_value=None)",
          "documentation": {
            "description": "Return an ndarray of indices that sort the array along the\n        specified axis.  Masked values are filled beforehand to\n        `fill_value`.",
            "parameters": {
              "kind": {
                "type": "{'quicksort'",
                "description": ", 'mergesort', 'heapsort', 'stable'}, optional\n            The sorting algorithm used."
              },
              "order": {
                "type": "list",
                "description": "When `a` is an array with fields defined, this argument specifies\n            which fields to compare first, second, etc.  Not all fields need be\n            specified."
              },
              "endwith": {
                "type": "{True",
                "description": ", False}, optional\n            Whether missing values (if any) should be treated as the largest values\n            (True) or the smallest values (False)\n            When the array contains unmasked values at the same extremes of the\n            datatype, the ordering of these values and the masked values is\n            undefined."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used internally for the masked values.\n            If ``fill_value`` is not None, it supersedes ``endwith``."
              },
              "lexsort": {
                "type": "Indirect stable sort with multiple keys.",
                "description": "numpy.ndarray.sort : Inplace sort."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(dtype, order='K', casting='unsafe', subok=True, copy=True)",
          "documentation": {
            "description": "a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\n\n    Copy of the array, cast to a specified type.",
            "parameters": {
              "order": {
                "type": "{'C'",
                "description": ", 'F', 'A', 'K'}, optional\n        Controls the memory layout order of the result.\n        'C' means C order, 'F' means Fortran order, 'A'\n        means 'F' order if all the arrays are Fortran contiguous,\n        'C' order otherwise, and 'K' means as close to the\n        order the array elements appear in memory as possible.\n        Default is 'K'."
              },
              "casting": {
                "type": "{'no'",
                "description": ", 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur. Defaults to 'unsafe'\n        for backwards compatibility.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n          * 'unsafe' means any data conversions may be done."
              },
              "subok": {
                "type": "bool",
                "description": "If True, then sub-classes will be passed-through (default), otherwise\n        the returned array will be forced to be a base-class array."
              },
              "copy": {
                "type": "bool",
                "description": "By default, astype always returns a newly allocated array. If this\n        is set to false, and the `dtype`, `order`, and `subok`\n        requirements are satisfied, the input array is returned instead\n        of a copy."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(inplace=False)",
          "documentation": {
            "description": "a.byteswap(inplace=False)\n\n    Swap the bytes of the array elements\n\n    Toggle between low-endian and big-endian data representation by\n    returning a byteswapped array, optionally swapped in-place.\n    Arrays of byte-strings are not swapped. The real and imaginary\n    parts of a complex number are swapped individually.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(choices, out=None, mode='raise')",
          "documentation": {
            "description": "a.choose(choices, out=None, mode='raise')\n\n    Use an index array to construct a new array from a set of choices.\n\n    Refer to `numpy.choose` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.choose : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(min=None, max=None, out=None, **kwargs)",
          "documentation": {
            "description": "a.clip(min=None, max=None, out=None, **kwargs)\n\n    Return an array whose values are limited to ``[min, max]``.\n    One of max or min must be given.\n\n    Refer to `numpy.clip` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.clip : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(self, condition, axis=None, out=None)",
          "documentation": {
            "description": "Return `a` where condition is ``True``.\n\n        If condition is a `~ma.MaskedArray`, missing values are considered\n        as ``False``.",
            "parameters": {
              "axis": {
                "type": "{None",
                "description": ", int}, optional\n            Axis along which the operation must be performed."
              },
              "out": {
                "type": "{None",
                "description": ", ndarray}, optional\n            Alternative output array in which to place the result. It must have\n            the same shape as the expected output but the type will be cast if\n            necessary."
              },
              "A": {
                "type": "class:`~ma.MaskedArray` object.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compressed",
          "signature": "compressed(self)",
          "documentation": {
            "description": "Return all the non-masked data as a 1-D array.",
            "parameters": {},
            "returns": ">>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n        >>> x.compressed()\n        array([0, 1])\n        >>> type(x.compressed())\n        <class 'numpy.ndarray'>",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj()",
          "documentation": {
            "description": "a.conj()\n\n    Complex-conjugate all elements.\n\n    Refer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate()",
          "documentation": {
            "description": "a.conjugate()\n\n    Return the complex conjugate, element-wise.\n\n    Refer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(self, *args, **params)",
          "documentation": {
            "description": "a.copy(order='C')\n\n    Return a copy of the array.",
            "parameters": {
              "function": {
                "type": "func:`numpy.copy` is similar",
                "description": ", but it defaults to using order 'K',\n    and will not pass sub-classes through by default."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "count",
          "signature": "count(self, axis=None, keepdims=<no value>)",
          "documentation": {
            "description": "Count the non-masked elements of the array along the given axis.",
            "parameters": {
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(self, axis=None, dtype=None, out=None)",
          "documentation": {
            "description": "Return the cumulative product of the array elements over the given axis.\n\n        Masked values are set to 1 internally during the computation.\n        However, their position is saved, and the result will be masked at\n        the same locations.\n\n        Refer to `numpy.cumprod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "numpy.ndarray.cumprod : corresponding function for ndarrays\n        numpy.cumprod : equivalent function",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(self, axis=None, dtype=None, out=None)",
          "documentation": {
            "description": "Return the cumulative sum of the array elements over the given axis.\n\n        Masked values are set to 0 internally during the computation.\n        However, their position is saved, and the result will be masked at\n        the same locations.\n\n        Refer to `numpy.cumsum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": ">>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n        >>> marr.cumsum()\n        masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n                     mask=[False, False, False,  True,  True,  True, False, False,\n                           False, False],\n               fill_value=999999)",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(self, *args, **params)",
          "documentation": {
            "description": "a.diagonal(offset=0, axis1=0, axis2=1)\n\n    Return specified diagonals. In NumPy 1.9 the returned array is a\n    read-only view instead of a copy as in previous NumPy versions.  In\n    a future version the read-only restriction will be removed.\n\n    Refer to :func:`numpy.diagonal` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.diagonal : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dot",
          "signature": "dot(self, b, out=None, strict=False)",
          "documentation": {
            "description": "a.dot(b, out=None)\n\n        Masked dot product of two arrays. Note that `out` and `strict` are\n        located in different positions than in `ma.dot`. In order to\n        maintain compatibility with the functional version, it is\n        recommended that the optional arguments be treated as keyword only.\n        At some point that may be mandatory.\n\n        .. versionadded:: 1.10.0",
            "parameters": {
              "out": {
                "type": "masked_array",
                "description": "Output argument. This must have the exact kind that would be\n            returned if it was not used. In particular, it must have the\n            right type, must be C-contiguous, and its dtype must be the\n            dtype that would be returned for `ma.dot(a,b)`. This is a\n            performance feature. Therefore, if these conditions are not\n            met, an exception is raised, instead of attempting to be\n            flexible."
              },
              "strict": {
                "type": "bool",
                "description": "Whether masked data are propagated (True) or set to 0 (False)\n            for the computation. Default is False.  Propagating the mask\n            means that if a masked value appears in a row or column, the\n            whole row or column is considered masked.\n\n            .. versionadded:: 1.10.2"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(file)",
          "documentation": {
            "description": "a.dump(file)\n\n    Dump a pickle of the array to the specified file.\n    The array can be read back with pickle.load or numpy.load.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps()",
          "documentation": {
            "description": "a.dumps()\n\n    Returns the pickle of the array as a string.\n    pickle.loads will convert the string back to an array.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(value)",
          "documentation": {
            "description": "a.fill(value)\n\n    Fill the array with a scalar value.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "filled",
          "signature": "filled(self, fill_value=None)",
          "documentation": {
            "description": "Return a copy of self, with masked values filled with a given value.\n        **However**, if there are no masked values to fill, self will be\n        returned instead as an ndarray.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(self, *args, **params)",
          "documentation": {
            "description": "a.flatten(order='C')\n\n    Return a copy of the array collapsed into one dimension.",
            "parameters": {
              "flat": {
                "type": "A 1-D flat iterator over the array.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_fill_value",
          "signature": "fill_value(self)",
          "documentation": {
            "description": "The filling value of the masked array is a scalar. When setting, None\n        will set to a default based on the data type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> for dt in [np.int32, np.int64, np.float64, np.complex128]:\n        ...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n        ...\n        999999\n        999999\n        1e+20\n        (1e+20+0j)\n\n        >>> x = np.ma.array([0, 1.], fill_value=-np.inf)\n        >>> x.fill_value\n        -inf\n        >>> x.fill_value = np.pi\n        >>> x.fill_value\n        3.1415926535897931 # may vary\n\n        Reset to default:\n\n        >>> x.fill_value = None\n        >>> x.fill_value\n        1e+20"
          }
        },
        {
          "name": "get_imag",
          "signature": "imag(self)",
          "documentation": {
            "description": "The imaginary part of the masked array.\n\n        This property is a view on the imaginary part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n        >>> x.imag\n        masked_array(data=[1.0, --, 1.6],\n                     mask=[False,  True, False],\n               fill_value=1e+20)",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_real",
          "signature": "real(self)",
          "documentation": {
            "description": "The real part of the masked array.\n\n        This property is a view on the real part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n        >>> x.real\n        masked_array(data=[1.0, --, 3.45],\n                     mask=[False,  True, False],\n               fill_value=1e+20)",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(dtype, offset=0)",
          "documentation": {
            "description": "a.getfield(dtype, offset=0)\n\n    Returns a field of the given array as a certain type.\n\n    A field is a view of the array data with a given data-type. The values in\n    the view are determined by the given type and the offset into the current\n    array in bytes. The offset needs to be such that the view dtype fits in the\n    array dtype; for example an array of dtype complex128 has 16-byte elements.\n    If taking a view with a 32-bit integer (4 bytes), the offset needs to be\n    between 0 and 12 bytes.",
            "parameters": {
              "offset": {
                "type": "int",
                "description": "Number of bytes to skip before beginning the element view."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "harden_mask",
          "signature": "harden_mask(self)",
          "documentation": {
            "description": "Force the mask to hard, preventing unmasking by assignment.\n\n        Whether the mask of a masked array is hard or soft is determined by\n        its `~ma.MaskedArray.hardmask` property. `harden_mask` sets\n        `~ma.MaskedArray.hardmask` to ``True`` (and returns the modified\n        self).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "ma.MaskedArray.hardmask\n        ma.MaskedArray.soften_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ids",
          "signature": "ids(self)",
          "documentation": {
            "description": "Return the addresses of the data and mask areas.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "iscontiguous",
          "signature": "iscontiguous(self)",
          "documentation": {
            "description": "Return a boolean indicating whether the data is contiguous.",
            "parameters": {
              "C_CONTIGUOUS": {
                "type": "True",
                "description": ""
              },
              "F_CONTIGUOUS": {
                "type": "True",
                "description": ""
              },
              "OWNDATA": {
                "type": "False",
                "description": ""
              },
              "WRITEABLE": {
                "type": "True",
                "description": ""
              },
              "ALIGNED": {
                "type": "True",
                "description": ""
              },
              "WRITEBACKIFCOPY": {
                "type": "False",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(*args)",
          "documentation": {
            "description": "a.item(*args)\n\n    Copy an element of an array to a standard Python scalar and return it.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(*args)",
          "documentation": {
            "description": "a.itemset(*args)\n\n    Insert scalar into an array (scalar is cast to array's dtype, if possible)\n\n    There must be at least 1 argument, and define the last argument\n    as *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster\n    than ``a[args] = item``.  The item should be a scalar value and `args`\n    must select a single item in the array `a`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the maximum along a given axis.",
            "parameters": {
              "out": {
                "type": "array_like",
                "description": "Alternative output array in which to place the result.  Must\n            be of the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values.\n            If None, use the output of maximum_fill_value()."
              },
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Returns the average of the array elements along given axis.\n\n        Masked entries are ignored, and result elements which are not\n        finite will be masked.\n\n        Refer to `numpy.mean` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> a = np.ma.array([1,2,3], mask=[False, False, True])\n        >>> a\n        masked_array(data=[1, 2, --],\n                     mask=[False, False,  True],\n               fill_value=999999)\n        >>> a.mean()\n        1.5",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the minimum along a given axis.",
            "parameters": {
              "out": {
                "type": "array_like",
                "description": "Alternative output array in which to place the result.  Must be of\n            the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values.\n            If None, use the output of `minimum_fill_value`."
              },
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "arr.newbyteorder(new_order='S', /)\n\n    Return the array with the same data viewed with a different byte order.\n\n    Equivalent to::\n\n        arr.view(arr.dtype.newbytorder(new_order))\n\n    Changes are also made in all fields and sub-arrays of the array data\n    type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(self)",
          "documentation": {
            "description": "Return the indices of unmasked elements that are not zero.\n\n        Returns a tuple of arrays, one for each dimension, containing the\n        indices of the non-zero elements in that dimension. The corresponding\n        non-zero values can be obtained with::\n\n            a[a.nonzero()]\n\n        To group the indices by element, rather than dimension, use\n        instead::\n\n            np.transpose(a.nonzero())\n\n        The result of this is always a 2d array, with a row for each non-zero\n        element.",
            "parameters": {
              "flatnonzero": {
                "type": "Return indices that are non-zero in the flattened version of the input",
                "description": "array.\n        numpy.ndarray.nonzero :\n            Equivalent ndarray method."
              },
              "count_nonzero": {
                "type": "Counts the number of non-zero elements in the input array.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "partition",
          "signature": "partition(self, *args, **kwargs)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the product of the array elements over the given axis.\n\n        Masked elements are set to 1 internally for computation.\n\n        Refer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "numpy.ndarray.prod : corresponding function for ndarrays\n        numpy.prod : equivalent function",
            "examples": ""
          }
        },
        {
          "name": "product",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the product of the array elements over the given axis.\n\n        Masked elements are set to 1 internally for computation.\n\n        Refer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "numpy.ndarray.prod : corresponding function for ndarrays\n        numpy.prod : equivalent function",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(self, axis=None, out=None, fill_value=None, keepdims=False)",
          "documentation": {
            "description": "Return (maximum - minimum) along the given dimension\n        (i.e. peak-to-peak value).\n\n        .. warning::\n            `ptp` preserves the data type of the array. This means the\n            return value for an input of signed integers with n bits\n            (e.g. `np.int8`, `np.int16`, etc) is also a signed integer\n            with n bits.  In that case, peak-to-peak values greater than\n            ``2**(n-1)-1`` will be returned as negative values. An example\n            with a work-around is shown below.",
            "parameters": {
              "out": {
                "type": "{None",
                "description": ", array_like}, optional\n            Alternative output array in which to place the result. It must\n            have the same shape and buffer length as the expected output\n            but the type will be cast if necessary."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values."
              },
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(self, indices, values, mode='raise')",
          "documentation": {
            "description": "Set storage-indexed locations to corresponding values.\n\n        Sets self._data.flat[n] = values[n] for each n in indices.\n        If `values` is shorter than `indices` then it will repeat.\n        If `values` has some masked values, the initial mask is updated\n        in consequence, else the corresponding values are unmasked.",
            "parameters": {
              "values": {
                "type": "array_like",
                "description": "Values to place in self._data copy at target indices."
              },
              "mode": {
                "type": "{'raise'",
                "description": ", 'wrap', 'clip'}, optional\n            Specifies how out-of-bounds indices will behave.\n            'raise' : raise an error.\n            'wrap' : wrap around.\n            'clip' : clip to the range."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(self, order='C')",
          "documentation": {
            "description": "Returns a 1D version of self, as a view.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(self, *args, **params)",
          "documentation": {
            "description": "a.repeat(repeats, axis=None)\n\n    Repeat elements of an array.\n\n    Refer to `numpy.repeat` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.repeat : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(self, *s, **kwargs)",
          "documentation": {
            "description": "Give a new shape to the array without changing its data.\n\n        Returns a masked array containing the same data, but with a new shape.\n        The result is a view on the original array; if this is not possible, a\n        ValueError is raised.",
            "parameters": {
              "order": {
                "type": "{'C'",
                "description": ", 'F'}, optional\n            Determines whether the array data should be viewed as in C\n            (row-major) or FORTRAN (column-major) order."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(self, newshape, refcheck=True, order=False)",
          "documentation": {
            "description": ".. warning::\n\n            This method does nothing, except raise a ValueError exception. A\n            masked array does not own its data and therefore cannot safely be\n            resized in place. Use the `numpy.ma.resize` function instead.\n\n        This method is difficult to implement safely and may be deprecated in\n        future releases of NumPy.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(self, decimals=0, out=None)",
          "documentation": {
            "description": "Return each element rounded to the given number of decimals.\n\n        Refer to `numpy.around` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.round : corresponding function for ndarrays\n        numpy.around : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(v, side='left', sorter=None)",
          "documentation": {
            "description": "a.searchsorted(v, side='left', sorter=None)\n\n    Find indices where elements of v should be inserted in a to maintain order.\n\n    For full documentation, see `numpy.searchsorted`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.searchsorted : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_fill_value",
          "signature": "fill_value(self, value=None)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(val, dtype, offset=0)",
          "documentation": {
            "description": "a.setfield(val, dtype, offset=0)\n\n    Put a value into a specified place in a field defined by a data-type.\n\n    Place `val` into `a`'s field defined by `dtype` and beginning `offset`\n    bytes into the field.",
            "parameters": {
              "dtype": {
                "type": "dtype object",
                "description": "Data-type of the field in which to place `val`."
              },
              "offset": {
                "type": "int",
                "description": "The number of bytes into the field at which to place `val`."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(write=None, align=None, uic=None)",
          "documentation": {
            "description": "a.setflags(write=None, align=None, uic=None)\n\n    Set array flags WRITEABLE, ALIGNED, WRITEBACKIFCOPY,\n    respectively.\n\n    These Boolean-valued flags affect how numpy interprets the memory\n    area used by `a` (see Notes below). The ALIGNED flag can only\n    be set to True if the data is actually aligned according to the type.\n    The WRITEBACKIFCOPY and flag can never be set\n    to True. The flag WRITEABLE can only be set to True if the array owns its\n    own memory, or the ultimate owner of the memory exposes a writeable buffer\n    interface, or is a string. (The exception for string is made so that\n    unpickling can be done without copying memory.)",
            "parameters": {
              "align": {
                "type": "bool",
                "description": "Describes whether or not `a` is aligned properly for its type."
              },
              "uic": {
                "type": "bool",
                "description": "Describes whether or not `a` is a copy of another \"base\" array."
              },
              "C_CONTIGUOUS": {
                "type": "True",
                "description": ""
              },
              "F_CONTIGUOUS": {
                "type": "False",
                "description": ""
              },
              "OWNDATA": {
                "type": "True",
                "description": ""
              },
              "WRITEABLE": {
                "type": "False",
                "description": ""
              },
              "ALIGNED": {
                "type": "False",
                "description": ""
              },
              "WRITEBACKIFCOPY": {
                "type": "False",
                "description": ">>> y.setflags(uic=1)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>"
              },
              "ValueError": {
                "type": "cannot set WRITEBACKIFCOPY flag to True",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "shrink_mask",
          "signature": "shrink_mask(self)",
          "documentation": {
            "description": "Reduce a mask to nomask when possible.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "soften_mask",
          "signature": "soften_mask(self)",
          "documentation": {
            "description": "Force the mask to soft (default), allowing unmasking by assignment.\n\n        Whether the mask of a masked array is hard or soft is determined by\n        its `~ma.MaskedArray.hardmask` property. `soften_mask` sets\n        `~ma.MaskedArray.hardmask` to ``False`` (and returns the modified\n        self).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "ma.MaskedArray.hardmask\n        ma.MaskedArray.harden_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(self, axis=-1, kind=None, order=None, endwith=True, fill_value=None)",
          "documentation": {
            "description": "Sort the array, in-place",
            "parameters": {
              "axis": {
                "type": "int",
                "description": "Axis along which to sort. If None, the array is flattened before\n            sorting. The default is -1, which sorts along the last axis."
              },
              "kind": {
                "type": "{'quicksort'",
                "description": ", 'mergesort', 'heapsort', 'stable'}, optional\n            The sorting algorithm used."
              },
              "order": {
                "type": "list",
                "description": "When `a` is a structured array, this argument specifies which fields\n            to compare first, second, and so on.  This list does not need to\n            include all of the fields."
              },
              "endwith": {
                "type": "{True",
                "description": ", False}, optional\n            Whether missing values (if any) should be treated as the largest values\n            (True) or the smallest values (False)\n            When the array contains unmasked values sorting at the same extremes of the\n            datatype, the ordering of these values and the masked values is\n            undefined."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used internally for the masked values.\n            If ``fill_value`` is not None, it supersedes ``endwith``."
              },
              "argsort": {
                "type": "Indirect sort.",
                "description": ""
              },
              "lexsort": {
                "type": "Indirect stable sort on multiple keys.",
                "description": ""
              },
              "searchsorted": {
                "type": "Find elements in a sorted array.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(self, *args, **params)",
          "documentation": {
            "description": "a.squeeze(axis=None)\n\n    Remove axes of length one from `a`.\n\n    Refer to `numpy.squeeze` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.squeeze : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "documentation": {
            "description": "Returns the standard deviation of the array elements along given axis.\n\n        Masked entries are ignored.\n\n        Refer to `numpy.std` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.std : corresponding function for ndarrays\n        numpy.std : Equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the sum of the array elements over the given axis.\n\n        Masked elements are set to 0 internally.\n\n        Refer to `numpy.sum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n        >>> x\n        masked_array(\n          data=[[1, --, 3],\n                [--, 5, --],\n                [7, --, 9]],\n          mask=[[False,  True, False],\n                [ True, False,  True],\n                [False,  True, False]],\n          fill_value=999999)\n        >>> x.sum()\n        25\n        >>> x.sum(axis=1)\n        masked_array(data=[4, 5, 16],\n                     mask=[False, False, False],\n               fill_value=999999)\n        >>> x.sum(axis=0)\n        masked_array(data=[8, 5, 12],\n                     mask=[False, False, False],\n               fill_value=999999)\n        >>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n        <class 'numpy.int64'>",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(self, *args, **params)",
          "documentation": {
            "description": "a.swapaxes(axis1, axis2)\n\n    Return a view of the array with `axis1` and `axis2` interchanged.\n\n    Refer to `numpy.swapaxes` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.swapaxes : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(self, indices, axis=None, out=None, mode='raise')",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(self, fill_value=None, order='C')",
          "documentation": {
            "description": "Return the array data as a string containing the raw bytes in the array.\n\n        The array is filled with a fill value before the string conversion.\n\n        .. versionadded:: 1.9.0",
            "parameters": {
              "order": {
                "type": "{'C'",
                "description": ",'F','A'}, optional\n            Order of the data item in the copy. Default is 'C'.\n\n            - 'C'   -- C order (row major).\n            - 'F'   -- Fortran order (column major).\n            - 'A'   -- Any, current order of array.\n            - None  -- Same as 'A'."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(self, fid, sep='', format='%s')",
          "documentation": {
            "description": "Save a masked array to a file in binary format.\n\n        .. warning::\n          This function is not implemented yet.",
            "parameters": {},
            "returns": "",
            "raises": "NotImplementedError\n            When `tofile` is called.",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "toflex",
          "signature": "toflex(self)",
          "documentation": {
            "description": "Transforms a masked array into a flexible-type array.\n\n        The flexible type array that is returned will have two fields:\n\n        * the ``_data`` field stores the ``_data`` part of the array.\n        * the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(self, fill_value=None)",
          "documentation": {
            "description": "Return the data portion of the masked array as a hierarchical Python list.\n\n        Data items are converted to the nearest compatible Python type.\n        Masked values are converted to `fill_value`. If `fill_value` is None,\n        the corresponding entries in the output list will be ``None``.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "torecords",
          "signature": "toflex(self)",
          "documentation": {
            "description": "Transforms a masked array into a flexible-type array.\n\n        The flexible type array that is returned will have two fields:\n\n        * the ``_data`` field stores the ``_data`` part of the array.\n        * the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(self, fill_value=None, order='C')",
          "documentation": {
            "description": "A compatibility alias for `tobytes`, with exactly the same behavior.\n\n        Despite its name, it returns `bytes` not `str`\\ s.\n\n        .. deprecated:: 1.19.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)",
          "documentation": {
            "description": "a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\n\n    Return the sum along diagonals of the array.\n\n    Refer to `numpy.trace` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.trace : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(self, *args, **params)",
          "documentation": {
            "description": "a.transpose(*axes)\n\n    Returns a view of the array with axes transposed.\n\n    Refer to `numpy.transpose` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unshare_mask",
          "signature": "unshare_mask(self)",
          "documentation": {
            "description": "Copy the mask and set the `sharedmask` flag to ``False``.\n\n        Whether the mask is shared between masked arrays can be seen from\n        the `sharedmask` property. `unshare_mask` ensures the mask is not\n        shared. A copy of the mask is only made if it was shared.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "sharedmask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "documentation": {
            "description": "Compute the variance along the specified axis.\n\n    Returns the variance of the array elements, a measure of the spread of a\n    distribution.  The variance is computed for the flattened array by\n    default, otherwise over the specified axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints",
                "description": "Axis or axes along which the variance is computed.  The default is to\n        compute the variance of the flattened array.\n\n        .. versionadded:: 1.7.0\n\n        If this is a tuple of ints, a variance is performed over multiple axes,\n        instead of a single axis or all the axes as before."
              },
              "dtype": {
                "type": "data-type",
                "description": "Type to use in computing the variance.  For arrays of integer type\n        the default is `float64`; for arrays of float types it is the same as\n        the array type."
              },
              "out": {
                "type": "ndarray",
                "description": "Alternate output array in which to place the result.  It must have\n        the same shape as the expected output, but the type is cast if\n        necessary."
              },
              "ddof": {
                "type": "int",
                "description": "\"Delta Degrees of Freedom\": the divisor used in the calculation is\n        ``N - ddof``, where ``N`` represents the number of elements. By\n        default `ddof` is zero."
              },
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `var` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised."
              },
              "where": {
                "type": "array_like of bool",
                "description": "Elements to include in the variance. See `~numpy.ufunc.reduce` for\n        details.\n\n        .. versionadded:: 1.20.0"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(self, dtype=None, type=None, fill_value=None)",
          "documentation": {
            "description": "Return a view of the MaskedArray data.",
            "parameters": {
              "type": {
                "type": "Python type",
                "description": "Type of the returned view, either ndarray or a subclass.  The\n            default None results in type preservation."
              },
              "fill_value": {
                "type": "scalar",
                "description": "The value to use for invalid entries (None by default).\n            If None, then this argument is inferred from the passed `dtype`, or\n            in its absence the original array, as discussed in the notes below."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "bool_",
      "documentation": {
        "description": "Boolean type (True or False), stored as a byte.\n\n    .. warning::\n\n       The :class:`bool_` type is not a subclass of the :class:`int_` type\n       (the :class:`bool_` is not even a number type). This is different\n       than Python's default implementation of :class:`bool` as a\n       sub-class of :class:`int`.\n\n    :Character code: ``'?'``",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.all`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.any`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.argmax`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.argmin`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.argsort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.astype`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.byteswap`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.choose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.clip`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.compress`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.conjugate`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.copy`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.cumprod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.cumsum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.diagonal`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.dump`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.dumps`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.fill`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.flatten`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.getfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.item`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.itemset`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.max`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.mean`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.min`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "newbyteorder(new_order='S', /)\n\n    Return a new `dtype` with a different byte order.\n\n    Changes are also made in all fields and sub-arrays of the data type.\n\n    The `new_order` code can be any from the following:\n\n    * 'S' - swap dtype from current to opposite endian\n    * {'<', 'little'} - little endian\n    * {'>', 'big'} - big endian\n    * {'=', 'native'} - native order\n    * {'|', 'I'} - ignore (no change to byte order)",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.nonzero`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.prod`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.ptp`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.put`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.ravel`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.repeat`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.reshape`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.resize`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.round`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.searchsorted`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.setfield`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.setflags`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.sort`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.squeeze`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.std`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.sum`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.swapaxes`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.take`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(...)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.tofile`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.tolist`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.tostring`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.trace`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.transpose`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.var`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(...)",
          "documentation": {
            "description": "Scalar method identical to the corresponding array attribute.\n\n    Please see `ndarray.view`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "masked_array",
      "documentation": {
        "description": "An array class with possibly masked values.\n\n    Masked values of True exclude the corresponding element from any\n    computation.\n\n    Construction::\n\n      x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\n                      ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\n                      shrink=True, order=None)",
        "parameters": {
          "mask": {
            "type": "sequence",
            "description": "Mask. Must be convertible to an array of booleans with the same\n        shape as `data`. True indicates a masked (i.e. invalid) data."
          },
          "dtype": {
            "type": "dtype",
            "description": "Data type of the output.\n        If `dtype` is None, the type of the data argument (``data.dtype``)\n        is used. If `dtype` is not None and different from ``data.dtype``,\n        a copy is performed."
          },
          "copy": {
            "type": "bool",
            "description": "Whether to copy the input data (True), or to use a reference instead.\n        Default is False."
          },
          "subok": {
            "type": "bool",
            "description": "Whether to return a subclass of `MaskedArray` if possible (True) or a\n        plain `MaskedArray`. Default is True."
          },
          "ndmin": {
            "type": "int",
            "description": "Minimum number of dimensions. Default is 0."
          },
          "fill_value": {
            "type": "scalar",
            "description": "Value used to fill in the masked values when necessary.\n        If None, a default based on the data-type is used."
          },
          "keep_mask": {
            "type": "bool",
            "description": "Whether to combine `mask` with the mask of the input data, if any\n        (True), or to use only `mask` for the output (False). Default is True."
          },
          "hard_mask": {
            "type": "bool",
            "description": "Whether to use a hard mask or not. With a hard mask, masked values\n        cannot be unmasked. Default is False."
          },
          "shrink": {
            "type": "bool",
            "description": "Whether to force compression of an empty mask. Default is True."
          },
          "order": {
            "type": "{'C'",
            "description": ", 'F', 'A'}, optional\n        Specify the order of the array.  If order is 'C', then the array\n        will be in C-contiguous order (last-index varies the fastest).\n        If order is 'F', then the returned array will be in\n        Fortran-contiguous order (first-index varies the fastest).\n        If order is 'A' (default), then the returned array may be\n        in any order (either C-, Fortran-contiguous, or even discontiguous),\n        unless a copy is required, in which case it will be C-contiguous."
          }
        },
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(self, axis=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Returns True if all elements evaluate to True.\n\n        The output array is masked where all the values along the given axis\n        are masked: if the output would have been a scalar and that all the\n        values are masked, then the output is `masked`.\n\n        Refer to `numpy.all` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> np.ma.array([1,2,3]).all()\n        True\n        >>> a = np.ma.array([1,2,3], mask=True)\n        >>> (a.all() is np.ma.masked)\n        True",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "anom",
          "signature": "anom(self, axis=None, dtype=None)",
          "documentation": {
            "description": "Compute the anomalies (deviations from the arithmetic mean)\n        along the given axis.\n\n        Returns an array of anomalies, with the same shape as the input and\n        where the arithmetic mean is computed along the given axis.",
            "parameters": {
              "dtype": {
                "type": "dtype",
                "description": "Type to use in computing the variance. For arrays of integer type\n             the default is float32; for arrays of float types it is the same as\n             the array type."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(self, axis=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Returns True if any of the elements of `a` evaluate to True.\n\n        Masked values are considered as False during computation.\n\n        Refer to `numpy.any` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.any : corresponding function for ndarrays\n        numpy.any : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "documentation": {
            "description": "Returns array of indices of the maximum values along the given axis.\n        Masked values are treated as if they had the value fill_value.",
            "parameters": {
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values.  If None, the output of\n            maximum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None",
                "description": ", array}, optional\n            Array into which the result can be placed. Its type is preserved\n            and it must be of the right shape to hold the output."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "documentation": {
            "description": "Return array of indices to the minimum values along the given axis.",
            "parameters": {
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values.  If None, the output of\n            minimum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None",
                "description": ", array}, optional\n            Array into which the result can be placed. Its type is preserved\n            and it must be of the right shape to hold the output."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argpartition",
          "signature": "argpartition(self, *args, **kwargs)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(self, axis=<no value>, kind=None, order=None, endwith=True, fill_value=None)",
          "documentation": {
            "description": "Return an ndarray of indices that sort the array along the\n        specified axis.  Masked values are filled beforehand to\n        `fill_value`.",
            "parameters": {
              "kind": {
                "type": "{'quicksort'",
                "description": ", 'mergesort', 'heapsort', 'stable'}, optional\n            The sorting algorithm used."
              },
              "order": {
                "type": "list",
                "description": "When `a` is an array with fields defined, this argument specifies\n            which fields to compare first, second, etc.  Not all fields need be\n            specified."
              },
              "endwith": {
                "type": "{True",
                "description": ", False}, optional\n            Whether missing values (if any) should be treated as the largest values\n            (True) or the smallest values (False)\n            When the array contains unmasked values at the same extremes of the\n            datatype, the ordering of these values and the masked values is\n            undefined."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used internally for the masked values.\n            If ``fill_value`` is not None, it supersedes ``endwith``."
              },
              "lexsort": {
                "type": "Indirect stable sort with multiple keys.",
                "description": "numpy.ndarray.sort : Inplace sort."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(dtype, order='K', casting='unsafe', subok=True, copy=True)",
          "documentation": {
            "description": "a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\n\n    Copy of the array, cast to a specified type.",
            "parameters": {
              "order": {
                "type": "{'C'",
                "description": ", 'F', 'A', 'K'}, optional\n        Controls the memory layout order of the result.\n        'C' means C order, 'F' means Fortran order, 'A'\n        means 'F' order if all the arrays are Fortran contiguous,\n        'C' order otherwise, and 'K' means as close to the\n        order the array elements appear in memory as possible.\n        Default is 'K'."
              },
              "casting": {
                "type": "{'no'",
                "description": ", 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur. Defaults to 'unsafe'\n        for backwards compatibility.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n          * 'unsafe' means any data conversions may be done."
              },
              "subok": {
                "type": "bool",
                "description": "If True, then sub-classes will be passed-through (default), otherwise\n        the returned array will be forced to be a base-class array."
              },
              "copy": {
                "type": "bool",
                "description": "By default, astype always returns a newly allocated array. If this\n        is set to false, and the `dtype`, `order`, and `subok`\n        requirements are satisfied, the input array is returned instead\n        of a copy."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(inplace=False)",
          "documentation": {
            "description": "a.byteswap(inplace=False)\n\n    Swap the bytes of the array elements\n\n    Toggle between low-endian and big-endian data representation by\n    returning a byteswapped array, optionally swapped in-place.\n    Arrays of byte-strings are not swapped. The real and imaginary\n    parts of a complex number are swapped individually.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(choices, out=None, mode='raise')",
          "documentation": {
            "description": "a.choose(choices, out=None, mode='raise')\n\n    Use an index array to construct a new array from a set of choices.\n\n    Refer to `numpy.choose` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.choose : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(min=None, max=None, out=None, **kwargs)",
          "documentation": {
            "description": "a.clip(min=None, max=None, out=None, **kwargs)\n\n    Return an array whose values are limited to ``[min, max]``.\n    One of max or min must be given.\n\n    Refer to `numpy.clip` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.clip : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(self, condition, axis=None, out=None)",
          "documentation": {
            "description": "Return `a` where condition is ``True``.\n\n        If condition is a `~ma.MaskedArray`, missing values are considered\n        as ``False``.",
            "parameters": {
              "axis": {
                "type": "{None",
                "description": ", int}, optional\n            Axis along which the operation must be performed."
              },
              "out": {
                "type": "{None",
                "description": ", ndarray}, optional\n            Alternative output array in which to place the result. It must have\n            the same shape as the expected output but the type will be cast if\n            necessary."
              },
              "A": {
                "type": "class:`~ma.MaskedArray` object.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compressed",
          "signature": "compressed(self)",
          "documentation": {
            "description": "Return all the non-masked data as a 1-D array.",
            "parameters": {},
            "returns": ">>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n        >>> x.compressed()\n        array([0, 1])\n        >>> type(x.compressed())\n        <class 'numpy.ndarray'>",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj()",
          "documentation": {
            "description": "a.conj()\n\n    Complex-conjugate all elements.\n\n    Refer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate()",
          "documentation": {
            "description": "a.conjugate()\n\n    Return the complex conjugate, element-wise.\n\n    Refer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(self, *args, **params)",
          "documentation": {
            "description": "a.copy(order='C')\n\n    Return a copy of the array.",
            "parameters": {
              "function": {
                "type": "func:`numpy.copy` is similar",
                "description": ", but it defaults to using order 'K',\n    and will not pass sub-classes through by default."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "count",
          "signature": "count(self, axis=None, keepdims=<no value>)",
          "documentation": {
            "description": "Count the non-masked elements of the array along the given axis.",
            "parameters": {
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(self, axis=None, dtype=None, out=None)",
          "documentation": {
            "description": "Return the cumulative product of the array elements over the given axis.\n\n        Masked values are set to 1 internally during the computation.\n        However, their position is saved, and the result will be masked at\n        the same locations.\n\n        Refer to `numpy.cumprod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "numpy.ndarray.cumprod : corresponding function for ndarrays\n        numpy.cumprod : equivalent function",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(self, axis=None, dtype=None, out=None)",
          "documentation": {
            "description": "Return the cumulative sum of the array elements over the given axis.\n\n        Masked values are set to 0 internally during the computation.\n        However, their position is saved, and the result will be masked at\n        the same locations.\n\n        Refer to `numpy.cumsum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": ">>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n        >>> marr.cumsum()\n        masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n                     mask=[False, False, False,  True,  True,  True, False, False,\n                           False, False],\n               fill_value=999999)",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(self, *args, **params)",
          "documentation": {
            "description": "a.diagonal(offset=0, axis1=0, axis2=1)\n\n    Return specified diagonals. In NumPy 1.9 the returned array is a\n    read-only view instead of a copy as in previous NumPy versions.  In\n    a future version the read-only restriction will be removed.\n\n    Refer to :func:`numpy.diagonal` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.diagonal : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dot",
          "signature": "dot(self, b, out=None, strict=False)",
          "documentation": {
            "description": "a.dot(b, out=None)\n\n        Masked dot product of two arrays. Note that `out` and `strict` are\n        located in different positions than in `ma.dot`. In order to\n        maintain compatibility with the functional version, it is\n        recommended that the optional arguments be treated as keyword only.\n        At some point that may be mandatory.\n\n        .. versionadded:: 1.10.0",
            "parameters": {
              "out": {
                "type": "masked_array",
                "description": "Output argument. This must have the exact kind that would be\n            returned if it was not used. In particular, it must have the\n            right type, must be C-contiguous, and its dtype must be the\n            dtype that would be returned for `ma.dot(a,b)`. This is a\n            performance feature. Therefore, if these conditions are not\n            met, an exception is raised, instead of attempting to be\n            flexible."
              },
              "strict": {
                "type": "bool",
                "description": "Whether masked data are propagated (True) or set to 0 (False)\n            for the computation. Default is False.  Propagating the mask\n            means that if a masked value appears in a row or column, the\n            whole row or column is considered masked.\n\n            .. versionadded:: 1.10.2"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(file)",
          "documentation": {
            "description": "a.dump(file)\n\n    Dump a pickle of the array to the specified file.\n    The array can be read back with pickle.load or numpy.load.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps()",
          "documentation": {
            "description": "a.dumps()\n\n    Returns the pickle of the array as a string.\n    pickle.loads will convert the string back to an array.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(value)",
          "documentation": {
            "description": "a.fill(value)\n\n    Fill the array with a scalar value.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "filled",
          "signature": "filled(self, fill_value=None)",
          "documentation": {
            "description": "Return a copy of self, with masked values filled with a given value.\n        **However**, if there are no masked values to fill, self will be\n        returned instead as an ndarray.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(self, *args, **params)",
          "documentation": {
            "description": "a.flatten(order='C')\n\n    Return a copy of the array collapsed into one dimension.",
            "parameters": {
              "flat": {
                "type": "A 1-D flat iterator over the array.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_fill_value",
          "signature": "fill_value(self)",
          "documentation": {
            "description": "The filling value of the masked array is a scalar. When setting, None\n        will set to a default based on the data type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> for dt in [np.int32, np.int64, np.float64, np.complex128]:\n        ...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n        ...\n        999999\n        999999\n        1e+20\n        (1e+20+0j)\n\n        >>> x = np.ma.array([0, 1.], fill_value=-np.inf)\n        >>> x.fill_value\n        -inf\n        >>> x.fill_value = np.pi\n        >>> x.fill_value\n        3.1415926535897931 # may vary\n\n        Reset to default:\n\n        >>> x.fill_value = None\n        >>> x.fill_value\n        1e+20"
          }
        },
        {
          "name": "get_imag",
          "signature": "imag(self)",
          "documentation": {
            "description": "The imaginary part of the masked array.\n\n        This property is a view on the imaginary part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n        >>> x.imag\n        masked_array(data=[1.0, --, 1.6],\n                     mask=[False,  True, False],\n               fill_value=1e+20)",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_real",
          "signature": "real(self)",
          "documentation": {
            "description": "The real part of the masked array.\n\n        This property is a view on the real part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n        >>> x.real\n        masked_array(data=[1.0, --, 3.45],\n                     mask=[False,  True, False],\n               fill_value=1e+20)",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(dtype, offset=0)",
          "documentation": {
            "description": "a.getfield(dtype, offset=0)\n\n    Returns a field of the given array as a certain type.\n\n    A field is a view of the array data with a given data-type. The values in\n    the view are determined by the given type and the offset into the current\n    array in bytes. The offset needs to be such that the view dtype fits in the\n    array dtype; for example an array of dtype complex128 has 16-byte elements.\n    If taking a view with a 32-bit integer (4 bytes), the offset needs to be\n    between 0 and 12 bytes.",
            "parameters": {
              "offset": {
                "type": "int",
                "description": "Number of bytes to skip before beginning the element view."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "harden_mask",
          "signature": "harden_mask(self)",
          "documentation": {
            "description": "Force the mask to hard, preventing unmasking by assignment.\n\n        Whether the mask of a masked array is hard or soft is determined by\n        its `~ma.MaskedArray.hardmask` property. `harden_mask` sets\n        `~ma.MaskedArray.hardmask` to ``True`` (and returns the modified\n        self).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "ma.MaskedArray.hardmask\n        ma.MaskedArray.soften_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ids",
          "signature": "ids(self)",
          "documentation": {
            "description": "Return the addresses of the data and mask areas.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "iscontiguous",
          "signature": "iscontiguous(self)",
          "documentation": {
            "description": "Return a boolean indicating whether the data is contiguous.",
            "parameters": {
              "C_CONTIGUOUS": {
                "type": "True",
                "description": ""
              },
              "F_CONTIGUOUS": {
                "type": "True",
                "description": ""
              },
              "OWNDATA": {
                "type": "False",
                "description": ""
              },
              "WRITEABLE": {
                "type": "True",
                "description": ""
              },
              "ALIGNED": {
                "type": "True",
                "description": ""
              },
              "WRITEBACKIFCOPY": {
                "type": "False",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(*args)",
          "documentation": {
            "description": "a.item(*args)\n\n    Copy an element of an array to a standard Python scalar and return it.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(*args)",
          "documentation": {
            "description": "a.itemset(*args)\n\n    Insert scalar into an array (scalar is cast to array's dtype, if possible)\n\n    There must be at least 1 argument, and define the last argument\n    as *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster\n    than ``a[args] = item``.  The item should be a scalar value and `args`\n    must select a single item in the array `a`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the maximum along a given axis.",
            "parameters": {
              "out": {
                "type": "array_like",
                "description": "Alternative output array in which to place the result.  Must\n            be of the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values.\n            If None, use the output of maximum_fill_value()."
              },
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Returns the average of the array elements along given axis.\n\n        Masked entries are ignored, and result elements which are not\n        finite will be masked.\n\n        Refer to `numpy.mean` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> a = np.ma.array([1,2,3], mask=[False, False, True])\n        >>> a\n        masked_array(data=[1, 2, --],\n                     mask=[False, False,  True],\n               fill_value=999999)\n        >>> a.mean()\n        1.5",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the minimum along a given axis.",
            "parameters": {
              "out": {
                "type": "array_like",
                "description": "Alternative output array in which to place the result.  Must be of\n            the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values.\n            If None, use the output of `minimum_fill_value`."
              },
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "arr.newbyteorder(new_order='S', /)\n\n    Return the array with the same data viewed with a different byte order.\n\n    Equivalent to::\n\n        arr.view(arr.dtype.newbytorder(new_order))\n\n    Changes are also made in all fields and sub-arrays of the array data\n    type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(self)",
          "documentation": {
            "description": "Return the indices of unmasked elements that are not zero.\n\n        Returns a tuple of arrays, one for each dimension, containing the\n        indices of the non-zero elements in that dimension. The corresponding\n        non-zero values can be obtained with::\n\n            a[a.nonzero()]\n\n        To group the indices by element, rather than dimension, use\n        instead::\n\n            np.transpose(a.nonzero())\n\n        The result of this is always a 2d array, with a row for each non-zero\n        element.",
            "parameters": {
              "flatnonzero": {
                "type": "Return indices that are non-zero in the flattened version of the input",
                "description": "array.\n        numpy.ndarray.nonzero :\n            Equivalent ndarray method."
              },
              "count_nonzero": {
                "type": "Counts the number of non-zero elements in the input array.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "partition",
          "signature": "partition(self, *args, **kwargs)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the product of the array elements over the given axis.\n\n        Masked elements are set to 1 internally for computation.\n\n        Refer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "numpy.ndarray.prod : corresponding function for ndarrays\n        numpy.prod : equivalent function",
            "examples": ""
          }
        },
        {
          "name": "product",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the product of the array elements over the given axis.\n\n        Masked elements are set to 1 internally for computation.\n\n        Refer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "numpy.ndarray.prod : corresponding function for ndarrays\n        numpy.prod : equivalent function",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(self, axis=None, out=None, fill_value=None, keepdims=False)",
          "documentation": {
            "description": "Return (maximum - minimum) along the given dimension\n        (i.e. peak-to-peak value).\n\n        .. warning::\n            `ptp` preserves the data type of the array. This means the\n            return value for an input of signed integers with n bits\n            (e.g. `np.int8`, `np.int16`, etc) is also a signed integer\n            with n bits.  In that case, peak-to-peak values greater than\n            ``2**(n-1)-1`` will be returned as negative values. An example\n            with a work-around is shown below.",
            "parameters": {
              "out": {
                "type": "{None",
                "description": ", array_like}, optional\n            Alternative output array in which to place the result. It must\n            have the same shape and buffer length as the expected output\n            but the type will be cast if necessary."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values."
              },
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(self, indices, values, mode='raise')",
          "documentation": {
            "description": "Set storage-indexed locations to corresponding values.\n\n        Sets self._data.flat[n] = values[n] for each n in indices.\n        If `values` is shorter than `indices` then it will repeat.\n        If `values` has some masked values, the initial mask is updated\n        in consequence, else the corresponding values are unmasked.",
            "parameters": {
              "values": {
                "type": "array_like",
                "description": "Values to place in self._data copy at target indices."
              },
              "mode": {
                "type": "{'raise'",
                "description": ", 'wrap', 'clip'}, optional\n            Specifies how out-of-bounds indices will behave.\n            'raise' : raise an error.\n            'wrap' : wrap around.\n            'clip' : clip to the range."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(self, order='C')",
          "documentation": {
            "description": "Returns a 1D version of self, as a view.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(self, *args, **params)",
          "documentation": {
            "description": "a.repeat(repeats, axis=None)\n\n    Repeat elements of an array.\n\n    Refer to `numpy.repeat` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.repeat : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(self, *s, **kwargs)",
          "documentation": {
            "description": "Give a new shape to the array without changing its data.\n\n        Returns a masked array containing the same data, but with a new shape.\n        The result is a view on the original array; if this is not possible, a\n        ValueError is raised.",
            "parameters": {
              "order": {
                "type": "{'C'",
                "description": ", 'F'}, optional\n            Determines whether the array data should be viewed as in C\n            (row-major) or FORTRAN (column-major) order."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(self, newshape, refcheck=True, order=False)",
          "documentation": {
            "description": ".. warning::\n\n            This method does nothing, except raise a ValueError exception. A\n            masked array does not own its data and therefore cannot safely be\n            resized in place. Use the `numpy.ma.resize` function instead.\n\n        This method is difficult to implement safely and may be deprecated in\n        future releases of NumPy.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(self, decimals=0, out=None)",
          "documentation": {
            "description": "Return each element rounded to the given number of decimals.\n\n        Refer to `numpy.around` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.round : corresponding function for ndarrays\n        numpy.around : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(v, side='left', sorter=None)",
          "documentation": {
            "description": "a.searchsorted(v, side='left', sorter=None)\n\n    Find indices where elements of v should be inserted in a to maintain order.\n\n    For full documentation, see `numpy.searchsorted`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.searchsorted : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_fill_value",
          "signature": "fill_value(self, value=None)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(val, dtype, offset=0)",
          "documentation": {
            "description": "a.setfield(val, dtype, offset=0)\n\n    Put a value into a specified place in a field defined by a data-type.\n\n    Place `val` into `a`'s field defined by `dtype` and beginning `offset`\n    bytes into the field.",
            "parameters": {
              "dtype": {
                "type": "dtype object",
                "description": "Data-type of the field in which to place `val`."
              },
              "offset": {
                "type": "int",
                "description": "The number of bytes into the field at which to place `val`."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(write=None, align=None, uic=None)",
          "documentation": {
            "description": "a.setflags(write=None, align=None, uic=None)\n\n    Set array flags WRITEABLE, ALIGNED, WRITEBACKIFCOPY,\n    respectively.\n\n    These Boolean-valued flags affect how numpy interprets the memory\n    area used by `a` (see Notes below). The ALIGNED flag can only\n    be set to True if the data is actually aligned according to the type.\n    The WRITEBACKIFCOPY and flag can never be set\n    to True. The flag WRITEABLE can only be set to True if the array owns its\n    own memory, or the ultimate owner of the memory exposes a writeable buffer\n    interface, or is a string. (The exception for string is made so that\n    unpickling can be done without copying memory.)",
            "parameters": {
              "align": {
                "type": "bool",
                "description": "Describes whether or not `a` is aligned properly for its type."
              },
              "uic": {
                "type": "bool",
                "description": "Describes whether or not `a` is a copy of another \"base\" array."
              },
              "C_CONTIGUOUS": {
                "type": "True",
                "description": ""
              },
              "F_CONTIGUOUS": {
                "type": "False",
                "description": ""
              },
              "OWNDATA": {
                "type": "True",
                "description": ""
              },
              "WRITEABLE": {
                "type": "False",
                "description": ""
              },
              "ALIGNED": {
                "type": "False",
                "description": ""
              },
              "WRITEBACKIFCOPY": {
                "type": "False",
                "description": ">>> y.setflags(uic=1)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>"
              },
              "ValueError": {
                "type": "cannot set WRITEBACKIFCOPY flag to True",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "shrink_mask",
          "signature": "shrink_mask(self)",
          "documentation": {
            "description": "Reduce a mask to nomask when possible.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "soften_mask",
          "signature": "soften_mask(self)",
          "documentation": {
            "description": "Force the mask to soft (default), allowing unmasking by assignment.\n\n        Whether the mask of a masked array is hard or soft is determined by\n        its `~ma.MaskedArray.hardmask` property. `soften_mask` sets\n        `~ma.MaskedArray.hardmask` to ``False`` (and returns the modified\n        self).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "ma.MaskedArray.hardmask\n        ma.MaskedArray.harden_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(self, axis=-1, kind=None, order=None, endwith=True, fill_value=None)",
          "documentation": {
            "description": "Sort the array, in-place",
            "parameters": {
              "axis": {
                "type": "int",
                "description": "Axis along which to sort. If None, the array is flattened before\n            sorting. The default is -1, which sorts along the last axis."
              },
              "kind": {
                "type": "{'quicksort'",
                "description": ", 'mergesort', 'heapsort', 'stable'}, optional\n            The sorting algorithm used."
              },
              "order": {
                "type": "list",
                "description": "When `a` is a structured array, this argument specifies which fields\n            to compare first, second, and so on.  This list does not need to\n            include all of the fields."
              },
              "endwith": {
                "type": "{True",
                "description": ", False}, optional\n            Whether missing values (if any) should be treated as the largest values\n            (True) or the smallest values (False)\n            When the array contains unmasked values sorting at the same extremes of the\n            datatype, the ordering of these values and the masked values is\n            undefined."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used internally for the masked values.\n            If ``fill_value`` is not None, it supersedes ``endwith``."
              },
              "argsort": {
                "type": "Indirect sort.",
                "description": ""
              },
              "lexsort": {
                "type": "Indirect stable sort on multiple keys.",
                "description": ""
              },
              "searchsorted": {
                "type": "Find elements in a sorted array.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(self, *args, **params)",
          "documentation": {
            "description": "a.squeeze(axis=None)\n\n    Remove axes of length one from `a`.\n\n    Refer to `numpy.squeeze` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.squeeze : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "documentation": {
            "description": "Returns the standard deviation of the array elements along given axis.\n\n        Masked entries are ignored.\n\n        Refer to `numpy.std` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.std : corresponding function for ndarrays\n        numpy.std : Equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the sum of the array elements over the given axis.\n\n        Masked elements are set to 0 internally.\n\n        Refer to `numpy.sum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n        >>> x\n        masked_array(\n          data=[[1, --, 3],\n                [--, 5, --],\n                [7, --, 9]],\n          mask=[[False,  True, False],\n                [ True, False,  True],\n                [False,  True, False]],\n          fill_value=999999)\n        >>> x.sum()\n        25\n        >>> x.sum(axis=1)\n        masked_array(data=[4, 5, 16],\n                     mask=[False, False, False],\n               fill_value=999999)\n        >>> x.sum(axis=0)\n        masked_array(data=[8, 5, 12],\n                     mask=[False, False, False],\n               fill_value=999999)\n        >>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n        <class 'numpy.int64'>",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(self, *args, **params)",
          "documentation": {
            "description": "a.swapaxes(axis1, axis2)\n\n    Return a view of the array with `axis1` and `axis2` interchanged.\n\n    Refer to `numpy.swapaxes` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.swapaxes : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(self, indices, axis=None, out=None, mode='raise')",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(self, fill_value=None, order='C')",
          "documentation": {
            "description": "Return the array data as a string containing the raw bytes in the array.\n\n        The array is filled with a fill value before the string conversion.\n\n        .. versionadded:: 1.9.0",
            "parameters": {
              "order": {
                "type": "{'C'",
                "description": ",'F','A'}, optional\n            Order of the data item in the copy. Default is 'C'.\n\n            - 'C'   -- C order (row major).\n            - 'F'   -- Fortran order (column major).\n            - 'A'   -- Any, current order of array.\n            - None  -- Same as 'A'."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(self, fid, sep='', format='%s')",
          "documentation": {
            "description": "Save a masked array to a file in binary format.\n\n        .. warning::\n          This function is not implemented yet.",
            "parameters": {},
            "returns": "",
            "raises": "NotImplementedError\n            When `tofile` is called.",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "toflex",
          "signature": "toflex(self)",
          "documentation": {
            "description": "Transforms a masked array into a flexible-type array.\n\n        The flexible type array that is returned will have two fields:\n\n        * the ``_data`` field stores the ``_data`` part of the array.\n        * the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(self, fill_value=None)",
          "documentation": {
            "description": "Return the data portion of the masked array as a hierarchical Python list.\n\n        Data items are converted to the nearest compatible Python type.\n        Masked values are converted to `fill_value`. If `fill_value` is None,\n        the corresponding entries in the output list will be ``None``.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "torecords",
          "signature": "toflex(self)",
          "documentation": {
            "description": "Transforms a masked array into a flexible-type array.\n\n        The flexible type array that is returned will have two fields:\n\n        * the ``_data`` field stores the ``_data`` part of the array.\n        * the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(self, fill_value=None, order='C')",
          "documentation": {
            "description": "A compatibility alias for `tobytes`, with exactly the same behavior.\n\n        Despite its name, it returns `bytes` not `str`\\ s.\n\n        .. deprecated:: 1.19.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)",
          "documentation": {
            "description": "a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\n\n    Return the sum along diagonals of the array.\n\n    Refer to `numpy.trace` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.trace : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(self, *args, **params)",
          "documentation": {
            "description": "a.transpose(*axes)\n\n    Returns a view of the array with axes transposed.\n\n    Refer to `numpy.transpose` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unshare_mask",
          "signature": "unshare_mask(self)",
          "documentation": {
            "description": "Copy the mask and set the `sharedmask` flag to ``False``.\n\n        Whether the mask is shared between masked arrays can be seen from\n        the `sharedmask` property. `unshare_mask` ensures the mask is not\n        shared. A copy of the mask is only made if it was shared.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "sharedmask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "documentation": {
            "description": "Compute the variance along the specified axis.\n\n    Returns the variance of the array elements, a measure of the spread of a\n    distribution.  The variance is computed for the flattened array by\n    default, otherwise over the specified axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints",
                "description": "Axis or axes along which the variance is computed.  The default is to\n        compute the variance of the flattened array.\n\n        .. versionadded:: 1.7.0\n\n        If this is a tuple of ints, a variance is performed over multiple axes,\n        instead of a single axis or all the axes as before."
              },
              "dtype": {
                "type": "data-type",
                "description": "Type to use in computing the variance.  For arrays of integer type\n        the default is `float64`; for arrays of float types it is the same as\n        the array type."
              },
              "out": {
                "type": "ndarray",
                "description": "Alternate output array in which to place the result.  It must have\n        the same shape as the expected output, but the type is cast if\n        necessary."
              },
              "ddof": {
                "type": "int",
                "description": "\"Delta Degrees of Freedom\": the divisor used in the calculation is\n        ``N - ddof``, where ``N`` represents the number of elements. By\n        default `ddof` is zero."
              },
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `var` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised."
              },
              "where": {
                "type": "array_like of bool",
                "description": "Elements to include in the variance. See `~numpy.ufunc.reduce` for\n        details.\n\n        .. versionadded:: 1.20.0"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(self, dtype=None, type=None, fill_value=None)",
          "documentation": {
            "description": "Return a view of the MaskedArray data.",
            "parameters": {
              "type": {
                "type": "Python type",
                "description": "Type of the returned view, either ndarray or a subclass.  The\n            default None results in type preservation."
              },
              "fill_value": {
                "type": "scalar",
                "description": "The value to use for invalid entries (None by default).\n            If None, then this argument is inferred from the passed `dtype`, or\n            in its absence the original array, as discussed in the notes below."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    },
    {
      "name": "mvoid",
      "documentation": {
        "description": "Fake a 'void' object to use for masked array with structured dtypes.",
        "parameters": {},
        "returns": "",
        "raises": "",
        "see_also": "",
        "notes": "",
        "examples": ""
      },
      "methods": [
        {
          "name": "all",
          "signature": "all(self, axis=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Returns True if all elements evaluate to True.\n\n        The output array is masked where all the values along the given axis\n        are masked: if the output would have been a scalar and that all the\n        values are masked, then the output is `masked`.\n\n        Refer to `numpy.all` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> np.ma.array([1,2,3]).all()\n        True\n        >>> a = np.ma.array([1,2,3], mask=True)\n        >>> (a.all() is np.ma.masked)\n        True",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "anom",
          "signature": "anom(self, axis=None, dtype=None)",
          "documentation": {
            "description": "Compute the anomalies (deviations from the arithmetic mean)\n        along the given axis.\n\n        Returns an array of anomalies, with the same shape as the input and\n        where the arithmetic mean is computed along the given axis.",
            "parameters": {
              "dtype": {
                "type": "dtype",
                "description": "Type to use in computing the variance. For arrays of integer type\n             the default is float32; for arrays of float types it is the same as\n             the array type."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "any",
          "signature": "any(self, axis=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Returns True if any of the elements of `a` evaluate to True.\n\n        Masked values are considered as False during computation.\n\n        Refer to `numpy.any` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.any : corresponding function for ndarrays\n        numpy.any : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmax",
          "signature": "argmax(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "documentation": {
            "description": "Returns array of indices of the maximum values along the given axis.\n        Masked values are treated as if they had the value fill_value.",
            "parameters": {
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values.  If None, the output of\n            maximum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None",
                "description": ", array}, optional\n            Array into which the result can be placed. Its type is preserved\n            and it must be of the right shape to hold the output."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argmin",
          "signature": "argmin(self, axis=None, fill_value=None, out=None, *, keepdims=<no value>)",
          "documentation": {
            "description": "Return array of indices to the minimum values along the given axis.",
            "parameters": {
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values.  If None, the output of\n            minimum_fill_value(self._data) is used instead."
              },
              "out": {
                "type": "{None",
                "description": ", array}, optional\n            Array into which the result can be placed. Its type is preserved\n            and it must be of the right shape to hold the output."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argpartition",
          "signature": "argpartition(self, *args, **kwargs)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "argsort",
          "signature": "argsort(self, axis=<no value>, kind=None, order=None, endwith=True, fill_value=None)",
          "documentation": {
            "description": "Return an ndarray of indices that sort the array along the\n        specified axis.  Masked values are filled beforehand to\n        `fill_value`.",
            "parameters": {
              "kind": {
                "type": "{'quicksort'",
                "description": ", 'mergesort', 'heapsort', 'stable'}, optional\n            The sorting algorithm used."
              },
              "order": {
                "type": "list",
                "description": "When `a` is an array with fields defined, this argument specifies\n            which fields to compare first, second, etc.  Not all fields need be\n            specified."
              },
              "endwith": {
                "type": "{True",
                "description": ", False}, optional\n            Whether missing values (if any) should be treated as the largest values\n            (True) or the smallest values (False)\n            When the array contains unmasked values at the same extremes of the\n            datatype, the ordering of these values and the masked values is\n            undefined."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used internally for the masked values.\n            If ``fill_value`` is not None, it supersedes ``endwith``."
              },
              "lexsort": {
                "type": "Indirect stable sort with multiple keys.",
                "description": "numpy.ndarray.sort : Inplace sort."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "astype",
          "signature": "astype(dtype, order='K', casting='unsafe', subok=True, copy=True)",
          "documentation": {
            "description": "a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\n\n    Copy of the array, cast to a specified type.",
            "parameters": {
              "order": {
                "type": "{'C'",
                "description": ", 'F', 'A', 'K'}, optional\n        Controls the memory layout order of the result.\n        'C' means C order, 'F' means Fortran order, 'A'\n        means 'F' order if all the arrays are Fortran contiguous,\n        'C' order otherwise, and 'K' means as close to the\n        order the array elements appear in memory as possible.\n        Default is 'K'."
              },
              "casting": {
                "type": "{'no'",
                "description": ", 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur. Defaults to 'unsafe'\n        for backwards compatibility.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n          * 'unsafe' means any data conversions may be done."
              },
              "subok": {
                "type": "bool",
                "description": "If True, then sub-classes will be passed-through (default), otherwise\n        the returned array will be forced to be a base-class array."
              },
              "copy": {
                "type": "bool",
                "description": "By default, astype always returns a newly allocated array. If this\n        is set to false, and the `dtype`, `order`, and `subok`\n        requirements are satisfied, the input array is returned instead\n        of a copy."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "byteswap",
          "signature": "byteswap(inplace=False)",
          "documentation": {
            "description": "a.byteswap(inplace=False)\n\n    Swap the bytes of the array elements\n\n    Toggle between low-endian and big-endian data representation by\n    returning a byteswapped array, optionally swapped in-place.\n    Arrays of byte-strings are not swapped. The real and imaginary\n    parts of a complex number are swapped individually.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "choose",
          "signature": "choose(choices, out=None, mode='raise')",
          "documentation": {
            "description": "a.choose(choices, out=None, mode='raise')\n\n    Use an index array to construct a new array from a set of choices.\n\n    Refer to `numpy.choose` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.choose : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "clip",
          "signature": "clip(min=None, max=None, out=None, **kwargs)",
          "documentation": {
            "description": "a.clip(min=None, max=None, out=None, **kwargs)\n\n    Return an array whose values are limited to ``[min, max]``.\n    One of max or min must be given.\n\n    Refer to `numpy.clip` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.clip : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compress",
          "signature": "compress(self, condition, axis=None, out=None)",
          "documentation": {
            "description": "Return `a` where condition is ``True``.\n\n        If condition is a `~ma.MaskedArray`, missing values are considered\n        as ``False``.",
            "parameters": {
              "axis": {
                "type": "{None",
                "description": ", int}, optional\n            Axis along which the operation must be performed."
              },
              "out": {
                "type": "{None",
                "description": ", ndarray}, optional\n            Alternative output array in which to place the result. It must have\n            the same shape as the expected output but the type will be cast if\n            necessary."
              },
              "A": {
                "type": "class:`~ma.MaskedArray` object.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "compressed",
          "signature": "compressed(self)",
          "documentation": {
            "description": "Return all the non-masked data as a 1-D array.",
            "parameters": {},
            "returns": ">>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n        >>> x.compressed()\n        array([0, 1])\n        >>> type(x.compressed())\n        <class 'numpy.ndarray'>",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conj",
          "signature": "conj()",
          "documentation": {
            "description": "a.conj()\n\n    Complex-conjugate all elements.\n\n    Refer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "conjugate",
          "signature": "conjugate()",
          "documentation": {
            "description": "a.conjugate()\n\n    Return the complex conjugate, element-wise.\n\n    Refer to `numpy.conjugate` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.conjugate : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "copy",
          "signature": "copy(self, *args, **params)",
          "documentation": {
            "description": "a.copy(order='C')\n\n    Return a copy of the array.",
            "parameters": {
              "function": {
                "type": "func:`numpy.copy` is similar",
                "description": ", but it defaults to using order 'K',\n    and will not pass sub-classes through by default."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "count",
          "signature": "count(self, axis=None, keepdims=<no value>)",
          "documentation": {
            "description": "Count the non-masked elements of the array along the given axis.",
            "parameters": {
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "cumprod",
          "signature": "cumprod(self, axis=None, dtype=None, out=None)",
          "documentation": {
            "description": "Return the cumulative product of the array elements over the given axis.\n\n        Masked values are set to 1 internally during the computation.\n        However, their position is saved, and the result will be masked at\n        the same locations.\n\n        Refer to `numpy.cumprod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "numpy.ndarray.cumprod : corresponding function for ndarrays\n        numpy.cumprod : equivalent function",
            "examples": ""
          }
        },
        {
          "name": "cumsum",
          "signature": "cumsum(self, axis=None, dtype=None, out=None)",
          "documentation": {
            "description": "Return the cumulative sum of the array elements over the given axis.\n\n        Masked values are set to 0 internally during the computation.\n        However, their position is saved, and the result will be masked at\n        the same locations.\n\n        Refer to `numpy.cumsum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": ">>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n        >>> marr.cumsum()\n        masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n                     mask=[False, False, False,  True,  True,  True, False, False,\n                           False, False],\n               fill_value=999999)",
            "examples": ""
          }
        },
        {
          "name": "diagonal",
          "signature": "diagonal(self, *args, **params)",
          "documentation": {
            "description": "a.diagonal(offset=0, axis1=0, axis2=1)\n\n    Return specified diagonals. In NumPy 1.9 the returned array is a\n    read-only view instead of a copy as in previous NumPy versions.  In\n    a future version the read-only restriction will be removed.\n\n    Refer to :func:`numpy.diagonal` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.diagonal : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dot",
          "signature": "dot(self, b, out=None, strict=False)",
          "documentation": {
            "description": "a.dot(b, out=None)\n\n        Masked dot product of two arrays. Note that `out` and `strict` are\n        located in different positions than in `ma.dot`. In order to\n        maintain compatibility with the functional version, it is\n        recommended that the optional arguments be treated as keyword only.\n        At some point that may be mandatory.\n\n        .. versionadded:: 1.10.0",
            "parameters": {
              "out": {
                "type": "masked_array",
                "description": "Output argument. This must have the exact kind that would be\n            returned if it was not used. In particular, it must have the\n            right type, must be C-contiguous, and its dtype must be the\n            dtype that would be returned for `ma.dot(a,b)`. This is a\n            performance feature. Therefore, if these conditions are not\n            met, an exception is raised, instead of attempting to be\n            flexible."
              },
              "strict": {
                "type": "bool",
                "description": "Whether masked data are propagated (True) or set to 0 (False)\n            for the computation. Default is False.  Propagating the mask\n            means that if a masked value appears in a row or column, the\n            whole row or column is considered masked.\n\n            .. versionadded:: 1.10.2"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dump",
          "signature": "dump(file)",
          "documentation": {
            "description": "a.dump(file)\n\n    Dump a pickle of the array to the specified file.\n    The array can be read back with pickle.load or numpy.load.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "dumps",
          "signature": "dumps()",
          "documentation": {
            "description": "a.dumps()\n\n    Returns the pickle of the array as a string.\n    pickle.loads will convert the string back to an array.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "fill",
          "signature": "fill(value)",
          "documentation": {
            "description": "a.fill(value)\n\n    Fill the array with a scalar value.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "filled",
          "signature": "filled(self, fill_value=None)",
          "documentation": {
            "description": "Return a copy with masked fields filled with a given value.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "flatten",
          "signature": "flatten(self, *args, **params)",
          "documentation": {
            "description": "a.flatten(order='C')\n\n    Return a copy of the array collapsed into one dimension.",
            "parameters": {
              "flat": {
                "type": "A 1-D flat iterator over the array.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_fill_value",
          "signature": "fill_value(self)",
          "documentation": {
            "description": "The filling value of the masked array is a scalar. When setting, None\n        will set to a default based on the data type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ">>> for dt in [np.int32, np.int64, np.float64, np.complex128]:\n        ...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n        ...\n        999999\n        999999\n        1e+20\n        (1e+20+0j)\n\n        >>> x = np.ma.array([0, 1.], fill_value=-np.inf)\n        >>> x.fill_value\n        -inf\n        >>> x.fill_value = np.pi\n        >>> x.fill_value\n        3.1415926535897931 # may vary\n\n        Reset to default:\n\n        >>> x.fill_value = None\n        >>> x.fill_value\n        1e+20"
          }
        },
        {
          "name": "get_imag",
          "signature": "imag(self)",
          "documentation": {
            "description": "The imaginary part of the masked array.\n\n        This property is a view on the imaginary part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n        >>> x.imag\n        masked_array(data=[1.0, --, 1.6],\n                     mask=[False,  True, False],\n               fill_value=1e+20)",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "get_real",
          "signature": "real(self)",
          "documentation": {
            "description": "The real part of the masked array.\n\n        This property is a view on the real part of this `MaskedArray`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n        >>> x.real\n        masked_array(data=[1.0, --, 3.45],\n                     mask=[False,  True, False],\n               fill_value=1e+20)",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "getfield",
          "signature": "getfield(dtype, offset=0)",
          "documentation": {
            "description": "a.getfield(dtype, offset=0)\n\n    Returns a field of the given array as a certain type.\n\n    A field is a view of the array data with a given data-type. The values in\n    the view are determined by the given type and the offset into the current\n    array in bytes. The offset needs to be such that the view dtype fits in the\n    array dtype; for example an array of dtype complex128 has 16-byte elements.\n    If taking a view with a 32-bit integer (4 bytes), the offset needs to be\n    between 0 and 12 bytes.",
            "parameters": {
              "offset": {
                "type": "int",
                "description": "Number of bytes to skip before beginning the element view."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "harden_mask",
          "signature": "harden_mask(self)",
          "documentation": {
            "description": "Force the mask to hard, preventing unmasking by assignment.\n\n        Whether the mask of a masked array is hard or soft is determined by\n        its `~ma.MaskedArray.hardmask` property. `harden_mask` sets\n        `~ma.MaskedArray.hardmask` to ``True`` (and returns the modified\n        self).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "ma.MaskedArray.hardmask\n        ma.MaskedArray.soften_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ids",
          "signature": "ids(self)",
          "documentation": {
            "description": "Return the addresses of the data and mask areas.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "iscontiguous",
          "signature": "iscontiguous(self)",
          "documentation": {
            "description": "Return a boolean indicating whether the data is contiguous.",
            "parameters": {
              "C_CONTIGUOUS": {
                "type": "True",
                "description": ""
              },
              "F_CONTIGUOUS": {
                "type": "True",
                "description": ""
              },
              "OWNDATA": {
                "type": "False",
                "description": ""
              },
              "WRITEABLE": {
                "type": "True",
                "description": ""
              },
              "ALIGNED": {
                "type": "True",
                "description": ""
              },
              "WRITEBACKIFCOPY": {
                "type": "False",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "item",
          "signature": "item(*args)",
          "documentation": {
            "description": "a.item(*args)\n\n    Copy an element of an array to a standard Python scalar and return it.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "itemset",
          "signature": "itemset(*args)",
          "documentation": {
            "description": "a.itemset(*args)\n\n    Insert scalar into an array (scalar is cast to array's dtype, if possible)\n\n    There must be at least 1 argument, and define the last argument\n    as *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster\n    than ``a[args] = item``.  The item should be a scalar value and `args`\n    must select a single item in the array `a`.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "max",
          "signature": "max(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the maximum along a given axis.",
            "parameters": {
              "out": {
                "type": "array_like",
                "description": "Alternative output array in which to place the result.  Must\n            be of the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values.\n            If None, use the output of maximum_fill_value()."
              },
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "mean",
          "signature": "mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Returns the average of the array elements along given axis.\n\n        Masked entries are ignored, and result elements which are not\n        finite will be masked.\n\n        Refer to `numpy.mean` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> a = np.ma.array([1,2,3], mask=[False, False, True])\n        >>> a\n        masked_array(data=[1, 2, --],\n                     mask=[False, False,  True],\n               fill_value=999999)\n        >>> a.mean()\n        1.5",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "min",
          "signature": "min(self, axis=None, out=None, fill_value=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the minimum along a given axis.",
            "parameters": {
              "out": {
                "type": "array_like",
                "description": "Alternative output array in which to place the result.  Must be of\n            the same shape and buffer length as the expected output."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values.\n            If None, use the output of `minimum_fill_value`."
              },
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "newbyteorder",
          "signature": "newbyteorder(new_order='S', /)",
          "documentation": {
            "description": "arr.newbyteorder(new_order='S', /)\n\n    Return the array with the same data viewed with a different byte order.\n\n    Equivalent to::\n\n        arr.view(arr.dtype.newbytorder(new_order))\n\n    Changes are also made in all fields and sub-arrays of the array data\n    type.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "nonzero",
          "signature": "nonzero(self)",
          "documentation": {
            "description": "Return the indices of unmasked elements that are not zero.\n\n        Returns a tuple of arrays, one for each dimension, containing the\n        indices of the non-zero elements in that dimension. The corresponding\n        non-zero values can be obtained with::\n\n            a[a.nonzero()]\n\n        To group the indices by element, rather than dimension, use\n        instead::\n\n            np.transpose(a.nonzero())\n\n        The result of this is always a 2d array, with a row for each non-zero\n        element.",
            "parameters": {
              "flatnonzero": {
                "type": "Return indices that are non-zero in the flattened version of the input",
                "description": "array.\n        numpy.ndarray.nonzero :\n            Equivalent ndarray method."
              },
              "count_nonzero": {
                "type": "Counts the number of non-zero elements in the input array.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "partition",
          "signature": "partition(self, *args, **kwargs)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "prod",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the product of the array elements over the given axis.\n\n        Masked elements are set to 1 internally for computation.\n\n        Refer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "numpy.ndarray.prod : corresponding function for ndarrays\n        numpy.prod : equivalent function",
            "examples": ""
          }
        },
        {
          "name": "product",
          "signature": "prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the product of the array elements over the given axis.\n\n        Masked elements are set to 1 internally for computation.\n\n        Refer to `numpy.prod` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "numpy.ndarray.prod : corresponding function for ndarrays\n        numpy.prod : equivalent function",
            "examples": ""
          }
        },
        {
          "name": "ptp",
          "signature": "ptp(self, axis=None, out=None, fill_value=None, keepdims=False)",
          "documentation": {
            "description": "Return (maximum - minimum) along the given dimension\n        (i.e. peak-to-peak value).\n\n        .. warning::\n            `ptp` preserves the data type of the array. This means the\n            return value for an input of signed integers with n bits\n            (e.g. `np.int8`, `np.int16`, etc) is also a signed integer\n            with n bits.  In that case, peak-to-peak values greater than\n            ``2**(n-1)-1`` will be returned as negative values. An example\n            with a work-around is shown below.",
            "parameters": {
              "out": {
                "type": "{None",
                "description": ", array_like}, optional\n            Alternative output array in which to place the result. It must\n            have the same shape and buffer length as the expected output\n            but the type will be cast if necessary."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used to fill in the masked values."
              },
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n            in the result as dimensions with size one. With this option,\n            the result will broadcast correctly against the array."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "put",
          "signature": "put(self, indices, values, mode='raise')",
          "documentation": {
            "description": "Set storage-indexed locations to corresponding values.\n\n        Sets self._data.flat[n] = values[n] for each n in indices.\n        If `values` is shorter than `indices` then it will repeat.\n        If `values` has some masked values, the initial mask is updated\n        in consequence, else the corresponding values are unmasked.",
            "parameters": {
              "values": {
                "type": "array_like",
                "description": "Values to place in self._data copy at target indices."
              },
              "mode": {
                "type": "{'raise'",
                "description": ", 'wrap', 'clip'}, optional\n            Specifies how out-of-bounds indices will behave.\n            'raise' : raise an error.\n            'wrap' : wrap around.\n            'clip' : clip to the range."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "ravel",
          "signature": "ravel(self, order='C')",
          "documentation": {
            "description": "Returns a 1D version of self, as a view.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "repeat",
          "signature": "repeat(self, *args, **params)",
          "documentation": {
            "description": "a.repeat(repeats, axis=None)\n\n    Repeat elements of an array.\n\n    Refer to `numpy.repeat` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.repeat : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "reshape",
          "signature": "reshape(self, *s, **kwargs)",
          "documentation": {
            "description": "Give a new shape to the array without changing its data.\n\n        Returns a masked array containing the same data, but with a new shape.\n        The result is a view on the original array; if this is not possible, a\n        ValueError is raised.",
            "parameters": {
              "order": {
                "type": "{'C'",
                "description": ", 'F'}, optional\n            Determines whether the array data should be viewed as in C\n            (row-major) or FORTRAN (column-major) order."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "resize",
          "signature": "resize(self, newshape, refcheck=True, order=False)",
          "documentation": {
            "description": ".. warning::\n\n            This method does nothing, except raise a ValueError exception. A\n            masked array does not own its data and therefore cannot safely be\n            resized in place. Use the `numpy.ma.resize` function instead.\n\n        This method is difficult to implement safely and may be deprecated in\n        future releases of NumPy.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "round",
          "signature": "round(self, decimals=0, out=None)",
          "documentation": {
            "description": "Return each element rounded to the given number of decimals.\n\n        Refer to `numpy.around` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.round : corresponding function for ndarrays\n        numpy.around : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "searchsorted",
          "signature": "searchsorted(v, side='left', sorter=None)",
          "documentation": {
            "description": "a.searchsorted(v, side='left', sorter=None)\n\n    Find indices where elements of v should be inserted in a to maintain order.\n\n    For full documentation, see `numpy.searchsorted`",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.searchsorted : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "set_fill_value",
          "signature": "fill_value(self, value=None)",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setfield",
          "signature": "setfield(val, dtype, offset=0)",
          "documentation": {
            "description": "a.setfield(val, dtype, offset=0)\n\n    Put a value into a specified place in a field defined by a data-type.\n\n    Place `val` into `a`'s field defined by `dtype` and beginning `offset`\n    bytes into the field.",
            "parameters": {
              "dtype": {
                "type": "dtype object",
                "description": "Data-type of the field in which to place `val`."
              },
              "offset": {
                "type": "int",
                "description": "The number of bytes into the field at which to place `val`."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "setflags",
          "signature": "setflags(write=None, align=None, uic=None)",
          "documentation": {
            "description": "a.setflags(write=None, align=None, uic=None)\n\n    Set array flags WRITEABLE, ALIGNED, WRITEBACKIFCOPY,\n    respectively.\n\n    These Boolean-valued flags affect how numpy interprets the memory\n    area used by `a` (see Notes below). The ALIGNED flag can only\n    be set to True if the data is actually aligned according to the type.\n    The WRITEBACKIFCOPY and flag can never be set\n    to True. The flag WRITEABLE can only be set to True if the array owns its\n    own memory, or the ultimate owner of the memory exposes a writeable buffer\n    interface, or is a string. (The exception for string is made so that\n    unpickling can be done without copying memory.)",
            "parameters": {
              "align": {
                "type": "bool",
                "description": "Describes whether or not `a` is aligned properly for its type."
              },
              "uic": {
                "type": "bool",
                "description": "Describes whether or not `a` is a copy of another \"base\" array."
              },
              "C_CONTIGUOUS": {
                "type": "True",
                "description": ""
              },
              "F_CONTIGUOUS": {
                "type": "False",
                "description": ""
              },
              "OWNDATA": {
                "type": "True",
                "description": ""
              },
              "WRITEABLE": {
                "type": "False",
                "description": ""
              },
              "ALIGNED": {
                "type": "False",
                "description": ""
              },
              "WRITEBACKIFCOPY": {
                "type": "False",
                "description": ">>> y.setflags(uic=1)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>"
              },
              "ValueError": {
                "type": "cannot set WRITEBACKIFCOPY flag to True",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "shrink_mask",
          "signature": "shrink_mask(self)",
          "documentation": {
            "description": "Reduce a mask to nomask when possible.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "soften_mask",
          "signature": "soften_mask(self)",
          "documentation": {
            "description": "Force the mask to soft (default), allowing unmasking by assignment.\n\n        Whether the mask of a masked array is hard or soft is determined by\n        its `~ma.MaskedArray.hardmask` property. `soften_mask` sets\n        `~ma.MaskedArray.hardmask` to ``False`` (and returns the modified\n        self).",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "ma.MaskedArray.hardmask\n        ma.MaskedArray.harden_mask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sort",
          "signature": "sort(self, axis=-1, kind=None, order=None, endwith=True, fill_value=None)",
          "documentation": {
            "description": "Sort the array, in-place",
            "parameters": {
              "axis": {
                "type": "int",
                "description": "Axis along which to sort. If None, the array is flattened before\n            sorting. The default is -1, which sorts along the last axis."
              },
              "kind": {
                "type": "{'quicksort'",
                "description": ", 'mergesort', 'heapsort', 'stable'}, optional\n            The sorting algorithm used."
              },
              "order": {
                "type": "list",
                "description": "When `a` is a structured array, this argument specifies which fields\n            to compare first, second, and so on.  This list does not need to\n            include all of the fields."
              },
              "endwith": {
                "type": "{True",
                "description": ", False}, optional\n            Whether missing values (if any) should be treated as the largest values\n            (True) or the smallest values (False)\n            When the array contains unmasked values sorting at the same extremes of the\n            datatype, the ordering of these values and the masked values is\n            undefined."
              },
              "fill_value": {
                "type": "scalar or None",
                "description": "Value used internally for the masked values.\n            If ``fill_value`` is not None, it supersedes ``endwith``."
              },
              "argsort": {
                "type": "Indirect sort.",
                "description": ""
              },
              "lexsort": {
                "type": "Indirect stable sort on multiple keys.",
                "description": ""
              },
              "searchsorted": {
                "type": "Find elements in a sorted array.",
                "description": ""
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "squeeze",
          "signature": "squeeze(self, *args, **params)",
          "documentation": {
            "description": "a.squeeze(axis=None)\n\n    Remove axes of length one from `a`.\n\n    Refer to `numpy.squeeze` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.squeeze : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "std",
          "signature": "std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "documentation": {
            "description": "Returns the standard deviation of the array elements along given axis.\n\n        Masked entries are ignored.\n\n        Refer to `numpy.std` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.ndarray.std : corresponding function for ndarrays\n        numpy.std : Equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "sum",
          "signature": "sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)",
          "documentation": {
            "description": "Return the sum of the array elements over the given axis.\n\n        Masked elements are set to 0 internally.\n\n        Refer to `numpy.sum` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": ">>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n        >>> x\n        masked_array(\n          data=[[1, --, 3],\n                [--, 5, --],\n                [7, --, 9]],\n          mask=[[False,  True, False],\n                [ True, False,  True],\n                [False,  True, False]],\n          fill_value=999999)\n        >>> x.sum()\n        25\n        >>> x.sum(axis=1)\n        masked_array(data=[4, 5, 16],\n                     mask=[False, False, False],\n               fill_value=999999)\n        >>> x.sum(axis=0)\n        masked_array(data=[8, 5, 12],\n                     mask=[False, False, False],\n               fill_value=999999)\n        >>> print(type(x.sum(axis=0, dtype=np.int64)[0]))\n        <class 'numpy.int64'>",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "swapaxes",
          "signature": "swapaxes(self, *args, **params)",
          "documentation": {
            "description": "a.swapaxes(axis1, axis2)\n\n    Return a view of the array with `axis1` and `axis2` interchanged.\n\n    Refer to `numpy.swapaxes` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.swapaxes : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "take",
          "signature": "take(self, indices, axis=None, out=None, mode='raise')",
          "documentation": {
            "description": "",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tobytes",
          "signature": "tobytes(self, fill_value=None, order='C')",
          "documentation": {
            "description": "Return the array data as a string containing the raw bytes in the array.\n\n        The array is filled with a fill value before the string conversion.\n\n        .. versionadded:: 1.9.0",
            "parameters": {
              "order": {
                "type": "{'C'",
                "description": ",'F','A'}, optional\n            Order of the data item in the copy. Default is 'C'.\n\n            - 'C'   -- C order (row major).\n            - 'F'   -- Fortran order (column major).\n            - 'A'   -- Any, current order of array.\n            - None  -- Same as 'A'."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tofile",
          "signature": "tofile(self, fid, sep='', format='%s')",
          "documentation": {
            "description": "Save a masked array to a file in binary format.\n\n        .. warning::\n          This function is not implemented yet.",
            "parameters": {},
            "returns": "",
            "raises": "NotImplementedError\n            When `tofile` is called.",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "toflex",
          "signature": "toflex(self)",
          "documentation": {
            "description": "Transforms a masked array into a flexible-type array.\n\n        The flexible type array that is returned will have two fields:\n\n        * the ``_data`` field stores the ``_data`` part of the array.\n        * the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tolist",
          "signature": "tolist(self)",
          "documentation": {
            "description": "Transforms the mvoid object into a tuple.\n\n    Masked fields are replaced by None.",
            "parameters": {},
            "returns": "returned_tuple\n        Tuple of fields",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "torecords",
          "signature": "toflex(self)",
          "documentation": {
            "description": "Transforms a masked array into a flexible-type array.\n\n        The flexible type array that is returned will have two fields:\n\n        * the ``_data`` field stores the ``_data`` part of the array.\n        * the ``_mask`` field stores the ``_mask`` part of the array.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "tostring",
          "signature": "tostring(self, fill_value=None, order='C')",
          "documentation": {
            "description": "A compatibility alias for `tobytes`, with exactly the same behavior.\n\n        Despite its name, it returns `bytes` not `str`\\ s.\n\n        .. deprecated:: 1.19.0",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "trace",
          "signature": "trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)",
          "documentation": {
            "description": "a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\n\n    Return the sum along diagonals of the array.\n\n    Refer to `numpy.trace` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "numpy.trace : equivalent function",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "transpose",
          "signature": "transpose(self, *args, **params)",
          "documentation": {
            "description": "a.transpose(*axes)\n\n    Returns a view of the array with axes transposed.\n\n    Refer to `numpy.transpose` for full documentation.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "unshare_mask",
          "signature": "unshare_mask(self)",
          "documentation": {
            "description": "Copy the mask and set the `sharedmask` flag to ``False``.\n\n        Whether the mask is shared between masked arrays can be seen from\n        the `sharedmask` property. `unshare_mask` ensures the mask is not\n        shared. A copy of the mask is only made if it was shared.",
            "parameters": {},
            "returns": "",
            "raises": "",
            "see_also": "sharedmask",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "var",
          "signature": "var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)",
          "documentation": {
            "description": "Compute the variance along the specified axis.\n\n    Returns the variance of the array elements, a measure of the spread of a\n    distribution.  The variance is computed for the flattened array by\n    default, otherwise over the specified axis.",
            "parameters": {
              "axis": {
                "type": "None or int or tuple of ints",
                "description": "Axis or axes along which the variance is computed.  The default is to\n        compute the variance of the flattened array.\n\n        .. versionadded:: 1.7.0\n\n        If this is a tuple of ints, a variance is performed over multiple axes,\n        instead of a single axis or all the axes as before."
              },
              "dtype": {
                "type": "data-type",
                "description": "Type to use in computing the variance.  For arrays of integer type\n        the default is `float64`; for arrays of float types it is the same as\n        the array type."
              },
              "out": {
                "type": "ndarray",
                "description": "Alternate output array in which to place the result.  It must have\n        the same shape as the expected output, but the type is cast if\n        necessary."
              },
              "ddof": {
                "type": "int",
                "description": "\"Delta Degrees of Freedom\": the divisor used in the calculation is\n        ``N - ddof``, where ``N`` represents the number of elements. By\n        default `ddof` is zero."
              },
              "keepdims": {
                "type": "bool",
                "description": "If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `var` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised."
              },
              "where": {
                "type": "array_like of bool",
                "description": "Elements to include in the variance. See `~numpy.ufunc.reduce` for\n        details.\n\n        .. versionadded:: 1.20.0"
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        },
        {
          "name": "view",
          "signature": "view(self, dtype=None, type=None, fill_value=None)",
          "documentation": {
            "description": "Return a view of the MaskedArray data.",
            "parameters": {
              "type": {
                "type": "Python type",
                "description": "Type of the returned view, either ndarray or a subclass.  The\n            default None results in type preservation."
              },
              "fill_value": {
                "type": "scalar",
                "description": "The value to use for invalid entries (None by default).\n            If None, then this argument is inferred from the passed `dtype`, or\n            in its absence the original array, as discussed in the notes below."
              }
            },
            "returns": "",
            "raises": "",
            "see_also": "",
            "notes": "",
            "examples": ""
          }
        }
      ]
    }
  ]
}